/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "?c852":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?8c28":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CPedro%20Vasco%5C%5CDocuments%5C%5CDesafios%5C%5CPlayer%20de%20M%C3%BAsica%20%E2%80%A2%20Desafio%2001%5C%5Cdesafio1%5C%5Capp%5C%5CHome%5C%5Ccomponents%5C%5CPlayer.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CPedro%20Vasco%5C%5CDocuments%5C%5CDesafios%5C%5CPlayer%20de%20M%C3%BAsica%20%E2%80%A2%20Desafio%2001%5C%5Cdesafio1%5C%5Capp%5C%5CHome%5C%5Ccomponents%5C%5CPlayer.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false! ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/Home/components/Player.tsx */ \"(app-pages-browser)/./app/Home/components/Player.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDUGVkcm8lMjBWYXNjbyU1QyU1Q0RvY3VtZW50cyU1QyU1Q0Rlc2FmaW9zJTVDJTVDUGxheWVyJTIwZGUlMjBNJUMzJUJBc2ljYSUyMCVFMiU4MCVBMiUyMERlc2FmaW8lMjAwMSU1QyU1Q2Rlc2FmaW8xJTVDJTVDYXBwJTVDJTVDSG9tZSU1QyU1Q2NvbXBvbmVudHMlNUMlNUNQbGF5ZXIudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyZGVmYXVsdCUyMiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLDBMQUF5TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2RkZDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJkZWZhdWx0XCJdICovIFwiQzpcXFxcVXNlcnNcXFxcUGVkcm8gVmFzY29cXFxcRG9jdW1lbnRzXFxcXERlc2FmaW9zXFxcXFBsYXllciBkZSBNw7pzaWNhIOKAoiBEZXNhZmlvIDAxXFxcXGRlc2FmaW8xXFxcXGFwcFxcXFxIb21lXFxcXGNvbXBvbmVudHNcXFxcUGxheWVyLnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5CPedro%20Vasco%5C%5CDocuments%5C%5CDesafios%5C%5CPlayer%20de%20M%C3%BAsica%20%E2%80%A2%20Desafio%2001%5C%5Cdesafio1%5C%5Capp%5C%5CHome%5C%5Ccomponents%5C%5CPlayer.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanM/Nzc2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"(app-pages-browser)/./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"(app-pages-browser)/./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIseUJBQXlCOztBQUV6QjtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxxQkFBcUIsV0FBVyxHQUFHLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxnQkFBZ0IsV0FBVyxHQUFHLElBQUksS0FBSyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0Qjs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLEtBQUssbURBQW1ELGNBQWM7QUFDekYsR0FBRztBQUNIO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU0sYUFBYSxTQUFTO0FBQ3REO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCLGNBQWMsb0JBQW9CLEVBQUUsSUFBSTtBQUN4QztBQUNBLFlBQVksZ0JBQWdCLEVBQUUsSUFBSTtBQUNsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsR0FBRyxTQUFTLEdBQUcsS0FBSyxxQkFBcUIsRUFBRSxFQUFFO0FBQ3BFLFFBQVE7QUFDUix5QkFBeUIsR0FBRyxLQUFLLHlCQUF5QixFQUFFLEVBQUU7QUFDOUQsbUJBQW1CLHlCQUF5QixFQUFFLEVBQUU7QUFDaEQ7QUFDQSxNQUFNO0FBQ04sb0JBQW9CLElBQUksRUFBRSxHQUFHLFNBQVMsSUFBSSxFQUFFLEVBQUU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLGNBQWMsU0FBUyxPQUFPO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcz9jN2RiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG5jb25zdCBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5jb25zdCBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuY29uc3QgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGNvbnN0IGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgbGV0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgbGV0IGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICBjb25zdCBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICBsZXQgeCA9IGEubGVuZ3RoXG4gIGxldCB5ID0gYi5sZW5ndGhcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIGxldCBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgbGV0IHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGNvbnN0IG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2VyY2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIGNvbnN0IGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIGxldCBzdHIgPSAnJ1xuICBjb25zdCBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICBsZXQgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgbGV0IHkgPSBlbmQgLSBzdGFydFxuICBjb25zdCBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICBsZXQgaW5kZXhTaXplID0gMVxuICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICBsZXQgaVxuICBpZiAoZGlyKSB7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICBjb25zdCByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIGNvbnN0IHJlcyA9IFtdXG5cbiAgbGV0IGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIGxldCBjb2RlUG9pbnQgPSBudWxsXG4gICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5jb25zdCBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgbGV0IG91dCA9ICcnXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgbGV0IHJlcyA9ICcnXG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICBsZXQgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGxvID0gZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNFxuXG4gIGNvbnN0IGhpID0gdGhpc1srK29mZnNldF0gK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIGxhc3QgKiAyICoqIDI0XG5cbiAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgY29uc3QgbG8gPSB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3RcblxuICByZXR1cm4gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoXG4gIGxldCBtdWwgPSAxXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICtcbiAgICB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICtcbiAgICB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArXG4gICAgKGxhc3QgPDwgMjQpIC8vIE92ZXJmbG93XG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gKGZpcnN0IDw8IDI0KSArIC8vIE92ZXJmbG93XG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQodGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRMRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICByZXR1cm4gb2Zmc2V0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyA3XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNl0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDVdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA0XSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgM10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDJdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAxXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0XSA9IGhpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gMFxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICBsZXQgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBDVVNUT00gRVJST1JTXG4vLyA9PT09PT09PT09PT09XG5cbi8vIFNpbXBsaWZpZWQgdmVyc2lvbnMgZnJvbSBOb2RlLCBjaGFuZ2VkIGZvciBCdWZmZXItb25seSB1c2FnZVxuY29uc3QgZXJyb3JzID0ge31cbmZ1bmN0aW9uIEUgKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkge1xuICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske3N5bX1dYFxuICAgICAgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgICAgIC8vIGZyb20gdGhlIG5hbWUuXG4gICAgICB0aGlzLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgICAvLyBSZXNldCB0aGUgbmFtZSB0byB0aGUgYWN0dWFsIG5hbWUuXG4gICAgICBkZWxldGUgdGhpcy5uYW1lXG4gICAgfVxuXG4gICAgZ2V0IGNvZGUgKCkge1xuICAgICAgcmV0dXJuIHN5bVxuICAgIH1cblxuICAgIHNldCBjb2RlICh2YWx1ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2RlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgIH1cbiAgfVxufVxuXG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLFxuICBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gYCR7bmFtZX0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYFxuICAgIH1cblxuICAgIHJldHVybiAnQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcydcbiAgfSwgUmFuZ2VFcnJvcilcbkUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcbiAgZnVuY3Rpb24gKG5hbWUsIGFjdHVhbCkge1xuICAgIHJldHVybiBgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWBcbiAgfSwgVHlwZUVycm9yKVxuRSgnRVJSX09VVF9PRl9SQU5HRScsXG4gIGZ1bmN0aW9uIChzdHIsIHJhbmdlLCBpbnB1dCkge1xuICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLmBcbiAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dFxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7XG4gICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpXG4gICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7XG4gICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKVxuICAgICAgfVxuICAgICAgcmVjZWl2ZWQgKz0gJ24nXG4gICAgfVxuICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YFxuICAgIHJldHVybiBtc2dcbiAgfSwgUmFuZ2VFcnJvcilcblxuZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yICh2YWwpIHtcbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gdmFsLmxlbmd0aFxuICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gJy0nID8gMSA6IDBcbiAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHtcbiAgICByZXMgPSBgXyR7dmFsLnNsaWNlKGkgLSAzLCBpKX0ke3Jlc31gXG4gIH1cbiAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gXG59XG5cbi8vIENIRUNLIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRzIChidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBpZiAoYnVmW29mZnNldF0gPT09IHVuZGVmaW5lZCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoICsgMSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRCSSAodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHtcbiAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gJ2JpZ2ludCcgPyAnbicgOiAnJ1xuICAgIGxldCByYW5nZVxuICAgIGlmIChieXRlTGVuZ3RoID4gMykge1xuICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkge1xuICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4fSR7bn1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogYCArXG4gICAgICAgICAgICAgICAgYCR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn1gXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlID0gYD49ICR7bWlufSR7bn0gYW5kIDw9ICR7bWF4fSR7bn1gXG4gICAgfVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSgndmFsdWUnLCByYW5nZSwgdmFsdWUpXG4gIH1cbiAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyICh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0Vycm9yICh2YWx1ZSwgbGVuZ3RoLCB0eXBlKSB7XG4gIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcbiAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSlcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JywgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuXG4gIGlmIChsZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKVxuICB9XG5cbiAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUpXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuY29uc3QgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIGxldCBjb2RlUG9pbnRcbiAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgY29uc3QgYnl0ZXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIGxldCBjLCBoaSwgbG9cbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxuY29uc3QgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgY29uc3QgaTE2ID0gaSAqIDE2XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG5cbi8vIFJldHVybiBub3QgZnVuY3Rpb24gd2l0aCBFcnJvciBpZiBCaWdJbnQgbm90IHN1cHBvcnRlZFxuZnVuY3Rpb24gZGVmaW5lQmlnSW50TWV0aG9kIChmbikge1xuICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXJCaWdJbnROb3REZWZpbmVkIDogZm5cbn1cblxuZnVuY3Rpb24gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQmlnSW50IG5vdCBzdXBwb3J0ZWQnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/content-type/index.js":
/*!********************************************!*\
  !*** ./node_modules/content-type/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * content-type\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nvar PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *(\"(?:[\\u000b\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u000b\\u0020-\\u00ff])*\"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g // eslint-disable-line no-control-regex\nvar TEXT_REGEXP = /^[\\u000b\\u0020-\\u007e\\u0080-\\u00ff]+$/ // eslint-disable-line no-control-regex\nvar TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nvar QESC_REGEXP = /\\\\([\\u000b\\u0020-\\u00ff])/g // eslint-disable-line no-control-regex\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6\n */\nvar QUOTE_REGEXP = /([\\\\\"])/g\n\n/**\n * RegExp to match type in RFC 7231 sec 3.1.1.1\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nvar TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * Module exports.\n * @public\n */\n\nexports.format = format\nexports.parse = parse\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @public\n */\n\nfunction format (obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || !TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  var string = type\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      if (!TOKEN_REGEXP.test(param)) {\n        throw new TypeError('invalid parameter name')\n      }\n\n      string += '; ' + param + '=' + qstring(parameters[param])\n    }\n  }\n\n  return string\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} string\n * @return {Object}\n * @public\n */\n\nfunction parse (string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  // support req/res-like objects as argument\n  var header = typeof string === 'object'\n    ? getcontenttype(string)\n    : string\n\n  if (typeof header !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var index = header.indexOf(';')\n  var type = index !== -1\n    ? header.slice(0, index).trim()\n    : header.trim()\n\n  if (!TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid media type')\n  }\n\n  var obj = new ContentType(type.toLowerCase())\n\n  // parse parameters\n  if (index !== -1) {\n    var key\n    var match\n    var value\n\n    PARAM_REGEXP.lastIndex = index\n\n    while ((match = PARAM_REGEXP.exec(header))) {\n      if (match.index !== index) {\n        throw new TypeError('invalid parameter format')\n      }\n\n      index += match[0].length\n      key = match[1].toLowerCase()\n      value = match[2]\n\n      if (value.charCodeAt(0) === 0x22 /* \" */) {\n        // remove quotes\n        value = value.slice(1, -1)\n\n        // remove escapes\n        if (value.indexOf('\\\\') !== -1) {\n          value = value.replace(QESC_REGEXP, '$1')\n        }\n      }\n\n      obj.parameters[key] = value\n    }\n\n    if (index !== header.length) {\n      throw new TypeError('invalid parameter format')\n    }\n  }\n\n  return obj\n}\n\n/**\n * Get content-type from req/res objects.\n *\n * @param {object}\n * @return {Object}\n * @private\n */\n\nfunction getcontenttype (obj) {\n  var header\n\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    header = obj.getHeader('content-type')\n  } else if (typeof obj.headers === 'object') {\n    // req-like\n    header = obj.headers && obj.headers['content-type']\n  }\n\n  if (typeof header !== 'string') {\n    throw new TypeError('content-type header is missing from object')\n  }\n\n  return header\n}\n\n/**\n * Quote a string if necessary.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction qstring (val) {\n  var str = String(val)\n\n  // no need to quote tokens\n  if (TOKEN_REGEXP.test(str)) {\n    return str\n  }\n\n  if (str.length > 0 && !TEXT_REGEXP.test(str)) {\n    throw new TypeError('invalid parameter value')\n  }\n\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"'\n}\n\n/**\n * Class to represent a content type.\n * @private\n */\nfunction ContentType (type) {\n  this.parameters = Object.create(null)\n  this.type = type\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb250ZW50LXR5cGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixtQkFBbUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb250ZW50LXR5cGUvaW5kZXguanM/OWRhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGNvbnRlbnQtdHlwZVxuICogQ29weXJpZ2h0KGMpIDIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCAqKCBcIjtcIiBwYXJhbWV0ZXIgKSBpbiBSRkMgNzIzMSBzZWMgMy4xLjEuMVxuICpcbiAqIHBhcmFtZXRlciAgICAgPSB0b2tlbiBcIj1cIiAoIHRva2VuIC8gcXVvdGVkLXN0cmluZyApXG4gKiB0b2tlbiAgICAgICAgID0gMSp0Y2hhclxuICogdGNoYXIgICAgICAgICA9IFwiIVwiIC8gXCIjXCIgLyBcIiRcIiAvIFwiJVwiIC8gXCImXCIgLyBcIidcIiAvIFwiKlwiXG4gKiAgICAgICAgICAgICAgIC8gXCIrXCIgLyBcIi1cIiAvIFwiLlwiIC8gXCJeXCIgLyBcIl9cIiAvIFwiYFwiIC8gXCJ8XCIgLyBcIn5cIlxuICogICAgICAgICAgICAgICAvIERJR0lUIC8gQUxQSEFcbiAqICAgICAgICAgICAgICAgOyBhbnkgVkNIQVIsIGV4Y2VwdCBkZWxpbWl0ZXJzXG4gKiBxdW90ZWQtc3RyaW5nID0gRFFVT1RFICooIHFkdGV4dCAvIHF1b3RlZC1wYWlyICkgRFFVT1RFXG4gKiBxZHRleHQgICAgICAgID0gSFRBQiAvIFNQIC8gJXgyMSAvICV4MjMtNUIgLyAleDVELTdFIC8gb2JzLXRleHRcbiAqIG9icy10ZXh0ICAgICAgPSAleDgwLUZGXG4gKiBxdW90ZWQtcGFpciAgID0gXCJcXFwiICggSFRBQiAvIFNQIC8gVkNIQVIgLyBvYnMtdGV4dCApXG4gKi9cbnZhciBQQVJBTV9SRUdFWFAgPSAvOyAqKFshIyQlJicqKy5eX2B8fjAtOUEtWmEtei1dKykgKj0gKihcIig/OltcXHUwMDBiXFx1MDAyMFxcdTAwMjFcXHUwMDIzLVxcdTAwNWJcXHUwMDVkLVxcdTAwN2VcXHUwMDgwLVxcdTAwZmZdfFxcXFxbXFx1MDAwYlxcdTAwMjAtXFx1MDBmZl0pKlwifFshIyQlJicqKy5eX2B8fjAtOUEtWmEtei1dKykgKi9nIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxudmFyIFRFWFRfUkVHRVhQID0gL15bXFx1MDAwYlxcdTAwMjAtXFx1MDA3ZVxcdTAwODAtXFx1MDBmZl0rJC8gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG52YXIgVE9LRU5fUkVHRVhQID0gL15bISMkJSYnKisuXl9gfH4wLTlBLVphLXotXSskL1xuXG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCBxdW90ZWQtcGFpciBpbiBSRkMgNzIzMCBzZWMgMy4yLjZcbiAqXG4gKiBxdW90ZWQtcGFpciA9IFwiXFxcIiAoIEhUQUIgLyBTUCAvIFZDSEFSIC8gb2JzLXRleHQgKVxuICogb2JzLXRleHQgICAgPSAleDgwLUZGXG4gKi9cbnZhciBRRVNDX1JFR0VYUCA9IC9cXFxcKFtcXHUwMDBiXFx1MDAyMC1cXHUwMGZmXSkvZyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuLyoqXG4gKiBSZWdFeHAgdG8gbWF0Y2ggY2hhcnMgdGhhdCBtdXN0IGJlIHF1b3RlZC1wYWlyIGluIFJGQyA3MjMwIHNlYyAzLjIuNlxuICovXG52YXIgUVVPVEVfUkVHRVhQID0gLyhbXFxcXFwiXSkvZ1xuXG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCB0eXBlIGluIFJGQyA3MjMxIHNlYyAzLjEuMS4xXG4gKlxuICogbWVkaWEtdHlwZSA9IHR5cGUgXCIvXCIgc3VidHlwZVxuICogdHlwZSAgICAgICA9IHRva2VuXG4gKiBzdWJ0eXBlICAgID0gdG9rZW5cbiAqL1xudmFyIFRZUEVfUkVHRVhQID0gL15bISMkJSYnKisuXl9gfH4wLTlBLVphLXotXStcXC9bISMkJSYnKisuXl9gfH4wLTlBLVphLXotXSskL1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZm9ybWF0ID0gZm9ybWF0XG5leHBvcnRzLnBhcnNlID0gcGFyc2VcblxuLyoqXG4gKiBGb3JtYXQgb2JqZWN0IHRvIG1lZGlhIHR5cGUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdCAob2JqKSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgb2JqIGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIHZhciBwYXJhbWV0ZXJzID0gb2JqLnBhcmFtZXRlcnNcbiAgdmFyIHR5cGUgPSBvYmoudHlwZVxuXG4gIGlmICghdHlwZSB8fCAhVFlQRV9SRUdFWFAudGVzdCh0eXBlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgdHlwZScpXG4gIH1cblxuICB2YXIgc3RyaW5nID0gdHlwZVxuXG4gIC8vIGFwcGVuZCBwYXJhbWV0ZXJzXG4gIGlmIChwYXJhbWV0ZXJzICYmIHR5cGVvZiBwYXJhbWV0ZXJzID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBwYXJhbVxuICAgIHZhciBwYXJhbXMgPSBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKS5zb3J0KClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJhbSA9IHBhcmFtc1tpXVxuXG4gICAgICBpZiAoIVRPS0VOX1JFR0VYUC50ZXN0KHBhcmFtKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtZXRlciBuYW1lJylcbiAgICAgIH1cblxuICAgICAgc3RyaW5nICs9ICc7ICcgKyBwYXJhbSArICc9JyArIHFzdHJpbmcocGFyYW1ldGVyc1twYXJhbV0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1xufVxuXG4vKipcbiAqIFBhcnNlIG1lZGlhIHR5cGUgdG8gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gc3RyaW5nXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcGFyc2UgKHN0cmluZykge1xuICBpZiAoIXN0cmluZykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHN0cmluZyBpcyByZXF1aXJlZCcpXG4gIH1cblxuICAvLyBzdXBwb3J0IHJlcS9yZXMtbGlrZSBvYmplY3RzIGFzIGFyZ3VtZW50XG4gIHZhciBoZWFkZXIgPSB0eXBlb2Ygc3RyaW5nID09PSAnb2JqZWN0J1xuICAgID8gZ2V0Y29udGVudHR5cGUoc3RyaW5nKVxuICAgIDogc3RyaW5nXG5cbiAgaWYgKHR5cGVvZiBoZWFkZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc3RyaW5nIGlzIHJlcXVpcmVkIHRvIGJlIGEgc3RyaW5nJylcbiAgfVxuXG4gIHZhciBpbmRleCA9IGhlYWRlci5pbmRleE9mKCc7JylcbiAgdmFyIHR5cGUgPSBpbmRleCAhPT0gLTFcbiAgICA/IGhlYWRlci5zbGljZSgwLCBpbmRleCkudHJpbSgpXG4gICAgOiBoZWFkZXIudHJpbSgpXG5cbiAgaWYgKCFUWVBFX1JFR0VYUC50ZXN0KHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBtZWRpYSB0eXBlJylcbiAgfVxuXG4gIHZhciBvYmogPSBuZXcgQ29udGVudFR5cGUodHlwZS50b0xvd2VyQ2FzZSgpKVxuXG4gIC8vIHBhcnNlIHBhcmFtZXRlcnNcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIHZhciBrZXlcbiAgICB2YXIgbWF0Y2hcbiAgICB2YXIgdmFsdWVcblxuICAgIFBBUkFNX1JFR0VYUC5sYXN0SW5kZXggPSBpbmRleFxuXG4gICAgd2hpbGUgKChtYXRjaCA9IFBBUkFNX1JFR0VYUC5leGVjKGhlYWRlcikpKSB7XG4gICAgICBpZiAobWF0Y2guaW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGFyYW1ldGVyIGZvcm1hdCcpXG4gICAgICB9XG5cbiAgICAgIGluZGV4ICs9IG1hdGNoWzBdLmxlbmd0aFxuICAgICAga2V5ID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKVxuICAgICAgdmFsdWUgPSBtYXRjaFsyXVxuXG4gICAgICBpZiAodmFsdWUuY2hhckNvZGVBdCgwKSA9PT0gMHgyMiAvKiBcIiAqLykge1xuICAgICAgICAvLyByZW1vdmUgcXVvdGVzXG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSwgLTEpXG5cbiAgICAgICAgLy8gcmVtb3ZlIGVzY2FwZXNcbiAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoJ1xcXFwnKSAhPT0gLTEpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoUUVTQ19SRUdFWFAsICckMScpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb2JqLnBhcmFtZXRlcnNba2V5XSA9IHZhbHVlXG4gICAgfVxuXG4gICAgaWYgKGluZGV4ICE9PSBoZWFkZXIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtZXRlciBmb3JtYXQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuLyoqXG4gKiBHZXQgY29udGVudC10eXBlIGZyb20gcmVxL3JlcyBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fVxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRjb250ZW50dHlwZSAob2JqKSB7XG4gIHZhciBoZWFkZXJcblxuICBpZiAodHlwZW9mIG9iai5nZXRIZWFkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyByZXMtbGlrZVxuICAgIGhlYWRlciA9IG9iai5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iai5oZWFkZXJzID09PSAnb2JqZWN0Jykge1xuICAgIC8vIHJlcS1saWtlXG4gICAgaGVhZGVyID0gb2JqLmhlYWRlcnMgJiYgb2JqLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG4gIH1cblxuICBpZiAodHlwZW9mIGhlYWRlciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb250ZW50LXR5cGUgaGVhZGVyIGlzIG1pc3NpbmcgZnJvbSBvYmplY3QnKVxuICB9XG5cbiAgcmV0dXJuIGhlYWRlclxufVxuXG4vKipcbiAqIFF1b3RlIGEgc3RyaW5nIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHFzdHJpbmcgKHZhbCkge1xuICB2YXIgc3RyID0gU3RyaW5nKHZhbClcblxuICAvLyBubyBuZWVkIHRvIHF1b3RlIHRva2Vuc1xuICBpZiAoVE9LRU5fUkVHRVhQLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIGlmIChzdHIubGVuZ3RoID4gMCAmJiAhVEVYVF9SRUdFWFAudGVzdChzdHIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbWV0ZXIgdmFsdWUnKVxuICB9XG5cbiAgcmV0dXJuICdcIicgKyBzdHIucmVwbGFjZShRVU9URV9SRUdFWFAsICdcXFxcJDEnKSArICdcIidcbn1cblxuLyoqXG4gKiBDbGFzcyB0byByZXByZXNlbnQgYSBjb250ZW50IHR5cGUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBDb250ZW50VHlwZSAodHlwZSkge1xuICB0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHRoaXMudHlwZSA9IHR5cGVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/content-type/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"(app-pages-browser)/./node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1osWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBNEM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixPQUFPLDZCQUE2QixPQUFPO0FBQzdELE1BQU0sT0FBTztBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLHdFQUFVOztBQUVuQyxPQUFPLFlBQVk7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcz81Yjg0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRsZXQgbTtcblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiAobSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pKSAmJiBwYXJzZUludChtWzFdLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/debug/src/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"(app-pages-browser)/./node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDBEQUFJO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzPzVjMDQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc2xpY2UoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/debug/src/common.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQsWUFBWTtBQUMxRTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanM/MDEyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/events/events.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/file-type/core.js":
/*!****************************************!*\
  !*** ./node_modules/file-type/core.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst strtok3 = __webpack_require__(/*! strtok3/lib/core */ \"(app-pages-browser)/./node_modules/strtok3/lib/core.js\");\nconst {\n\tstringToBytes,\n\ttarHeaderChecksumMatches,\n\tuint32SyncSafeToken\n} = __webpack_require__(/*! ./util */ \"(app-pages-browser)/./node_modules/file-type/util.js\");\nconst supported = __webpack_require__(/*! ./supported */ \"(app-pages-browser)/./node_modules/file-type/supported.js\");\n\nconst minimumBytes = 4100; // A fair amount of file-types are detectable within this range\n\nasync function fromStream(stream) {\n\tconst tokenizer = await strtok3.fromStream(stream);\n\ttry {\n\t\treturn await fromTokenizer(tokenizer);\n\t} finally {\n\t\tawait tokenizer.close();\n\t}\n}\n\nasync function fromBuffer(input) {\n\tif (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {\n\t\tthrow new TypeError(`Expected the \\`input\\` argument to be of type \\`Uint8Array\\` or \\`Buffer\\` or \\`ArrayBuffer\\`, got \\`${typeof input}\\``);\n\t}\n\n\tconst buffer = input instanceof Buffer ? input : Buffer.from(input);\n\n\tif (!(buffer && buffer.length > 1)) {\n\t\treturn;\n\t}\n\n\tconst tokenizer = strtok3.fromBuffer(buffer);\n\treturn fromTokenizer(tokenizer);\n}\n\nfunction _check(buffer, headers, options) {\n\toptions = {\n\t\toffset: 0,\n\t\t...options\n\t};\n\n\tfor (const [index, header] of headers.entries()) {\n\t\t// If a bitmask is set\n\t\tif (options.mask) {\n\t\t\t// If header doesn't equal `buf` with bits masked off\n\t\t\tif (header !== (options.mask[index] & buffer[index + options.offset])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (header !== buffer[index + options.offset]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nasync function fromTokenizer(tokenizer) {\n\ttry {\n\t\treturn _fromTokenizer(tokenizer);\n\t} catch (error) {\n\t\tif (!(error instanceof strtok3.EndOfStreamError)) {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nasync function _fromTokenizer(tokenizer) {\n\tlet buffer = Buffer.alloc(minimumBytes);\n\tconst bytesRead = 12;\n\tconst check = (header, options) => _check(buffer, header, options);\n\tconst checkString = (header, options) => check(stringToBytes(header), options);\n\n\t// Keep reading until EOF if the file size is unknown.\n\tif (!tokenizer.fileInfo.size) {\n\t\ttokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;\n\t}\n\n\tawait tokenizer.peekBuffer(buffer, {length: bytesRead, mayBeLess: true});\n\n\t// -- 2-byte signatures --\n\n\tif (check([0x42, 0x4D])) {\n\t\treturn {\n\t\t\text: 'bmp',\n\t\t\tmime: 'image/bmp'\n\t\t};\n\t}\n\n\tif (check([0x0B, 0x77])) {\n\t\treturn {\n\t\t\text: 'ac3',\n\t\t\tmime: 'audio/vnd.dolby.dd-raw'\n\t\t};\n\t}\n\n\tif (check([0x78, 0x01])) {\n\t\treturn {\n\t\t\text: 'dmg',\n\t\t\tmime: 'application/x-apple-diskimage'\n\t\t};\n\t}\n\n\tif (check([0x4D, 0x5A])) {\n\t\treturn {\n\t\t\text: 'exe',\n\t\t\tmime: 'application/x-msdownload'\n\t\t};\n\t}\n\n\tif (check([0x25, 0x21])) {\n\t\tawait tokenizer.peekBuffer(buffer, {length: 24, mayBeLess: true});\n\n\t\tif (checkString('PS-Adobe-', {offset: 2}) &&\n\t\t\tcheckString(' EPSF-', {offset: 14})) {\n\t\t\treturn {\n\t\t\t\text: 'eps',\n\t\t\t\tmime: 'application/eps'\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\text: 'ps',\n\t\t\tmime: 'application/postscript'\n\t\t};\n\t}\n\n\tif (\n\t\tcheck([0x1F, 0xA0]) ||\n\t\tcheck([0x1F, 0x9D])\n\t) {\n\t\treturn {\n\t\t\text: 'Z',\n\t\t\tmime: 'application/x-compress'\n\t\t};\n\t}\n\n\t// -- 3-byte signatures --\n\n\tif (check([0xFF, 0xD8, 0xFF])) {\n\t\treturn {\n\t\t\text: 'jpg',\n\t\t\tmime: 'image/jpeg'\n\t\t};\n\t}\n\n\tif (check([0x49, 0x49, 0xBC])) {\n\t\treturn {\n\t\t\text: 'jxr',\n\t\t\tmime: 'image/vnd.ms-photo'\n\t\t};\n\t}\n\n\tif (check([0x1F, 0x8B, 0x8])) {\n\t\treturn {\n\t\t\text: 'gz',\n\t\t\tmime: 'application/gzip'\n\t\t};\n\t}\n\n\tif (check([0x42, 0x5A, 0x68])) {\n\t\treturn {\n\t\t\text: 'bz2',\n\t\t\tmime: 'application/x-bzip2'\n\t\t};\n\t}\n\n\tif (checkString('ID3')) {\n\t\tawait tokenizer.ignore(6); // Skip ID3 header until the header size\n\t\tconst id3HeaderLen = await tokenizer.readToken(uint32SyncSafeToken);\n\t\tif (tokenizer.position + id3HeaderLen > tokenizer.fileInfo.size) {\n\t\t\t// Guess file type based on ID3 header for backward compatibility\n\t\t\treturn {\n\t\t\t\text: 'mp3',\n\t\t\t\tmime: 'audio/mpeg'\n\t\t\t};\n\t\t}\n\n\t\tawait tokenizer.ignore(id3HeaderLen);\n\t\treturn fromTokenizer(tokenizer); // Skip ID3 header, recursion\n\t}\n\n\t// Musepack, SV7\n\tif (checkString('MP+')) {\n\t\treturn {\n\t\t\text: 'mpc',\n\t\t\tmime: 'audio/x-musepack'\n\t\t};\n\t}\n\n\tif (\n\t\t(buffer[0] === 0x43 || buffer[0] === 0x46) &&\n\t\tcheck([0x57, 0x53], {offset: 1})\n\t) {\n\t\treturn {\n\t\t\text: 'swf',\n\t\t\tmime: 'application/x-shockwave-flash'\n\t\t};\n\t}\n\n\t// -- 4-byte signatures --\n\n\tif (check([0x47, 0x49, 0x46])) {\n\t\treturn {\n\t\t\text: 'gif',\n\t\t\tmime: 'image/gif'\n\t\t};\n\t}\n\n\tif (checkString('FLIF')) {\n\t\treturn {\n\t\t\text: 'flif',\n\t\t\tmime: 'image/flif'\n\t\t};\n\t}\n\n\tif (checkString('8BPS')) {\n\t\treturn {\n\t\t\text: 'psd',\n\t\t\tmime: 'image/vnd.adobe.photoshop'\n\t\t};\n\t}\n\n\tif (checkString('WEBP', {offset: 8})) {\n\t\treturn {\n\t\t\text: 'webp',\n\t\t\tmime: 'image/webp'\n\t\t};\n\t}\n\n\t// Musepack, SV8\n\tif (checkString('MPCK')) {\n\t\treturn {\n\t\t\text: 'mpc',\n\t\t\tmime: 'audio/x-musepack'\n\t\t};\n\t}\n\n\tif (checkString('FORM')) {\n\t\treturn {\n\t\t\text: 'aif',\n\t\t\tmime: 'audio/aiff'\n\t\t};\n\t}\n\n\tif (checkString('icns', {offset: 0})) {\n\t\treturn {\n\t\t\text: 'icns',\n\t\t\tmime: 'image/icns'\n\t\t};\n\t}\n\n\t// Zip-based file formats\n\t// Need to be before the `zip` check\n\tif (check([0x50, 0x4B, 0x3, 0x4])) { // Local file header signature\n\t\ttry {\n\t\t\twhile (tokenizer.position + 30 < tokenizer.fileInfo.size) {\n\t\t\t\tawait tokenizer.readBuffer(buffer, {length: 30});\n\n\t\t\t\t// https://en.wikipedia.org/wiki/Zip_(file_format)#File_headers\n\t\t\t\tconst zipHeader = {\n\t\t\t\t\tcompressedSize: buffer.readUInt32LE(18),\n\t\t\t\t\tuncompressedSize: buffer.readUInt32LE(22),\n\t\t\t\t\tfilenameLength: buffer.readUInt16LE(26),\n\t\t\t\t\textraFieldLength: buffer.readUInt16LE(28)\n\t\t\t\t};\n\n\t\t\t\tzipHeader.filename = await tokenizer.readToken(new Token.StringType(zipHeader.filenameLength, 'utf-8'));\n\t\t\t\tawait tokenizer.ignore(zipHeader.extraFieldLength);\n\n\t\t\t\t// Assumes signed `.xpi` from addons.mozilla.org\n\t\t\t\tif (zipHeader.filename === 'META-INF/mozilla.rsa') {\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'xpi',\n\t\t\t\t\t\tmime: 'application/x-xpinstall'\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (zipHeader.filename.endsWith('.rels') || zipHeader.filename.endsWith('.xml')) {\n\t\t\t\t\tconst type = zipHeader.filename.split('/')[0];\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase '_rels':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'word':\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\text: 'docx',\n\t\t\t\t\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'ppt':\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\text: 'pptx',\n\t\t\t\t\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'xl':\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\text: 'xlsx',\n\t\t\t\t\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (zipHeader.filename.startsWith('xl/')) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'xlsx',\n\t\t\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (zipHeader.filename.startsWith('3D/') && zipHeader.filename.endsWith('.model')) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: '3mf',\n\t\t\t\t\t\tmime: 'model/3mf'\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// The docx, xlsx and pptx file types extend the Office Open XML file format:\n\t\t\t\t// https://en.wikipedia.org/wiki/Office_Open_XML_file_formats\n\t\t\t\t// We look for:\n\t\t\t\t// - one entry named '[Content_Types].xml' or '_rels/.rels',\n\t\t\t\t// - one entry indicating specific type of file.\n\t\t\t\t// MS Office, OpenOffice and LibreOffice may put the parts in different order, so the check should not rely on it.\n\t\t\t\tif (zipHeader.filename === 'mimetype' && zipHeader.compressedSize === zipHeader.uncompressedSize) {\n\t\t\t\t\tconst mimeType = await tokenizer.readToken(new Token.StringType(zipHeader.compressedSize, 'utf-8'));\n\n\t\t\t\t\tswitch (mimeType) {\n\t\t\t\t\t\tcase 'application/epub+zip':\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\text: 'epub',\n\t\t\t\t\t\t\t\tmime: 'application/epub+zip'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'application/vnd.oasis.opendocument.text':\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\text: 'odt',\n\t\t\t\t\t\t\t\tmime: 'application/vnd.oasis.opendocument.text'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'application/vnd.oasis.opendocument.spreadsheet':\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\text: 'ods',\n\t\t\t\t\t\t\t\tmime: 'application/vnd.oasis.opendocument.spreadsheet'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcase 'application/vnd.oasis.opendocument.presentation':\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\text: 'odp',\n\t\t\t\t\t\t\t\tmime: 'application/vnd.oasis.opendocument.presentation'\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Try to find next header manually when current one is corrupted\n\t\t\t\tif (zipHeader.compressedSize === 0) {\n\t\t\t\t\tlet nextHeaderIndex = -1;\n\n\t\t\t\t\twhile (nextHeaderIndex < 0 && (tokenizer.position < tokenizer.fileInfo.size)) {\n\t\t\t\t\t\tawait tokenizer.peekBuffer(buffer, {mayBeLess: true});\n\n\t\t\t\t\t\tnextHeaderIndex = buffer.indexOf('504B0304', 0, 'hex');\n\t\t\t\t\t\t// Move position to the next header if found, skip the whole buffer otherwise\n\t\t\t\t\t\tawait tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : buffer.length);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait tokenizer.ignore(zipHeader.compressedSize);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tif (!(error instanceof strtok3.EndOfStreamError)) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\text: 'zip',\n\t\t\tmime: 'application/zip'\n\t\t};\n\t}\n\n\tif (checkString('OggS')) {\n\t\t// This is an OGG container\n\t\tawait tokenizer.ignore(28);\n\t\tconst type = Buffer.alloc(8);\n\t\tawait tokenizer.readBuffer(type);\n\n\t\t// Needs to be before `ogg` check\n\t\tif (_check(type, [0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64])) {\n\t\t\treturn {\n\t\t\t\text: 'opus',\n\t\t\t\tmime: 'audio/opus'\n\t\t\t};\n\t\t}\n\n\t\t// If ' theora' in header.\n\t\tif (_check(type, [0x80, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x61])) {\n\t\t\treturn {\n\t\t\t\text: 'ogv',\n\t\t\t\tmime: 'video/ogg'\n\t\t\t};\n\t\t}\n\n\t\t// If '\\x01video' in header.\n\t\tif (_check(type, [0x01, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x00])) {\n\t\t\treturn {\n\t\t\t\text: 'ogm',\n\t\t\t\tmime: 'video/ogg'\n\t\t\t};\n\t\t}\n\n\t\t// If ' FLAC' in header  https://xiph.org/flac/faq.html\n\t\tif (_check(type, [0x7F, 0x46, 0x4C, 0x41, 0x43])) {\n\t\t\treturn {\n\t\t\t\text: 'oga',\n\t\t\t\tmime: 'audio/ogg'\n\t\t\t};\n\t\t}\n\n\t\t// 'Speex  ' in header https://en.wikipedia.org/wiki/Speex\n\t\tif (_check(type, [0x53, 0x70, 0x65, 0x65, 0x78, 0x20, 0x20])) {\n\t\t\treturn {\n\t\t\t\text: 'spx',\n\t\t\t\tmime: 'audio/ogg'\n\t\t\t};\n\t\t}\n\n\t\t// If '\\x01vorbis' in header\n\t\tif (_check(type, [0x01, 0x76, 0x6F, 0x72, 0x62, 0x69, 0x73])) {\n\t\t\treturn {\n\t\t\t\text: 'ogg',\n\t\t\t\tmime: 'audio/ogg'\n\t\t\t};\n\t\t}\n\n\t\t// Default OGG container https://www.iana.org/assignments/media-types/application/ogg\n\t\treturn {\n\t\t\text: 'ogx',\n\t\t\tmime: 'application/ogg'\n\t\t};\n\t}\n\n\tif (\n\t\tcheck([0x50, 0x4B]) &&\n\t\t(buffer[2] === 0x3 || buffer[2] === 0x5 || buffer[2] === 0x7) &&\n\t\t(buffer[3] === 0x4 || buffer[3] === 0x6 || buffer[3] === 0x8)\n\t) {\n\t\treturn {\n\t\t\text: 'zip',\n\t\t\tmime: 'application/zip'\n\t\t};\n\t}\n\n\t//\n\n\t// File Type Box (https://en.wikipedia.org/wiki/ISO_base_media_file_format)\n\t// It's not required to be first, but it's recommended to be. Almost all ISO base media files start with `ftyp` box.\n\t// `ftyp` box must contain a brand major identifier, which must consist of ISO 8859-1 printable characters.\n\t// Here we check for 8859-1 printable characters (for simplicity, it's a mask which also catches one non-printable character).\n\tif (\n\t\tcheckString('ftyp', {offset: 4}) &&\n\t\t(buffer[8] & 0x60) !== 0x00 // Brand major, first character ASCII?\n\t) {\n\t\t// They all can have MIME `video/mp4` except `application/mp4` special-case which is hard to detect.\n\t\t// For some cases, we're specific, everything else falls to `video/mp4` with `mp4` extension.\n\t\tconst brandMajor = buffer.toString('binary', 8, 12).replace('\\0', ' ').trim();\n\t\tswitch (brandMajor) {\n\t\t\tcase 'avif':\n\t\t\t\treturn {ext: 'avif', mime: 'image/avif'};\n\t\t\tcase 'mif1':\n\t\t\t\treturn {ext: 'heic', mime: 'image/heif'};\n\t\t\tcase 'msf1':\n\t\t\t\treturn {ext: 'heic', mime: 'image/heif-sequence'};\n\t\t\tcase 'heic':\n\t\t\tcase 'heix':\n\t\t\t\treturn {ext: 'heic', mime: 'image/heic'};\n\t\t\tcase 'hevc':\n\t\t\tcase 'hevx':\n\t\t\t\treturn {ext: 'heic', mime: 'image/heic-sequence'};\n\t\t\tcase 'qt':\n\t\t\t\treturn {ext: 'mov', mime: 'video/quicktime'};\n\t\t\tcase 'M4V':\n\t\t\tcase 'M4VH':\n\t\t\tcase 'M4VP':\n\t\t\t\treturn {ext: 'm4v', mime: 'video/x-m4v'};\n\t\t\tcase 'M4P':\n\t\t\t\treturn {ext: 'm4p', mime: 'video/mp4'};\n\t\t\tcase 'M4B':\n\t\t\t\treturn {ext: 'm4b', mime: 'audio/mp4'};\n\t\t\tcase 'M4A':\n\t\t\t\treturn {ext: 'm4a', mime: 'audio/x-m4a'};\n\t\t\tcase 'F4V':\n\t\t\t\treturn {ext: 'f4v', mime: 'video/mp4'};\n\t\t\tcase 'F4P':\n\t\t\t\treturn {ext: 'f4p', mime: 'video/mp4'};\n\t\t\tcase 'F4A':\n\t\t\t\treturn {ext: 'f4a', mime: 'audio/mp4'};\n\t\t\tcase 'F4B':\n\t\t\t\treturn {ext: 'f4b', mime: 'audio/mp4'};\n\t\t\tcase 'crx':\n\t\t\t\treturn {ext: 'cr3', mime: 'image/x-canon-cr3'};\n\t\t\tdefault:\n\t\t\t\tif (brandMajor.startsWith('3g')) {\n\t\t\t\t\tif (brandMajor.startsWith('3g2')) {\n\t\t\t\t\t\treturn {ext: '3g2', mime: 'video/3gpp2'};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {ext: '3gp', mime: 'video/3gpp'};\n\t\t\t\t}\n\n\t\t\t\treturn {ext: 'mp4', mime: 'video/mp4'};\n\t\t}\n\t}\n\n\tif (checkString('MThd')) {\n\t\treturn {\n\t\t\text: 'mid',\n\t\t\tmime: 'audio/midi'\n\t\t};\n\t}\n\n\tif (\n\t\tcheckString('wOFF') &&\n\t\t(\n\t\t\tcheck([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||\n\t\t\tcheckString('OTTO', {offset: 4})\n\t\t)\n\t) {\n\t\treturn {\n\t\t\text: 'woff',\n\t\t\tmime: 'font/woff'\n\t\t};\n\t}\n\n\tif (\n\t\tcheckString('wOF2') &&\n\t\t(\n\t\t\tcheck([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||\n\t\t\tcheckString('OTTO', {offset: 4})\n\t\t)\n\t) {\n\t\treturn {\n\t\t\text: 'woff2',\n\t\t\tmime: 'font/woff2'\n\t\t};\n\t}\n\n\tif (check([0xD4, 0xC3, 0xB2, 0xA1]) || check([0xA1, 0xB2, 0xC3, 0xD4])) {\n\t\treturn {\n\t\t\text: 'pcap',\n\t\t\tmime: 'application/vnd.tcpdump.pcap'\n\t\t};\n\t}\n\n\t// Sony DSD Stream File (DSF)\n\tif (checkString('DSD ')) {\n\t\treturn {\n\t\t\text: 'dsf',\n\t\t\tmime: 'audio/x-dsf' // Non-standard\n\t\t};\n\t}\n\n\tif (checkString('LZIP')) {\n\t\treturn {\n\t\t\text: 'lz',\n\t\t\tmime: 'application/x-lzip'\n\t\t};\n\t}\n\n\tif (checkString('fLaC')) {\n\t\treturn {\n\t\t\text: 'flac',\n\t\t\tmime: 'audio/x-flac'\n\t\t};\n\t}\n\n\tif (check([0x42, 0x50, 0x47, 0xFB])) {\n\t\treturn {\n\t\t\text: 'bpg',\n\t\t\tmime: 'image/bpg'\n\t\t};\n\t}\n\n\tif (checkString('wvpk')) {\n\t\treturn {\n\t\t\text: 'wv',\n\t\t\tmime: 'audio/wavpack'\n\t\t};\n\t}\n\n\tif (checkString('%PDF')) {\n\t\tawait tokenizer.ignore(1350);\n\t\tconst maxBufferSize = 10 * 1024 * 1024;\n\t\tconst buffer = Buffer.alloc(Math.min(maxBufferSize, tokenizer.fileInfo.size));\n\t\tawait tokenizer.readBuffer(buffer, {mayBeLess: true});\n\n\t\t// Check if this is an Adobe Illustrator file\n\t\tif (buffer.includes(Buffer.from('AIPrivateData'))) {\n\t\t\treturn {\n\t\t\t\text: 'ai',\n\t\t\t\tmime: 'application/postscript'\n\t\t\t};\n\t\t}\n\n\t\t// Assume this is just a normal PDF\n\t\treturn {\n\t\t\text: 'pdf',\n\t\t\tmime: 'application/pdf'\n\t\t};\n\t}\n\n\tif (check([0x00, 0x61, 0x73, 0x6D])) {\n\t\treturn {\n\t\t\text: 'wasm',\n\t\t\tmime: 'application/wasm'\n\t\t};\n\t}\n\n\t// TIFF, little-endian type\n\tif (check([0x49, 0x49, 0x2A, 0x0])) {\n\t\tif (checkString('CR', {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'cr2',\n\t\t\t\tmime: 'image/x-canon-cr2'\n\t\t\t};\n\t\t}\n\n\t\tif (check([0x1C, 0x00, 0xFE, 0x00], {offset: 8}) || check([0x1F, 0x00, 0x0B, 0x00], {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'nef',\n\t\t\t\tmime: 'image/x-nikon-nef'\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tcheck([0x08, 0x00, 0x00, 0x00], {offset: 4}) &&\n\t\t\t(check([0x2D, 0x00, 0xFE, 0x00], {offset: 8}) ||\n\t\t\t\tcheck([0x27, 0x00, 0xFE, 0x00], {offset: 8}))\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'dng',\n\t\t\t\tmime: 'image/x-adobe-dng'\n\t\t\t};\n\t\t}\n\n\t\tbuffer = Buffer.alloc(24);\n\t\tawait tokenizer.peekBuffer(buffer);\n\t\tif (\n\t\t\t(check([0x10, 0xFB, 0x86, 0x01], {offset: 4}) || check([0x08, 0x00, 0x00, 0x00], {offset: 4})) &&\n\t\t\t// This pattern differentiates ARW from other TIFF-ish file types:\n\t\t\tcheck([0x00, 0xFE, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x01], {offset: 9})\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'arw',\n\t\t\t\tmime: 'image/x-sony-arw'\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\text: 'tif',\n\t\t\tmime: 'image/tiff'\n\t\t};\n\t}\n\n\t// TIFF, big-endian type\n\tif (check([0x4D, 0x4D, 0x0, 0x2A])) {\n\t\treturn {\n\t\t\text: 'tif',\n\t\t\tmime: 'image/tiff'\n\t\t};\n\t}\n\n\tif (checkString('MAC ')) {\n\t\treturn {\n\t\t\text: 'ape',\n\t\t\tmime: 'audio/ape'\n\t\t};\n\t}\n\n\t// https://github.com/threatstack/libmagic/blob/master/magic/Magdir/matroska\n\tif (check([0x1A, 0x45, 0xDF, 0xA3])) { // Root element: EBML\n\t\tasync function readField() {\n\t\t\tconst msb = await tokenizer.peekNumber(Token.UINT8);\n\t\t\tlet mask = 0x80;\n\t\t\tlet ic = 0; // 0 = A, 1 = B, 2 = C, 3 = D\n\n\t\t\twhile ((msb & mask) === 0 && mask !== 0) {\n\t\t\t\t++ic;\n\t\t\t\tmask >>= 1;\n\t\t\t}\n\n\t\t\tconst id = Buffer.alloc(ic + 1);\n\t\t\tawait tokenizer.readBuffer(id);\n\t\t\treturn id;\n\t\t}\n\n\t\tasync function readElement() {\n\t\t\tconst id = await readField();\n\t\t\tconst lenField = await readField();\n\t\t\tlenField[0] ^= 0x80 >> (lenField.length - 1);\n\t\t\tconst nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer\n\t\t\treturn {\n\t\t\t\tid: id.readUIntBE(0, id.length),\n\t\t\t\tlen: lenField.readUIntBE(lenField.length - nrLen, nrLen)\n\t\t\t};\n\t\t}\n\n\t\tasync function readChildren(level, children) {\n\t\t\twhile (children > 0) {\n\t\t\t\tconst e = await readElement();\n\t\t\t\tif (e.id === 0x4282) {\n\t\t\t\t\treturn tokenizer.readToken(new Token.StringType(e.len, 'utf-8')); // Return DocType\n\t\t\t\t}\n\n\t\t\t\tawait tokenizer.ignore(e.len); // ignore payload\n\t\t\t\t--children;\n\t\t\t}\n\t\t}\n\n\t\tconst re = await readElement();\n\t\tconst docType = await readChildren(1, re.len);\n\n\t\tswitch (docType) {\n\t\t\tcase 'webm':\n\t\t\t\treturn {\n\t\t\t\t\text: 'webm',\n\t\t\t\t\tmime: 'video/webm'\n\t\t\t\t};\n\n\t\t\tcase 'matroska':\n\t\t\t\treturn {\n\t\t\t\t\text: 'mkv',\n\t\t\t\t\tmime: 'video/x-matroska'\n\t\t\t\t};\n\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t// RIFF file format which might be AVI, WAV, QCP, etc\n\tif (check([0x52, 0x49, 0x46, 0x46])) {\n\t\tif (check([0x41, 0x56, 0x49], {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'avi',\n\t\t\t\tmime: 'video/vnd.avi'\n\t\t\t};\n\t\t}\n\n\t\tif (check([0x57, 0x41, 0x56, 0x45], {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'wav',\n\t\t\t\tmime: 'audio/vnd.wave'\n\t\t\t};\n\t\t}\n\n\t\t// QLCM, QCP file\n\t\tif (check([0x51, 0x4C, 0x43, 0x4D], {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'qcp',\n\t\t\t\tmime: 'audio/qcelp'\n\t\t\t};\n\t\t}\n\t}\n\n\tif (checkString('SQLi')) {\n\t\treturn {\n\t\t\text: 'sqlite',\n\t\t\tmime: 'application/x-sqlite3'\n\t\t};\n\t}\n\n\tif (check([0x4E, 0x45, 0x53, 0x1A])) {\n\t\treturn {\n\t\t\text: 'nes',\n\t\t\tmime: 'application/x-nintendo-nes-rom'\n\t\t};\n\t}\n\n\tif (checkString('Cr24')) {\n\t\treturn {\n\t\t\text: 'crx',\n\t\t\tmime: 'application/x-google-chrome-extension'\n\t\t};\n\t}\n\n\tif (\n\t\tcheckString('MSCF') ||\n\t\tcheckString('ISc(')\n\t) {\n\t\treturn {\n\t\t\text: 'cab',\n\t\t\tmime: 'application/vnd.ms-cab-compressed'\n\t\t};\n\t}\n\n\tif (check([0xED, 0xAB, 0xEE, 0xDB])) {\n\t\treturn {\n\t\t\text: 'rpm',\n\t\t\tmime: 'application/x-rpm'\n\t\t};\n\t}\n\n\tif (check([0xC5, 0xD0, 0xD3, 0xC6])) {\n\t\treturn {\n\t\t\text: 'eps',\n\t\t\tmime: 'application/eps'\n\t\t};\n\t}\n\n\tif (check([0x28, 0xB5, 0x2F, 0xFD])) {\n\t\treturn {\n\t\t\text: 'zst',\n\t\t\tmime: 'application/zstd'\n\t\t};\n\t}\n\n\t// -- 5-byte signatures --\n\n\tif (check([0x4F, 0x54, 0x54, 0x4F, 0x00])) {\n\t\treturn {\n\t\t\text: 'otf',\n\t\t\tmime: 'font/otf'\n\t\t};\n\t}\n\n\tif (checkString('#!AMR')) {\n\t\treturn {\n\t\t\text: 'amr',\n\t\t\tmime: 'audio/amr'\n\t\t};\n\t}\n\n\tif (checkString('{\\\\rtf')) {\n\t\treturn {\n\t\t\text: 'rtf',\n\t\t\tmime: 'application/rtf'\n\t\t};\n\t}\n\n\tif (check([0x46, 0x4C, 0x56, 0x01])) {\n\t\treturn {\n\t\t\text: 'flv',\n\t\t\tmime: 'video/x-flv'\n\t\t};\n\t}\n\n\tif (checkString('IMPM')) {\n\t\treturn {\n\t\t\text: 'it',\n\t\t\tmime: 'audio/x-it'\n\t\t};\n\t}\n\n\tif (\n\t\tcheckString('-lh0-', {offset: 2}) ||\n\t\tcheckString('-lh1-', {offset: 2}) ||\n\t\tcheckString('-lh2-', {offset: 2}) ||\n\t\tcheckString('-lh3-', {offset: 2}) ||\n\t\tcheckString('-lh4-', {offset: 2}) ||\n\t\tcheckString('-lh5-', {offset: 2}) ||\n\t\tcheckString('-lh6-', {offset: 2}) ||\n\t\tcheckString('-lh7-', {offset: 2}) ||\n\t\tcheckString('-lzs-', {offset: 2}) ||\n\t\tcheckString('-lz4-', {offset: 2}) ||\n\t\tcheckString('-lz5-', {offset: 2}) ||\n\t\tcheckString('-lhd-', {offset: 2})\n\t) {\n\t\treturn {\n\t\t\text: 'lzh',\n\t\t\tmime: 'application/x-lzh-compressed'\n\t\t};\n\t}\n\n\t// MPEG program stream (PS or MPEG-PS)\n\tif (check([0x00, 0x00, 0x01, 0xBA])) {\n\t\t//  MPEG-PS, MPEG-1 Part 1\n\t\tif (check([0x21], {offset: 4, mask: [0xF1]})) {\n\t\t\treturn {\n\t\t\t\text: 'mpg', // May also be .ps, .mpeg\n\t\t\t\tmime: 'video/MP1S'\n\t\t\t};\n\t\t}\n\n\t\t// MPEG-PS, MPEG-2 Part 1\n\t\tif (check([0x44], {offset: 4, mask: [0xC4]})) {\n\t\t\treturn {\n\t\t\t\text: 'mpg', // May also be .mpg, .m2p, .vob or .sub\n\t\t\t\tmime: 'video/MP2P'\n\t\t\t};\n\t\t}\n\t}\n\n\tif (checkString('ITSF')) {\n\t\treturn {\n\t\t\text: 'chm',\n\t\t\tmime: 'application/vnd.ms-htmlhelp'\n\t\t};\n\t}\n\n\t// -- 6-byte signatures --\n\n\tif (check([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])) {\n\t\treturn {\n\t\t\text: 'xz',\n\t\t\tmime: 'application/x-xz'\n\t\t};\n\t}\n\n\tif (checkString('<?xml ')) {\n\t\treturn {\n\t\t\text: 'xml',\n\t\t\tmime: 'application/xml'\n\t\t};\n\t}\n\n\tif (check([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C])) {\n\t\treturn {\n\t\t\text: '7z',\n\t\t\tmime: 'application/x-7z-compressed'\n\t\t};\n\t}\n\n\tif (\n\t\tcheck([0x52, 0x61, 0x72, 0x21, 0x1A, 0x7]) &&\n\t\t(buffer[6] === 0x0 || buffer[6] === 0x1)\n\t) {\n\t\treturn {\n\t\t\text: 'rar',\n\t\t\tmime: 'application/x-rar-compressed'\n\t\t};\n\t}\n\n\tif (checkString('solid ')) {\n\t\treturn {\n\t\t\text: 'stl',\n\t\t\tmime: 'model/stl'\n\t\t};\n\t}\n\n\t// -- 7-byte signatures --\n\n\tif (checkString('BLENDER')) {\n\t\treturn {\n\t\t\text: 'blend',\n\t\t\tmime: 'application/x-blender'\n\t\t};\n\t}\n\n\tif (checkString('!<arch>')) {\n\t\tawait tokenizer.ignore(8);\n\t\tconst str = await tokenizer.readToken(new Token.StringType(13, 'ascii'));\n\t\tif (str === 'debian-binary') {\n\t\t\treturn {\n\t\t\t\text: 'deb',\n\t\t\t\tmime: 'application/x-deb'\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\text: 'ar',\n\t\t\tmime: 'application/x-unix-archive'\n\t\t};\n\t}\n\n\t// -- 8-byte signatures --\n\n\tif (check([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {\n\t\t// APNG format (https://wiki.mozilla.org/APNG_Specification)\n\t\t// 1. Find the first IDAT (image data) chunk (49 44 41 54)\n\t\t// 2. Check if there is an \"acTL\" chunk before the IDAT one (61 63 54 4C)\n\n\t\t// Offset calculated as follows:\n\t\t// - 8 bytes: PNG signature\n\t\t// - 4 (length) + 4 (chunk type) + 13 (chunk data) + 4 (CRC): IHDR chunk\n\n\t\tawait tokenizer.ignore(8); // ignore PNG signature\n\n\t\tasync function readChunkHeader() {\n\t\t\treturn {\n\t\t\t\tlength: await tokenizer.readToken(Token.INT32_BE),\n\t\t\t\ttype: await tokenizer.readToken(new Token.StringType(4, 'binary'))\n\t\t\t};\n\t\t}\n\n\t\tdo {\n\t\t\tconst chunk = await readChunkHeader();\n\t\t\tif (chunk.length < 0) {\n\t\t\t\treturn; // Invalid chunk length\n\t\t\t}\n\n\t\t\tswitch (chunk.type) {\n\t\t\t\tcase 'IDAT':\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'png',\n\t\t\t\t\t\tmime: 'image/png'\n\t\t\t\t\t};\n\t\t\t\tcase 'acTL':\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'apng',\n\t\t\t\t\t\tmime: 'image/apng'\n\t\t\t\t\t};\n\t\t\t\tdefault:\n\t\t\t\t\tawait tokenizer.ignore(chunk.length + 4); // Ignore chunk-data + CRC\n\t\t\t}\n\t\t} while (tokenizer.position + 8 < tokenizer.fileInfo.size);\n\n\t\treturn {\n\t\t\text: 'png',\n\t\t\tmime: 'image/png'\n\t\t};\n\t}\n\n\tif (check([0x41, 0x52, 0x52, 0x4F, 0x57, 0x31, 0x00, 0x00])) {\n\t\treturn {\n\t\t\text: 'arrow',\n\t\t\tmime: 'application/x-apache-arrow'\n\t\t};\n\t}\n\n\tif (check([0x67, 0x6C, 0x54, 0x46, 0x02, 0x00, 0x00, 0x00])) {\n\t\treturn {\n\t\t\text: 'glb',\n\t\t\tmime: 'model/gltf-binary'\n\t\t};\n\t}\n\n\t// `mov` format variants\n\tif (\n\t\tcheck([0x66, 0x72, 0x65, 0x65], {offset: 4}) || // `free`\n\t\tcheck([0x6D, 0x64, 0x61, 0x74], {offset: 4}) || // `mdat` MJPEG\n\t\tcheck([0x6D, 0x6F, 0x6F, 0x76], {offset: 4}) || // `moov`\n\t\tcheck([0x77, 0x69, 0x64, 0x65], {offset: 4}) // `wide`\n\t) {\n\t\treturn {\n\t\t\text: 'mov',\n\t\t\tmime: 'video/quicktime'\n\t\t};\n\t}\n\n\t// -- 9-byte signatures --\n\n\tif (check([0x49, 0x49, 0x52, 0x4F, 0x08, 0x00, 0x00, 0x00, 0x18])) {\n\t\treturn {\n\t\t\text: 'orf',\n\t\t\tmime: 'image/x-olympus-orf'\n\t\t};\n\t}\n\n\tif (checkString('gimp xcf ')) {\n\t\treturn {\n\t\t\text: 'xcf',\n\t\t\tmime: 'image/x-xcf'\n\t\t};\n\t}\n\n\t// -- 12-byte signatures --\n\n\tif (check([0x49, 0x49, 0x55, 0x00, 0x18, 0x00, 0x00, 0x00, 0x88, 0xE7, 0x74, 0xD8])) {\n\t\treturn {\n\t\t\text: 'rw2',\n\t\t\tmime: 'image/x-panasonic-rw2'\n\t\t};\n\t}\n\n\t// ASF_Header_Object first 80 bytes\n\tif (check([0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9])) {\n\t\tasync function readHeader() {\n\t\t\tconst guid = Buffer.alloc(16);\n\t\t\tawait tokenizer.readBuffer(guid);\n\t\t\treturn {\n\t\t\t\tid: guid,\n\t\t\t\tsize: Number(await tokenizer.readToken(Token.UINT64_LE))\n\t\t\t};\n\t\t}\n\n\t\tawait tokenizer.ignore(30);\n\t\t// Search for header should be in first 1KB of file.\n\t\twhile (tokenizer.position + 24 < tokenizer.fileInfo.size) {\n\t\t\tconst header = await readHeader();\n\t\t\tlet payload = header.size - 24;\n\t\t\tif (_check(header.id, [0x91, 0x07, 0xDC, 0xB7, 0xB7, 0xA9, 0xCF, 0x11, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65])) {\n\t\t\t\t// Sync on Stream-Properties-Object (B7DC0791-A9B7-11CF-8EE6-00C00C205365)\n\t\t\t\tconst typeId = Buffer.alloc(16);\n\t\t\t\tpayload -= await tokenizer.readBuffer(typeId);\n\n\t\t\t\tif (_check(typeId, [0x40, 0x9E, 0x69, 0xF8, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {\n\t\t\t\t\t// Found audio:\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'asf',\n\t\t\t\t\t\tmime: 'audio/x-ms-asf'\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (_check(typeId, [0xC0, 0xEF, 0x19, 0xBC, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B])) {\n\t\t\t\t\t// Found video:\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'asf',\n\t\t\t\t\t\tmime: 'video/x-ms-asf'\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tawait tokenizer.ignore(payload);\n\t\t}\n\n\t\t// Default to ASF generic extension\n\t\treturn {\n\t\t\text: 'asf',\n\t\t\tmime: 'application/vnd.ms-asf'\n\t\t};\n\t}\n\n\tif (check([0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A])) {\n\t\treturn {\n\t\t\text: 'ktx',\n\t\t\tmime: 'image/ktx'\n\t\t};\n\t}\n\n\tif ((check([0x7E, 0x10, 0x04]) || check([0x7E, 0x18, 0x04])) && check([0x30, 0x4D, 0x49, 0x45], {offset: 4})) {\n\t\treturn {\n\t\t\text: 'mie',\n\t\t\tmime: 'application/x-mie'\n\t\t};\n\t}\n\n\tif (check([0x27, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], {offset: 2})) {\n\t\treturn {\n\t\t\text: 'shp',\n\t\t\tmime: 'application/x-esri-shape'\n\t\t};\n\t}\n\n\tif (check([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A])) {\n\t\t// JPEG-2000 family\n\n\t\tawait tokenizer.ignore(20);\n\t\tconst type = await tokenizer.readToken(new Token.StringType(4, 'ascii'));\n\t\tswitch (type) {\n\t\t\tcase 'jp2 ':\n\t\t\t\treturn {\n\t\t\t\t\text: 'jp2',\n\t\t\t\t\tmime: 'image/jp2'\n\t\t\t\t};\n\t\t\tcase 'jpx ':\n\t\t\t\treturn {\n\t\t\t\t\text: 'jpx',\n\t\t\t\t\tmime: 'image/jpx'\n\t\t\t\t};\n\t\t\tcase 'jpm ':\n\t\t\t\treturn {\n\t\t\t\t\text: 'jpm',\n\t\t\t\t\tmime: 'image/jpm'\n\t\t\t\t};\n\t\t\tcase 'mjp2':\n\t\t\t\treturn {\n\t\t\t\t\text: 'mj2',\n\t\t\t\t\tmime: 'image/mj2'\n\t\t\t\t};\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tif (\n\t\tcheck([0xFF, 0x0A]) ||\n\t\tcheck([0x00, 0x00, 0x00, 0x0C, 0x4A, 0x58, 0x4C, 0x20, 0x0D, 0x0A, 0x87, 0x0A])\n\t) {\n\t\treturn {\n\t\t\text: 'jxl',\n\t\t\tmime: 'image/jxl'\n\t\t};\n\t}\n\n\t// -- Unsafe signatures --\n\n\tif (\n\t\tcheck([0x0, 0x0, 0x1, 0xBA]) ||\n\t\tcheck([0x0, 0x0, 0x1, 0xB3])\n\t) {\n\t\treturn {\n\t\t\text: 'mpg',\n\t\t\tmime: 'video/mpeg'\n\t\t};\n\t}\n\n\tif (check([0x00, 0x01, 0x00, 0x00, 0x00])) {\n\t\treturn {\n\t\t\text: 'ttf',\n\t\t\tmime: 'font/ttf'\n\t\t};\n\t}\n\n\tif (check([0x00, 0x00, 0x01, 0x00])) {\n\t\treturn {\n\t\t\text: 'ico',\n\t\t\tmime: 'image/x-icon'\n\t\t};\n\t}\n\n\tif (check([0x00, 0x00, 0x02, 0x00])) {\n\t\treturn {\n\t\t\text: 'cur',\n\t\t\tmime: 'image/x-icon'\n\t\t};\n\t}\n\n\tif (check([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1])) {\n\t\t// Detected Microsoft Compound File Binary File (MS-CFB) Format.\n\t\treturn {\n\t\t\text: 'cfb',\n\t\t\tmime: 'application/x-cfb'\n\t\t};\n\t}\n\n\t// Increase sample size from 12 to 256.\n\tawait tokenizer.peekBuffer(buffer, {length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true});\n\n\t// -- 15-byte signatures --\n\n\tif (checkString('BEGIN:')) {\n\t\tif (checkString('VCARD', {offset: 6})) {\n\t\t\treturn {\n\t\t\t\text: 'vcf',\n\t\t\t\tmime: 'text/vcard'\n\t\t\t};\n\t\t}\n\n\t\tif (checkString('VCALENDAR', {offset: 6})) {\n\t\t\treturn {\n\t\t\t\text: 'ics',\n\t\t\t\tmime: 'text/calendar'\n\t\t\t};\n\t\t}\n\t}\n\n\t// `raf` is here just to keep all the raw image detectors together.\n\tif (checkString('FUJIFILMCCD-RAW')) {\n\t\treturn {\n\t\t\text: 'raf',\n\t\t\tmime: 'image/x-fujifilm-raf'\n\t\t};\n\t}\n\n\tif (checkString('Extended Module:')) {\n\t\treturn {\n\t\t\text: 'xm',\n\t\t\tmime: 'audio/x-xm'\n\t\t};\n\t}\n\n\tif (checkString('Creative Voice File')) {\n\t\treturn {\n\t\t\text: 'voc',\n\t\t\tmime: 'audio/x-voc'\n\t\t};\n\t}\n\n\tif (check([0x04, 0x00, 0x00, 0x00]) && buffer.length >= 16) { // Rough & quick check Pickle/ASAR\n\t\tconst jsonSize = buffer.readUInt32LE(12);\n\t\tif (jsonSize > 12 && buffer.length >= jsonSize + 16) {\n\t\t\ttry {\n\t\t\t\tconst header = buffer.slice(16, jsonSize + 16).toString();\n\t\t\t\tconst json = JSON.parse(header);\n\t\t\t\t// Check if Pickle is ASAR\n\t\t\t\tif (json.files) { // Final check, assuring Pickle/ASAR format\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'asar',\n\t\t\t\t\t\tmime: 'application/x-asar'\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} catch (_) {\n\t\t\t}\n\t\t}\n\t}\n\n\tif (check([0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02])) {\n\t\treturn {\n\t\t\text: 'mxf',\n\t\t\tmime: 'application/mxf'\n\t\t};\n\t}\n\n\tif (checkString('SCRM', {offset: 44})) {\n\t\treturn {\n\t\t\text: 's3m',\n\t\t\tmime: 'audio/x-s3m'\n\t\t};\n\t}\n\n\tif (check([0x47], {offset: 4}) && (check([0x47], {offset: 192}) || check([0x47], {offset: 196}))) {\n\t\treturn {\n\t\t\text: 'mts',\n\t\t\tmime: 'video/mp2t'\n\t\t};\n\t}\n\n\tif (check([0x42, 0x4F, 0x4F, 0x4B, 0x4D, 0x4F, 0x42, 0x49], {offset: 60})) {\n\t\treturn {\n\t\t\text: 'mobi',\n\t\t\tmime: 'application/x-mobipocket-ebook'\n\t\t};\n\t}\n\n\tif (check([0x44, 0x49, 0x43, 0x4D], {offset: 128})) {\n\t\treturn {\n\t\t\text: 'dcm',\n\t\t\tmime: 'application/dicom'\n\t\t};\n\t}\n\n\tif (check([0x4C, 0x00, 0x00, 0x00, 0x01, 0x14, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46])) {\n\t\treturn {\n\t\t\text: 'lnk',\n\t\t\tmime: 'application/x.ms.shortcut' // Invented by us\n\t\t};\n\t}\n\n\tif (check([0x62, 0x6F, 0x6F, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x61, 0x72, 0x6B, 0x00, 0x00, 0x00, 0x00])) {\n\t\treturn {\n\t\t\text: 'alias',\n\t\t\tmime: 'application/x.apple.alias' // Invented by us\n\t\t};\n\t}\n\n\tif (\n\t\tcheck([0x4C, 0x50], {offset: 34}) &&\n\t\t(\n\t\t\tcheck([0x00, 0x00, 0x01], {offset: 8}) ||\n\t\t\tcheck([0x01, 0x00, 0x02], {offset: 8}) ||\n\t\t\tcheck([0x02, 0x00, 0x02], {offset: 8})\n\t\t)\n\t) {\n\t\treturn {\n\t\t\text: 'eot',\n\t\t\tmime: 'application/vnd.ms-fontobject'\n\t\t};\n\t}\n\n\tif (check([0x06, 0x06, 0xED, 0xF5, 0xD8, 0x1D, 0x46, 0xE5, 0xBD, 0x31, 0xEF, 0xE7, 0xFE, 0x74, 0xB7, 0x1D])) {\n\t\treturn {\n\t\t\text: 'indd',\n\t\t\tmime: 'application/x-indesign'\n\t\t};\n\t}\n\n\t// Increase sample size from 256 to 512\n\tawait tokenizer.peekBuffer(buffer, {length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true});\n\n\t// Requires a buffer size of 512 bytes\n\tif (tarHeaderChecksumMatches(buffer)) {\n\t\treturn {\n\t\t\text: 'tar',\n\t\t\tmime: 'application/x-tar'\n\t\t};\n\t}\n\n\tif (check([0xFF, 0xFE, 0xFF, 0x0E, 0x53, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x74, 0x00, 0x63, 0x00, 0x68, 0x00, 0x55, 0x00, 0x70, 0x00, 0x20, 0x00, 0x4D, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x65, 0x00, 0x6C, 0x00])) {\n\t\treturn {\n\t\t\text: 'skp',\n\t\t\tmime: 'application/vnd.sketchup.skp'\n\t\t};\n\t}\n\n\tif (checkString('-----BEGIN PGP MESSAGE-----')) {\n\t\treturn {\n\t\t\text: 'pgp',\n\t\t\tmime: 'application/pgp-encrypted'\n\t\t};\n\t}\n\n\t// Check MPEG 1 or 2 Layer 3 header, or 'layer 0' for ADTS (MPEG sync-word 0xFFE)\n\tif (buffer.length >= 2 && check([0xFF, 0xE0], {offset: 0, mask: [0xFF, 0xE0]})) {\n\t\tif (check([0x10], {offset: 1, mask: [0x16]})) {\n\t\t\t// Check for (ADTS) MPEG-2\n\t\t\tif (check([0x08], {offset: 1, mask: [0x08]})) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'aac',\n\t\t\t\t\tmime: 'audio/aac'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Must be (ADTS) MPEG-4\n\t\t\treturn {\n\t\t\t\text: 'aac',\n\t\t\t\tmime: 'audio/aac'\n\t\t\t};\n\t\t}\n\n\t\t// MPEG 1 or 2 Layer 3 header\n\t\t// Check for MPEG layer 3\n\t\tif (check([0x02], {offset: 1, mask: [0x06]})) {\n\t\t\treturn {\n\t\t\t\text: 'mp3',\n\t\t\t\tmime: 'audio/mpeg'\n\t\t\t};\n\t\t}\n\n\t\t// Check for MPEG layer 2\n\t\tif (check([0x04], {offset: 1, mask: [0x06]})) {\n\t\t\treturn {\n\t\t\t\text: 'mp2',\n\t\t\t\tmime: 'audio/mpeg'\n\t\t\t};\n\t\t}\n\n\t\t// Check for MPEG layer 1\n\t\tif (check([0x06], {offset: 1, mask: [0x06]})) {\n\t\t\treturn {\n\t\t\t\text: 'mp1',\n\t\t\t\tmime: 'audio/mpeg'\n\t\t\t};\n\t\t}\n\t}\n}\n\nconst stream = readableStream => new Promise((resolve, reject) => {\n\t// Using `eval` to work around issues when bundling with Webpack\n\tconst stream = eval('require')('stream'); // eslint-disable-line no-eval\n\n\treadableStream.on('error', reject);\n\treadableStream.once('readable', async () => {\n\t\t// Set up output stream\n\t\tconst pass = new stream.PassThrough();\n\t\tlet outputStream;\n\t\tif (stream.pipeline) {\n\t\t\toutputStream = stream.pipeline(readableStream, pass, () => {\n\t\t\t});\n\t\t} else {\n\t\t\toutputStream = readableStream.pipe(pass);\n\t\t}\n\n\t\t// Read the input stream and detect the filetype\n\t\tconst chunk = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);\n\t\ttry {\n\t\t\tconst fileType = await fromBuffer(chunk);\n\t\t\tpass.fileType = fileType;\n\t\t} catch (error) {\n\t\t\treject(error);\n\t\t}\n\n\t\tresolve(outputStream);\n\t});\n});\n\nconst fileType = {\n\tfromStream,\n\tfromTokenizer,\n\tfromBuffer,\n\tstream\n};\n\nObject.defineProperty(fileType, 'extensions', {\n\tget() {\n\t\treturn new Set(supported.extensions);\n\t}\n});\n\nObject.defineProperty(fileType, 'mimeTypes', {\n\tget() {\n\t\treturn new Set(supported.mimeTypes);\n\t}\n});\n\nmodule.exports = fileType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9maWxlLXR5cGUvY29yZS5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYixjQUFjLG1CQUFPLENBQUMsZ0ZBQWE7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsb0VBQVE7QUFDcEIsa0JBQWtCLG1CQUFPLENBQUMsOEVBQWE7O0FBRXZDLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0VBQXNFLE1BQU07QUFDNUUsOEhBQThILGFBQWE7QUFDM0k7O0FBRUEsaUNBQWlDLE1BQU0sV0FBVyxNQUFNOztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxtQ0FBbUM7O0FBRXhFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyw0QkFBNEI7O0FBRWxFLGdDQUFnQyxVQUFVO0FBQzFDLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLHdDQUF3QyxXQUFXOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxnQkFBZ0I7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBLGFBQWE7QUFDYjs7QUFFQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUMsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUMsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QixzQ0FBc0MsZ0JBQWdCOztBQUV0RDtBQUNBLHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsVUFBVSxzQ0FBc0MsVUFBVTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUMscUNBQXFDLFVBQVU7QUFDL0MscUNBQXFDLFVBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0EscUNBQXFDLFVBQVUsc0NBQXNDLFVBQVU7QUFDL0Y7QUFDQSxzR0FBc0csVUFBVTtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxVQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDLHdCQUF3QixVQUFVO0FBQ2xDLHdCQUF3QixVQUFVO0FBQ2xDLHdCQUF3QixVQUFVO0FBQ2xDLHdCQUF3QixVQUFVO0FBQ2xDLHdCQUF3QixVQUFVO0FBQ2xDLHdCQUF3QixVQUFVO0FBQ2xDLHdCQUF3QixVQUFVO0FBQ2xDLHdCQUF3QixVQUFVO0FBQ2xDLHdCQUF3QixVQUFVO0FBQ2xDLHdCQUF3QixVQUFVO0FBQ2xDLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0MsbUNBQW1DLFVBQVU7QUFDN0MsbUNBQW1DLFVBQVU7QUFDN0MsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtHQUFrRyxVQUFVO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0ZBQXNGLFVBQVU7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLGdFQUFnRTs7QUFFckc7O0FBRUE7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFVBQVUscUJBQXFCLFlBQVksb0JBQW9CLFlBQVk7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQsV0FBVztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEMsOEJBQThCLFVBQVU7QUFDeEMsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLGdFQUFnRTs7QUFFckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCw4QkFBOEI7QUFDOUUscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEUsTUFBTTtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9maWxlLXR5cGUvY29yZS5qcz82ZjI4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IFRva2VuID0gcmVxdWlyZSgndG9rZW4tdHlwZXMnKTtcbmNvbnN0IHN0cnRvazMgPSByZXF1aXJlKCdzdHJ0b2szL2xpYi9jb3JlJyk7XG5jb25zdCB7XG5cdHN0cmluZ1RvQnl0ZXMsXG5cdHRhckhlYWRlckNoZWNrc3VtTWF0Y2hlcyxcblx0dWludDMyU3luY1NhZmVUb2tlblxufSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3Qgc3VwcG9ydGVkID0gcmVxdWlyZSgnLi9zdXBwb3J0ZWQnKTtcblxuY29uc3QgbWluaW11bUJ5dGVzID0gNDEwMDsgLy8gQSBmYWlyIGFtb3VudCBvZiBmaWxlLXR5cGVzIGFyZSBkZXRlY3RhYmxlIHdpdGhpbiB0aGlzIHJhbmdlXG5cbmFzeW5jIGZ1bmN0aW9uIGZyb21TdHJlYW0oc3RyZWFtKSB7XG5cdGNvbnN0IHRva2VuaXplciA9IGF3YWl0IHN0cnRvazMuZnJvbVN0cmVhbShzdHJlYW0pO1xuXHR0cnkge1xuXHRcdHJldHVybiBhd2FpdCBmcm9tVG9rZW5pemVyKHRva2VuaXplcik7XG5cdH0gZmluYWxseSB7XG5cdFx0YXdhaXQgdG9rZW5pemVyLmNsb3NlKCk7XG5cdH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZnJvbUJ1ZmZlcihpbnB1dCkge1xuXHRpZiAoIShpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBCdWZmZXIuaXNCdWZmZXIoaW5wdXQpKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHRoZSBcXGBpbnB1dFxcYCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIFxcYFVpbnQ4QXJyYXlcXGAgb3IgXFxgQnVmZmVyXFxgIG9yIFxcYEFycmF5QnVmZmVyXFxgLCBnb3QgXFxgJHt0eXBlb2YgaW5wdXR9XFxgYCk7XG5cdH1cblxuXHRjb25zdCBidWZmZXIgPSBpbnB1dCBpbnN0YW5jZW9mIEJ1ZmZlciA/IGlucHV0IDogQnVmZmVyLmZyb20oaW5wdXQpO1xuXG5cdGlmICghKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoID4gMSkpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCB0b2tlbml6ZXIgPSBzdHJ0b2szLmZyb21CdWZmZXIoYnVmZmVyKTtcblx0cmV0dXJuIGZyb21Ub2tlbml6ZXIodG9rZW5pemVyKTtcbn1cblxuZnVuY3Rpb24gX2NoZWNrKGJ1ZmZlciwgaGVhZGVycywgb3B0aW9ucykge1xuXHRvcHRpb25zID0ge1xuXHRcdG9mZnNldDogMCxcblx0XHQuLi5vcHRpb25zXG5cdH07XG5cblx0Zm9yIChjb25zdCBbaW5kZXgsIGhlYWRlcl0gb2YgaGVhZGVycy5lbnRyaWVzKCkpIHtcblx0XHQvLyBJZiBhIGJpdG1hc2sgaXMgc2V0XG5cdFx0aWYgKG9wdGlvbnMubWFzaykge1xuXHRcdFx0Ly8gSWYgaGVhZGVyIGRvZXNuJ3QgZXF1YWwgYGJ1ZmAgd2l0aCBiaXRzIG1hc2tlZCBvZmZcblx0XHRcdGlmIChoZWFkZXIgIT09IChvcHRpb25zLm1hc2tbaW5kZXhdICYgYnVmZmVyW2luZGV4ICsgb3B0aW9ucy5vZmZzZXRdKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChoZWFkZXIgIT09IGJ1ZmZlcltpbmRleCArIG9wdGlvbnMub2Zmc2V0XSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufVxuXG5hc3luYyBmdW5jdGlvbiBmcm9tVG9rZW5pemVyKHRva2VuaXplcikge1xuXHR0cnkge1xuXHRcdHJldHVybiBfZnJvbVRva2VuaXplcih0b2tlbml6ZXIpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGlmICghKGVycm9yIGluc3RhbmNlb2Ygc3RydG9rMy5FbmRPZlN0cmVhbUVycm9yKSkge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIF9mcm9tVG9rZW5pemVyKHRva2VuaXplcikge1xuXHRsZXQgYnVmZmVyID0gQnVmZmVyLmFsbG9jKG1pbmltdW1CeXRlcyk7XG5cdGNvbnN0IGJ5dGVzUmVhZCA9IDEyO1xuXHRjb25zdCBjaGVjayA9IChoZWFkZXIsIG9wdGlvbnMpID0+IF9jaGVjayhidWZmZXIsIGhlYWRlciwgb3B0aW9ucyk7XG5cdGNvbnN0IGNoZWNrU3RyaW5nID0gKGhlYWRlciwgb3B0aW9ucykgPT4gY2hlY2soc3RyaW5nVG9CeXRlcyhoZWFkZXIpLCBvcHRpb25zKTtcblxuXHQvLyBLZWVwIHJlYWRpbmcgdW50aWwgRU9GIGlmIHRoZSBmaWxlIHNpemUgaXMgdW5rbm93bi5cblx0aWYgKCF0b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSkge1xuXHRcdHRva2VuaXplci5maWxlSW5mby5zaXplID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cdH1cblxuXHRhd2FpdCB0b2tlbml6ZXIucGVla0J1ZmZlcihidWZmZXIsIHtsZW5ndGg6IGJ5dGVzUmVhZCwgbWF5QmVMZXNzOiB0cnVlfSk7XG5cblx0Ly8gLS0gMi1ieXRlIHNpZ25hdHVyZXMgLS1cblxuXHRpZiAoY2hlY2soWzB4NDIsIDB4NERdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdibXAnLFxuXHRcdFx0bWltZTogJ2ltYWdlL2JtcCdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDBCLCAweDc3XSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnYWMzJyxcblx0XHRcdG1pbWU6ICdhdWRpby92bmQuZG9sYnkuZGQtcmF3J1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NzgsIDB4MDFdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdkbWcnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtYXBwbGUtZGlza2ltYWdlJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NEQsIDB4NUFdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdleGUnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtbXNkb3dubG9hZCdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDI1LCAweDIxXSkpIHtcblx0XHRhd2FpdCB0b2tlbml6ZXIucGVla0J1ZmZlcihidWZmZXIsIHtsZW5ndGg6IDI0LCBtYXlCZUxlc3M6IHRydWV9KTtcblxuXHRcdGlmIChjaGVja1N0cmluZygnUFMtQWRvYmUtJywge29mZnNldDogMn0pICYmXG5cdFx0XHRjaGVja1N0cmluZygnIEVQU0YtJywge29mZnNldDogMTR9KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnZXBzJyxcblx0XHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL2Vwcydcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3BzJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi9wb3N0c2NyaXB0J1xuXHRcdH07XG5cdH1cblxuXHRpZiAoXG5cdFx0Y2hlY2soWzB4MUYsIDB4QTBdKSB8fFxuXHRcdGNoZWNrKFsweDFGLCAweDlEXSlcblx0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ1onLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtY29tcHJlc3MnXG5cdFx0fTtcblx0fVxuXG5cdC8vIC0tIDMtYnl0ZSBzaWduYXR1cmVzIC0tXG5cblx0aWYgKGNoZWNrKFsweEZGLCAweEQ4LCAweEZGXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnanBnJyxcblx0XHRcdG1pbWU6ICdpbWFnZS9qcGVnJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NDksIDB4NDksIDB4QkNdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdqeHInLFxuXHRcdFx0bWltZTogJ2ltYWdlL3ZuZC5tcy1waG90bydcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDFGLCAweDhCLCAweDhdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdneicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vZ3ppcCdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDQyLCAweDVBLCAweDY4XSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnYnoyJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LWJ6aXAyJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJ0lEMycpKSB7XG5cdFx0YXdhaXQgdG9rZW5pemVyLmlnbm9yZSg2KTsgLy8gU2tpcCBJRDMgaGVhZGVyIHVudGlsIHRoZSBoZWFkZXIgc2l6ZVxuXHRcdGNvbnN0IGlkM0hlYWRlckxlbiA9IGF3YWl0IHRva2VuaXplci5yZWFkVG9rZW4odWludDMyU3luY1NhZmVUb2tlbik7XG5cdFx0aWYgKHRva2VuaXplci5wb3NpdGlvbiArIGlkM0hlYWRlckxlbiA+IHRva2VuaXplci5maWxlSW5mby5zaXplKSB7XG5cdFx0XHQvLyBHdWVzcyBmaWxlIHR5cGUgYmFzZWQgb24gSUQzIGhlYWRlciBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnbXAzJyxcblx0XHRcdFx0bWltZTogJ2F1ZGlvL21wZWcnXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGF3YWl0IHRva2VuaXplci5pZ25vcmUoaWQzSGVhZGVyTGVuKTtcblx0XHRyZXR1cm4gZnJvbVRva2VuaXplcih0b2tlbml6ZXIpOyAvLyBTa2lwIElEMyBoZWFkZXIsIHJlY3Vyc2lvblxuXHR9XG5cblx0Ly8gTXVzZXBhY2ssIFNWN1xuXHRpZiAoY2hlY2tTdHJpbmcoJ01QKycpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ21wYycsXG5cdFx0XHRtaW1lOiAnYXVkaW8veC1tdXNlcGFjaydcblx0XHR9O1xuXHR9XG5cblx0aWYgKFxuXHRcdChidWZmZXJbMF0gPT09IDB4NDMgfHwgYnVmZmVyWzBdID09PSAweDQ2KSAmJlxuXHRcdGNoZWNrKFsweDU3LCAweDUzXSwge29mZnNldDogMX0pXG5cdCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdzd2YnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJ1xuXHRcdH07XG5cdH1cblxuXHQvLyAtLSA0LWJ5dGUgc2lnbmF0dXJlcyAtLVxuXG5cdGlmIChjaGVjayhbMHg0NywgMHg0OSwgMHg0Nl0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2dpZicsXG5cdFx0XHRtaW1lOiAnaW1hZ2UvZ2lmJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJ0ZMSUYnKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdmbGlmJyxcblx0XHRcdG1pbWU6ICdpbWFnZS9mbGlmJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJzhCUFMnKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdwc2QnLFxuXHRcdFx0bWltZTogJ2ltYWdlL3ZuZC5hZG9iZS5waG90b3Nob3AnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnV0VCUCcsIHtvZmZzZXQ6IDh9KSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd3ZWJwJyxcblx0XHRcdG1pbWU6ICdpbWFnZS93ZWJwJ1xuXHRcdH07XG5cdH1cblxuXHQvLyBNdXNlcGFjaywgU1Y4XG5cdGlmIChjaGVja1N0cmluZygnTVBDSycpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ21wYycsXG5cdFx0XHRtaW1lOiAnYXVkaW8veC1tdXNlcGFjaydcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrU3RyaW5nKCdGT1JNJykpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnYWlmJyxcblx0XHRcdG1pbWU6ICdhdWRpby9haWZmJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJ2ljbnMnLCB7b2Zmc2V0OiAwfSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnaWNucycsXG5cdFx0XHRtaW1lOiAnaW1hZ2UvaWNucydcblx0XHR9O1xuXHR9XG5cblx0Ly8gWmlwLWJhc2VkIGZpbGUgZm9ybWF0c1xuXHQvLyBOZWVkIHRvIGJlIGJlZm9yZSB0aGUgYHppcGAgY2hlY2tcblx0aWYgKGNoZWNrKFsweDUwLCAweDRCLCAweDMsIDB4NF0pKSB7IC8vIExvY2FsIGZpbGUgaGVhZGVyIHNpZ25hdHVyZVxuXHRcdHRyeSB7XG5cdFx0XHR3aGlsZSAodG9rZW5pemVyLnBvc2l0aW9uICsgMzAgPCB0b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSkge1xuXHRcdFx0XHRhd2FpdCB0b2tlbml6ZXIucmVhZEJ1ZmZlcihidWZmZXIsIHtsZW5ndGg6IDMwfSk7XG5cblx0XHRcdFx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWmlwXyhmaWxlX2Zvcm1hdCkjRmlsZV9oZWFkZXJzXG5cdFx0XHRcdGNvbnN0IHppcEhlYWRlciA9IHtcblx0XHRcdFx0XHRjb21wcmVzc2VkU2l6ZTogYnVmZmVyLnJlYWRVSW50MzJMRSgxOCksXG5cdFx0XHRcdFx0dW5jb21wcmVzc2VkU2l6ZTogYnVmZmVyLnJlYWRVSW50MzJMRSgyMiksXG5cdFx0XHRcdFx0ZmlsZW5hbWVMZW5ndGg6IGJ1ZmZlci5yZWFkVUludDE2TEUoMjYpLFxuXHRcdFx0XHRcdGV4dHJhRmllbGRMZW5ndGg6IGJ1ZmZlci5yZWFkVUludDE2TEUoMjgpXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0emlwSGVhZGVyLmZpbGVuYW1lID0gYXdhaXQgdG9rZW5pemVyLnJlYWRUb2tlbihuZXcgVG9rZW4uU3RyaW5nVHlwZSh6aXBIZWFkZXIuZmlsZW5hbWVMZW5ndGgsICd1dGYtOCcpKTtcblx0XHRcdFx0YXdhaXQgdG9rZW5pemVyLmlnbm9yZSh6aXBIZWFkZXIuZXh0cmFGaWVsZExlbmd0aCk7XG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBzaWduZWQgYC54cGlgIGZyb20gYWRkb25zLm1vemlsbGEub3JnXG5cdFx0XHRcdGlmICh6aXBIZWFkZXIuZmlsZW5hbWUgPT09ICdNRVRBLUlORi9tb3ppbGxhLnJzYScpIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZXh0OiAneHBpJyxcblx0XHRcdFx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LXhwaW5zdGFsbCdcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHppcEhlYWRlci5maWxlbmFtZS5lbmRzV2l0aCgnLnJlbHMnKSB8fCB6aXBIZWFkZXIuZmlsZW5hbWUuZW5kc1dpdGgoJy54bWwnKSkge1xuXHRcdFx0XHRcdGNvbnN0IHR5cGUgPSB6aXBIZWFkZXIuZmlsZW5hbWUuc3BsaXQoJy8nKVswXTtcblx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ19yZWxzJzpcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICd3b3JkJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRleHQ6ICdkb2N4Jyxcblx0XHRcdFx0XHRcdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRjYXNlICdwcHQnOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdGV4dDogJ3BwdHgnLFxuXHRcdFx0XHRcdFx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uJ1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0Y2FzZSAneGwnOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdGV4dDogJ3hsc3gnLFxuXHRcdFx0XHRcdFx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldCdcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh6aXBIZWFkZXIuZmlsZW5hbWUuc3RhcnRzV2l0aCgneGwvJykpIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZXh0OiAneGxzeCcsXG5cdFx0XHRcdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQnXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh6aXBIZWFkZXIuZmlsZW5hbWUuc3RhcnRzV2l0aCgnM0QvJykgJiYgemlwSGVhZGVyLmZpbGVuYW1lLmVuZHNXaXRoKCcubW9kZWwnKSkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRleHQ6ICczbWYnLFxuXHRcdFx0XHRcdFx0bWltZTogJ21vZGVsLzNtZidcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVGhlIGRvY3gsIHhsc3ggYW5kIHBwdHggZmlsZSB0eXBlcyBleHRlbmQgdGhlIE9mZmljZSBPcGVuIFhNTCBmaWxlIGZvcm1hdDpcblx0XHRcdFx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT2ZmaWNlX09wZW5fWE1MX2ZpbGVfZm9ybWF0c1xuXHRcdFx0XHQvLyBXZSBsb29rIGZvcjpcblx0XHRcdFx0Ly8gLSBvbmUgZW50cnkgbmFtZWQgJ1tDb250ZW50X1R5cGVzXS54bWwnIG9yICdfcmVscy8ucmVscycsXG5cdFx0XHRcdC8vIC0gb25lIGVudHJ5IGluZGljYXRpbmcgc3BlY2lmaWMgdHlwZSBvZiBmaWxlLlxuXHRcdFx0XHQvLyBNUyBPZmZpY2UsIE9wZW5PZmZpY2UgYW5kIExpYnJlT2ZmaWNlIG1heSBwdXQgdGhlIHBhcnRzIGluIGRpZmZlcmVudCBvcmRlciwgc28gdGhlIGNoZWNrIHNob3VsZCBub3QgcmVseSBvbiBpdC5cblx0XHRcdFx0aWYgKHppcEhlYWRlci5maWxlbmFtZSA9PT0gJ21pbWV0eXBlJyAmJiB6aXBIZWFkZXIuY29tcHJlc3NlZFNpemUgPT09IHppcEhlYWRlci51bmNvbXByZXNzZWRTaXplKSB7XG5cdFx0XHRcdFx0Y29uc3QgbWltZVR5cGUgPSBhd2FpdCB0b2tlbml6ZXIucmVhZFRva2VuKG5ldyBUb2tlbi5TdHJpbmdUeXBlKHppcEhlYWRlci5jb21wcmVzc2VkU2l6ZSwgJ3V0Zi04JykpO1xuXG5cdFx0XHRcdFx0c3dpdGNoIChtaW1lVHlwZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnYXBwbGljYXRpb24vZXB1Yit6aXAnOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdGV4dDogJ2VwdWInLFxuXHRcdFx0XHRcdFx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi9lcHViK3ppcCdcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGNhc2UgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dCc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0ZXh0OiAnb2R0Jyxcblx0XHRcdFx0XHRcdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0J1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0Y2FzZSAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5zcHJlYWRzaGVldCc6XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0ZXh0OiAnb2RzJyxcblx0XHRcdFx0XHRcdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5zcHJlYWRzaGVldCdcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGNhc2UgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRleHQ6ICdvZHAnLFxuXHRcdFx0XHRcdFx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnByZXNlbnRhdGlvbidcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJ5IHRvIGZpbmQgbmV4dCBoZWFkZXIgbWFudWFsbHkgd2hlbiBjdXJyZW50IG9uZSBpcyBjb3JydXB0ZWRcblx0XHRcdFx0aWYgKHppcEhlYWRlci5jb21wcmVzc2VkU2l6ZSA9PT0gMCkge1xuXHRcdFx0XHRcdGxldCBuZXh0SGVhZGVySW5kZXggPSAtMTtcblxuXHRcdFx0XHRcdHdoaWxlIChuZXh0SGVhZGVySW5kZXggPCAwICYmICh0b2tlbml6ZXIucG9zaXRpb24gPCB0b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSkpIHtcblx0XHRcdFx0XHRcdGF3YWl0IHRva2VuaXplci5wZWVrQnVmZmVyKGJ1ZmZlciwge21heUJlTGVzczogdHJ1ZX0pO1xuXG5cdFx0XHRcdFx0XHRuZXh0SGVhZGVySW5kZXggPSBidWZmZXIuaW5kZXhPZignNTA0QjAzMDQnLCAwLCAnaGV4Jyk7XG5cdFx0XHRcdFx0XHQvLyBNb3ZlIHBvc2l0aW9uIHRvIHRoZSBuZXh0IGhlYWRlciBpZiBmb3VuZCwgc2tpcCB0aGUgd2hvbGUgYnVmZmVyIG90aGVyd2lzZVxuXHRcdFx0XHRcdFx0YXdhaXQgdG9rZW5pemVyLmlnbm9yZShuZXh0SGVhZGVySW5kZXggPj0gMCA/IG5leHRIZWFkZXJJbmRleCA6IGJ1ZmZlci5sZW5ndGgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhd2FpdCB0b2tlbml6ZXIuaWdub3JlKHppcEhlYWRlci5jb21wcmVzc2VkU2l6ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBzdHJ0b2szLkVuZE9mU3RyZWFtRXJyb3IpKSB7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd6aXAnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3ppcCdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrU3RyaW5nKCdPZ2dTJykpIHtcblx0XHQvLyBUaGlzIGlzIGFuIE9HRyBjb250YWluZXJcblx0XHRhd2FpdCB0b2tlbml6ZXIuaWdub3JlKDI4KTtcblx0XHRjb25zdCB0eXBlID0gQnVmZmVyLmFsbG9jKDgpO1xuXHRcdGF3YWl0IHRva2VuaXplci5yZWFkQnVmZmVyKHR5cGUpO1xuXG5cdFx0Ly8gTmVlZHMgdG8gYmUgYmVmb3JlIGBvZ2dgIGNoZWNrXG5cdFx0aWYgKF9jaGVjayh0eXBlLCBbMHg0RiwgMHg3MCwgMHg3NSwgMHg3MywgMHg0OCwgMHg2NSwgMHg2MSwgMHg2NF0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdvcHVzJyxcblx0XHRcdFx0bWltZTogJ2F1ZGlvL29wdXMnXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIElmICcgdGhlb3JhJyBpbiBoZWFkZXIuXG5cdFx0aWYgKF9jaGVjayh0eXBlLCBbMHg4MCwgMHg3NCwgMHg2OCwgMHg2NSwgMHg2RiwgMHg3MiwgMHg2MV0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdvZ3YnLFxuXHRcdFx0XHRtaW1lOiAndmlkZW8vb2dnJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBJZiAnXFx4MDF2aWRlbycgaW4gaGVhZGVyLlxuXHRcdGlmIChfY2hlY2sodHlwZSwgWzB4MDEsIDB4NzYsIDB4NjksIDB4NjQsIDB4NjUsIDB4NkYsIDB4MDBdKSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnb2dtJyxcblx0XHRcdFx0bWltZTogJ3ZpZGVvL29nZydcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSWYgJyBGTEFDJyBpbiBoZWFkZXIgIGh0dHBzOi8veGlwaC5vcmcvZmxhYy9mYXEuaHRtbFxuXHRcdGlmIChfY2hlY2sodHlwZSwgWzB4N0YsIDB4NDYsIDB4NEMsIDB4NDEsIDB4NDNdKSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnb2dhJyxcblx0XHRcdFx0bWltZTogJ2F1ZGlvL29nZydcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gJ1NwZWV4ICAnIGluIGhlYWRlciBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGVleFxuXHRcdGlmIChfY2hlY2sodHlwZSwgWzB4NTMsIDB4NzAsIDB4NjUsIDB4NjUsIDB4NzgsIDB4MjAsIDB4MjBdKSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnc3B4Jyxcblx0XHRcdFx0bWltZTogJ2F1ZGlvL29nZydcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSWYgJ1xceDAxdm9yYmlzJyBpbiBoZWFkZXJcblx0XHRpZiAoX2NoZWNrKHR5cGUsIFsweDAxLCAweDc2LCAweDZGLCAweDcyLCAweDYyLCAweDY5LCAweDczXSkpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ29nZycsXG5cdFx0XHRcdG1pbWU6ICdhdWRpby9vZ2cnXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIERlZmF1bHQgT0dHIGNvbnRhaW5lciBodHRwczovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9tZWRpYS10eXBlcy9hcHBsaWNhdGlvbi9vZ2dcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnb2d4Jyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi9vZ2cnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChcblx0XHRjaGVjayhbMHg1MCwgMHg0Ql0pICYmXG5cdFx0KGJ1ZmZlclsyXSA9PT0gMHgzIHx8IGJ1ZmZlclsyXSA9PT0gMHg1IHx8IGJ1ZmZlclsyXSA9PT0gMHg3KSAmJlxuXHRcdChidWZmZXJbM10gPT09IDB4NCB8fCBidWZmZXJbM10gPT09IDB4NiB8fCBidWZmZXJbM10gPT09IDB4OClcblx0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3ppcCcsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vemlwJ1xuXHRcdH07XG5cdH1cblxuXHQvL1xuXG5cdC8vIEZpbGUgVHlwZSBCb3ggKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT19iYXNlX21lZGlhX2ZpbGVfZm9ybWF0KVxuXHQvLyBJdCdzIG5vdCByZXF1aXJlZCB0byBiZSBmaXJzdCwgYnV0IGl0J3MgcmVjb21tZW5kZWQgdG8gYmUuIEFsbW9zdCBhbGwgSVNPIGJhc2UgbWVkaWEgZmlsZXMgc3RhcnQgd2l0aCBgZnR5cGAgYm94LlxuXHQvLyBgZnR5cGAgYm94IG11c3QgY29udGFpbiBhIGJyYW5kIG1ham9yIGlkZW50aWZpZXIsIHdoaWNoIG11c3QgY29uc2lzdCBvZiBJU08gODg1OS0xIHByaW50YWJsZSBjaGFyYWN0ZXJzLlxuXHQvLyBIZXJlIHdlIGNoZWNrIGZvciA4ODU5LTEgcHJpbnRhYmxlIGNoYXJhY3RlcnMgKGZvciBzaW1wbGljaXR5LCBpdCdzIGEgbWFzayB3aGljaCBhbHNvIGNhdGNoZXMgb25lIG5vbi1wcmludGFibGUgY2hhcmFjdGVyKS5cblx0aWYgKFxuXHRcdGNoZWNrU3RyaW5nKCdmdHlwJywge29mZnNldDogNH0pICYmXG5cdFx0KGJ1ZmZlcls4XSAmIDB4NjApICE9PSAweDAwIC8vIEJyYW5kIG1ham9yLCBmaXJzdCBjaGFyYWN0ZXIgQVNDSUk/XG5cdCkge1xuXHRcdC8vIFRoZXkgYWxsIGNhbiBoYXZlIE1JTUUgYHZpZGVvL21wNGAgZXhjZXB0IGBhcHBsaWNhdGlvbi9tcDRgIHNwZWNpYWwtY2FzZSB3aGljaCBpcyBoYXJkIHRvIGRldGVjdC5cblx0XHQvLyBGb3Igc29tZSBjYXNlcywgd2UncmUgc3BlY2lmaWMsIGV2ZXJ5dGhpbmcgZWxzZSBmYWxscyB0byBgdmlkZW8vbXA0YCB3aXRoIGBtcDRgIGV4dGVuc2lvbi5cblx0XHRjb25zdCBicmFuZE1ham9yID0gYnVmZmVyLnRvU3RyaW5nKCdiaW5hcnknLCA4LCAxMikucmVwbGFjZSgnXFwwJywgJyAnKS50cmltKCk7XG5cdFx0c3dpdGNoIChicmFuZE1ham9yKSB7XG5cdFx0XHRjYXNlICdhdmlmJzpcblx0XHRcdFx0cmV0dXJuIHtleHQ6ICdhdmlmJywgbWltZTogJ2ltYWdlL2F2aWYnfTtcblx0XHRcdGNhc2UgJ21pZjEnOlxuXHRcdFx0XHRyZXR1cm4ge2V4dDogJ2hlaWMnLCBtaW1lOiAnaW1hZ2UvaGVpZid9O1xuXHRcdFx0Y2FzZSAnbXNmMSc6XG5cdFx0XHRcdHJldHVybiB7ZXh0OiAnaGVpYycsIG1pbWU6ICdpbWFnZS9oZWlmLXNlcXVlbmNlJ307XG5cdFx0XHRjYXNlICdoZWljJzpcblx0XHRcdGNhc2UgJ2hlaXgnOlxuXHRcdFx0XHRyZXR1cm4ge2V4dDogJ2hlaWMnLCBtaW1lOiAnaW1hZ2UvaGVpYyd9O1xuXHRcdFx0Y2FzZSAnaGV2Yyc6XG5cdFx0XHRjYXNlICdoZXZ4Jzpcblx0XHRcdFx0cmV0dXJuIHtleHQ6ICdoZWljJywgbWltZTogJ2ltYWdlL2hlaWMtc2VxdWVuY2UnfTtcblx0XHRcdGNhc2UgJ3F0Jzpcblx0XHRcdFx0cmV0dXJuIHtleHQ6ICdtb3YnLCBtaW1lOiAndmlkZW8vcXVpY2t0aW1lJ307XG5cdFx0XHRjYXNlICdNNFYnOlxuXHRcdFx0Y2FzZSAnTTRWSCc6XG5cdFx0XHRjYXNlICdNNFZQJzpcblx0XHRcdFx0cmV0dXJuIHtleHQ6ICdtNHYnLCBtaW1lOiAndmlkZW8veC1tNHYnfTtcblx0XHRcdGNhc2UgJ000UCc6XG5cdFx0XHRcdHJldHVybiB7ZXh0OiAnbTRwJywgbWltZTogJ3ZpZGVvL21wNCd9O1xuXHRcdFx0Y2FzZSAnTTRCJzpcblx0XHRcdFx0cmV0dXJuIHtleHQ6ICdtNGInLCBtaW1lOiAnYXVkaW8vbXA0J307XG5cdFx0XHRjYXNlICdNNEEnOlxuXHRcdFx0XHRyZXR1cm4ge2V4dDogJ200YScsIG1pbWU6ICdhdWRpby94LW00YSd9O1xuXHRcdFx0Y2FzZSAnRjRWJzpcblx0XHRcdFx0cmV0dXJuIHtleHQ6ICdmNHYnLCBtaW1lOiAndmlkZW8vbXA0J307XG5cdFx0XHRjYXNlICdGNFAnOlxuXHRcdFx0XHRyZXR1cm4ge2V4dDogJ2Y0cCcsIG1pbWU6ICd2aWRlby9tcDQnfTtcblx0XHRcdGNhc2UgJ0Y0QSc6XG5cdFx0XHRcdHJldHVybiB7ZXh0OiAnZjRhJywgbWltZTogJ2F1ZGlvL21wNCd9O1xuXHRcdFx0Y2FzZSAnRjRCJzpcblx0XHRcdFx0cmV0dXJuIHtleHQ6ICdmNGInLCBtaW1lOiAnYXVkaW8vbXA0J307XG5cdFx0XHRjYXNlICdjcngnOlxuXHRcdFx0XHRyZXR1cm4ge2V4dDogJ2NyMycsIG1pbWU6ICdpbWFnZS94LWNhbm9uLWNyMyd9O1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0aWYgKGJyYW5kTWFqb3Iuc3RhcnRzV2l0aCgnM2cnKSkge1xuXHRcdFx0XHRcdGlmIChicmFuZE1ham9yLnN0YXJ0c1dpdGgoJzNnMicpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge2V4dDogJzNnMicsIG1pbWU6ICd2aWRlby8zZ3BwMid9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB7ZXh0OiAnM2dwJywgbWltZTogJ3ZpZGVvLzNncHAnfTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB7ZXh0OiAnbXA0JywgbWltZTogJ3ZpZGVvL21wNCd9O1xuXHRcdH1cblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnTVRoZCcpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ21pZCcsXG5cdFx0XHRtaW1lOiAnYXVkaW8vbWlkaSdcblx0XHR9O1xuXHR9XG5cblx0aWYgKFxuXHRcdGNoZWNrU3RyaW5nKCd3T0ZGJykgJiZcblx0XHQoXG5cdFx0XHRjaGVjayhbMHgwMCwgMHgwMSwgMHgwMCwgMHgwMF0sIHtvZmZzZXQ6IDR9KSB8fFxuXHRcdFx0Y2hlY2tTdHJpbmcoJ09UVE8nLCB7b2Zmc2V0OiA0fSlcblx0XHQpXG5cdCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd3b2ZmJyxcblx0XHRcdG1pbWU6ICdmb250L3dvZmYnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChcblx0XHRjaGVja1N0cmluZygnd09GMicpICYmXG5cdFx0KFxuXHRcdFx0Y2hlY2soWzB4MDAsIDB4MDEsIDB4MDAsIDB4MDBdLCB7b2Zmc2V0OiA0fSkgfHxcblx0XHRcdGNoZWNrU3RyaW5nKCdPVFRPJywge29mZnNldDogNH0pXG5cdFx0KVxuXHQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnd29mZjInLFxuXHRcdFx0bWltZTogJ2ZvbnQvd29mZjInXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHhENCwgMHhDMywgMHhCMiwgMHhBMV0pIHx8IGNoZWNrKFsweEExLCAweEIyLCAweEMzLCAweEQ0XSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAncGNhcCcsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vdm5kLnRjcGR1bXAucGNhcCdcblx0XHR9O1xuXHR9XG5cblx0Ly8gU29ueSBEU0QgU3RyZWFtIEZpbGUgKERTRilcblx0aWYgKGNoZWNrU3RyaW5nKCdEU0QgJykpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnZHNmJyxcblx0XHRcdG1pbWU6ICdhdWRpby94LWRzZicgLy8gTm9uLXN0YW5kYXJkXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnTFpJUCcpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2x6Jyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LWx6aXAnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnZkxhQycpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2ZsYWMnLFxuXHRcdFx0bWltZTogJ2F1ZGlvL3gtZmxhYydcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDQyLCAweDUwLCAweDQ3LCAweEZCXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnYnBnJyxcblx0XHRcdG1pbWU6ICdpbWFnZS9icGcnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnd3ZwaycpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3d2Jyxcblx0XHRcdG1pbWU6ICdhdWRpby93YXZwYWNrJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJyVQREYnKSkge1xuXHRcdGF3YWl0IHRva2VuaXplci5pZ25vcmUoMTM1MCk7XG5cdFx0Y29uc3QgbWF4QnVmZmVyU2l6ZSA9IDEwICogMTAyNCAqIDEwMjQ7XG5cdFx0Y29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKE1hdGgubWluKG1heEJ1ZmZlclNpemUsIHRva2VuaXplci5maWxlSW5mby5zaXplKSk7XG5cdFx0YXdhaXQgdG9rZW5pemVyLnJlYWRCdWZmZXIoYnVmZmVyLCB7bWF5QmVMZXNzOiB0cnVlfSk7XG5cblx0XHQvLyBDaGVjayBpZiB0aGlzIGlzIGFuIEFkb2JlIElsbHVzdHJhdG9yIGZpbGVcblx0XHRpZiAoYnVmZmVyLmluY2x1ZGVzKEJ1ZmZlci5mcm9tKCdBSVByaXZhdGVEYXRhJykpKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdhaScsXG5cdFx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi9wb3N0c2NyaXB0J1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBBc3N1bWUgdGhpcyBpcyBqdXN0IGEgbm9ybWFsIFBERlxuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdwZGYnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3BkZidcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDAwLCAweDYxLCAweDczLCAweDZEXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnd2FzbScsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vd2FzbSdcblx0XHR9O1xuXHR9XG5cblx0Ly8gVElGRiwgbGl0dGxlLWVuZGlhbiB0eXBlXG5cdGlmIChjaGVjayhbMHg0OSwgMHg0OSwgMHgyQSwgMHgwXSkpIHtcblx0XHRpZiAoY2hlY2tTdHJpbmcoJ0NSJywge29mZnNldDogOH0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdjcjInLFxuXHRcdFx0XHRtaW1lOiAnaW1hZ2UveC1jYW5vbi1jcjInXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGlmIChjaGVjayhbMHgxQywgMHgwMCwgMHhGRSwgMHgwMF0sIHtvZmZzZXQ6IDh9KSB8fCBjaGVjayhbMHgxRiwgMHgwMCwgMHgwQiwgMHgwMF0sIHtvZmZzZXQ6IDh9KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnbmVmJyxcblx0XHRcdFx0bWltZTogJ2ltYWdlL3gtbmlrb24tbmVmJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHRjaGVjayhbMHgwOCwgMHgwMCwgMHgwMCwgMHgwMF0sIHtvZmZzZXQ6IDR9KSAmJlxuXHRcdFx0KGNoZWNrKFsweDJELCAweDAwLCAweEZFLCAweDAwXSwge29mZnNldDogOH0pIHx8XG5cdFx0XHRcdGNoZWNrKFsweDI3LCAweDAwLCAweEZFLCAweDAwXSwge29mZnNldDogOH0pKVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnZG5nJyxcblx0XHRcdFx0bWltZTogJ2ltYWdlL3gtYWRvYmUtZG5nJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRidWZmZXIgPSBCdWZmZXIuYWxsb2MoMjQpO1xuXHRcdGF3YWl0IHRva2VuaXplci5wZWVrQnVmZmVyKGJ1ZmZlcik7XG5cdFx0aWYgKFxuXHRcdFx0KGNoZWNrKFsweDEwLCAweEZCLCAweDg2LCAweDAxXSwge29mZnNldDogNH0pIHx8IGNoZWNrKFsweDA4LCAweDAwLCAweDAwLCAweDAwXSwge29mZnNldDogNH0pKSAmJlxuXHRcdFx0Ly8gVGhpcyBwYXR0ZXJuIGRpZmZlcmVudGlhdGVzIEFSVyBmcm9tIG90aGVyIFRJRkYtaXNoIGZpbGUgdHlwZXM6XG5cdFx0XHRjaGVjayhbMHgwMCwgMHhGRSwgMHgwMCwgMHgwNCwgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMywgMHgwMV0sIHtvZmZzZXQ6IDl9KVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnYXJ3Jyxcblx0XHRcdFx0bWltZTogJ2ltYWdlL3gtc29ueS1hcncnXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd0aWYnLFxuXHRcdFx0bWltZTogJ2ltYWdlL3RpZmYnXG5cdFx0fTtcblx0fVxuXG5cdC8vIFRJRkYsIGJpZy1lbmRpYW4gdHlwZVxuXHRpZiAoY2hlY2soWzB4NEQsIDB4NEQsIDB4MCwgMHgyQV0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3RpZicsXG5cdFx0XHRtaW1lOiAnaW1hZ2UvdGlmZidcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrU3RyaW5nKCdNQUMgJykpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnYXBlJyxcblx0XHRcdG1pbWU6ICdhdWRpby9hcGUnXG5cdFx0fTtcblx0fVxuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aHJlYXRzdGFjay9saWJtYWdpYy9ibG9iL21hc3Rlci9tYWdpYy9NYWdkaXIvbWF0cm9za2Fcblx0aWYgKGNoZWNrKFsweDFBLCAweDQ1LCAweERGLCAweEEzXSkpIHsgLy8gUm9vdCBlbGVtZW50OiBFQk1MXG5cdFx0YXN5bmMgZnVuY3Rpb24gcmVhZEZpZWxkKCkge1xuXHRcdFx0Y29uc3QgbXNiID0gYXdhaXQgdG9rZW5pemVyLnBlZWtOdW1iZXIoVG9rZW4uVUlOVDgpO1xuXHRcdFx0bGV0IG1hc2sgPSAweDgwO1xuXHRcdFx0bGV0IGljID0gMDsgLy8gMCA9IEEsIDEgPSBCLCAyID0gQywgMyA9IERcblxuXHRcdFx0d2hpbGUgKChtc2IgJiBtYXNrKSA9PT0gMCAmJiBtYXNrICE9PSAwKSB7XG5cdFx0XHRcdCsraWM7XG5cdFx0XHRcdG1hc2sgPj49IDE7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGlkID0gQnVmZmVyLmFsbG9jKGljICsgMSk7XG5cdFx0XHRhd2FpdCB0b2tlbml6ZXIucmVhZEJ1ZmZlcihpZCk7XG5cdFx0XHRyZXR1cm4gaWQ7XG5cdFx0fVxuXG5cdFx0YXN5bmMgZnVuY3Rpb24gcmVhZEVsZW1lbnQoKSB7XG5cdFx0XHRjb25zdCBpZCA9IGF3YWl0IHJlYWRGaWVsZCgpO1xuXHRcdFx0Y29uc3QgbGVuRmllbGQgPSBhd2FpdCByZWFkRmllbGQoKTtcblx0XHRcdGxlbkZpZWxkWzBdIF49IDB4ODAgPj4gKGxlbkZpZWxkLmxlbmd0aCAtIDEpO1xuXHRcdFx0Y29uc3QgbnJMZW4gPSBNYXRoLm1pbig2LCBsZW5GaWVsZC5sZW5ndGgpOyAvLyBKYXZhU2NyaXB0IGNhbiBtYXggcmVhZCA2IGJ5dGVzIGludGVnZXJcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGlkOiBpZC5yZWFkVUludEJFKDAsIGlkLmxlbmd0aCksXG5cdFx0XHRcdGxlbjogbGVuRmllbGQucmVhZFVJbnRCRShsZW5GaWVsZC5sZW5ndGggLSBuckxlbiwgbnJMZW4pXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGFzeW5jIGZ1bmN0aW9uIHJlYWRDaGlsZHJlbihsZXZlbCwgY2hpbGRyZW4pIHtcblx0XHRcdHdoaWxlIChjaGlsZHJlbiA+IDApIHtcblx0XHRcdFx0Y29uc3QgZSA9IGF3YWl0IHJlYWRFbGVtZW50KCk7XG5cdFx0XHRcdGlmIChlLmlkID09PSAweDQyODIpIHtcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5pemVyLnJlYWRUb2tlbihuZXcgVG9rZW4uU3RyaW5nVHlwZShlLmxlbiwgJ3V0Zi04JykpOyAvLyBSZXR1cm4gRG9jVHlwZVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXdhaXQgdG9rZW5pemVyLmlnbm9yZShlLmxlbik7IC8vIGlnbm9yZSBwYXlsb2FkXG5cdFx0XHRcdC0tY2hpbGRyZW47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmUgPSBhd2FpdCByZWFkRWxlbWVudCgpO1xuXHRcdGNvbnN0IGRvY1R5cGUgPSBhd2FpdCByZWFkQ2hpbGRyZW4oMSwgcmUubGVuKTtcblxuXHRcdHN3aXRjaCAoZG9jVHlwZSkge1xuXHRcdFx0Y2FzZSAnd2VibSc6XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0ZXh0OiAnd2VibScsXG5cdFx0XHRcdFx0bWltZTogJ3ZpZGVvL3dlYm0nXG5cdFx0XHRcdH07XG5cblx0XHRcdGNhc2UgJ21hdHJvc2thJzpcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRleHQ6ICdta3YnLFxuXHRcdFx0XHRcdG1pbWU6ICd2aWRlby94LW1hdHJvc2thJ1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0Ly8gUklGRiBmaWxlIGZvcm1hdCB3aGljaCBtaWdodCBiZSBBVkksIFdBViwgUUNQLCBldGNcblx0aWYgKGNoZWNrKFsweDUyLCAweDQ5LCAweDQ2LCAweDQ2XSkpIHtcblx0XHRpZiAoY2hlY2soWzB4NDEsIDB4NTYsIDB4NDldLCB7b2Zmc2V0OiA4fSkpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ2F2aScsXG5cdFx0XHRcdG1pbWU6ICd2aWRlby92bmQuYXZpJ1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZiAoY2hlY2soWzB4NTcsIDB4NDEsIDB4NTYsIDB4NDVdLCB7b2Zmc2V0OiA4fSkpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ3dhdicsXG5cdFx0XHRcdG1pbWU6ICdhdWRpby92bmQud2F2ZSdcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gUUxDTSwgUUNQIGZpbGVcblx0XHRpZiAoY2hlY2soWzB4NTEsIDB4NEMsIDB4NDMsIDB4NERdLCB7b2Zmc2V0OiA4fSkpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ3FjcCcsXG5cdFx0XHRcdG1pbWU6ICdhdWRpby9xY2VscCdcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0aWYgKGNoZWNrU3RyaW5nKCdTUUxpJykpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnc3FsaXRlJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LXNxbGl0ZTMnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg0RSwgMHg0NSwgMHg1MywgMHgxQV0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ25lcycsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1uaW50ZW5kby1uZXMtcm9tJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJ0NyMjQnKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdjcngnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtZ29vZ2xlLWNocm9tZS1leHRlbnNpb24nXG5cdFx0fTtcblx0fVxuXG5cdGlmIChcblx0XHRjaGVja1N0cmluZygnTVNDRicpIHx8XG5cdFx0Y2hlY2tTdHJpbmcoJ0lTYygnKVxuXHQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnY2FiJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi92bmQubXMtY2FiLWNvbXByZXNzZWQnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHhFRCwgMHhBQiwgMHhFRSwgMHhEQl0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3JwbScsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1ycG0nXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHhDNSwgMHhEMCwgMHhEMywgMHhDNl0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2VwcycsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vZXBzJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4MjgsIDB4QjUsIDB4MkYsIDB4RkRdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICd6c3QnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3pzdGQnXG5cdFx0fTtcblx0fVxuXG5cdC8vIC0tIDUtYnl0ZSBzaWduYXR1cmVzIC0tXG5cblx0aWYgKGNoZWNrKFsweDRGLCAweDU0LCAweDU0LCAweDRGLCAweDAwXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnb3RmJyxcblx0XHRcdG1pbWU6ICdmb250L290Zidcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrU3RyaW5nKCcjIUFNUicpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2FtcicsXG5cdFx0XHRtaW1lOiAnYXVkaW8vYW1yJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJ3tcXFxccnRmJykpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAncnRmJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi9ydGYnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg0NiwgMHg0QywgMHg1NiwgMHgwMV0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2ZsdicsXG5cdFx0XHRtaW1lOiAndmlkZW8veC1mbHYnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnSU1QTScpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2l0Jyxcblx0XHRcdG1pbWU6ICdhdWRpby94LWl0J1xuXHRcdH07XG5cdH1cblxuXHRpZiAoXG5cdFx0Y2hlY2tTdHJpbmcoJy1saDAtJywge29mZnNldDogMn0pIHx8XG5cdFx0Y2hlY2tTdHJpbmcoJy1saDEtJywge29mZnNldDogMn0pIHx8XG5cdFx0Y2hlY2tTdHJpbmcoJy1saDItJywge29mZnNldDogMn0pIHx8XG5cdFx0Y2hlY2tTdHJpbmcoJy1saDMtJywge29mZnNldDogMn0pIHx8XG5cdFx0Y2hlY2tTdHJpbmcoJy1saDQtJywge29mZnNldDogMn0pIHx8XG5cdFx0Y2hlY2tTdHJpbmcoJy1saDUtJywge29mZnNldDogMn0pIHx8XG5cdFx0Y2hlY2tTdHJpbmcoJy1saDYtJywge29mZnNldDogMn0pIHx8XG5cdFx0Y2hlY2tTdHJpbmcoJy1saDctJywge29mZnNldDogMn0pIHx8XG5cdFx0Y2hlY2tTdHJpbmcoJy1senMtJywge29mZnNldDogMn0pIHx8XG5cdFx0Y2hlY2tTdHJpbmcoJy1sejQtJywge29mZnNldDogMn0pIHx8XG5cdFx0Y2hlY2tTdHJpbmcoJy1sejUtJywge29mZnNldDogMn0pIHx8XG5cdFx0Y2hlY2tTdHJpbmcoJy1saGQtJywge29mZnNldDogMn0pXG5cdCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdsemgnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtbHpoLWNvbXByZXNzZWQnXG5cdFx0fTtcblx0fVxuXG5cdC8vIE1QRUcgcHJvZ3JhbSBzdHJlYW0gKFBTIG9yIE1QRUctUFMpXG5cdGlmIChjaGVjayhbMHgwMCwgMHgwMCwgMHgwMSwgMHhCQV0pKSB7XG5cdFx0Ly8gIE1QRUctUFMsIE1QRUctMSBQYXJ0IDFcblx0XHRpZiAoY2hlY2soWzB4MjFdLCB7b2Zmc2V0OiA0LCBtYXNrOiBbMHhGMV19KSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0OiAnbXBnJywgLy8gTWF5IGFsc28gYmUgLnBzLCAubXBlZ1xuXHRcdFx0XHRtaW1lOiAndmlkZW8vTVAxUydcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gTVBFRy1QUywgTVBFRy0yIFBhcnQgMVxuXHRcdGlmIChjaGVjayhbMHg0NF0sIHtvZmZzZXQ6IDQsIG1hc2s6IFsweEM0XX0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdtcGcnLCAvLyBNYXkgYWxzbyBiZSAubXBnLCAubTJwLCAudm9iIG9yIC5zdWJcblx0XHRcdFx0bWltZTogJ3ZpZGVvL01QMlAnXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnSVRTRicpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2NobScsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vdm5kLm1zLWh0bWxoZWxwJ1xuXHRcdH07XG5cdH1cblxuXHQvLyAtLSA2LWJ5dGUgc2lnbmF0dXJlcyAtLVxuXG5cdGlmIChjaGVjayhbMHhGRCwgMHgzNywgMHg3QSwgMHg1OCwgMHg1QSwgMHgwMF0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3h6Jyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LXh6J1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJzw/eG1sICcpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3htbCcsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veG1sJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4MzcsIDB4N0EsIDB4QkMsIDB4QUYsIDB4MjcsIDB4MUNdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICc3eicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC03ei1jb21wcmVzc2VkJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoXG5cdFx0Y2hlY2soWzB4NTIsIDB4NjEsIDB4NzIsIDB4MjEsIDB4MUEsIDB4N10pICYmXG5cdFx0KGJ1ZmZlcls2XSA9PT0gMHgwIHx8IGJ1ZmZlcls2XSA9PT0gMHgxKVxuXHQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAncmFyJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LXJhci1jb21wcmVzc2VkJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2tTdHJpbmcoJ3NvbGlkICcpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3N0bCcsXG5cdFx0XHRtaW1lOiAnbW9kZWwvc3RsJ1xuXHRcdH07XG5cdH1cblxuXHQvLyAtLSA3LWJ5dGUgc2lnbmF0dXJlcyAtLVxuXG5cdGlmIChjaGVja1N0cmluZygnQkxFTkRFUicpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2JsZW5kJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LWJsZW5kZXInXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnITxhcmNoPicpKSB7XG5cdFx0YXdhaXQgdG9rZW5pemVyLmlnbm9yZSg4KTtcblx0XHRjb25zdCBzdHIgPSBhd2FpdCB0b2tlbml6ZXIucmVhZFRva2VuKG5ldyBUb2tlbi5TdHJpbmdUeXBlKDEzLCAnYXNjaWknKSk7XG5cdFx0aWYgKHN0ciA9PT0gJ2RlYmlhbi1iaW5hcnknKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdkZWInLFxuXHRcdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1kZWInXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdhcicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC11bml4LWFyY2hpdmUnXG5cdFx0fTtcblx0fVxuXG5cdC8vIC0tIDgtYnl0ZSBzaWduYXR1cmVzIC0tXG5cblx0aWYgKGNoZWNrKFsweDg5LCAweDUwLCAweDRFLCAweDQ3LCAweDBELCAweDBBLCAweDFBLCAweDBBXSkpIHtcblx0XHQvLyBBUE5HIGZvcm1hdCAoaHR0cHM6Ly93aWtpLm1vemlsbGEub3JnL0FQTkdfU3BlY2lmaWNhdGlvbilcblx0XHQvLyAxLiBGaW5kIHRoZSBmaXJzdCBJREFUIChpbWFnZSBkYXRhKSBjaHVuayAoNDkgNDQgNDEgNTQpXG5cdFx0Ly8gMi4gQ2hlY2sgaWYgdGhlcmUgaXMgYW4gXCJhY1RMXCIgY2h1bmsgYmVmb3JlIHRoZSBJREFUIG9uZSAoNjEgNjMgNTQgNEMpXG5cblx0XHQvLyBPZmZzZXQgY2FsY3VsYXRlZCBhcyBmb2xsb3dzOlxuXHRcdC8vIC0gOCBieXRlczogUE5HIHNpZ25hdHVyZVxuXHRcdC8vIC0gNCAobGVuZ3RoKSArIDQgKGNodW5rIHR5cGUpICsgMTMgKGNodW5rIGRhdGEpICsgNCAoQ1JDKTogSUhEUiBjaHVua1xuXG5cdFx0YXdhaXQgdG9rZW5pemVyLmlnbm9yZSg4KTsgLy8gaWdub3JlIFBORyBzaWduYXR1cmVcblxuXHRcdGFzeW5jIGZ1bmN0aW9uIHJlYWRDaHVua0hlYWRlcigpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGxlbmd0aDogYXdhaXQgdG9rZW5pemVyLnJlYWRUb2tlbihUb2tlbi5JTlQzMl9CRSksXG5cdFx0XHRcdHR5cGU6IGF3YWl0IHRva2VuaXplci5yZWFkVG9rZW4obmV3IFRva2VuLlN0cmluZ1R5cGUoNCwgJ2JpbmFyeScpKVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRkbyB7XG5cdFx0XHRjb25zdCBjaHVuayA9IGF3YWl0IHJlYWRDaHVua0hlYWRlcigpO1xuXHRcdFx0aWYgKGNodW5rLmxlbmd0aCA8IDApIHtcblx0XHRcdFx0cmV0dXJuOyAvLyBJbnZhbGlkIGNodW5rIGxlbmd0aFxuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKGNodW5rLnR5cGUpIHtcblx0XHRcdFx0Y2FzZSAnSURBVCc6XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGV4dDogJ3BuZycsXG5cdFx0XHRcdFx0XHRtaW1lOiAnaW1hZ2UvcG5nJ1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdGNhc2UgJ2FjVEwnOlxuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRleHQ6ICdhcG5nJyxcblx0XHRcdFx0XHRcdG1pbWU6ICdpbWFnZS9hcG5nJ1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0YXdhaXQgdG9rZW5pemVyLmlnbm9yZShjaHVuay5sZW5ndGggKyA0KTsgLy8gSWdub3JlIGNodW5rLWRhdGEgKyBDUkNcblx0XHRcdH1cblx0XHR9IHdoaWxlICh0b2tlbml6ZXIucG9zaXRpb24gKyA4IDwgdG9rZW5pemVyLmZpbGVJbmZvLnNpemUpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3BuZycsXG5cdFx0XHRtaW1lOiAnaW1hZ2UvcG5nJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NDEsIDB4NTIsIDB4NTIsIDB4NEYsIDB4NTcsIDB4MzEsIDB4MDAsIDB4MDBdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdhcnJvdycsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1hcGFjaGUtYXJyb3cnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHg2NywgMHg2QywgMHg1NCwgMHg0NiwgMHgwMiwgMHgwMCwgMHgwMCwgMHgwMF0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2dsYicsXG5cdFx0XHRtaW1lOiAnbW9kZWwvZ2x0Zi1iaW5hcnknXG5cdFx0fTtcblx0fVxuXG5cdC8vIGBtb3ZgIGZvcm1hdCB2YXJpYW50c1xuXHRpZiAoXG5cdFx0Y2hlY2soWzB4NjYsIDB4NzIsIDB4NjUsIDB4NjVdLCB7b2Zmc2V0OiA0fSkgfHwgLy8gYGZyZWVgXG5cdFx0Y2hlY2soWzB4NkQsIDB4NjQsIDB4NjEsIDB4NzRdLCB7b2Zmc2V0OiA0fSkgfHwgLy8gYG1kYXRgIE1KUEVHXG5cdFx0Y2hlY2soWzB4NkQsIDB4NkYsIDB4NkYsIDB4NzZdLCB7b2Zmc2V0OiA0fSkgfHwgLy8gYG1vb3ZgXG5cdFx0Y2hlY2soWzB4NzcsIDB4NjksIDB4NjQsIDB4NjVdLCB7b2Zmc2V0OiA0fSkgLy8gYHdpZGVgXG5cdCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdtb3YnLFxuXHRcdFx0bWltZTogJ3ZpZGVvL3F1aWNrdGltZSdcblx0XHR9O1xuXHR9XG5cblx0Ly8gLS0gOS1ieXRlIHNpZ25hdHVyZXMgLS1cblxuXHRpZiAoY2hlY2soWzB4NDksIDB4NDksIDB4NTIsIDB4NEYsIDB4MDgsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MThdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdvcmYnLFxuXHRcdFx0bWltZTogJ2ltYWdlL3gtb2x5bXB1cy1vcmYnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnZ2ltcCB4Y2YgJykpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAneGNmJyxcblx0XHRcdG1pbWU6ICdpbWFnZS94LXhjZidcblx0XHR9O1xuXHR9XG5cblx0Ly8gLS0gMTItYnl0ZSBzaWduYXR1cmVzIC0tXG5cblx0aWYgKGNoZWNrKFsweDQ5LCAweDQ5LCAweDU1LCAweDAwLCAweDE4LCAweDAwLCAweDAwLCAweDAwLCAweDg4LCAweEU3LCAweDc0LCAweEQ4XSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAncncyJyxcblx0XHRcdG1pbWU6ICdpbWFnZS94LXBhbmFzb25pYy1ydzInXG5cdFx0fTtcblx0fVxuXG5cdC8vIEFTRl9IZWFkZXJfT2JqZWN0IGZpcnN0IDgwIGJ5dGVzXG5cdGlmIChjaGVjayhbMHgzMCwgMHgyNiwgMHhCMiwgMHg3NSwgMHg4RSwgMHg2NiwgMHhDRiwgMHgxMSwgMHhBNiwgMHhEOV0pKSB7XG5cdFx0YXN5bmMgZnVuY3Rpb24gcmVhZEhlYWRlcigpIHtcblx0XHRcdGNvbnN0IGd1aWQgPSBCdWZmZXIuYWxsb2MoMTYpO1xuXHRcdFx0YXdhaXQgdG9rZW5pemVyLnJlYWRCdWZmZXIoZ3VpZCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRpZDogZ3VpZCxcblx0XHRcdFx0c2l6ZTogTnVtYmVyKGF3YWl0IHRva2VuaXplci5yZWFkVG9rZW4oVG9rZW4uVUlOVDY0X0xFKSlcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0YXdhaXQgdG9rZW5pemVyLmlnbm9yZSgzMCk7XG5cdFx0Ly8gU2VhcmNoIGZvciBoZWFkZXIgc2hvdWxkIGJlIGluIGZpcnN0IDFLQiBvZiBmaWxlLlxuXHRcdHdoaWxlICh0b2tlbml6ZXIucG9zaXRpb24gKyAyNCA8IHRva2VuaXplci5maWxlSW5mby5zaXplKSB7XG5cdFx0XHRjb25zdCBoZWFkZXIgPSBhd2FpdCByZWFkSGVhZGVyKCk7XG5cdFx0XHRsZXQgcGF5bG9hZCA9IGhlYWRlci5zaXplIC0gMjQ7XG5cdFx0XHRpZiAoX2NoZWNrKGhlYWRlci5pZCwgWzB4OTEsIDB4MDcsIDB4REMsIDB4QjcsIDB4QjcsIDB4QTksIDB4Q0YsIDB4MTEsIDB4OEUsIDB4RTYsIDB4MDAsIDB4QzAsIDB4MEMsIDB4MjAsIDB4NTMsIDB4NjVdKSkge1xuXHRcdFx0XHQvLyBTeW5jIG9uIFN0cmVhbS1Qcm9wZXJ0aWVzLU9iamVjdCAoQjdEQzA3OTEtQTlCNy0xMUNGLThFRTYtMDBDMDBDMjA1MzY1KVxuXHRcdFx0XHRjb25zdCB0eXBlSWQgPSBCdWZmZXIuYWxsb2MoMTYpO1xuXHRcdFx0XHRwYXlsb2FkIC09IGF3YWl0IHRva2VuaXplci5yZWFkQnVmZmVyKHR5cGVJZCk7XG5cblx0XHRcdFx0aWYgKF9jaGVjayh0eXBlSWQsIFsweDQwLCAweDlFLCAweDY5LCAweEY4LCAweDRELCAweDVCLCAweENGLCAweDExLCAweEE4LCAweEZELCAweDAwLCAweDgwLCAweDVGLCAweDVDLCAweDQ0LCAweDJCXSkpIHtcblx0XHRcdFx0XHQvLyBGb3VuZCBhdWRpbzpcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZXh0OiAnYXNmJyxcblx0XHRcdFx0XHRcdG1pbWU6ICdhdWRpby94LW1zLWFzZidcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKF9jaGVjayh0eXBlSWQsIFsweEMwLCAweEVGLCAweDE5LCAweEJDLCAweDRELCAweDVCLCAweENGLCAweDExLCAweEE4LCAweEZELCAweDAwLCAweDgwLCAweDVGLCAweDVDLCAweDQ0LCAweDJCXSkpIHtcblx0XHRcdFx0XHQvLyBGb3VuZCB2aWRlbzpcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZXh0OiAnYXNmJyxcblx0XHRcdFx0XHRcdG1pbWU6ICd2aWRlby94LW1zLWFzZidcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdGF3YWl0IHRva2VuaXplci5pZ25vcmUocGF5bG9hZCk7XG5cdFx0fVxuXG5cdFx0Ly8gRGVmYXVsdCB0byBBU0YgZ2VuZXJpYyBleHRlbnNpb25cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnYXNmJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi92bmQubXMtYXNmJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4QUIsIDB4NEIsIDB4NTQsIDB4NTgsIDB4MjAsIDB4MzEsIDB4MzEsIDB4QkIsIDB4MEQsIDB4MEEsIDB4MUEsIDB4MEFdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdrdHgnLFxuXHRcdFx0bWltZTogJ2ltYWdlL2t0eCdcblx0XHR9O1xuXHR9XG5cblx0aWYgKChjaGVjayhbMHg3RSwgMHgxMCwgMHgwNF0pIHx8IGNoZWNrKFsweDdFLCAweDE4LCAweDA0XSkpICYmIGNoZWNrKFsweDMwLCAweDRELCAweDQ5LCAweDQ1XSwge29mZnNldDogNH0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ21pZScsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1taWUnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHgyNywgMHgwQSwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMF0sIHtvZmZzZXQ6IDJ9KSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdzaHAnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtZXNyaS1zaGFwZSdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDAwLCAweDAwLCAweDAwLCAweDBDLCAweDZBLCAweDUwLCAweDIwLCAweDIwLCAweDBELCAweDBBLCAweDg3LCAweDBBXSkpIHtcblx0XHQvLyBKUEVHLTIwMDAgZmFtaWx5XG5cblx0XHRhd2FpdCB0b2tlbml6ZXIuaWdub3JlKDIwKTtcblx0XHRjb25zdCB0eXBlID0gYXdhaXQgdG9rZW5pemVyLnJlYWRUb2tlbihuZXcgVG9rZW4uU3RyaW5nVHlwZSg0LCAnYXNjaWknKSk7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdqcDIgJzpcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRleHQ6ICdqcDInLFxuXHRcdFx0XHRcdG1pbWU6ICdpbWFnZS9qcDInXG5cdFx0XHRcdH07XG5cdFx0XHRjYXNlICdqcHggJzpcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRleHQ6ICdqcHgnLFxuXHRcdFx0XHRcdG1pbWU6ICdpbWFnZS9qcHgnXG5cdFx0XHRcdH07XG5cdFx0XHRjYXNlICdqcG0gJzpcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRleHQ6ICdqcG0nLFxuXHRcdFx0XHRcdG1pbWU6ICdpbWFnZS9qcG0nXG5cdFx0XHRcdH07XG5cdFx0XHRjYXNlICdtanAyJzpcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRleHQ6ICdtajInLFxuXHRcdFx0XHRcdG1pbWU6ICdpbWFnZS9tajInXG5cdFx0XHRcdH07XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0aWYgKFxuXHRcdGNoZWNrKFsweEZGLCAweDBBXSkgfHxcblx0XHRjaGVjayhbMHgwMCwgMHgwMCwgMHgwMCwgMHgwQywgMHg0QSwgMHg1OCwgMHg0QywgMHgyMCwgMHgwRCwgMHgwQSwgMHg4NywgMHgwQV0pXG5cdCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdqeGwnLFxuXHRcdFx0bWltZTogJ2ltYWdlL2p4bCdcblx0XHR9O1xuXHR9XG5cblx0Ly8gLS0gVW5zYWZlIHNpZ25hdHVyZXMgLS1cblxuXHRpZiAoXG5cdFx0Y2hlY2soWzB4MCwgMHgwLCAweDEsIDB4QkFdKSB8fFxuXHRcdGNoZWNrKFsweDAsIDB4MCwgMHgxLCAweEIzXSlcblx0KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ21wZycsXG5cdFx0XHRtaW1lOiAndmlkZW8vbXBlZydcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDAwLCAweDAxLCAweDAwLCAweDAwLCAweDAwXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAndHRmJyxcblx0XHRcdG1pbWU6ICdmb250L3R0Zidcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDAwLCAweDAwLCAweDAxLCAweDAwXSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnaWNvJyxcblx0XHRcdG1pbWU6ICdpbWFnZS94LWljb24nXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHgwMCwgMHgwMCwgMHgwMiwgMHgwMF0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ2N1cicsXG5cdFx0XHRtaW1lOiAnaW1hZ2UveC1pY29uJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4RDAsIDB4Q0YsIDB4MTEsIDB4RTAsIDB4QTEsIDB4QjEsIDB4MUEsIDB4RTFdKSkge1xuXHRcdC8vIERldGVjdGVkIE1pY3Jvc29mdCBDb21wb3VuZCBGaWxlIEJpbmFyeSBGaWxlIChNUy1DRkIpIEZvcm1hdC5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnY2ZiJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LWNmYidcblx0XHR9O1xuXHR9XG5cblx0Ly8gSW5jcmVhc2Ugc2FtcGxlIHNpemUgZnJvbSAxMiB0byAyNTYuXG5cdGF3YWl0IHRva2VuaXplci5wZWVrQnVmZmVyKGJ1ZmZlciwge2xlbmd0aDogTWF0aC5taW4oMjU2LCB0b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSksIG1heUJlTGVzczogdHJ1ZX0pO1xuXG5cdC8vIC0tIDE1LWJ5dGUgc2lnbmF0dXJlcyAtLVxuXG5cdGlmIChjaGVja1N0cmluZygnQkVHSU46JykpIHtcblx0XHRpZiAoY2hlY2tTdHJpbmcoJ1ZDQVJEJywge29mZnNldDogNn0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICd2Y2YnLFxuXHRcdFx0XHRtaW1lOiAndGV4dC92Y2FyZCdcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aWYgKGNoZWNrU3RyaW5nKCdWQ0FMRU5EQVInLCB7b2Zmc2V0OiA2fSkpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ2ljcycsXG5cdFx0XHRcdG1pbWU6ICd0ZXh0L2NhbGVuZGFyJ1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHQvLyBgcmFmYCBpcyBoZXJlIGp1c3QgdG8ga2VlcCBhbGwgdGhlIHJhdyBpbWFnZSBkZXRlY3RvcnMgdG9nZXRoZXIuXG5cdGlmIChjaGVja1N0cmluZygnRlVKSUZJTE1DQ0QtUkFXJykpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAncmFmJyxcblx0XHRcdG1pbWU6ICdpbWFnZS94LWZ1amlmaWxtLXJhZidcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrU3RyaW5nKCdFeHRlbmRlZCBNb2R1bGU6JykpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAneG0nLFxuXHRcdFx0bWltZTogJ2F1ZGlvL3gteG0nXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVja1N0cmluZygnQ3JlYXRpdmUgVm9pY2UgRmlsZScpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3ZvYycsXG5cdFx0XHRtaW1lOiAnYXVkaW8veC12b2MnXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHgwNCwgMHgwMCwgMHgwMCwgMHgwMF0pICYmIGJ1ZmZlci5sZW5ndGggPj0gMTYpIHsgLy8gUm91Z2ggJiBxdWljayBjaGVjayBQaWNrbGUvQVNBUlxuXHRcdGNvbnN0IGpzb25TaXplID0gYnVmZmVyLnJlYWRVSW50MzJMRSgxMik7XG5cdFx0aWYgKGpzb25TaXplID4gMTIgJiYgYnVmZmVyLmxlbmd0aCA+PSBqc29uU2l6ZSArIDE2KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCBoZWFkZXIgPSBidWZmZXIuc2xpY2UoMTYsIGpzb25TaXplICsgMTYpLnRvU3RyaW5nKCk7XG5cdFx0XHRcdGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGhlYWRlcik7XG5cdFx0XHRcdC8vIENoZWNrIGlmIFBpY2tsZSBpcyBBU0FSXG5cdFx0XHRcdGlmIChqc29uLmZpbGVzKSB7IC8vIEZpbmFsIGNoZWNrLCBhc3N1cmluZyBQaWNrbGUvQVNBUiBmb3JtYXRcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZXh0OiAnYXNhcicsXG5cdFx0XHRcdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC1hc2FyJ1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKF8pIHtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4MDYsIDB4MEUsIDB4MkIsIDB4MzQsIDB4MDIsIDB4MDUsIDB4MDEsIDB4MDEsIDB4MEQsIDB4MDEsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MDJdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdteGYnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL214Zidcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrU3RyaW5nKCdTQ1JNJywge29mZnNldDogNDR9KSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdzM20nLFxuXHRcdFx0bWltZTogJ2F1ZGlvL3gtczNtJ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NDddLCB7b2Zmc2V0OiA0fSkgJiYgKGNoZWNrKFsweDQ3XSwge29mZnNldDogMTkyfSkgfHwgY2hlY2soWzB4NDddLCB7b2Zmc2V0OiAxOTZ9KSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnbXRzJyxcblx0XHRcdG1pbWU6ICd2aWRlby9tcDJ0J1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NDIsIDB4NEYsIDB4NEYsIDB4NEIsIDB4NEQsIDB4NEYsIDB4NDIsIDB4NDldLCB7b2Zmc2V0OiA2MH0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ21vYmknLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3gtbW9iaXBvY2tldC1lYm9vaydcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDQ0LCAweDQ5LCAweDQzLCAweDREXSwge29mZnNldDogMTI4fSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnZGNtJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi9kaWNvbSdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrKFsweDRDLCAweDAwLCAweDAwLCAweDAwLCAweDAxLCAweDE0LCAweDAyLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweEMwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDQ2XSkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0OiAnbG5rJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94Lm1zLnNob3J0Y3V0JyAvLyBJbnZlbnRlZCBieSB1c1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4NjIsIDB4NkYsIDB4NkYsIDB4NkIsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4NkQsIDB4NjEsIDB4NzIsIDB4NkIsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdhbGlhcycsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC5hcHBsZS5hbGlhcycgLy8gSW52ZW50ZWQgYnkgdXNcblx0XHR9O1xuXHR9XG5cblx0aWYgKFxuXHRcdGNoZWNrKFsweDRDLCAweDUwXSwge29mZnNldDogMzR9KSAmJlxuXHRcdChcblx0XHRcdGNoZWNrKFsweDAwLCAweDAwLCAweDAxXSwge29mZnNldDogOH0pIHx8XG5cdFx0XHRjaGVjayhbMHgwMSwgMHgwMCwgMHgwMl0sIHtvZmZzZXQ6IDh9KSB8fFxuXHRcdFx0Y2hlY2soWzB4MDIsIDB4MDAsIDB4MDJdLCB7b2Zmc2V0OiA4fSlcblx0XHQpXG5cdCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdlb3QnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1mb250b2JqZWN0J1xuXHRcdH07XG5cdH1cblxuXHRpZiAoY2hlY2soWzB4MDYsIDB4MDYsIDB4RUQsIDB4RjUsIDB4RDgsIDB4MUQsIDB4NDYsIDB4RTUsIDB4QkQsIDB4MzEsIDB4RUYsIDB4RTcsIDB4RkUsIDB4NzQsIDB4QjcsIDB4MURdKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdpbmRkJyxcblx0XHRcdG1pbWU6ICdhcHBsaWNhdGlvbi94LWluZGVzaWduJ1xuXHRcdH07XG5cdH1cblxuXHQvLyBJbmNyZWFzZSBzYW1wbGUgc2l6ZSBmcm9tIDI1NiB0byA1MTJcblx0YXdhaXQgdG9rZW5pemVyLnBlZWtCdWZmZXIoYnVmZmVyLCB7bGVuZ3RoOiBNYXRoLm1pbig1MTIsIHRva2VuaXplci5maWxlSW5mby5zaXplKSwgbWF5QmVMZXNzOiB0cnVlfSk7XG5cblx0Ly8gUmVxdWlyZXMgYSBidWZmZXIgc2l6ZSBvZiA1MTIgYnl0ZXNcblx0aWYgKHRhckhlYWRlckNoZWNrc3VtTWF0Y2hlcyhidWZmZXIpKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3RhcicsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24veC10YXInXG5cdFx0fTtcblx0fVxuXG5cdGlmIChjaGVjayhbMHhGRiwgMHhGRSwgMHhGRiwgMHgwRSwgMHg1MywgMHgwMCwgMHg2QiwgMHgwMCwgMHg2NSwgMHgwMCwgMHg3NCwgMHgwMCwgMHg2MywgMHgwMCwgMHg2OCwgMHgwMCwgMHg1NSwgMHgwMCwgMHg3MCwgMHgwMCwgMHgyMCwgMHgwMCwgMHg0RCwgMHgwMCwgMHg2RiwgMHgwMCwgMHg2NCwgMHgwMCwgMHg2NSwgMHgwMCwgMHg2QywgMHgwMF0pKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4dDogJ3NrcCcsXG5cdFx0XHRtaW1lOiAnYXBwbGljYXRpb24vdm5kLnNrZXRjaHVwLnNrcCdcblx0XHR9O1xuXHR9XG5cblx0aWYgKGNoZWNrU3RyaW5nKCctLS0tLUJFR0lOIFBHUCBNRVNTQUdFLS0tLS0nKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHQ6ICdwZ3AnLFxuXHRcdFx0bWltZTogJ2FwcGxpY2F0aW9uL3BncC1lbmNyeXB0ZWQnXG5cdFx0fTtcblx0fVxuXG5cdC8vIENoZWNrIE1QRUcgMSBvciAyIExheWVyIDMgaGVhZGVyLCBvciAnbGF5ZXIgMCcgZm9yIEFEVFMgKE1QRUcgc3luYy13b3JkIDB4RkZFKVxuXHRpZiAoYnVmZmVyLmxlbmd0aCA+PSAyICYmIGNoZWNrKFsweEZGLCAweEUwXSwge29mZnNldDogMCwgbWFzazogWzB4RkYsIDB4RTBdfSkpIHtcblx0XHRpZiAoY2hlY2soWzB4MTBdLCB7b2Zmc2V0OiAxLCBtYXNrOiBbMHgxNl19KSkge1xuXHRcdFx0Ly8gQ2hlY2sgZm9yIChBRFRTKSBNUEVHLTJcblx0XHRcdGlmIChjaGVjayhbMHgwOF0sIHtvZmZzZXQ6IDEsIG1hc2s6IFsweDA4XX0pKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0ZXh0OiAnYWFjJyxcblx0XHRcdFx0XHRtaW1lOiAnYXVkaW8vYWFjJ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNdXN0IGJlIChBRFRTKSBNUEVHLTRcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGV4dDogJ2FhYycsXG5cdFx0XHRcdG1pbWU6ICdhdWRpby9hYWMnXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIE1QRUcgMSBvciAyIExheWVyIDMgaGVhZGVyXG5cdFx0Ly8gQ2hlY2sgZm9yIE1QRUcgbGF5ZXIgM1xuXHRcdGlmIChjaGVjayhbMHgwMl0sIHtvZmZzZXQ6IDEsIG1hc2s6IFsweDA2XX0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdtcDMnLFxuXHRcdFx0XHRtaW1lOiAnYXVkaW8vbXBlZydcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIE1QRUcgbGF5ZXIgMlxuXHRcdGlmIChjaGVjayhbMHgwNF0sIHtvZmZzZXQ6IDEsIG1hc2s6IFsweDA2XX0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdtcDInLFxuXHRcdFx0XHRtaW1lOiAnYXVkaW8vbXBlZydcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIE1QRUcgbGF5ZXIgMVxuXHRcdGlmIChjaGVjayhbMHgwNl0sIHtvZmZzZXQ6IDEsIG1hc2s6IFsweDA2XX0pKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHQ6ICdtcDEnLFxuXHRcdFx0XHRtaW1lOiAnYXVkaW8vbXBlZydcblx0XHRcdH07XG5cdFx0fVxuXHR9XG59XG5cbmNvbnN0IHN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0Ly8gVXNpbmcgYGV2YWxgIHRvIHdvcmsgYXJvdW5kIGlzc3VlcyB3aGVuIGJ1bmRsaW5nIHdpdGggV2VicGFja1xuXHRjb25zdCBzdHJlYW0gPSBldmFsKCdyZXF1aXJlJykoJ3N0cmVhbScpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblxuXHRyZWFkYWJsZVN0cmVhbS5vbignZXJyb3InLCByZWplY3QpO1xuXHRyZWFkYWJsZVN0cmVhbS5vbmNlKCdyZWFkYWJsZScsIGFzeW5jICgpID0+IHtcblx0XHQvLyBTZXQgdXAgb3V0cHV0IHN0cmVhbVxuXHRcdGNvbnN0IHBhc3MgPSBuZXcgc3RyZWFtLlBhc3NUaHJvdWdoKCk7XG5cdFx0bGV0IG91dHB1dFN0cmVhbTtcblx0XHRpZiAoc3RyZWFtLnBpcGVsaW5lKSB7XG5cdFx0XHRvdXRwdXRTdHJlYW0gPSBzdHJlYW0ucGlwZWxpbmUocmVhZGFibGVTdHJlYW0sIHBhc3MsICgpID0+IHtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvdXRwdXRTdHJlYW0gPSByZWFkYWJsZVN0cmVhbS5waXBlKHBhc3MpO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgdGhlIGlucHV0IHN0cmVhbSBhbmQgZGV0ZWN0IHRoZSBmaWxldHlwZVxuXHRcdGNvbnN0IGNodW5rID0gcmVhZGFibGVTdHJlYW0ucmVhZChtaW5pbXVtQnl0ZXMpIHx8IHJlYWRhYmxlU3RyZWFtLnJlYWQoKSB8fCBCdWZmZXIuYWxsb2MoMCk7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGZpbGVUeXBlID0gYXdhaXQgZnJvbUJ1ZmZlcihjaHVuayk7XG5cdFx0XHRwYXNzLmZpbGVUeXBlID0gZmlsZVR5cGU7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0fVxuXG5cdFx0cmVzb2x2ZShvdXRwdXRTdHJlYW0pO1xuXHR9KTtcbn0pO1xuXG5jb25zdCBmaWxlVHlwZSA9IHtcblx0ZnJvbVN0cmVhbSxcblx0ZnJvbVRva2VuaXplcixcblx0ZnJvbUJ1ZmZlcixcblx0c3RyZWFtXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZmlsZVR5cGUsICdleHRlbnNpb25zJywge1xuXHRnZXQoKSB7XG5cdFx0cmV0dXJuIG5ldyBTZXQoc3VwcG9ydGVkLmV4dGVuc2lvbnMpO1xuXHR9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGZpbGVUeXBlLCAnbWltZVR5cGVzJywge1xuXHRnZXQoKSB7XG5cdFx0cmV0dXJuIG5ldyBTZXQoc3VwcG9ydGVkLm1pbWVUeXBlcyk7XG5cdH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbGVUeXBlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/file-type/core.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/file-type/supported.js":
/*!*********************************************!*\
  !*** ./node_modules/file-type/supported.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nmodule.exports = {\n\textensions: [\n\t\t'jpg',\n\t\t'png',\n\t\t'apng',\n\t\t'gif',\n\t\t'webp',\n\t\t'flif',\n\t\t'xcf',\n\t\t'cr2',\n\t\t'cr3',\n\t\t'orf',\n\t\t'arw',\n\t\t'dng',\n\t\t'nef',\n\t\t'rw2',\n\t\t'raf',\n\t\t'tif',\n\t\t'bmp',\n\t\t'icns',\n\t\t'jxr',\n\t\t'psd',\n\t\t'indd',\n\t\t'zip',\n\t\t'tar',\n\t\t'rar',\n\t\t'gz',\n\t\t'bz2',\n\t\t'7z',\n\t\t'dmg',\n\t\t'mp4',\n\t\t'mid',\n\t\t'mkv',\n\t\t'webm',\n\t\t'mov',\n\t\t'avi',\n\t\t'mpg',\n\t\t'mp2',\n\t\t'mp3',\n\t\t'm4a',\n\t\t'oga',\n\t\t'ogg',\n\t\t'ogv',\n\t\t'opus',\n\t\t'flac',\n\t\t'wav',\n\t\t'spx',\n\t\t'amr',\n\t\t'pdf',\n\t\t'epub',\n\t\t'exe',\n\t\t'swf',\n\t\t'rtf',\n\t\t'wasm',\n\t\t'woff',\n\t\t'woff2',\n\t\t'eot',\n\t\t'ttf',\n\t\t'otf',\n\t\t'ico',\n\t\t'flv',\n\t\t'ps',\n\t\t'xz',\n\t\t'sqlite',\n\t\t'nes',\n\t\t'crx',\n\t\t'xpi',\n\t\t'cab',\n\t\t'deb',\n\t\t'ar',\n\t\t'rpm',\n\t\t'Z',\n\t\t'lz',\n\t\t'cfb',\n\t\t'mxf',\n\t\t'mts',\n\t\t'blend',\n\t\t'bpg',\n\t\t'docx',\n\t\t'pptx',\n\t\t'xlsx',\n\t\t'3gp',\n\t\t'3g2',\n\t\t'jp2',\n\t\t'jpm',\n\t\t'jpx',\n\t\t'mj2',\n\t\t'aif',\n\t\t'qcp',\n\t\t'odt',\n\t\t'ods',\n\t\t'odp',\n\t\t'xml',\n\t\t'mobi',\n\t\t'heic',\n\t\t'cur',\n\t\t'ktx',\n\t\t'ape',\n\t\t'wv',\n\t\t'dcm',\n\t\t'ics',\n\t\t'glb',\n\t\t'pcap',\n\t\t'dsf',\n\t\t'lnk',\n\t\t'alias',\n\t\t'voc',\n\t\t'ac3',\n\t\t'm4v',\n\t\t'm4p',\n\t\t'm4b',\n\t\t'f4v',\n\t\t'f4p',\n\t\t'f4b',\n\t\t'f4a',\n\t\t'mie',\n\t\t'asf',\n\t\t'ogm',\n\t\t'ogx',\n\t\t'mpc',\n\t\t'arrow',\n\t\t'shp',\n\t\t'aac',\n\t\t'mp1',\n\t\t'it',\n\t\t's3m',\n\t\t'xm',\n\t\t'ai',\n\t\t'skp',\n\t\t'avif',\n\t\t'eps',\n\t\t'lzh',\n\t\t'pgp',\n\t\t'asar',\n\t\t'stl',\n\t\t'chm',\n\t\t'3mf',\n\t\t'zst',\n\t\t'jxl',\n\t\t'vcf'\n\t],\n\tmimeTypes: [\n\t\t'image/jpeg',\n\t\t'image/png',\n\t\t'image/gif',\n\t\t'image/webp',\n\t\t'image/flif',\n\t\t'image/x-xcf',\n\t\t'image/x-canon-cr2',\n\t\t'image/x-canon-cr3',\n\t\t'image/tiff',\n\t\t'image/bmp',\n\t\t'image/vnd.ms-photo',\n\t\t'image/vnd.adobe.photoshop',\n\t\t'application/x-indesign',\n\t\t'application/epub+zip',\n\t\t'application/x-xpinstall',\n\t\t'application/vnd.oasis.opendocument.text',\n\t\t'application/vnd.oasis.opendocument.spreadsheet',\n\t\t'application/vnd.oasis.opendocument.presentation',\n\t\t'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n\t\t'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n\t\t'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n\t\t'application/zip',\n\t\t'application/x-tar',\n\t\t'application/x-rar-compressed',\n\t\t'application/gzip',\n\t\t'application/x-bzip2',\n\t\t'application/x-7z-compressed',\n\t\t'application/x-apple-diskimage',\n\t\t'application/x-apache-arrow',\n\t\t'video/mp4',\n\t\t'audio/midi',\n\t\t'video/x-matroska',\n\t\t'video/webm',\n\t\t'video/quicktime',\n\t\t'video/vnd.avi',\n\t\t'audio/vnd.wave',\n\t\t'audio/qcelp',\n\t\t'audio/x-ms-asf',\n\t\t'video/x-ms-asf',\n\t\t'application/vnd.ms-asf',\n\t\t'video/mpeg',\n\t\t'video/3gpp',\n\t\t'audio/mpeg',\n\t\t'audio/mp4', // RFC 4337\n\t\t'audio/opus',\n\t\t'video/ogg',\n\t\t'audio/ogg',\n\t\t'application/ogg',\n\t\t'audio/x-flac',\n\t\t'audio/ape',\n\t\t'audio/wavpack',\n\t\t'audio/amr',\n\t\t'application/pdf',\n\t\t'application/x-msdownload',\n\t\t'application/x-shockwave-flash',\n\t\t'application/rtf',\n\t\t'application/wasm',\n\t\t'font/woff',\n\t\t'font/woff2',\n\t\t'application/vnd.ms-fontobject',\n\t\t'font/ttf',\n\t\t'font/otf',\n\t\t'image/x-icon',\n\t\t'video/x-flv',\n\t\t'application/postscript',\n\t\t'application/eps',\n\t\t'application/x-xz',\n\t\t'application/x-sqlite3',\n\t\t'application/x-nintendo-nes-rom',\n\t\t'application/x-google-chrome-extension',\n\t\t'application/vnd.ms-cab-compressed',\n\t\t'application/x-deb',\n\t\t'application/x-unix-archive',\n\t\t'application/x-rpm',\n\t\t'application/x-compress',\n\t\t'application/x-lzip',\n\t\t'application/x-cfb',\n\t\t'application/x-mie',\n\t\t'application/mxf',\n\t\t'video/mp2t',\n\t\t'application/x-blender',\n\t\t'image/bpg',\n\t\t'image/jp2',\n\t\t'image/jpx',\n\t\t'image/jpm',\n\t\t'image/mj2',\n\t\t'audio/aiff',\n\t\t'application/xml',\n\t\t'application/x-mobipocket-ebook',\n\t\t'image/heif',\n\t\t'image/heif-sequence',\n\t\t'image/heic',\n\t\t'image/heic-sequence',\n\t\t'image/icns',\n\t\t'image/ktx',\n\t\t'application/dicom',\n\t\t'audio/x-musepack',\n\t\t'text/calendar',\n\t\t'text/vcard',\n\t\t'model/gltf-binary',\n\t\t'application/vnd.tcpdump.pcap',\n\t\t'audio/x-dsf', // Non-standard\n\t\t'application/x.ms.shortcut', // Invented by us\n\t\t'application/x.apple.alias', // Invented by us\n\t\t'audio/x-voc',\n\t\t'audio/vnd.dolby.dd-raw',\n\t\t'audio/x-m4a',\n\t\t'image/apng',\n\t\t'image/x-olympus-orf',\n\t\t'image/x-sony-arw',\n\t\t'image/x-adobe-dng',\n\t\t'image/x-nikon-nef',\n\t\t'image/x-panasonic-rw2',\n\t\t'image/x-fujifilm-raf',\n\t\t'video/x-m4v',\n\t\t'video/3gpp2',\n\t\t'application/x-esri-shape',\n\t\t'audio/aac',\n\t\t'audio/x-it',\n\t\t'audio/x-s3m',\n\t\t'audio/x-xm',\n\t\t'video/MP1S',\n\t\t'video/MP2P',\n\t\t'application/vnd.sketchup.skp',\n\t\t'image/avif',\n\t\t'application/x-lzh-compressed',\n\t\t'application/pgp-encrypted',\n\t\t'application/x-asar',\n\t\t'model/stl',\n\t\t'application/vnd.ms-htmlhelp',\n\t\t'model/3mf',\n\t\t'image/jxl',\n\t\t'application/zstd'\n\t]\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9maWxlLXR5cGUvc3VwcG9ydGVkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9maWxlLXR5cGUvc3VwcG9ydGVkLmpzPzc5NTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0ZXh0ZW5zaW9uczogW1xuXHRcdCdqcGcnLFxuXHRcdCdwbmcnLFxuXHRcdCdhcG5nJyxcblx0XHQnZ2lmJyxcblx0XHQnd2VicCcsXG5cdFx0J2ZsaWYnLFxuXHRcdCd4Y2YnLFxuXHRcdCdjcjInLFxuXHRcdCdjcjMnLFxuXHRcdCdvcmYnLFxuXHRcdCdhcncnLFxuXHRcdCdkbmcnLFxuXHRcdCduZWYnLFxuXHRcdCdydzInLFxuXHRcdCdyYWYnLFxuXHRcdCd0aWYnLFxuXHRcdCdibXAnLFxuXHRcdCdpY25zJyxcblx0XHQnanhyJyxcblx0XHQncHNkJyxcblx0XHQnaW5kZCcsXG5cdFx0J3ppcCcsXG5cdFx0J3RhcicsXG5cdFx0J3JhcicsXG5cdFx0J2d6Jyxcblx0XHQnYnoyJyxcblx0XHQnN3onLFxuXHRcdCdkbWcnLFxuXHRcdCdtcDQnLFxuXHRcdCdtaWQnLFxuXHRcdCdta3YnLFxuXHRcdCd3ZWJtJyxcblx0XHQnbW92Jyxcblx0XHQnYXZpJyxcblx0XHQnbXBnJyxcblx0XHQnbXAyJyxcblx0XHQnbXAzJyxcblx0XHQnbTRhJyxcblx0XHQnb2dhJyxcblx0XHQnb2dnJyxcblx0XHQnb2d2Jyxcblx0XHQnb3B1cycsXG5cdFx0J2ZsYWMnLFxuXHRcdCd3YXYnLFxuXHRcdCdzcHgnLFxuXHRcdCdhbXInLFxuXHRcdCdwZGYnLFxuXHRcdCdlcHViJyxcblx0XHQnZXhlJyxcblx0XHQnc3dmJyxcblx0XHQncnRmJyxcblx0XHQnd2FzbScsXG5cdFx0J3dvZmYnLFxuXHRcdCd3b2ZmMicsXG5cdFx0J2VvdCcsXG5cdFx0J3R0ZicsXG5cdFx0J290ZicsXG5cdFx0J2ljbycsXG5cdFx0J2ZsdicsXG5cdFx0J3BzJyxcblx0XHQneHonLFxuXHRcdCdzcWxpdGUnLFxuXHRcdCduZXMnLFxuXHRcdCdjcngnLFxuXHRcdCd4cGknLFxuXHRcdCdjYWInLFxuXHRcdCdkZWInLFxuXHRcdCdhcicsXG5cdFx0J3JwbScsXG5cdFx0J1onLFxuXHRcdCdseicsXG5cdFx0J2NmYicsXG5cdFx0J214ZicsXG5cdFx0J210cycsXG5cdFx0J2JsZW5kJyxcblx0XHQnYnBnJyxcblx0XHQnZG9jeCcsXG5cdFx0J3BwdHgnLFxuXHRcdCd4bHN4Jyxcblx0XHQnM2dwJyxcblx0XHQnM2cyJyxcblx0XHQnanAyJyxcblx0XHQnanBtJyxcblx0XHQnanB4Jyxcblx0XHQnbWoyJyxcblx0XHQnYWlmJyxcblx0XHQncWNwJyxcblx0XHQnb2R0Jyxcblx0XHQnb2RzJyxcblx0XHQnb2RwJyxcblx0XHQneG1sJyxcblx0XHQnbW9iaScsXG5cdFx0J2hlaWMnLFxuXHRcdCdjdXInLFxuXHRcdCdrdHgnLFxuXHRcdCdhcGUnLFxuXHRcdCd3dicsXG5cdFx0J2RjbScsXG5cdFx0J2ljcycsXG5cdFx0J2dsYicsXG5cdFx0J3BjYXAnLFxuXHRcdCdkc2YnLFxuXHRcdCdsbmsnLFxuXHRcdCdhbGlhcycsXG5cdFx0J3ZvYycsXG5cdFx0J2FjMycsXG5cdFx0J200dicsXG5cdFx0J200cCcsXG5cdFx0J200YicsXG5cdFx0J2Y0dicsXG5cdFx0J2Y0cCcsXG5cdFx0J2Y0YicsXG5cdFx0J2Y0YScsXG5cdFx0J21pZScsXG5cdFx0J2FzZicsXG5cdFx0J29nbScsXG5cdFx0J29neCcsXG5cdFx0J21wYycsXG5cdFx0J2Fycm93Jyxcblx0XHQnc2hwJyxcblx0XHQnYWFjJyxcblx0XHQnbXAxJyxcblx0XHQnaXQnLFxuXHRcdCdzM20nLFxuXHRcdCd4bScsXG5cdFx0J2FpJyxcblx0XHQnc2twJyxcblx0XHQnYXZpZicsXG5cdFx0J2VwcycsXG5cdFx0J2x6aCcsXG5cdFx0J3BncCcsXG5cdFx0J2FzYXInLFxuXHRcdCdzdGwnLFxuXHRcdCdjaG0nLFxuXHRcdCczbWYnLFxuXHRcdCd6c3QnLFxuXHRcdCdqeGwnLFxuXHRcdCd2Y2YnXG5cdF0sXG5cdG1pbWVUeXBlczogW1xuXHRcdCdpbWFnZS9qcGVnJyxcblx0XHQnaW1hZ2UvcG5nJyxcblx0XHQnaW1hZ2UvZ2lmJyxcblx0XHQnaW1hZ2Uvd2VicCcsXG5cdFx0J2ltYWdlL2ZsaWYnLFxuXHRcdCdpbWFnZS94LXhjZicsXG5cdFx0J2ltYWdlL3gtY2Fub24tY3IyJyxcblx0XHQnaW1hZ2UveC1jYW5vbi1jcjMnLFxuXHRcdCdpbWFnZS90aWZmJyxcblx0XHQnaW1hZ2UvYm1wJyxcblx0XHQnaW1hZ2Uvdm5kLm1zLXBob3RvJyxcblx0XHQnaW1hZ2Uvdm5kLmFkb2JlLnBob3Rvc2hvcCcsXG5cdFx0J2FwcGxpY2F0aW9uL3gtaW5kZXNpZ24nLFxuXHRcdCdhcHBsaWNhdGlvbi9lcHViK3ppcCcsXG5cdFx0J2FwcGxpY2F0aW9uL3gteHBpbnN0YWxsJyxcblx0XHQnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0Jyxcblx0XHQnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5zcHJlYWRzaGVldCcsXG5cdFx0J2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uJyxcblx0XHQnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLFxuXHRcdCdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uJyxcblx0XHQnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQnLFxuXHRcdCdhcHBsaWNhdGlvbi96aXAnLFxuXHRcdCdhcHBsaWNhdGlvbi94LXRhcicsXG5cdFx0J2FwcGxpY2F0aW9uL3gtcmFyLWNvbXByZXNzZWQnLFxuXHRcdCdhcHBsaWNhdGlvbi9nemlwJyxcblx0XHQnYXBwbGljYXRpb24veC1iemlwMicsXG5cdFx0J2FwcGxpY2F0aW9uL3gtN3otY29tcHJlc3NlZCcsXG5cdFx0J2FwcGxpY2F0aW9uL3gtYXBwbGUtZGlza2ltYWdlJyxcblx0XHQnYXBwbGljYXRpb24veC1hcGFjaGUtYXJyb3cnLFxuXHRcdCd2aWRlby9tcDQnLFxuXHRcdCdhdWRpby9taWRpJyxcblx0XHQndmlkZW8veC1tYXRyb3NrYScsXG5cdFx0J3ZpZGVvL3dlYm0nLFxuXHRcdCd2aWRlby9xdWlja3RpbWUnLFxuXHRcdCd2aWRlby92bmQuYXZpJyxcblx0XHQnYXVkaW8vdm5kLndhdmUnLFxuXHRcdCdhdWRpby9xY2VscCcsXG5cdFx0J2F1ZGlvL3gtbXMtYXNmJyxcblx0XHQndmlkZW8veC1tcy1hc2YnLFxuXHRcdCdhcHBsaWNhdGlvbi92bmQubXMtYXNmJyxcblx0XHQndmlkZW8vbXBlZycsXG5cdFx0J3ZpZGVvLzNncHAnLFxuXHRcdCdhdWRpby9tcGVnJyxcblx0XHQnYXVkaW8vbXA0JywgLy8gUkZDIDQzMzdcblx0XHQnYXVkaW8vb3B1cycsXG5cdFx0J3ZpZGVvL29nZycsXG5cdFx0J2F1ZGlvL29nZycsXG5cdFx0J2FwcGxpY2F0aW9uL29nZycsXG5cdFx0J2F1ZGlvL3gtZmxhYycsXG5cdFx0J2F1ZGlvL2FwZScsXG5cdFx0J2F1ZGlvL3dhdnBhY2snLFxuXHRcdCdhdWRpby9hbXInLFxuXHRcdCdhcHBsaWNhdGlvbi9wZGYnLFxuXHRcdCdhcHBsaWNhdGlvbi94LW1zZG93bmxvYWQnLFxuXHRcdCdhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCcsXG5cdFx0J2FwcGxpY2F0aW9uL3J0ZicsXG5cdFx0J2FwcGxpY2F0aW9uL3dhc20nLFxuXHRcdCdmb250L3dvZmYnLFxuXHRcdCdmb250L3dvZmYyJyxcblx0XHQnYXBwbGljYXRpb24vdm5kLm1zLWZvbnRvYmplY3QnLFxuXHRcdCdmb250L3R0ZicsXG5cdFx0J2ZvbnQvb3RmJyxcblx0XHQnaW1hZ2UveC1pY29uJyxcblx0XHQndmlkZW8veC1mbHYnLFxuXHRcdCdhcHBsaWNhdGlvbi9wb3N0c2NyaXB0Jyxcblx0XHQnYXBwbGljYXRpb24vZXBzJyxcblx0XHQnYXBwbGljYXRpb24veC14eicsXG5cdFx0J2FwcGxpY2F0aW9uL3gtc3FsaXRlMycsXG5cdFx0J2FwcGxpY2F0aW9uL3gtbmludGVuZG8tbmVzLXJvbScsXG5cdFx0J2FwcGxpY2F0aW9uL3gtZ29vZ2xlLWNocm9tZS1leHRlbnNpb24nLFxuXHRcdCdhcHBsaWNhdGlvbi92bmQubXMtY2FiLWNvbXByZXNzZWQnLFxuXHRcdCdhcHBsaWNhdGlvbi94LWRlYicsXG5cdFx0J2FwcGxpY2F0aW9uL3gtdW5peC1hcmNoaXZlJyxcblx0XHQnYXBwbGljYXRpb24veC1ycG0nLFxuXHRcdCdhcHBsaWNhdGlvbi94LWNvbXByZXNzJyxcblx0XHQnYXBwbGljYXRpb24veC1semlwJyxcblx0XHQnYXBwbGljYXRpb24veC1jZmInLFxuXHRcdCdhcHBsaWNhdGlvbi94LW1pZScsXG5cdFx0J2FwcGxpY2F0aW9uL214ZicsXG5cdFx0J3ZpZGVvL21wMnQnLFxuXHRcdCdhcHBsaWNhdGlvbi94LWJsZW5kZXInLFxuXHRcdCdpbWFnZS9icGcnLFxuXHRcdCdpbWFnZS9qcDInLFxuXHRcdCdpbWFnZS9qcHgnLFxuXHRcdCdpbWFnZS9qcG0nLFxuXHRcdCdpbWFnZS9tajInLFxuXHRcdCdhdWRpby9haWZmJyxcblx0XHQnYXBwbGljYXRpb24veG1sJyxcblx0XHQnYXBwbGljYXRpb24veC1tb2JpcG9ja2V0LWVib29rJyxcblx0XHQnaW1hZ2UvaGVpZicsXG5cdFx0J2ltYWdlL2hlaWYtc2VxdWVuY2UnLFxuXHRcdCdpbWFnZS9oZWljJyxcblx0XHQnaW1hZ2UvaGVpYy1zZXF1ZW5jZScsXG5cdFx0J2ltYWdlL2ljbnMnLFxuXHRcdCdpbWFnZS9rdHgnLFxuXHRcdCdhcHBsaWNhdGlvbi9kaWNvbScsXG5cdFx0J2F1ZGlvL3gtbXVzZXBhY2snLFxuXHRcdCd0ZXh0L2NhbGVuZGFyJyxcblx0XHQndGV4dC92Y2FyZCcsXG5cdFx0J21vZGVsL2dsdGYtYmluYXJ5Jyxcblx0XHQnYXBwbGljYXRpb24vdm5kLnRjcGR1bXAucGNhcCcsXG5cdFx0J2F1ZGlvL3gtZHNmJywgLy8gTm9uLXN0YW5kYXJkXG5cdFx0J2FwcGxpY2F0aW9uL3gubXMuc2hvcnRjdXQnLCAvLyBJbnZlbnRlZCBieSB1c1xuXHRcdCdhcHBsaWNhdGlvbi94LmFwcGxlLmFsaWFzJywgLy8gSW52ZW50ZWQgYnkgdXNcblx0XHQnYXVkaW8veC12b2MnLFxuXHRcdCdhdWRpby92bmQuZG9sYnkuZGQtcmF3Jyxcblx0XHQnYXVkaW8veC1tNGEnLFxuXHRcdCdpbWFnZS9hcG5nJyxcblx0XHQnaW1hZ2UveC1vbHltcHVzLW9yZicsXG5cdFx0J2ltYWdlL3gtc29ueS1hcncnLFxuXHRcdCdpbWFnZS94LWFkb2JlLWRuZycsXG5cdFx0J2ltYWdlL3gtbmlrb24tbmVmJyxcblx0XHQnaW1hZ2UveC1wYW5hc29uaWMtcncyJyxcblx0XHQnaW1hZ2UveC1mdWppZmlsbS1yYWYnLFxuXHRcdCd2aWRlby94LW00dicsXG5cdFx0J3ZpZGVvLzNncHAyJyxcblx0XHQnYXBwbGljYXRpb24veC1lc3JpLXNoYXBlJyxcblx0XHQnYXVkaW8vYWFjJyxcblx0XHQnYXVkaW8veC1pdCcsXG5cdFx0J2F1ZGlvL3gtczNtJyxcblx0XHQnYXVkaW8veC14bScsXG5cdFx0J3ZpZGVvL01QMVMnLFxuXHRcdCd2aWRlby9NUDJQJyxcblx0XHQnYXBwbGljYXRpb24vdm5kLnNrZXRjaHVwLnNrcCcsXG5cdFx0J2ltYWdlL2F2aWYnLFxuXHRcdCdhcHBsaWNhdGlvbi94LWx6aC1jb21wcmVzc2VkJyxcblx0XHQnYXBwbGljYXRpb24vcGdwLWVuY3J5cHRlZCcsXG5cdFx0J2FwcGxpY2F0aW9uL3gtYXNhcicsXG5cdFx0J21vZGVsL3N0bCcsXG5cdFx0J2FwcGxpY2F0aW9uL3ZuZC5tcy1odG1saGVscCcsXG5cdFx0J21vZGVsLzNtZicsXG5cdFx0J2ltYWdlL2p4bCcsXG5cdFx0J2FwcGxpY2F0aW9uL3pzdGQnXG5cdF1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/file-type/supported.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/file-type/util.js":
/*!****************************************!*\
  !*** ./node_modules/file-type/util.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.stringToBytes = string => [...string].map(character => character.charCodeAt(0));\n\n/**\nChecks whether the TAR checksum is valid.\n\n@param {Buffer} buffer - The TAR header `[offset ... offset + 512]`.\n@param {number} offset - TAR header offset.\n@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.\n*/\nexports.tarHeaderChecksumMatches = (buffer, offset = 0) => {\n\tconst readSum = parseInt(buffer.toString('utf8', 148, 154).replace(/\\0.*$/, '').trim(), 8); // Read sum in header\n\tif (isNaN(readSum)) {\n\t\treturn false;\n\t}\n\n\tlet sum = 8 * 0x20; // Initialize signed bit sum\n\n\tfor (let i = offset; i < offset + 148; i++) {\n\t\tsum += buffer[i];\n\t}\n\n\tfor (let i = offset + 156; i < offset + 512; i++) {\n\t\tsum += buffer[i];\n\t}\n\n\treturn readSum === sum;\n};\n\n/**\nID3 UINT32 sync-safe tokenizer token.\n28 bits (representing up to 256MB) integer, the msb is 0 to avoid \"false syncsignals\".\n*/\nexports.uint32SyncSafeToken = {\n\tget: (buffer, offset) => {\n\t\treturn (buffer[offset + 3] & 0x7F) | ((buffer[offset + 2]) << 7) | ((buffer[offset + 1]) << 14) | ((buffer[offset]) << 21);\n\t},\n\tlen: 4\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9maWxlLXR5cGUvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixxQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUEsUUFBUSxRQUFRO0FBQ2hCLFFBQVEsUUFBUTtBQUNoQixVQUFVLFNBQVM7QUFDbkI7QUFDQSxnQ0FBZ0M7QUFDaEMsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTs7QUFFQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2ZpbGUtdHlwZS91dGlsLmpzP2ExNDIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmcgPT4gWy4uLnN0cmluZ10ubWFwKGNoYXJhY3RlciA9PiBjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSk7XG5cbi8qKlxuQ2hlY2tzIHdoZXRoZXIgdGhlIFRBUiBjaGVja3N1bSBpcyB2YWxpZC5cblxuQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciAtIFRoZSBUQVIgaGVhZGVyIGBbb2Zmc2V0IC4uLiBvZmZzZXQgKyA1MTJdYC5cbkBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUQVIgaGVhZGVyIG9mZnNldC5cbkByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIFRBUiBjaGVja3N1bSBpcyB2YWxpZCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4qL1xuZXhwb3J0cy50YXJIZWFkZXJDaGVja3N1bU1hdGNoZXMgPSAoYnVmZmVyLCBvZmZzZXQgPSAwKSA9PiB7XG5cdGNvbnN0IHJlYWRTdW0gPSBwYXJzZUludChidWZmZXIudG9TdHJpbmcoJ3V0ZjgnLCAxNDgsIDE1NCkucmVwbGFjZSgvXFwwLiokLywgJycpLnRyaW0oKSwgOCk7IC8vIFJlYWQgc3VtIGluIGhlYWRlclxuXHRpZiAoaXNOYU4ocmVhZFN1bSkpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRsZXQgc3VtID0gOCAqIDB4MjA7IC8vIEluaXRpYWxpemUgc2lnbmVkIGJpdCBzdW1cblxuXHRmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgb2Zmc2V0ICsgMTQ4OyBpKyspIHtcblx0XHRzdW0gKz0gYnVmZmVyW2ldO1xuXHR9XG5cblx0Zm9yIChsZXQgaSA9IG9mZnNldCArIDE1NjsgaSA8IG9mZnNldCArIDUxMjsgaSsrKSB7XG5cdFx0c3VtICs9IGJ1ZmZlcltpXTtcblx0fVxuXG5cdHJldHVybiByZWFkU3VtID09PSBzdW07XG59O1xuXG4vKipcbklEMyBVSU5UMzIgc3luYy1zYWZlIHRva2VuaXplciB0b2tlbi5cbjI4IGJpdHMgKHJlcHJlc2VudGluZyB1cCB0byAyNTZNQikgaW50ZWdlciwgdGhlIG1zYiBpcyAwIHRvIGF2b2lkIFwiZmFsc2Ugc3luY3NpZ25hbHNcIi5cbiovXG5leHBvcnRzLnVpbnQzMlN5bmNTYWZlVG9rZW4gPSB7XG5cdGdldDogKGJ1ZmZlciwgb2Zmc2V0KSA9PiB7XG5cdFx0cmV0dXJuIChidWZmZXJbb2Zmc2V0ICsgM10gJiAweDdGKSB8ICgoYnVmZmVyW29mZnNldCArIDJdKSA8PCA3KSB8ICgoYnVmZmVyW29mZnNldCArIDFdKSA8PCAxNCkgfCAoKGJ1ZmZlcltvZmZzZXRdKSA8PCAyMSk7XG5cdH0sXG5cdGxlbjogNFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/file-type/util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLFNBQVMsVUFBVTs7QUFFbkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz82NGRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanM/OWMxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/inherits/inherits_browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/Zjg0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ms/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata-browser/lib/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata-browser/lib/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.fetchFromUrl = exports.parseBlob = exports.parseReadableStream = exports.parseNodeStream = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = void 0;\r\nconst initDebug = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\r\nconst mm = __webpack_require__(/*! music-metadata/lib/core */ \"(app-pages-browser)/./node_modules/music-metadata/lib/core.js\");\r\nconst readable_web_to_node_stream_1 = __webpack_require__(/*! readable-web-to-node-stream */ \"(app-pages-browser)/./node_modules/readable-web-to-node-stream/lib/index.js\");\r\nconst debug = initDebug('music-metadata-browser:main');\r\nvar core_1 = __webpack_require__(/*! music-metadata/lib/core */ \"(app-pages-browser)/./node_modules/music-metadata/lib/core.js\");\r\nObject.defineProperty(exports, \"parseBuffer\", ({ enumerable: true, get: function () { return core_1.parseBuffer; } }));\r\nObject.defineProperty(exports, \"parseFromTokenizer\", ({ enumerable: true, get: function () { return core_1.parseFromTokenizer; } }));\r\nObject.defineProperty(exports, \"orderTags\", ({ enumerable: true, get: function () { return core_1.orderTags; } }));\r\nObject.defineProperty(exports, \"ratingToStars\", ({ enumerable: true, get: function () { return core_1.ratingToStars; } }));\r\nObject.defineProperty(exports, \"selectCover\", ({ enumerable: true, get: function () { return core_1.selectCover; } }));\r\n/**\r\n * Parse audio Stream\r\n * @param stream - ReadableStream\r\n * @param contentType - MIME-Type\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nexports.parseNodeStream = mm.parseStream;\r\n/**\r\n * Parse Web API ReadableStream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\r\n * @param stream - ReadableStream (web stream according WTWG Streams Standard)\r\n * @param fileInfo FileInfo object or MIME-Type\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nasync function parseReadableStream(stream, fileInfo, options) {\r\n    const ns = new readable_web_to_node_stream_1.ReadableWebToNodeStream(stream);\r\n    const res = await (0, exports.parseNodeStream)(ns, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo, options);\r\n    await ns.close();\r\n    return res;\r\n}\r\nexports.parseReadableStream = parseReadableStream;\r\n/**\r\n * Parse Web API File\r\n * @param blob - Blob to parse\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nasync function parseBlob(blob, options) {\r\n    const fileInfo = { mimeType: blob.type, size: blob.size };\r\n    if (blob instanceof File) {\r\n        fileInfo.path = blob.name;\r\n    }\r\n    const stream = (blob.stream ? blob.stream() : convertBlobToReadableStream(blob));\r\n    return parseReadableStream(stream, { mimeType: blob.type, size: blob.size }, options);\r\n}\r\nexports.parseBlob = parseBlob;\r\n/**\r\n * Convert Blob to ReadableStream\r\n * Fallback for Safari versions < 14.1\r\n * @param blob\r\n */\r\nfunction convertBlobToReadableStream(blob) {\r\n    const fileReader = new FileReader();\r\n    return new ReadableStream({\r\n        start(controller) {\r\n            // The following function handles each data chunk\r\n            fileReader.onloadend = event => {\r\n                let data = event.target.result;\r\n                if (data instanceof ArrayBuffer) {\r\n                    data = new Uint8Array(data);\r\n                }\r\n                controller.enqueue(data);\r\n                controller.close();\r\n            };\r\n            fileReader.onerror = error => {\r\n                controller.close();\r\n            };\r\n            fileReader.onabort = error => {\r\n                controller.close();\r\n            };\r\n            fileReader.readAsArrayBuffer(blob);\r\n        }\r\n    });\r\n}\r\n/**\r\n * Parse fetched file, using the Web Fetch API\r\n * @param audioTrackUrl - URL to download the audio track from\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nasync function fetchFromUrl(audioTrackUrl, options) {\r\n    const response = await fetch(audioTrackUrl);\r\n    const fileInfo = {\r\n        size: parseInt(response.headers.get('Content-Length'), 10),\r\n        mimeType: response.headers.get('Content-Type')\r\n    };\r\n    if (response.ok) {\r\n        if (response.body) {\r\n            const res = await parseReadableStream(response.body, fileInfo, options);\r\n            debug('Closing HTTP-readable-stream...');\r\n            if (!response.body.locked) { // Prevent error in Firefox\r\n                await response.body.cancel();\r\n            }\r\n            debug('HTTP-readable-stream closed.');\r\n            return res;\r\n        }\r\n        else {\r\n            // Fall back on Blob\r\n            return parseBlob(await response.blob(), options);\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(`HTTP error status=${response.status}: ${response.statusText}`);\r\n    }\r\n}\r\nexports.fetchFromUrl = fetchFromUrl;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS1icm93c2VyL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxpQkFBaUIsR0FBRywyQkFBMkIsR0FBRyx1QkFBdUIsR0FBRyxtQkFBbUIsR0FBRyxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRywwQkFBMEIsR0FBRyxtQkFBbUI7QUFDck4sa0JBQWtCLG1CQUFPLENBQUMsc0VBQU87QUFDakMsV0FBVyxtQkFBTyxDQUFDLDhGQUF5QjtBQUM1QyxzQ0FBc0MsbUJBQU8sQ0FBQyxnSEFBNkI7QUFDM0U7QUFDQSxhQUFhLG1CQUFPLENBQUMsOEZBQXlCO0FBQzlDLCtDQUE4QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNwSCxzREFBcUQsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDbEksNkNBQTRDLEVBQUUscUNBQXFDLDRCQUE0QixFQUFDO0FBQ2hILGlEQUFnRCxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUN4SCwrQ0FBOEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLHFCQUFxQjtBQUM3RztBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0NBQXNDO0FBQy9FO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQixJQUFJLG9CQUFvQjtBQUNyRjtBQUNBO0FBQ0Esb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS1icm93c2VyL2xpYi9pbmRleC5qcz84ZjBlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZmV0Y2hGcm9tVXJsID0gZXhwb3J0cy5wYXJzZUJsb2IgPSBleHBvcnRzLnBhcnNlUmVhZGFibGVTdHJlYW0gPSBleHBvcnRzLnBhcnNlTm9kZVN0cmVhbSA9IGV4cG9ydHMuc2VsZWN0Q292ZXIgPSBleHBvcnRzLnJhdGluZ1RvU3RhcnMgPSBleHBvcnRzLm9yZGVyVGFncyA9IGV4cG9ydHMucGFyc2VGcm9tVG9rZW5pemVyID0gZXhwb3J0cy5wYXJzZUJ1ZmZlciA9IHZvaWQgMDtcclxuY29uc3QgaW5pdERlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpO1xyXG5jb25zdCBtbSA9IHJlcXVpcmUoXCJtdXNpYy1tZXRhZGF0YS9saWIvY29yZVwiKTtcclxuY29uc3QgcmVhZGFibGVfd2ViX3RvX25vZGVfc3RyZWFtXzEgPSByZXF1aXJlKFwicmVhZGFibGUtd2ViLXRvLW5vZGUtc3RyZWFtXCIpO1xyXG5jb25zdCBkZWJ1ZyA9IGluaXREZWJ1ZygnbXVzaWMtbWV0YWRhdGEtYnJvd3NlcjptYWluJyk7XHJcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwibXVzaWMtbWV0YWRhdGEvbGliL2NvcmVcIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlQnVmZmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlXzEucGFyc2VCdWZmZXI7IH0gfSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlRnJvbVRva2VuaXplclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29yZV8xLnBhcnNlRnJvbVRva2VuaXplcjsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwib3JkZXJUYWdzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlXzEub3JkZXJUYWdzOyB9IH0pO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyYXRpbmdUb1N0YXJzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlXzEucmF0aW5nVG9TdGFyczsgfSB9KTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2VsZWN0Q292ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmVfMS5zZWxlY3RDb3ZlcjsgfSB9KTtcclxuLyoqXHJcbiAqIFBhcnNlIGF1ZGlvIFN0cmVhbVxyXG4gKiBAcGFyYW0gc3RyZWFtIC0gUmVhZGFibGVTdHJlYW1cclxuICogQHBhcmFtIGNvbnRlbnRUeXBlIC0gTUlNRS1UeXBlXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0gUGFyc2luZyBvcHRpb25zXHJcbiAqIEByZXR1cm5zIE1ldGFkYXRhXHJcbiAqL1xyXG5leHBvcnRzLnBhcnNlTm9kZVN0cmVhbSA9IG1tLnBhcnNlU3RyZWFtO1xyXG4vKipcclxuICogUGFyc2UgV2ViIEFQSSBSZWFkYWJsZVN0cmVhbTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JlYWRhYmxlU3RyZWFtXHJcbiAqIEBwYXJhbSBzdHJlYW0gLSBSZWFkYWJsZVN0cmVhbSAod2ViIHN0cmVhbSBhY2NvcmRpbmcgV1RXRyBTdHJlYW1zIFN0YW5kYXJkKVxyXG4gKiBAcGFyYW0gZmlsZUluZm8gRmlsZUluZm8gb2JqZWN0IG9yIE1JTUUtVHlwZVxyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFBhcnNpbmcgb3B0aW9uc1xyXG4gKiBAcmV0dXJucyBNZXRhZGF0YVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcGFyc2VSZWFkYWJsZVN0cmVhbShzdHJlYW0sIGZpbGVJbmZvLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCBucyA9IG5ldyByZWFkYWJsZV93ZWJfdG9fbm9kZV9zdHJlYW1fMS5SZWFkYWJsZVdlYlRvTm9kZVN0cmVhbShzdHJlYW0pO1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgKDAsIGV4cG9ydHMucGFyc2VOb2RlU3RyZWFtKShucywgdHlwZW9mIGZpbGVJbmZvID09PSAnc3RyaW5nJyA/IHsgbWltZVR5cGU6IGZpbGVJbmZvIH0gOiBmaWxlSW5mbywgb3B0aW9ucyk7XHJcbiAgICBhd2FpdCBucy5jbG9zZSgpO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5leHBvcnRzLnBhcnNlUmVhZGFibGVTdHJlYW0gPSBwYXJzZVJlYWRhYmxlU3RyZWFtO1xyXG4vKipcclxuICogUGFyc2UgV2ViIEFQSSBGaWxlXHJcbiAqIEBwYXJhbSBibG9iIC0gQmxvYiB0byBwYXJzZVxyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFBhcnNpbmcgb3B0aW9uc1xyXG4gKiBAcmV0dXJucyBNZXRhZGF0YVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcGFyc2VCbG9iKGJsb2IsIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IGZpbGVJbmZvID0geyBtaW1lVHlwZTogYmxvYi50eXBlLCBzaXplOiBibG9iLnNpemUgfTtcclxuICAgIGlmIChibG9iIGluc3RhbmNlb2YgRmlsZSkge1xyXG4gICAgICAgIGZpbGVJbmZvLnBhdGggPSBibG9iLm5hbWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdHJlYW0gPSAoYmxvYi5zdHJlYW0gPyBibG9iLnN0cmVhbSgpIDogY29udmVydEJsb2JUb1JlYWRhYmxlU3RyZWFtKGJsb2IpKTtcclxuICAgIHJldHVybiBwYXJzZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSwgeyBtaW1lVHlwZTogYmxvYi50eXBlLCBzaXplOiBibG9iLnNpemUgfSwgb3B0aW9ucyk7XHJcbn1cclxuZXhwb3J0cy5wYXJzZUJsb2IgPSBwYXJzZUJsb2I7XHJcbi8qKlxyXG4gKiBDb252ZXJ0IEJsb2IgdG8gUmVhZGFibGVTdHJlYW1cclxuICogRmFsbGJhY2sgZm9yIFNhZmFyaSB2ZXJzaW9ucyA8IDE0LjFcclxuICogQHBhcmFtIGJsb2JcclxuICovXHJcbmZ1bmN0aW9uIGNvbnZlcnRCbG9iVG9SZWFkYWJsZVN0cmVhbShibG9iKSB7XHJcbiAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xyXG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcclxuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBmdW5jdGlvbiBoYW5kbGVzIGVhY2ggZGF0YSBjaHVua1xyXG4gICAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZGVuZCA9IGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBkYXRhID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZpbGVSZWFkZXIub25lcnJvciA9IGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZmlsZVJlYWRlci5vbmFib3J0ID0gZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBQYXJzZSBmZXRjaGVkIGZpbGUsIHVzaW5nIHRoZSBXZWIgRmV0Y2ggQVBJXHJcbiAqIEBwYXJhbSBhdWRpb1RyYWNrVXJsIC0gVVJMIHRvIGRvd25sb2FkIHRoZSBhdWRpbyB0cmFjayBmcm9tXHJcbiAqIEBwYXJhbSBvcHRpb25zIC0gUGFyc2luZyBvcHRpb25zXHJcbiAqIEByZXR1cm5zIE1ldGFkYXRhXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBmZXRjaEZyb21VcmwoYXVkaW9UcmFja1VybCwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhdWRpb1RyYWNrVXJsKTtcclxuICAgIGNvbnN0IGZpbGVJbmZvID0ge1xyXG4gICAgICAgIHNpemU6IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LUxlbmd0aCcpLCAxMCksXHJcbiAgICAgICAgbWltZVR5cGU6IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKVxyXG4gICAgfTtcclxuICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGlmIChyZXNwb25zZS5ib2R5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHBhcnNlUmVhZGFibGVTdHJlYW0ocmVzcG9uc2UuYm9keSwgZmlsZUluZm8sIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBkZWJ1ZygnQ2xvc2luZyBIVFRQLXJlYWRhYmxlLXN0cmVhbS4uLicpO1xyXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkubG9ja2VkKSB7IC8vIFByZXZlbnQgZXJyb3IgaW4gRmlyZWZveFxyXG4gICAgICAgICAgICAgICAgYXdhaXQgcmVzcG9uc2UuYm9keS5jYW5jZWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWJ1ZygnSFRUUC1yZWFkYWJsZS1zdHJlYW0gY2xvc2VkLicpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRmFsbCBiYWNrIG9uIEJsb2JcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlQmxvYihhd2FpdCByZXNwb25zZS5ibG9iKCksIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciBzdGF0dXM9JHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5mZXRjaEZyb21VcmwgPSBmZXRjaEZyb21Vcmw7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata-browser/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/ParserFactory.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/ParserFactory.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ParserFactory = exports.parseHttpContentType = void 0;\nconst FileType = __webpack_require__(/*! file-type/core */ \"(app-pages-browser)/./node_modules/file-type/core.js\");\nconst ContentType = __webpack_require__(/*! content-type */ \"(app-pages-browser)/./node_modules/content-type/index.js\");\nconst MimeType = __webpack_require__(/*! media-typer */ \"(app-pages-browser)/./node_modules/music-metadata/node_modules/media-typer/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst MetadataCollector_1 = __webpack_require__(/*! ./common/MetadataCollector */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/MetadataCollector.js\");\nconst AiffParser_1 = __webpack_require__(/*! ./aiff/AiffParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/aiff/AiffParser.js\");\nconst APEv2Parser_1 = __webpack_require__(/*! ./apev2/APEv2Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/apev2/APEv2Parser.js\");\nconst AsfParser_1 = __webpack_require__(/*! ./asf/AsfParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/asf/AsfParser.js\");\nconst FlacParser_1 = __webpack_require__(/*! ./flac/FlacParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/flac/FlacParser.js\");\nconst MP4Parser_1 = __webpack_require__(/*! ./mp4/MP4Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/mp4/MP4Parser.js\");\nconst MpegParser_1 = __webpack_require__(/*! ./mpeg/MpegParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/mpeg/MpegParser.js\");\nconst musepack_1 = __webpack_require__(/*! ./musepack */ \"(app-pages-browser)/./node_modules/music-metadata/lib/musepack/index.js\");\nconst OggParser_1 = __webpack_require__(/*! ./ogg/OggParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ogg/OggParser.js\");\nconst WaveParser_1 = __webpack_require__(/*! ./wav/WaveParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/wav/WaveParser.js\");\nconst WavPackParser_1 = __webpack_require__(/*! ./wavpack/WavPackParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/wavpack/WavPackParser.js\");\nconst DsfParser_1 = __webpack_require__(/*! ./dsf/DsfParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/dsf/DsfParser.js\");\nconst DsdiffParser_1 = __webpack_require__(/*! ./dsdiff/DsdiffParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/dsdiff/DsdiffParser.js\");\nconst MatroskaParser_1 = __webpack_require__(/*! ./matroska/MatroskaParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/matroska/MatroskaParser.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:factory');\nfunction parseHttpContentType(contentType) {\n    const type = ContentType.parse(contentType);\n    const mime = MimeType.parse(type.type);\n    return {\n        type: mime.type,\n        subtype: mime.subtype,\n        suffix: mime.suffix,\n        parameters: type.parameters\n    };\n}\nexports.parseHttpContentType = parseHttpContentType;\nasync function parse(tokenizer, parserId, opts = {}) {\n    // Parser found, execute parser\n    const parser = await ParserFactory.loadParser(parserId);\n    const metadata = new MetadataCollector_1.MetadataCollector(opts);\n    await parser.init(metadata, tokenizer, opts).parse();\n    return metadata.toCommonMetadata();\n}\nclass ParserFactory {\n    /**\n     * Parse metadata from tokenizer\n     * @param tokenizer - Tokenizer\n     * @param opts - Options\n     * @returns Native metadata\n     */\n    static async parseOnContentType(tokenizer, opts) {\n        const { mimeType, path, url } = await tokenizer.fileInfo;\n        // Resolve parser based on MIME-type or file extension\n        const parserId = ParserFactory.getParserIdForMimeType(mimeType) || ParserFactory.getParserIdForExtension(path) || ParserFactory.getParserIdForExtension(url);\n        if (!parserId) {\n            debug('No parser found for MIME-type / extension: ' + mimeType);\n        }\n        return this.parse(tokenizer, parserId, opts);\n    }\n    static async parse(tokenizer, parserId, opts) {\n        if (!parserId) {\n            // Parser could not be determined on MIME-type or extension\n            debug('Guess parser on content...');\n            const buf = Buffer.alloc(4100);\n            await tokenizer.peekBuffer(buf, { mayBeLess: true });\n            if (tokenizer.fileInfo.path) {\n                parserId = this.getParserIdForExtension(tokenizer.fileInfo.path);\n            }\n            if (!parserId) {\n                const guessedType = await FileType.fromBuffer(buf);\n                if (!guessedType) {\n                    throw new Error('Failed to determine audio format');\n                }\n                debug(`Guessed file type is mime=${guessedType.mime}, extension=${guessedType.ext}`);\n                parserId = ParserFactory.getParserIdForMimeType(guessedType.mime);\n                if (!parserId) {\n                    throw new Error('Guessed MIME-type not supported: ' + guessedType.mime);\n                }\n            }\n        }\n        // Parser found, execute parser\n        return parse(tokenizer, parserId, opts);\n    }\n    /**\n     * @param filePath - Path, filename or extension to audio file\n     * @return Parser sub-module name\n     */\n    static getParserIdForExtension(filePath) {\n        if (!filePath)\n            return;\n        const extension = this.getExtension(filePath).toLocaleLowerCase() || filePath;\n        switch (extension) {\n            case '.mp2':\n            case '.mp3':\n            case '.m2a':\n            case '.aac': // Assume it is ADTS-container\n                return 'mpeg';\n            case '.ape':\n                return 'apev2';\n            case '.mp4':\n            case '.m4a':\n            case '.m4b':\n            case '.m4pa':\n            case '.m4v':\n            case '.m4r':\n            case '.3gp':\n                return 'mp4';\n            case '.wma':\n            case '.wmv':\n            case '.asf':\n                return 'asf';\n            case '.flac':\n                return 'flac';\n            case '.ogg':\n            case '.ogv':\n            case '.oga':\n            case '.ogm':\n            case '.ogx':\n            case '.opus': // recommended filename extension for Ogg Opus\n            case '.spx': // recommended filename extension for Ogg Speex\n                return 'ogg';\n            case '.aif':\n            case '.aiff':\n            case '.aifc':\n                return 'aiff';\n            case '.wav':\n            case '.bwf': // Broadcast Wave Format\n                return 'riff';\n            case '.wv':\n            case '.wvp':\n                return 'wavpack';\n            case '.mpc':\n                return 'musepack';\n            case '.dsf':\n                return 'dsf';\n            case '.dff':\n                return 'dsdiff';\n            case '.mka':\n            case '.mkv':\n            case '.mk3d':\n            case '.mks':\n            case '.webm':\n                return 'matroska';\n        }\n    }\n    static async loadParser(moduleName) {\n        switch (moduleName) {\n            case 'aiff': return new AiffParser_1.AIFFParser();\n            case 'adts':\n            case 'mpeg':\n                return new MpegParser_1.MpegParser();\n            case 'apev2': return new APEv2Parser_1.APEv2Parser();\n            case 'asf': return new AsfParser_1.AsfParser();\n            case 'dsf': return new DsfParser_1.DsfParser();\n            case 'dsdiff': return new DsdiffParser_1.DsdiffParser();\n            case 'flac': return new FlacParser_1.FlacParser();\n            case 'mp4': return new MP4Parser_1.MP4Parser();\n            case 'musepack': return new musepack_1.default();\n            case 'ogg': return new OggParser_1.OggParser();\n            case 'riff': return new WaveParser_1.WaveParser();\n            case 'wavpack': return new WavPackParser_1.WavPackParser();\n            case 'matroska': return new MatroskaParser_1.MatroskaParser();\n            default:\n                throw new Error(`Unknown parser type: ${moduleName}`);\n        }\n    }\n    static getExtension(fname) {\n        const i = fname.lastIndexOf('.');\n        return i === -1 ? '' : fname.slice(i);\n    }\n    /**\n     * @param httpContentType - HTTP Content-Type, extension, path or filename\n     * @returns Parser sub-module name\n     */\n    static getParserIdForMimeType(httpContentType) {\n        let mime;\n        try {\n            mime = parseHttpContentType(httpContentType);\n        }\n        catch (err) {\n            debug(`Invalid HTTP Content-Type header value: ${httpContentType}`);\n            return;\n        }\n        const subType = mime.subtype.indexOf('x-') === 0 ? mime.subtype.substring(2) : mime.subtype;\n        switch (mime.type) {\n            case 'audio':\n                switch (subType) {\n                    case 'mp3': // Incorrect MIME-type, Chrome, in Web API File object\n                    case 'mpeg':\n                        return 'mpeg';\n                    case 'aac':\n                    case 'aacp':\n                        return 'adts';\n                    case 'flac':\n                        return 'flac';\n                    case 'ape':\n                    case 'monkeys-audio':\n                        return 'apev2';\n                    case 'mp4':\n                    case 'm4a':\n                        return 'mp4';\n                    case 'ogg': // RFC 7845\n                    case 'opus': // RFC 6716\n                    case 'speex': // RFC 5574\n                        return 'ogg';\n                    case 'ms-wma':\n                    case 'ms-wmv':\n                    case 'ms-asf':\n                        return 'asf';\n                    case 'aiff':\n                    case 'aif':\n                    case 'aifc':\n                        return 'aiff';\n                    case 'vnd.wave':\n                    case 'wav':\n                    case 'wave':\n                        return 'riff';\n                    case 'wavpack':\n                        return 'wavpack';\n                    case 'musepack':\n                        return 'musepack';\n                    case 'matroska':\n                    case 'webm':\n                        return 'matroska';\n                    case 'dsf':\n                        return 'dsf';\n                }\n                break;\n            case 'video':\n                switch (subType) {\n                    case 'ms-asf':\n                    case 'ms-wmv':\n                        return 'asf';\n                    case 'm4v':\n                    case 'mp4':\n                        return 'mp4';\n                    case 'ogg':\n                        return 'ogg';\n                    case 'matroska':\n                    case 'webm':\n                        return 'matroska';\n                }\n                break;\n            case 'application':\n                switch (subType) {\n                    case 'vnd.ms-asf':\n                        return 'asf';\n                    case 'ogg':\n                        return 'ogg';\n                }\n                break;\n        }\n    }\n}\nexports.ParserFactory = ParserFactory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvUGFyc2VyRmFjdG9yeS5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsNEJBQTRCO0FBQ3BELGlCQUFpQixtQkFBTyxDQUFDLDRFQUFnQjtBQUN6QyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYztBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyx3R0FBYTtBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBTztBQUMvQiw0QkFBNEIsbUJBQU8sQ0FBQyxxSEFBNEI7QUFDaEUscUJBQXFCLG1CQUFPLENBQUMsbUdBQW1CO0FBQ2hELHNCQUFzQixtQkFBTyxDQUFDLHVHQUFxQjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQywrRkFBaUI7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsbUdBQW1CO0FBQ2hELG9CQUFvQixtQkFBTyxDQUFDLCtGQUFpQjtBQUM3QyxxQkFBcUIsbUJBQU8sQ0FBQyxtR0FBbUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsMkZBQVk7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQWlCO0FBQzdDLHFCQUFxQixtQkFBTyxDQUFDLGlHQUFrQjtBQUMvQyx3QkFBd0IsbUJBQU8sQ0FBQywrR0FBeUI7QUFDekQsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQWlCO0FBQzdDLHVCQUF1QixtQkFBTyxDQUFDLDJHQUF1QjtBQUN0RCx5QkFBeUIsbUJBQU8sQ0FBQyxtSEFBMkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFNO0FBQzlCLDhDQUE4QyxpQkFBaUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpQkFBaUIsY0FBYyxnQkFBZ0I7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxXQUFXO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL1BhcnNlckZhY3RvcnkuanM/OWYxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFyc2VyRmFjdG9yeSA9IGV4cG9ydHMucGFyc2VIdHRwQ29udGVudFR5cGUgPSB2b2lkIDA7XG5jb25zdCBGaWxlVHlwZSA9IHJlcXVpcmUoXCJmaWxlLXR5cGUvY29yZVwiKTtcbmNvbnN0IENvbnRlbnRUeXBlID0gcmVxdWlyZShcImNvbnRlbnQtdHlwZVwiKTtcbmNvbnN0IE1pbWVUeXBlID0gcmVxdWlyZShcIm1lZGlhLXR5cGVyXCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IE1ldGFkYXRhQ29sbGVjdG9yXzEgPSByZXF1aXJlKFwiLi9jb21tb24vTWV0YWRhdGFDb2xsZWN0b3JcIik7XG5jb25zdCBBaWZmUGFyc2VyXzEgPSByZXF1aXJlKFwiLi9haWZmL0FpZmZQYXJzZXJcIik7XG5jb25zdCBBUEV2MlBhcnNlcl8xID0gcmVxdWlyZShcIi4vYXBldjIvQVBFdjJQYXJzZXJcIik7XG5jb25zdCBBc2ZQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL2FzZi9Bc2ZQYXJzZXJcIik7XG5jb25zdCBGbGFjUGFyc2VyXzEgPSByZXF1aXJlKFwiLi9mbGFjL0ZsYWNQYXJzZXJcIik7XG5jb25zdCBNUDRQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL21wNC9NUDRQYXJzZXJcIik7XG5jb25zdCBNcGVnUGFyc2VyXzEgPSByZXF1aXJlKFwiLi9tcGVnL01wZWdQYXJzZXJcIik7XG5jb25zdCBtdXNlcGFja18xID0gcmVxdWlyZShcIi4vbXVzZXBhY2tcIik7XG5jb25zdCBPZ2dQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL29nZy9PZ2dQYXJzZXJcIik7XG5jb25zdCBXYXZlUGFyc2VyXzEgPSByZXF1aXJlKFwiLi93YXYvV2F2ZVBhcnNlclwiKTtcbmNvbnN0IFdhdlBhY2tQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3dhdnBhY2svV2F2UGFja1BhcnNlclwiKTtcbmNvbnN0IERzZlBhcnNlcl8xID0gcmVxdWlyZShcIi4vZHNmL0RzZlBhcnNlclwiKTtcbmNvbnN0IERzZGlmZlBhcnNlcl8xID0gcmVxdWlyZShcIi4vZHNkaWZmL0RzZGlmZlBhcnNlclwiKTtcbmNvbnN0IE1hdHJvc2thUGFyc2VyXzEgPSByZXF1aXJlKFwiLi9tYXRyb3NrYS9NYXRyb3NrYVBhcnNlclwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjpmYWN0b3J5Jyk7XG5mdW5jdGlvbiBwYXJzZUh0dHBDb250ZW50VHlwZShjb250ZW50VHlwZSkge1xuICAgIGNvbnN0IHR5cGUgPSBDb250ZW50VHlwZS5wYXJzZShjb250ZW50VHlwZSk7XG4gICAgY29uc3QgbWltZSA9IE1pbWVUeXBlLnBhcnNlKHR5cGUudHlwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogbWltZS50eXBlLFxuICAgICAgICBzdWJ0eXBlOiBtaW1lLnN1YnR5cGUsXG4gICAgICAgIHN1ZmZpeDogbWltZS5zdWZmaXgsXG4gICAgICAgIHBhcmFtZXRlcnM6IHR5cGUucGFyYW1ldGVyc1xuICAgIH07XG59XG5leHBvcnRzLnBhcnNlSHR0cENvbnRlbnRUeXBlID0gcGFyc2VIdHRwQ29udGVudFR5cGU7XG5hc3luYyBmdW5jdGlvbiBwYXJzZSh0b2tlbml6ZXIsIHBhcnNlcklkLCBvcHRzID0ge30pIHtcbiAgICAvLyBQYXJzZXIgZm91bmQsIGV4ZWN1dGUgcGFyc2VyXG4gICAgY29uc3QgcGFyc2VyID0gYXdhaXQgUGFyc2VyRmFjdG9yeS5sb2FkUGFyc2VyKHBhcnNlcklkKTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBNZXRhZGF0YUNvbGxlY3Rvcl8xLk1ldGFkYXRhQ29sbGVjdG9yKG9wdHMpO1xuICAgIGF3YWl0IHBhcnNlci5pbml0KG1ldGFkYXRhLCB0b2tlbml6ZXIsIG9wdHMpLnBhcnNlKCk7XG4gICAgcmV0dXJuIG1ldGFkYXRhLnRvQ29tbW9uTWV0YWRhdGEoKTtcbn1cbmNsYXNzIFBhcnNlckZhY3Rvcnkge1xuICAgIC8qKlxuICAgICAqIFBhcnNlIG1ldGFkYXRhIGZyb20gdG9rZW5pemVyXG4gICAgICogQHBhcmFtIHRva2VuaXplciAtIFRva2VuaXplclxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9uc1xuICAgICAqIEByZXR1cm5zIE5hdGl2ZSBtZXRhZGF0YVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBwYXJzZU9uQ29udGVudFR5cGUodG9rZW5pemVyLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgbWltZVR5cGUsIHBhdGgsIHVybCB9ID0gYXdhaXQgdG9rZW5pemVyLmZpbGVJbmZvO1xuICAgICAgICAvLyBSZXNvbHZlIHBhcnNlciBiYXNlZCBvbiBNSU1FLXR5cGUgb3IgZmlsZSBleHRlbnNpb25cbiAgICAgICAgY29uc3QgcGFyc2VySWQgPSBQYXJzZXJGYWN0b3J5LmdldFBhcnNlcklkRm9yTWltZVR5cGUobWltZVR5cGUpIHx8IFBhcnNlckZhY3RvcnkuZ2V0UGFyc2VySWRGb3JFeHRlbnNpb24ocGF0aCkgfHwgUGFyc2VyRmFjdG9yeS5nZXRQYXJzZXJJZEZvckV4dGVuc2lvbih1cmwpO1xuICAgICAgICBpZiAoIXBhcnNlcklkKSB7XG4gICAgICAgICAgICBkZWJ1ZygnTm8gcGFyc2VyIGZvdW5kIGZvciBNSU1FLXR5cGUgLyBleHRlbnNpb246ICcgKyBtaW1lVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UodG9rZW5pemVyLCBwYXJzZXJJZCwgb3B0cyk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBwYXJzZSh0b2tlbml6ZXIsIHBhcnNlcklkLCBvcHRzKSB7XG4gICAgICAgIGlmICghcGFyc2VySWQpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlciBjb3VsZCBub3QgYmUgZGV0ZXJtaW5lZCBvbiBNSU1FLXR5cGUgb3IgZXh0ZW5zaW9uXG4gICAgICAgICAgICBkZWJ1ZygnR3Vlc3MgcGFyc2VyIG9uIGNvbnRlbnQuLi4nKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyg0MTAwKTtcbiAgICAgICAgICAgIGF3YWl0IHRva2VuaXplci5wZWVrQnVmZmVyKGJ1ZiwgeyBtYXlCZUxlc3M6IHRydWUgfSk7XG4gICAgICAgICAgICBpZiAodG9rZW5pemVyLmZpbGVJbmZvLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXJJZCA9IHRoaXMuZ2V0UGFyc2VySWRGb3JFeHRlbnNpb24odG9rZW5pemVyLmZpbGVJbmZvLnBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXJzZXJJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGd1ZXNzZWRUeXBlID0gYXdhaXQgRmlsZVR5cGUuZnJvbUJ1ZmZlcihidWYpO1xuICAgICAgICAgICAgICAgIGlmICghZ3Vlc3NlZFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGV0ZXJtaW5lIGF1ZGlvIGZvcm1hdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWJ1ZyhgR3Vlc3NlZCBmaWxlIHR5cGUgaXMgbWltZT0ke2d1ZXNzZWRUeXBlLm1pbWV9LCBleHRlbnNpb249JHtndWVzc2VkVHlwZS5leHR9YCk7XG4gICAgICAgICAgICAgICAgcGFyc2VySWQgPSBQYXJzZXJGYWN0b3J5LmdldFBhcnNlcklkRm9yTWltZVR5cGUoZ3Vlc3NlZFR5cGUubWltZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXJJZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0d1ZXNzZWQgTUlNRS10eXBlIG5vdCBzdXBwb3J0ZWQ6ICcgKyBndWVzc2VkVHlwZS5taW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2VyIGZvdW5kLCBleGVjdXRlIHBhcnNlclxuICAgICAgICByZXR1cm4gcGFyc2UodG9rZW5pemVyLCBwYXJzZXJJZCwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCAtIFBhdGgsIGZpbGVuYW1lIG9yIGV4dGVuc2lvbiB0byBhdWRpbyBmaWxlXG4gICAgICogQHJldHVybiBQYXJzZXIgc3ViLW1vZHVsZSBuYW1lXG4gICAgICovXG4gICAgc3RhdGljIGdldFBhcnNlcklkRm9yRXh0ZW5zaW9uKGZpbGVQYXRoKSB7XG4gICAgICAgIGlmICghZmlsZVBhdGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuZ2V0RXh0ZW5zaW9uKGZpbGVQYXRoKS50b0xvY2FsZUxvd2VyQ2FzZSgpIHx8IGZpbGVQYXRoO1xuICAgICAgICBzd2l0Y2ggKGV4dGVuc2lvbikge1xuICAgICAgICAgICAgY2FzZSAnLm1wMic6XG4gICAgICAgICAgICBjYXNlICcubXAzJzpcbiAgICAgICAgICAgIGNhc2UgJy5tMmEnOlxuICAgICAgICAgICAgY2FzZSAnLmFhYyc6IC8vIEFzc3VtZSBpdCBpcyBBRFRTLWNvbnRhaW5lclxuICAgICAgICAgICAgICAgIHJldHVybiAnbXBlZyc7XG4gICAgICAgICAgICBjYXNlICcuYXBlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FwZXYyJztcbiAgICAgICAgICAgIGNhc2UgJy5tcDQnOlxuICAgICAgICAgICAgY2FzZSAnLm00YSc6XG4gICAgICAgICAgICBjYXNlICcubTRiJzpcbiAgICAgICAgICAgIGNhc2UgJy5tNHBhJzpcbiAgICAgICAgICAgIGNhc2UgJy5tNHYnOlxuICAgICAgICAgICAgY2FzZSAnLm00cic6XG4gICAgICAgICAgICBjYXNlICcuM2dwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21wNCc7XG4gICAgICAgICAgICBjYXNlICcud21hJzpcbiAgICAgICAgICAgIGNhc2UgJy53bXYnOlxuICAgICAgICAgICAgY2FzZSAnLmFzZic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdhc2YnO1xuICAgICAgICAgICAgY2FzZSAnLmZsYWMnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZmxhYyc7XG4gICAgICAgICAgICBjYXNlICcub2dnJzpcbiAgICAgICAgICAgIGNhc2UgJy5vZ3YnOlxuICAgICAgICAgICAgY2FzZSAnLm9nYSc6XG4gICAgICAgICAgICBjYXNlICcub2dtJzpcbiAgICAgICAgICAgIGNhc2UgJy5vZ3gnOlxuICAgICAgICAgICAgY2FzZSAnLm9wdXMnOiAvLyByZWNvbW1lbmRlZCBmaWxlbmFtZSBleHRlbnNpb24gZm9yIE9nZyBPcHVzXG4gICAgICAgICAgICBjYXNlICcuc3B4JzogLy8gcmVjb21tZW5kZWQgZmlsZW5hbWUgZXh0ZW5zaW9uIGZvciBPZ2cgU3BlZXhcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29nZyc7XG4gICAgICAgICAgICBjYXNlICcuYWlmJzpcbiAgICAgICAgICAgIGNhc2UgJy5haWZmJzpcbiAgICAgICAgICAgIGNhc2UgJy5haWZjJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FpZmYnO1xuICAgICAgICAgICAgY2FzZSAnLndhdic6XG4gICAgICAgICAgICBjYXNlICcuYndmJzogLy8gQnJvYWRjYXN0IFdhdmUgRm9ybWF0XG4gICAgICAgICAgICAgICAgcmV0dXJuICdyaWZmJztcbiAgICAgICAgICAgIGNhc2UgJy53dic6XG4gICAgICAgICAgICBjYXNlICcud3ZwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3dhdnBhY2snO1xuICAgICAgICAgICAgY2FzZSAnLm1wYyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdtdXNlcGFjayc7XG4gICAgICAgICAgICBjYXNlICcuZHNmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RzZic7XG4gICAgICAgICAgICBjYXNlICcuZGZmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RzZGlmZic7XG4gICAgICAgICAgICBjYXNlICcubWthJzpcbiAgICAgICAgICAgIGNhc2UgJy5ta3YnOlxuICAgICAgICAgICAgY2FzZSAnLm1rM2QnOlxuICAgICAgICAgICAgY2FzZSAnLm1rcyc6XG4gICAgICAgICAgICBjYXNlICcud2VibSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdtYXRyb3NrYSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGxvYWRQYXJzZXIobW9kdWxlTmFtZSkge1xuICAgICAgICBzd2l0Y2ggKG1vZHVsZU5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FpZmYnOiByZXR1cm4gbmV3IEFpZmZQYXJzZXJfMS5BSUZGUGFyc2VyKCk7XG4gICAgICAgICAgICBjYXNlICdhZHRzJzpcbiAgICAgICAgICAgIGNhc2UgJ21wZWcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTXBlZ1BhcnNlcl8xLk1wZWdQYXJzZXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ2FwZXYyJzogcmV0dXJuIG5ldyBBUEV2MlBhcnNlcl8xLkFQRXYyUGFyc2VyKCk7XG4gICAgICAgICAgICBjYXNlICdhc2YnOiByZXR1cm4gbmV3IEFzZlBhcnNlcl8xLkFzZlBhcnNlcigpO1xuICAgICAgICAgICAgY2FzZSAnZHNmJzogcmV0dXJuIG5ldyBEc2ZQYXJzZXJfMS5Ec2ZQYXJzZXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ2RzZGlmZic6IHJldHVybiBuZXcgRHNkaWZmUGFyc2VyXzEuRHNkaWZmUGFyc2VyKCk7XG4gICAgICAgICAgICBjYXNlICdmbGFjJzogcmV0dXJuIG5ldyBGbGFjUGFyc2VyXzEuRmxhY1BhcnNlcigpO1xuICAgICAgICAgICAgY2FzZSAnbXA0JzogcmV0dXJuIG5ldyBNUDRQYXJzZXJfMS5NUDRQYXJzZXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ211c2VwYWNrJzogcmV0dXJuIG5ldyBtdXNlcGFja18xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIGNhc2UgJ29nZyc6IHJldHVybiBuZXcgT2dnUGFyc2VyXzEuT2dnUGFyc2VyKCk7XG4gICAgICAgICAgICBjYXNlICdyaWZmJzogcmV0dXJuIG5ldyBXYXZlUGFyc2VyXzEuV2F2ZVBhcnNlcigpO1xuICAgICAgICAgICAgY2FzZSAnd2F2cGFjayc6IHJldHVybiBuZXcgV2F2UGFja1BhcnNlcl8xLldhdlBhY2tQYXJzZXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ21hdHJvc2thJzogcmV0dXJuIG5ldyBNYXRyb3NrYVBhcnNlcl8xLk1hdHJvc2thUGFyc2VyKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJzZXIgdHlwZTogJHttb2R1bGVOYW1lfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnZXRFeHRlbnNpb24oZm5hbWUpIHtcbiAgICAgICAgY29uc3QgaSA9IGZuYW1lLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICAgIHJldHVybiBpID09PSAtMSA/ICcnIDogZm5hbWUuc2xpY2UoaSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBodHRwQ29udGVudFR5cGUgLSBIVFRQIENvbnRlbnQtVHlwZSwgZXh0ZW5zaW9uLCBwYXRoIG9yIGZpbGVuYW1lXG4gICAgICogQHJldHVybnMgUGFyc2VyIHN1Yi1tb2R1bGUgbmFtZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQYXJzZXJJZEZvck1pbWVUeXBlKGh0dHBDb250ZW50VHlwZSkge1xuICAgICAgICBsZXQgbWltZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1pbWUgPSBwYXJzZUh0dHBDb250ZW50VHlwZShodHRwQ29udGVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRlYnVnKGBJbnZhbGlkIEhUVFAgQ29udGVudC1UeXBlIGhlYWRlciB2YWx1ZTogJHtodHRwQ29udGVudFR5cGV9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ViVHlwZSA9IG1pbWUuc3VidHlwZS5pbmRleE9mKCd4LScpID09PSAwID8gbWltZS5zdWJ0eXBlLnN1YnN0cmluZygyKSA6IG1pbWUuc3VidHlwZTtcbiAgICAgICAgc3dpdGNoIChtaW1lLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1YlR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbXAzJzogLy8gSW5jb3JyZWN0IE1JTUUtdHlwZSwgQ2hyb21lLCBpbiBXZWIgQVBJIEZpbGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21wZWcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdtcGVnJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWFjJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWFjcCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2FkdHMnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmbGFjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZmxhYyc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FwZSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21vbmtleXMtYXVkaW8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhcGV2Mic7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21wNCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ200YSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ21wNCc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29nZyc6IC8vIFJGQyA3ODQ1XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ29wdXMnOiAvLyBSRkMgNjcxNlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzcGVleCc6IC8vIFJGQyA1NTc0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ29nZyc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21zLXdtYSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21zLXdtdic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21zLWFzZic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2FzZic7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FpZmYnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhaWYnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhaWZjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnYWlmZic7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ZuZC53YXZlJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2F2JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2F2ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3JpZmYnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd3YXZwYWNrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnd2F2cGFjayc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ211c2VwYWNrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbXVzZXBhY2snO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXRyb3NrYSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dlYm0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdtYXRyb3NrYSc7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RzZic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2RzZic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtcy1hc2YnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtcy13bXYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhc2YnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtNHYnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtcDQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdtcDQnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdvZ2cnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdvZ2cnO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXRyb3NrYSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dlYm0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdtYXRyb3NrYSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXBwbGljYXRpb24nOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd2bmQubXMtYXNmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnYXNmJztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2dnJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnb2dnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlBhcnNlckZhY3RvcnkgPSBQYXJzZXJGYWN0b3J5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/ParserFactory.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/aiff/AiffParser.js":
/*!************************************************************!*\
  !*** ./node_modules/music-metadata/lib/aiff/AiffParser.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AIFFParser = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst strtok3 = __webpack_require__(/*! strtok3/lib/core */ \"(app-pages-browser)/./node_modules/strtok3/lib/core.js\");\nconst ID3v2Parser_1 = __webpack_require__(/*! ../id3v2/ID3v2Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/FourCC.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst AiffToken = __webpack_require__(/*! ./AiffToken */ \"(app-pages-browser)/./node_modules/music-metadata/lib/aiff/AiffToken.js\");\nconst iff = __webpack_require__(/*! ../iff */ \"(app-pages-browser)/./node_modules/music-metadata/lib/iff/index.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:aiff');\nconst compressionTypes = {\n    NONE: 'not compressed\tPCM\tApple Computer',\n    sowt: 'PCM (byte swapped)',\n    fl32: '32-bit floating point IEEE 32-bit float',\n    fl64: '64-bit floating point IEEE 64-bit float\tApple Computer',\n    alaw: 'ALaw 2:1\t8-bit ITU-T G.711 A-law',\n    ulaw: 'µLaw 2:1\t8-bit ITU-T G.711 µ-law\tApple Computer',\n    ULAW: 'CCITT G.711 u-law 8-bit ITU-T G.711 µ-law',\n    ALAW: 'CCITT G.711 A-law 8-bit ITU-T G.711 A-law',\n    FL32: 'Float 32\tIEEE 32-bit float '\n};\n/**\n * AIFF - Audio Interchange File Format\n *\n * Ref:\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/AIFF.html\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-1.3.pdf\n */\nclass AIFFParser extends BasicParser_1.BasicParser {\n    async parse() {\n        const header = await this.tokenizer.readToken(iff.Header);\n        if (header.chunkID !== 'FORM')\n            throw new Error('Invalid Chunk-ID, expected \\'FORM\\''); // Not AIFF format\n        const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        switch (type) {\n            case 'AIFF':\n                this.metadata.setFormat('container', type);\n                this.isCompressed = false;\n                break;\n            case 'AIFC':\n                this.metadata.setFormat('container', 'AIFF-C');\n                this.isCompressed = true;\n                break;\n            default:\n                throw Error('Unsupported AIFF type: ' + type);\n        }\n        this.metadata.setFormat('lossless', !this.isCompressed);\n        try {\n            while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= iff.Header.len) {\n                debug('Reading AIFF chunk at offset=' + this.tokenizer.position);\n                const chunkHeader = await this.tokenizer.readToken(iff.Header);\n                const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);\n                const bytesRead = await this.readData(chunkHeader);\n                await this.tokenizer.ignore(nextChunk - bytesRead);\n            }\n        }\n        catch (err) {\n            if (err instanceof strtok3.EndOfStreamError) {\n                debug(`End-of-stream`);\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    async readData(header) {\n        var _a;\n        switch (header.chunkID) {\n            case 'COMM': // The Common Chunk\n                const common = await this.tokenizer.readToken(new AiffToken.Common(header, this.isCompressed));\n                this.metadata.setFormat('bitsPerSample', common.sampleSize);\n                this.metadata.setFormat('sampleRate', common.sampleRate);\n                this.metadata.setFormat('numberOfChannels', common.numChannels);\n                this.metadata.setFormat('numberOfSamples', common.numSampleFrames);\n                this.metadata.setFormat('duration', common.numSampleFrames / common.sampleRate);\n                this.metadata.setFormat('codec', (_a = common.compressionName) !== null && _a !== void 0 ? _a : compressionTypes[common.compressionType]);\n                return header.chunkSize;\n            case 'ID3 ': // ID3-meta-data\n                const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\n                const rst = strtok3.fromBuffer(id3_data);\n                await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n                return header.chunkSize;\n            case 'SSND': // Sound Data Chunk\n                if (this.metadata.format.duration) {\n                    this.metadata.setFormat('bitrate', 8 * header.chunkSize / this.metadata.format.duration);\n                }\n                return 0;\n            case 'NAME': // Sample name chunk\n            case 'AUTH': // Author chunk\n            case '(c) ': // Copyright chunk\n            case 'ANNO': // Annotation chunk\n                return this.readTextChunk(header);\n            default:\n                debug(`Ignore chunk id=${header.chunkID}, size=${header.chunkSize}`);\n                return 0;\n        }\n    }\n    async readTextChunk(header) {\n        const value = await this.tokenizer.readToken(new Token.StringType(header.chunkSize, 'ascii'));\n        value.split('\\0').map(v => v.trim()).filter(v => v && v.length > 0).forEach(v => {\n            this.metadata.addTag('AIFF', header.chunkID, v.trim());\n        });\n        return header.chunkSize;\n    }\n}\nexports.AIFFParser = AIFFParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYWlmZi9BaWZmUGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixjQUFjLG1CQUFPLENBQUMsZ0ZBQWE7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQU87QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQWtCO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLHdHQUFzQjtBQUNwRCxpQkFBaUIsbUJBQU8sQ0FBQyxnR0FBa0I7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsMEdBQXVCO0FBQ3JELGtCQUFrQixtQkFBTyxDQUFDLDRGQUFhO0FBQ3ZDLFlBQVksbUJBQU8sQ0FBQyxrRkFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFlLFNBQVMsaUJBQWlCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FpZmYvQWlmZlBhcnNlci5qcz9iMWZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BSUZGUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3Qgc3RydG9rMyA9IHJlcXVpcmUoXCJzdHJ0b2szL2xpYi9jb3JlXCIpO1xuY29uc3QgSUQzdjJQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9pZDN2Mi9JRDN2MlBhcnNlclwiKTtcbmNvbnN0IEZvdXJDQ18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Gb3VyQ0NcIik7XG5jb25zdCBCYXNpY1BhcnNlcl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9CYXNpY1BhcnNlclwiKTtcbmNvbnN0IEFpZmZUb2tlbiA9IHJlcXVpcmUoXCIuL0FpZmZUb2tlblwiKTtcbmNvbnN0IGlmZiA9IHJlcXVpcmUoXCIuLi9pZmZcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6YWlmZicpO1xuY29uc3QgY29tcHJlc3Npb25UeXBlcyA9IHtcbiAgICBOT05FOiAnbm90IGNvbXByZXNzZWRcdFBDTVx0QXBwbGUgQ29tcHV0ZXInLFxuICAgIHNvd3Q6ICdQQ00gKGJ5dGUgc3dhcHBlZCknLFxuICAgIGZsMzI6ICczMi1iaXQgZmxvYXRpbmcgcG9pbnQgSUVFRSAzMi1iaXQgZmxvYXQnLFxuICAgIGZsNjQ6ICc2NC1iaXQgZmxvYXRpbmcgcG9pbnQgSUVFRSA2NC1iaXQgZmxvYXRcdEFwcGxlIENvbXB1dGVyJyxcbiAgICBhbGF3OiAnQUxhdyAyOjFcdDgtYml0IElUVS1UIEcuNzExIEEtbGF3JyxcbiAgICB1bGF3OiAnwrVMYXcgMjoxXHQ4LWJpdCBJVFUtVCBHLjcxMSDCtS1sYXdcdEFwcGxlIENvbXB1dGVyJyxcbiAgICBVTEFXOiAnQ0NJVFQgRy43MTEgdS1sYXcgOC1iaXQgSVRVLVQgRy43MTEgwrUtbGF3JyxcbiAgICBBTEFXOiAnQ0NJVFQgRy43MTEgQS1sYXcgOC1iaXQgSVRVLVQgRy43MTEgQS1sYXcnLFxuICAgIEZMMzI6ICdGbG9hdCAzMlx0SUVFRSAzMi1iaXQgZmxvYXQgJ1xufTtcbi8qKlxuICogQUlGRiAtIEF1ZGlvIEludGVyY2hhbmdlIEZpbGUgRm9ybWF0XG4gKlxuICogUmVmOlxuICogLSBodHRwOi8vd3d3LW1tc3AuZWNlLm1jZ2lsbC5jYS9Eb2N1bWVudHMvQXVkaW9Gb3JtYXRzL0FJRkYvQUlGRi5odG1sXG4gKiAtIGh0dHA6Ly93d3ctbW1zcC5lY2UubWNnaWxsLmNhL0RvY3VtZW50cy9BdWRpb0Zvcm1hdHMvQUlGRi9Eb2NzL0FJRkYtMS4zLnBkZlxuICovXG5jbGFzcyBBSUZGUGFyc2VyIGV4dGVuZHMgQmFzaWNQYXJzZXJfMS5CYXNpY1BhcnNlciB7XG4gICAgYXN5bmMgcGFyc2UoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihpZmYuSGVhZGVyKTtcbiAgICAgICAgaWYgKGhlYWRlci5jaHVua0lEICE9PSAnRk9STScpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ2h1bmstSUQsIGV4cGVjdGVkIFxcJ0ZPUk1cXCcnKTsgLy8gTm90IEFJRkYgZm9ybWF0XG4gICAgICAgIGNvbnN0IHR5cGUgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oRm91ckNDXzEuRm91ckNjVG9rZW4pO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0FJRkYnOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb250YWluZXInLCB0eXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ29tcHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQUlGQyc6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvbnRhaW5lcicsICdBSUZGLUMnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ29tcHJlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdVbnN1cHBvcnRlZCBBSUZGIHR5cGU6ICcgKyB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbG9zc2xlc3MnLCAhdGhpcy5pc0NvbXByZXNzZWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2hpbGUgKCF0aGlzLnRva2VuaXplci5maWxlSW5mby5zaXplIHx8IHRoaXMudG9rZW5pemVyLmZpbGVJbmZvLnNpemUgLSB0aGlzLnRva2VuaXplci5wb3NpdGlvbiA+PSBpZmYuSGVhZGVyLmxlbikge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdSZWFkaW5nIEFJRkYgY2h1bmsgYXQgb2Zmc2V0PScgKyB0aGlzLnRva2VuaXplci5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtIZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oaWZmLkhlYWRlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENodW5rID0gMiAqIE1hdGgucm91bmQoY2h1bmtIZWFkZXIuY2h1bmtTaXplIC8gMik7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXNSZWFkID0gYXdhaXQgdGhpcy5yZWFkRGF0YShjaHVua0hlYWRlcik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKG5leHRDaHVuayAtIGJ5dGVzUmVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIHN0cnRvazMuRW5kT2ZTdHJlYW1FcnJvcikge1xuICAgICAgICAgICAgICAgIGRlYnVnKGBFbmQtb2Ytc3RyZWFtYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGEoaGVhZGVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3dpdGNoIChoZWFkZXIuY2h1bmtJRCkge1xuICAgICAgICAgICAgY2FzZSAnQ09NTSc6IC8vIFRoZSBDb21tb24gQ2h1bmtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tb24gPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEFpZmZUb2tlbi5Db21tb24oaGVhZGVyLCB0aGlzLmlzQ29tcHJlc3NlZCkpO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdiaXRzUGVyU2FtcGxlJywgY29tbW9uLnNhbXBsZVNpemUpO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdzYW1wbGVSYXRlJywgY29tbW9uLnNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZkNoYW5uZWxzJywgY29tbW9uLm51bUNoYW5uZWxzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZTYW1wbGVzJywgY29tbW9uLm51bVNhbXBsZUZyYW1lcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2R1cmF0aW9uJywgY29tbW9uLm51bVNhbXBsZUZyYW1lcyAvIGNvbW1vbi5zYW1wbGVSYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29kZWMnLCAoX2EgPSBjb21tb24uY29tcHJlc3Npb25OYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb21wcmVzc2lvblR5cGVzW2NvbW1vbi5jb21wcmVzc2lvblR5cGVdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyLmNodW5rU2l6ZTtcbiAgICAgICAgICAgIGNhc2UgJ0lEMyAnOiAvLyBJRDMtbWV0YS1kYXRhXG4gICAgICAgICAgICAgICAgY29uc3QgaWQzX2RhdGEgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IFRva2VuLlVpbnQ4QXJyYXlUeXBlKGhlYWRlci5jaHVua1NpemUpKTtcbiAgICAgICAgICAgICAgICBjb25zdCByc3QgPSBzdHJ0b2szLmZyb21CdWZmZXIoaWQzX2RhdGEpO1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBJRDN2MlBhcnNlcl8xLklEM3YyUGFyc2VyKCkucGFyc2UodGhpcy5tZXRhZGF0YSwgcnN0LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXIuY2h1bmtTaXplO1xuICAgICAgICAgICAgY2FzZSAnU1NORCc6IC8vIFNvdW5kIERhdGEgQ2h1bmtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tZXRhZGF0YS5mb3JtYXQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCA4ICogaGVhZGVyLmNodW5rU2l6ZSAvIHRoaXMubWV0YWRhdGEuZm9ybWF0LmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlICdOQU1FJzogLy8gU2FtcGxlIG5hbWUgY2h1bmtcbiAgICAgICAgICAgIGNhc2UgJ0FVVEgnOiAvLyBBdXRob3IgY2h1bmtcbiAgICAgICAgICAgIGNhc2UgJyhjKSAnOiAvLyBDb3B5cmlnaHQgY2h1bmtcbiAgICAgICAgICAgIGNhc2UgJ0FOTk8nOiAvLyBBbm5vdGF0aW9uIGNodW5rXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZFRleHRDaHVuayhoZWFkZXIpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBkZWJ1ZyhgSWdub3JlIGNodW5rIGlkPSR7aGVhZGVyLmNodW5rSUR9LCBzaXplPSR7aGVhZGVyLmNodW5rU2l6ZX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZWFkVGV4dENodW5rKGhlYWRlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgVG9rZW4uU3RyaW5nVHlwZShoZWFkZXIuY2h1bmtTaXplLCAnYXNjaWknKSk7XG4gICAgICAgIHZhbHVlLnNwbGl0KCdcXDAnKS5tYXAodiA9PiB2LnRyaW0oKSkuZmlsdGVyKHYgPT4gdiAmJiB2Lmxlbmd0aCA+IDApLmZvckVhY2godiA9PiB7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFRhZygnQUlGRicsIGhlYWRlci5jaHVua0lELCB2LnRyaW0oKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGVhZGVyLmNodW5rU2l6ZTtcbiAgICB9XG59XG5leHBvcnRzLkFJRkZQYXJzZXIgPSBBSUZGUGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/aiff/AiffParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/aiff/AiffTagMap.js":
/*!************************************************************!*\
  !*** ./node_modules/music-metadata/lib/aiff/AiffTagMap.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AiffTagMapper = void 0;\nconst GenericTagMapper_1 = __webpack_require__(/*! ../common/GenericTagMapper */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/GenericTagMapper.js\");\n/**\n * ID3v1 tag mappings\n */\nconst tagMap = {\n    NAME: 'title',\n    AUTH: 'artist',\n    '(c) ': 'copyright',\n    ANNO: 'comment'\n};\nclass AiffTagMapper extends GenericTagMapper_1.CommonTagMapper {\n    constructor() {\n        super(['AIFF'], tagMap);\n    }\n}\nexports.AiffTagMapper = AiffTagMapper;\n//# sourceMappingURL=AiffTagMap.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYWlmZi9BaWZmVGFnTWFwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQiwyQkFBMkIsbUJBQU8sQ0FBQyxvSEFBNEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FpZmYvQWlmZlRhZ01hcC5qcz8xNTRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BaWZmVGFnTWFwcGVyID0gdm9pZCAwO1xuY29uc3QgR2VuZXJpY1RhZ01hcHBlcl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9HZW5lcmljVGFnTWFwcGVyXCIpO1xuLyoqXG4gKiBJRDN2MSB0YWcgbWFwcGluZ3NcbiAqL1xuY29uc3QgdGFnTWFwID0ge1xuICAgIE5BTUU6ICd0aXRsZScsXG4gICAgQVVUSDogJ2FydGlzdCcsXG4gICAgJyhjKSAnOiAnY29weXJpZ2h0JyxcbiAgICBBTk5POiAnY29tbWVudCdcbn07XG5jbGFzcyBBaWZmVGFnTWFwcGVyIGV4dGVuZHMgR2VuZXJpY1RhZ01hcHBlcl8xLkNvbW1vblRhZ01hcHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFsnQUlGRiddLCB0YWdNYXApO1xuICAgIH1cbn1cbmV4cG9ydHMuQWlmZlRhZ01hcHBlciA9IEFpZmZUYWdNYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BaWZmVGFnTWFwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/aiff/AiffTagMap.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/aiff/AiffToken.js":
/*!***********************************************************!*\
  !*** ./node_modules/music-metadata/lib/aiff/AiffToken.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Common = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/FourCC.js\");\nclass Common {\n    constructor(header, isAifc) {\n        this.isAifc = isAifc;\n        const minimumChunkSize = isAifc ? 22 : 18;\n        if (header.chunkSize < minimumChunkSize)\n            throw new Error(`COMMON CHUNK size should always be at least ${minimumChunkSize}`);\n        this.len = header.chunkSize;\n    }\n    get(buf, off) {\n        // see: https://cycling74.com/forums/aiffs-80-bit-sample-rate-value\n        const shift = buf.readUInt16BE(off + 8) - 16398;\n        const baseSampleRate = buf.readUInt16BE(off + 8 + 2);\n        const res = {\n            numChannels: buf.readUInt16BE(off),\n            numSampleFrames: buf.readUInt32BE(off + 2),\n            sampleSize: buf.readUInt16BE(off + 6),\n            sampleRate: shift < 0 ? baseSampleRate >> Math.abs(shift) : baseSampleRate << shift\n        };\n        if (this.isAifc) {\n            res.compressionType = FourCC_1.FourCcToken.get(buf, off + 18);\n            if (this.len > 22) {\n                const strLen = buf.readInt8(off + 22);\n                if (strLen > 0) {\n                    const padding = (strLen + 1) % 2;\n                    if (23 + strLen + padding === this.len) {\n                        res.compressionName = new Token.StringType(strLen, 'binary').get(buf, off + 23);\n                    }\n                    else {\n                        throw new Error('Illegal pstring length');\n                    }\n                }\n                else {\n                    res.compressionName = undefined;\n                }\n            }\n        }\n        else {\n            res.compressionName = 'PCM';\n        }\n        return res;\n    }\n}\nexports.Common = Common;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYWlmZi9BaWZmVG9rZW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLGNBQWMsbUJBQU8sQ0FBQyxnRkFBYTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxnR0FBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxpQkFBaUI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FpZmYvQWlmZlRva2VuLmpzP2VhNzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1vbiA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgRm91ckNDXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0ZvdXJDQ1wiKTtcbmNsYXNzIENvbW1vbiB7XG4gICAgY29uc3RydWN0b3IoaGVhZGVyLCBpc0FpZmMpIHtcbiAgICAgICAgdGhpcy5pc0FpZmMgPSBpc0FpZmM7XG4gICAgICAgIGNvbnN0IG1pbmltdW1DaHVua1NpemUgPSBpc0FpZmMgPyAyMiA6IDE4O1xuICAgICAgICBpZiAoaGVhZGVyLmNodW5rU2l6ZSA8IG1pbmltdW1DaHVua1NpemUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENPTU1PTiBDSFVOSyBzaXplIHNob3VsZCBhbHdheXMgYmUgYXQgbGVhc3QgJHttaW5pbXVtQ2h1bmtTaXplfWApO1xuICAgICAgICB0aGlzLmxlbiA9IGhlYWRlci5jaHVua1NpemU7XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vY3ljbGluZzc0LmNvbS9mb3J1bXMvYWlmZnMtODAtYml0LXNhbXBsZS1yYXRlLXZhbHVlXG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gYnVmLnJlYWRVSW50MTZCRShvZmYgKyA4KSAtIDE2Mzk4O1xuICAgICAgICBjb25zdCBiYXNlU2FtcGxlUmF0ZSA9IGJ1Zi5yZWFkVUludDE2QkUob2ZmICsgOCArIDIpO1xuICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgICBudW1DaGFubmVsczogYnVmLnJlYWRVSW50MTZCRShvZmYpLFxuICAgICAgICAgICAgbnVtU2FtcGxlRnJhbWVzOiBidWYucmVhZFVJbnQzMkJFKG9mZiArIDIpLFxuICAgICAgICAgICAgc2FtcGxlU2l6ZTogYnVmLnJlYWRVSW50MTZCRShvZmYgKyA2KSxcbiAgICAgICAgICAgIHNhbXBsZVJhdGU6IHNoaWZ0IDwgMCA/IGJhc2VTYW1wbGVSYXRlID4+IE1hdGguYWJzKHNoaWZ0KSA6IGJhc2VTYW1wbGVSYXRlIDw8IHNoaWZ0XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmlzQWlmYykge1xuICAgICAgICAgICAgcmVzLmNvbXByZXNzaW9uVHlwZSA9IEZvdXJDQ18xLkZvdXJDY1Rva2VuLmdldChidWYsIG9mZiArIDE4KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlbiA+IDIyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyTGVuID0gYnVmLnJlYWRJbnQ4KG9mZiArIDIyKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyTGVuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gKHN0ckxlbiArIDEpICUgMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDIzICsgc3RyTGVuICsgcGFkZGluZyA9PT0gdGhpcy5sZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5jb21wcmVzc2lvbk5hbWUgPSBuZXcgVG9rZW4uU3RyaW5nVHlwZShzdHJMZW4sICdiaW5hcnknKS5nZXQoYnVmLCBvZmYgKyAyMyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgcHN0cmluZyBsZW5ndGgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmNvbXByZXNzaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMuY29tcHJlc3Npb25OYW1lID0gJ1BDTSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5leHBvcnRzLkNvbW1vbiA9IENvbW1vbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/aiff/AiffToken.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/apev2/APEv2Parser.js":
/*!**************************************************************!*\
  !*** ./node_modules/music-metadata/lib/apev2/APEv2Parser.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.APEv2Parser = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst strtok3 = __webpack_require__(/*! strtok3/lib/core */ \"(app-pages-browser)/./node_modules/strtok3/lib/core.js\");\nconst token_types_1 = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst util = __webpack_require__(/*! ../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst APEv2Token_1 = __webpack_require__(/*! ./APEv2Token */ \"(app-pages-browser)/./node_modules/music-metadata/lib/apev2/APEv2Token.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:APEv2');\nconst tagFormat = 'APEv2';\nconst preamble = 'APETAGEX';\nclass APEv2Parser extends BasicParser_1.BasicParser {\n    constructor() {\n        super(...arguments);\n        this.ape = {};\n    }\n    static tryParseApeHeader(metadata, tokenizer, options) {\n        const apeParser = new APEv2Parser();\n        apeParser.init(metadata, tokenizer, options);\n        return apeParser.tryParseApeHeader();\n    }\n    /**\n     * Calculate the media file duration\n     * @param ah ApeHeader\n     * @return {number} duration in seconds\n     */\n    static calculateDuration(ah) {\n        let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\n        duration += ah.finalFrameBlocks;\n        return duration / ah.sampleRate;\n    }\n    /**\n     * Calculates the APEv1 / APEv2 first field offset\n     * @param reader\n     * @param offset\n     */\n    static async findApeFooterOffset(reader, offset) {\n        // Search for APE footer header at the end of the file\n        const apeBuf = Buffer.alloc(APEv2Token_1.TagFooter.len);\n        await reader.randomRead(apeBuf, 0, APEv2Token_1.TagFooter.len, offset - APEv2Token_1.TagFooter.len);\n        const tagFooter = APEv2Token_1.TagFooter.get(apeBuf, 0);\n        if (tagFooter.ID === 'APETAGEX') {\n            debug(`APE footer header at offset=${offset}`);\n            return { footer: tagFooter, offset: offset - tagFooter.size };\n        }\n    }\n    static parseTagFooter(metadata, buffer, options) {\n        const footer = APEv2Token_1.TagFooter.get(buffer, buffer.length - APEv2Token_1.TagFooter.len);\n        if (footer.ID !== preamble)\n            throw new Error('Unexpected APEv2 Footer ID preamble value.');\n        strtok3.fromBuffer(buffer);\n        const apeParser = new APEv2Parser();\n        apeParser.init(metadata, strtok3.fromBuffer(buffer), options);\n        return apeParser.parseTags(footer);\n    }\n    /**\n     * Parse APEv1 / APEv2 header if header signature found\n     */\n    async tryParseApeHeader() {\n        if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < APEv2Token_1.TagFooter.len) {\n            debug(`No APEv2 header found, end-of-file reached`);\n            return;\n        }\n        const footer = await this.tokenizer.peekToken(APEv2Token_1.TagFooter);\n        if (footer.ID === preamble) {\n            await this.tokenizer.ignore(APEv2Token_1.TagFooter.len);\n            return this.parseTags(footer);\n        }\n        else {\n            debug(`APEv2 header not found at offset=${this.tokenizer.position}`);\n            if (this.tokenizer.fileInfo.size) {\n                // Try to read the APEv2 header using just the footer-header\n                const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account\n                const buffer = Buffer.alloc(remaining);\n                await this.tokenizer.readBuffer(buffer);\n                return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);\n            }\n        }\n    }\n    async parse() {\n        const descriptor = await this.tokenizer.readToken(APEv2Token_1.DescriptorParser);\n        if (descriptor.ID !== 'MAC ')\n            throw new Error('Unexpected descriptor ID');\n        this.ape.descriptor = descriptor;\n        const lenExp = descriptor.descriptorBytes - APEv2Token_1.DescriptorParser.len;\n        const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());\n        await this.tokenizer.ignore(header.forwardBytes);\n        return this.tryParseApeHeader();\n    }\n    async parseTags(footer) {\n        const keyBuffer = Buffer.alloc(256); // maximum tag key length\n        let bytesRemaining = footer.size - APEv2Token_1.TagFooter.len;\n        debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);\n        for (let i = 0; i < footer.fields; i++) {\n            if (bytesRemaining < APEv2Token_1.TagItemHeader.len) {\n                this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);\n                break;\n            }\n            // Only APEv2 tag has tag item headers\n            const tagItemHeader = await this.tokenizer.readToken(APEv2Token_1.TagItemHeader);\n            bytesRemaining -= APEv2Token_1.TagItemHeader.len + tagItemHeader.size;\n            await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });\n            let zero = util.findZero(keyBuffer, 0, keyBuffer.length);\n            const key = await this.tokenizer.readToken(new token_types_1.StringType(zero, 'ascii'));\n            await this.tokenizer.ignore(1);\n            bytesRemaining -= key.length + 1;\n            switch (tagItemHeader.flags.dataType) {\n                case APEv2Token_1.DataType.text_utf8: { // utf-8 text-string\n                    const value = await this.tokenizer.readToken(new token_types_1.StringType(tagItemHeader.size, 'utf8'));\n                    const values = value.split(/\\x00/g);\n                    for (const val of values) {\n                        this.metadata.addTag(tagFormat, key, val);\n                    }\n                    break;\n                }\n                case APEv2Token_1.DataType.binary: // binary (probably artwork)\n                    if (this.options.skipCovers) {\n                        await this.tokenizer.ignore(tagItemHeader.size);\n                    }\n                    else {\n                        const picData = Buffer.alloc(tagItemHeader.size);\n                        await this.tokenizer.readBuffer(picData);\n                        zero = util.findZero(picData, 0, picData.length);\n                        const description = picData.toString('utf8', 0, zero);\n                        const data = Buffer.from(picData.slice(zero + 1));\n                        this.metadata.addTag(tagFormat, key, {\n                            description,\n                            data\n                        });\n                    }\n                    break;\n                case APEv2Token_1.DataType.external_info:\n                    debug(`Ignore external info ${key}`);\n                    await this.tokenizer.ignore(tagItemHeader.size);\n                    break;\n                case APEv2Token_1.DataType.reserved:\n                    debug(`Ignore external info ${key}`);\n                    this.metadata.addWarning(`APEv2 header declares a reserved datatype for \"${key}\"`);\n                    await this.tokenizer.ignore(tagItemHeader.size);\n                    break;\n            }\n        }\n    }\n    async parseDescriptorExpansion(lenExp) {\n        await this.tokenizer.ignore(lenExp);\n        return this.parseHeader();\n    }\n    async parseHeader() {\n        const header = await this.tokenizer.readToken(APEv2Token_1.Header);\n        // ToDo before\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('container', 'Monkey\\'s Audio');\n        this.metadata.setFormat('bitsPerSample', header.bitsPerSample);\n        this.metadata.setFormat('sampleRate', header.sampleRate);\n        this.metadata.setFormat('numberOfChannels', header.channel);\n        this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));\n        return {\n            forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes +\n                this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\n        };\n    }\n}\nexports.APEv2Parser = APEv2Parser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYXBldjIvQVBFdjJQYXJzZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBTztBQUMvQixnQkFBZ0IsbUJBQU8sQ0FBQyxnRkFBa0I7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMsZ0ZBQWE7QUFDM0MsYUFBYSxtQkFBTyxDQUFDLDRGQUFnQjtBQUNyQyxzQkFBc0IsbUJBQU8sQ0FBQywwR0FBdUI7QUFDckQscUJBQXFCLG1CQUFPLENBQUMsK0ZBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixNQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx3QkFBd0I7QUFDOUU7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRiwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNLGFBQWE7QUFDN0M7QUFDQSwwQ0FBMEMsd0JBQXdCLFNBQVMsZUFBZTtBQUMxRix3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0EsOERBQThELG1CQUFtQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELG9EQUFvRDtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RCwrRkFBK0YsSUFBSTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9hcGV2Mi9BUEV2MlBhcnNlci5qcz80NzE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BUEV2MlBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBzdHJ0b2szID0gcmVxdWlyZShcInN0cnRvazMvbGliL2NvcmVcIik7XG5jb25zdCB0b2tlbl90eXBlc18xID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuLi9jb21tb24vVXRpbFwiKTtcbmNvbnN0IEJhc2ljUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0Jhc2ljUGFyc2VyXCIpO1xuY29uc3QgQVBFdjJUb2tlbl8xID0gcmVxdWlyZShcIi4vQVBFdjJUb2tlblwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjpBUEV2MicpO1xuY29uc3QgdGFnRm9ybWF0ID0gJ0FQRXYyJztcbmNvbnN0IHByZWFtYmxlID0gJ0FQRVRBR0VYJztcbmNsYXNzIEFQRXYyUGFyc2VyIGV4dGVuZHMgQmFzaWNQYXJzZXJfMS5CYXNpY1BhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYXBlID0ge307XG4gICAgfVxuICAgIHN0YXRpYyB0cnlQYXJzZUFwZUhlYWRlcihtZXRhZGF0YSwgdG9rZW5pemVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFwZVBhcnNlciA9IG5ldyBBUEV2MlBhcnNlcigpO1xuICAgICAgICBhcGVQYXJzZXIuaW5pdChtZXRhZGF0YSwgdG9rZW5pemVyLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGFwZVBhcnNlci50cnlQYXJzZUFwZUhlYWRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIG1lZGlhIGZpbGUgZHVyYXRpb25cbiAgICAgKiBAcGFyYW0gYWggQXBlSGVhZGVyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBkdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAgICovXG4gICAgc3RhdGljIGNhbGN1bGF0ZUR1cmF0aW9uKGFoKSB7XG4gICAgICAgIGxldCBkdXJhdGlvbiA9IGFoLnRvdGFsRnJhbWVzID4gMSA/IGFoLmJsb2Nrc1BlckZyYW1lICogKGFoLnRvdGFsRnJhbWVzIC0gMSkgOiAwO1xuICAgICAgICBkdXJhdGlvbiArPSBhaC5maW5hbEZyYW1lQmxvY2tzO1xuICAgICAgICByZXR1cm4gZHVyYXRpb24gLyBhaC5zYW1wbGVSYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBBUEV2MSAvIEFQRXYyIGZpcnN0IGZpZWxkIG9mZnNldFxuICAgICAqIEBwYXJhbSByZWFkZXJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZpbmRBcGVGb290ZXJPZmZzZXQocmVhZGVyLCBvZmZzZXQpIHtcbiAgICAgICAgLy8gU2VhcmNoIGZvciBBUEUgZm9vdGVyIGhlYWRlciBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlXG4gICAgICAgIGNvbnN0IGFwZUJ1ZiA9IEJ1ZmZlci5hbGxvYyhBUEV2MlRva2VuXzEuVGFnRm9vdGVyLmxlbik7XG4gICAgICAgIGF3YWl0IHJlYWRlci5yYW5kb21SZWFkKGFwZUJ1ZiwgMCwgQVBFdjJUb2tlbl8xLlRhZ0Zvb3Rlci5sZW4sIG9mZnNldCAtIEFQRXYyVG9rZW5fMS5UYWdGb290ZXIubGVuKTtcbiAgICAgICAgY29uc3QgdGFnRm9vdGVyID0gQVBFdjJUb2tlbl8xLlRhZ0Zvb3Rlci5nZXQoYXBlQnVmLCAwKTtcbiAgICAgICAgaWYgKHRhZ0Zvb3Rlci5JRCA9PT0gJ0FQRVRBR0VYJykge1xuICAgICAgICAgICAgZGVidWcoYEFQRSBmb290ZXIgaGVhZGVyIGF0IG9mZnNldD0ke29mZnNldH1gKTtcbiAgICAgICAgICAgIHJldHVybiB7IGZvb3RlcjogdGFnRm9vdGVyLCBvZmZzZXQ6IG9mZnNldCAtIHRhZ0Zvb3Rlci5zaXplIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhcnNlVGFnRm9vdGVyKG1ldGFkYXRhLCBidWZmZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZm9vdGVyID0gQVBFdjJUb2tlbl8xLlRhZ0Zvb3Rlci5nZXQoYnVmZmVyLCBidWZmZXIubGVuZ3RoIC0gQVBFdjJUb2tlbl8xLlRhZ0Zvb3Rlci5sZW4pO1xuICAgICAgICBpZiAoZm9vdGVyLklEICE9PSBwcmVhbWJsZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBBUEV2MiBGb290ZXIgSUQgcHJlYW1ibGUgdmFsdWUuJyk7XG4gICAgICAgIHN0cnRvazMuZnJvbUJ1ZmZlcihidWZmZXIpO1xuICAgICAgICBjb25zdCBhcGVQYXJzZXIgPSBuZXcgQVBFdjJQYXJzZXIoKTtcbiAgICAgICAgYXBlUGFyc2VyLmluaXQobWV0YWRhdGEsIHN0cnRvazMuZnJvbUJ1ZmZlcihidWZmZXIpLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGFwZVBhcnNlci5wYXJzZVRhZ3MoZm9vdGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgQVBFdjEgLyBBUEV2MiBoZWFkZXIgaWYgaGVhZGVyIHNpZ25hdHVyZSBmb3VuZFxuICAgICAqL1xuICAgIGFzeW5jIHRyeVBhcnNlQXBlSGVhZGVyKCkge1xuICAgICAgICBpZiAodGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSAmJiB0aGlzLnRva2VuaXplci5maWxlSW5mby5zaXplIC0gdGhpcy50b2tlbml6ZXIucG9zaXRpb24gPCBBUEV2MlRva2VuXzEuVGFnRm9vdGVyLmxlbikge1xuICAgICAgICAgICAgZGVidWcoYE5vIEFQRXYyIGhlYWRlciBmb3VuZCwgZW5kLW9mLWZpbGUgcmVhY2hlZGApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvb3RlciA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnBlZWtUb2tlbihBUEV2MlRva2VuXzEuVGFnRm9vdGVyKTtcbiAgICAgICAgaWYgKGZvb3Rlci5JRCA9PT0gcHJlYW1ibGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShBUEV2MlRva2VuXzEuVGFnRm9vdGVyLmxlbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRhZ3MoZm9vdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKGBBUEV2MiBoZWFkZXIgbm90IGZvdW5kIGF0IG9mZnNldD0ke3RoaXMudG9rZW5pemVyLnBvc2l0aW9ufWApO1xuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5pemVyLmZpbGVJbmZvLnNpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gcmVhZCB0aGUgQVBFdjIgaGVhZGVyIHVzaW5nIGp1c3QgdGhlIGZvb3Rlci1oZWFkZXJcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmcgPSB0aGlzLnRva2VuaXplci5maWxlSW5mby5zaXplIC0gdGhpcy50b2tlbml6ZXIucG9zaXRpb247IC8vIFRvRG86IHRha2UgSUQzdjEgaW50byBhY2NvdW50XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZEJ1ZmZlcihidWZmZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBBUEV2MlBhcnNlci5wYXJzZVRhZ0Zvb3Rlcih0aGlzLm1ldGFkYXRhLCBidWZmZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGFyc2UoKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oQVBFdjJUb2tlbl8xLkRlc2NyaXB0b3JQYXJzZXIpO1xuICAgICAgICBpZiAoZGVzY3JpcHRvci5JRCAhPT0gJ01BQyAnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGRlc2NyaXB0b3IgSUQnKTtcbiAgICAgICAgdGhpcy5hcGUuZGVzY3JpcHRvciA9IGRlc2NyaXB0b3I7XG4gICAgICAgIGNvbnN0IGxlbkV4cCA9IGRlc2NyaXB0b3IuZGVzY3JpcHRvckJ5dGVzIC0gQVBFdjJUb2tlbl8xLkRlc2NyaXB0b3JQYXJzZXIubGVuO1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBhd2FpdCAobGVuRXhwID4gMCA/IHRoaXMucGFyc2VEZXNjcmlwdG9yRXhwYW5zaW9uKGxlbkV4cCkgOiB0aGlzLnBhcnNlSGVhZGVyKCkpO1xuICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUoaGVhZGVyLmZvcndhcmRCeXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyeVBhcnNlQXBlSGVhZGVyKCk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlVGFncyhmb290ZXIpIHtcbiAgICAgICAgY29uc3Qga2V5QnVmZmVyID0gQnVmZmVyLmFsbG9jKDI1Nik7IC8vIG1heGltdW0gdGFnIGtleSBsZW5ndGhcbiAgICAgICAgbGV0IGJ5dGVzUmVtYWluaW5nID0gZm9vdGVyLnNpemUgLSBBUEV2MlRva2VuXzEuVGFnRm9vdGVyLmxlbjtcbiAgICAgICAgZGVidWcoYFBhcnNlIEFQRSB0YWdzIGF0IG9mZnNldD0ke3RoaXMudG9rZW5pemVyLnBvc2l0aW9ufSwgc2l6ZT0ke2J5dGVzUmVtYWluaW5nfWApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvb3Rlci5maWVsZHM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGJ5dGVzUmVtYWluaW5nIDwgQVBFdjJUb2tlbl8xLlRhZ0l0ZW1IZWFkZXIubGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRXYXJuaW5nKGBBUEV2MiBUYWctaGVhZGVyOiAke2Zvb3Rlci5maWVsZHMgLSBpfSBpdGVtcyByZW1haW5pbmcsIGJ1dCBubyBtb3JlIHRhZyBkYXRhIHRvIHJlYWQuYCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IEFQRXYyIHRhZyBoYXMgdGFnIGl0ZW0gaGVhZGVyc1xuICAgICAgICAgICAgY29uc3QgdGFnSXRlbUhlYWRlciA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihBUEV2MlRva2VuXzEuVGFnSXRlbUhlYWRlcik7XG4gICAgICAgICAgICBieXRlc1JlbWFpbmluZyAtPSBBUEV2MlRva2VuXzEuVGFnSXRlbUhlYWRlci5sZW4gKyB0YWdJdGVtSGVhZGVyLnNpemU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5wZWVrQnVmZmVyKGtleUJ1ZmZlciwgeyBsZW5ndGg6IE1hdGgubWluKGtleUJ1ZmZlci5sZW5ndGgsIGJ5dGVzUmVtYWluaW5nKSB9KTtcbiAgICAgICAgICAgIGxldCB6ZXJvID0gdXRpbC5maW5kWmVybyhrZXlCdWZmZXIsIDAsIGtleUJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyB0b2tlbl90eXBlc18xLlN0cmluZ1R5cGUoemVybywgJ2FzY2lpJykpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKDEpO1xuICAgICAgICAgICAgYnl0ZXNSZW1haW5pbmcgLT0ga2V5Lmxlbmd0aCArIDE7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZ0l0ZW1IZWFkZXIuZmxhZ3MuZGF0YVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEFQRXYyVG9rZW5fMS5EYXRhVHlwZS50ZXh0X3V0Zjg6IHsgLy8gdXRmLTggdGV4dC1zdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IHRva2VuX3R5cGVzXzEuU3RyaW5nVHlwZSh0YWdJdGVtSGVhZGVyLnNpemUsICd1dGY4JykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZS5zcGxpdCgvXFx4MDAvZyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRUYWcodGFnRm9ybWF0LCBrZXksIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgQVBFdjJUb2tlbl8xLkRhdGFUeXBlLmJpbmFyeTogLy8gYmluYXJ5IChwcm9iYWJseSBhcnR3b3JrKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNraXBDb3ZlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZSh0YWdJdGVtSGVhZGVyLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGljRGF0YSA9IEJ1ZmZlci5hbGxvYyh0YWdJdGVtSGVhZGVyLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZEJ1ZmZlcihwaWNEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHplcm8gPSB1dGlsLmZpbmRaZXJvKHBpY0RhdGEsIDAsIHBpY0RhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gcGljRGF0YS50b1N0cmluZygndXRmOCcsIDAsIHplcm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5mcm9tKHBpY0RhdGEuc2xpY2UoemVybyArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuYWRkVGFnKHRhZ0Zvcm1hdCwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBUEV2MlRva2VuXzEuRGF0YVR5cGUuZXh0ZXJuYWxfaW5mbzpcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoYElnbm9yZSBleHRlcm5hbCBpbmZvICR7a2V5fWApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUodGFnSXRlbUhlYWRlci5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBUEV2MlRva2VuXzEuRGF0YVR5cGUucmVzZXJ2ZWQ6XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKGBJZ25vcmUgZXh0ZXJuYWwgaW5mbyAke2tleX1gKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRXYXJuaW5nKGBBUEV2MiBoZWFkZXIgZGVjbGFyZXMgYSByZXNlcnZlZCBkYXRhdHlwZSBmb3IgXCIke2tleX1cImApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUodGFnSXRlbUhlYWRlci5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGFyc2VEZXNjcmlwdG9yRXhwYW5zaW9uKGxlbkV4cCkge1xuICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUobGVuRXhwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VIZWFkZXIoKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VIZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihBUEV2MlRva2VuXzEuSGVhZGVyKTtcbiAgICAgICAgLy8gVG9EbyBiZWZvcmVcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2xvc3NsZXNzJywgdHJ1ZSk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb250YWluZXInLCAnTW9ua2V5XFwncyBBdWRpbycpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYml0c1BlclNhbXBsZScsIGhlYWRlci5iaXRzUGVyU2FtcGxlKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ3NhbXBsZVJhdGUnLCBoZWFkZXIuc2FtcGxlUmF0ZSk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZkNoYW5uZWxzJywgaGVhZGVyLmNoYW5uZWwpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnZHVyYXRpb24nLCBBUEV2MlBhcnNlci5jYWxjdWxhdGVEdXJhdGlvbihoZWFkZXIpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcndhcmRCeXRlczogdGhpcy5hcGUuZGVzY3JpcHRvci5zZWVrVGFibGVCeXRlcyArIHRoaXMuYXBlLmRlc2NyaXB0b3IuaGVhZGVyRGF0YUJ5dGVzICtcbiAgICAgICAgICAgICAgICB0aGlzLmFwZS5kZXNjcmlwdG9yLmFwZUZyYW1lRGF0YUJ5dGVzICsgdGhpcy5hcGUuZGVzY3JpcHRvci50ZXJtaW5hdGluZ0RhdGFCeXRlc1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQVBFdjJQYXJzZXIgPSBBUEV2MlBhcnNlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/apev2/APEv2Parser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/apev2/APEv2TagMapper.js":
/*!*****************************************************************!*\
  !*** ./node_modules/music-metadata/lib/apev2/APEv2TagMapper.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.APEv2TagMapper = void 0;\nconst CaseInsensitiveTagMap_1 = __webpack_require__(/*! ../common/CaseInsensitiveTagMap */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js\");\n/**\n * ID3v2.2 tag mappings\n */\nconst apev2TagMap = {\n    Title: 'title',\n    Artist: 'artist',\n    Artists: 'artists',\n    'Album Artist': 'albumartist',\n    Album: 'album',\n    Year: 'date',\n    Originalyear: 'originalyear',\n    Originaldate: 'originaldate',\n    Comment: 'comment',\n    Track: 'track',\n    Disc: 'disk',\n    DISCNUMBER: 'disk',\n    Genre: 'genre',\n    'Cover Art (Front)': 'picture',\n    'Cover Art (Back)': 'picture',\n    Composer: 'composer',\n    Lyrics: 'lyrics',\n    ALBUMSORT: 'albumsort',\n    TITLESORT: 'titlesort',\n    WORK: 'work',\n    ARTISTSORT: 'artistsort',\n    ALBUMARTISTSORT: 'albumartistsort',\n    COMPOSERSORT: 'composersort',\n    Lyricist: 'lyricist',\n    Writer: 'writer',\n    Conductor: 'conductor',\n    // 'Performer=artist (instrument)': 'performer:instrument',\n    MixArtist: 'remixer',\n    Arranger: 'arranger',\n    Engineer: 'engineer',\n    Producer: 'producer',\n    DJMixer: 'djmixer',\n    Mixer: 'mixer',\n    Label: 'label',\n    Grouping: 'grouping',\n    Subtitle: 'subtitle',\n    DiscSubtitle: 'discsubtitle',\n    Compilation: 'compilation',\n    BPM: 'bpm',\n    Mood: 'mood',\n    Media: 'media',\n    CatalogNumber: 'catalognumber',\n    MUSICBRAINZ_ALBUMSTATUS: 'releasestatus',\n    MUSICBRAINZ_ALBUMTYPE: 'releasetype',\n    RELEASECOUNTRY: 'releasecountry',\n    Script: 'script',\n    Language: 'language',\n    Copyright: 'copyright',\n    LICENSE: 'license',\n    EncodedBy: 'encodedby',\n    EncoderSettings: 'encodersettings',\n    Barcode: 'barcode',\n    ISRC: 'isrc',\n    ASIN: 'asin',\n    musicbrainz_trackid: 'musicbrainz_recordingid',\n    musicbrainz_releasetrackid: 'musicbrainz_trackid',\n    MUSICBRAINZ_ALBUMID: 'musicbrainz_albumid',\n    MUSICBRAINZ_ARTISTID: 'musicbrainz_artistid',\n    MUSICBRAINZ_ALBUMARTISTID: 'musicbrainz_albumartistid',\n    MUSICBRAINZ_RELEASEGROUPID: 'musicbrainz_releasegroupid',\n    MUSICBRAINZ_WORKID: 'musicbrainz_workid',\n    MUSICBRAINZ_TRMID: 'musicbrainz_trmid',\n    MUSICBRAINZ_DISCID: 'musicbrainz_discid',\n    Acoustid_Id: 'acoustid_id',\n    ACOUSTID_FINGERPRINT: 'acoustid_fingerprint',\n    MUSICIP_PUID: 'musicip_puid',\n    Weblink: 'website',\n    REPLAYGAIN_TRACK_GAIN: 'replaygain_track_gain',\n    REPLAYGAIN_TRACK_PEAK: 'replaygain_track_peak',\n    MP3GAIN_MINMAX: 'replaygain_track_minmax',\n    MP3GAIN_UNDO: 'replaygain_undo'\n};\nclass APEv2TagMapper extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {\n    constructor() {\n        super(['APEv2'], apev2TagMap);\n    }\n}\nexports.APEv2TagMapper = APEv2TagMapper;\n//# sourceMappingURL=APEv2TagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYXBldjIvQVBFdjJUYWdNYXBwZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLGdDQUFnQyxtQkFBTyxDQUFDLDhIQUFpQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9hcGV2Mi9BUEV2MlRhZ01hcHBlci5qcz9lNjBlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BUEV2MlRhZ01hcHBlciA9IHZvaWQgMDtcbmNvbnN0IENhc2VJbnNlbnNpdGl2ZVRhZ01hcF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9DYXNlSW5zZW5zaXRpdmVUYWdNYXBcIik7XG4vKipcbiAqIElEM3YyLjIgdGFnIG1hcHBpbmdzXG4gKi9cbmNvbnN0IGFwZXYyVGFnTWFwID0ge1xuICAgIFRpdGxlOiAndGl0bGUnLFxuICAgIEFydGlzdDogJ2FydGlzdCcsXG4gICAgQXJ0aXN0czogJ2FydGlzdHMnLFxuICAgICdBbGJ1bSBBcnRpc3QnOiAnYWxidW1hcnRpc3QnLFxuICAgIEFsYnVtOiAnYWxidW0nLFxuICAgIFllYXI6ICdkYXRlJyxcbiAgICBPcmlnaW5hbHllYXI6ICdvcmlnaW5hbHllYXInLFxuICAgIE9yaWdpbmFsZGF0ZTogJ29yaWdpbmFsZGF0ZScsXG4gICAgQ29tbWVudDogJ2NvbW1lbnQnLFxuICAgIFRyYWNrOiAndHJhY2snLFxuICAgIERpc2M6ICdkaXNrJyxcbiAgICBESVNDTlVNQkVSOiAnZGlzaycsXG4gICAgR2VucmU6ICdnZW5yZScsXG4gICAgJ0NvdmVyIEFydCAoRnJvbnQpJzogJ3BpY3R1cmUnLFxuICAgICdDb3ZlciBBcnQgKEJhY2spJzogJ3BpY3R1cmUnLFxuICAgIENvbXBvc2VyOiAnY29tcG9zZXInLFxuICAgIEx5cmljczogJ2x5cmljcycsXG4gICAgQUxCVU1TT1JUOiAnYWxidW1zb3J0JyxcbiAgICBUSVRMRVNPUlQ6ICd0aXRsZXNvcnQnLFxuICAgIFdPUks6ICd3b3JrJyxcbiAgICBBUlRJU1RTT1JUOiAnYXJ0aXN0c29ydCcsXG4gICAgQUxCVU1BUlRJU1RTT1JUOiAnYWxidW1hcnRpc3Rzb3J0JyxcbiAgICBDT01QT1NFUlNPUlQ6ICdjb21wb3NlcnNvcnQnLFxuICAgIEx5cmljaXN0OiAnbHlyaWNpc3QnLFxuICAgIFdyaXRlcjogJ3dyaXRlcicsXG4gICAgQ29uZHVjdG9yOiAnY29uZHVjdG9yJyxcbiAgICAvLyAnUGVyZm9ybWVyPWFydGlzdMKgKGluc3RydW1lbnQpJzogJ3BlcmZvcm1lcjppbnN0cnVtZW50JyxcbiAgICBNaXhBcnRpc3Q6ICdyZW1peGVyJyxcbiAgICBBcnJhbmdlcjogJ2FycmFuZ2VyJyxcbiAgICBFbmdpbmVlcjogJ2VuZ2luZWVyJyxcbiAgICBQcm9kdWNlcjogJ3Byb2R1Y2VyJyxcbiAgICBESk1peGVyOiAnZGptaXhlcicsXG4gICAgTWl4ZXI6ICdtaXhlcicsXG4gICAgTGFiZWw6ICdsYWJlbCcsXG4gICAgR3JvdXBpbmc6ICdncm91cGluZycsXG4gICAgU3VidGl0bGU6ICdzdWJ0aXRsZScsXG4gICAgRGlzY1N1YnRpdGxlOiAnZGlzY3N1YnRpdGxlJyxcbiAgICBDb21waWxhdGlvbjogJ2NvbXBpbGF0aW9uJyxcbiAgICBCUE06ICdicG0nLFxuICAgIE1vb2Q6ICdtb29kJyxcbiAgICBNZWRpYTogJ21lZGlhJyxcbiAgICBDYXRhbG9nTnVtYmVyOiAnY2F0YWxvZ251bWJlcicsXG4gICAgTVVTSUNCUkFJTlpfQUxCVU1TVEFUVVM6ICdyZWxlYXNlc3RhdHVzJyxcbiAgICBNVVNJQ0JSQUlOWl9BTEJVTVRZUEU6ICdyZWxlYXNldHlwZScsXG4gICAgUkVMRUFTRUNPVU5UUlk6ICdyZWxlYXNlY291bnRyeScsXG4gICAgU2NyaXB0OiAnc2NyaXB0JyxcbiAgICBMYW5ndWFnZTogJ2xhbmd1YWdlJyxcbiAgICBDb3B5cmlnaHQ6ICdjb3B5cmlnaHQnLFxuICAgIExJQ0VOU0U6ICdsaWNlbnNlJyxcbiAgICBFbmNvZGVkQnk6ICdlbmNvZGVkYnknLFxuICAgIEVuY29kZXJTZXR0aW5nczogJ2VuY29kZXJzZXR0aW5ncycsXG4gICAgQmFyY29kZTogJ2JhcmNvZGUnLFxuICAgIElTUkM6ICdpc3JjJyxcbiAgICBBU0lOOiAnYXNpbicsXG4gICAgbXVzaWNicmFpbnpfdHJhY2tpZDogJ211c2ljYnJhaW56X3JlY29yZGluZ2lkJyxcbiAgICBtdXNpY2JyYWluel9yZWxlYXNldHJhY2tpZDogJ211c2ljYnJhaW56X3RyYWNraWQnLFxuICAgIE1VU0lDQlJBSU5aX0FMQlVNSUQ6ICdtdXNpY2JyYWluel9hbGJ1bWlkJyxcbiAgICBNVVNJQ0JSQUlOWl9BUlRJU1RJRDogJ211c2ljYnJhaW56X2FydGlzdGlkJyxcbiAgICBNVVNJQ0JSQUlOWl9BTEJVTUFSVElTVElEOiAnbXVzaWNicmFpbnpfYWxidW1hcnRpc3RpZCcsXG4gICAgTVVTSUNCUkFJTlpfUkVMRUFTRUdST1VQSUQ6ICdtdXNpY2JyYWluel9yZWxlYXNlZ3JvdXBpZCcsXG4gICAgTVVTSUNCUkFJTlpfV09SS0lEOiAnbXVzaWNicmFpbnpfd29ya2lkJyxcbiAgICBNVVNJQ0JSQUlOWl9UUk1JRDogJ211c2ljYnJhaW56X3RybWlkJyxcbiAgICBNVVNJQ0JSQUlOWl9ESVNDSUQ6ICdtdXNpY2JyYWluel9kaXNjaWQnLFxuICAgIEFjb3VzdGlkX0lkOiAnYWNvdXN0aWRfaWQnLFxuICAgIEFDT1VTVElEX0ZJTkdFUlBSSU5UOiAnYWNvdXN0aWRfZmluZ2VycHJpbnQnLFxuICAgIE1VU0lDSVBfUFVJRDogJ211c2ljaXBfcHVpZCcsXG4gICAgV2VibGluazogJ3dlYnNpdGUnLFxuICAgIFJFUExBWUdBSU5fVFJBQ0tfR0FJTjogJ3JlcGxheWdhaW5fdHJhY2tfZ2FpbicsXG4gICAgUkVQTEFZR0FJTl9UUkFDS19QRUFLOiAncmVwbGF5Z2Fpbl90cmFja19wZWFrJyxcbiAgICBNUDNHQUlOX01JTk1BWDogJ3JlcGxheWdhaW5fdHJhY2tfbWlubWF4JyxcbiAgICBNUDNHQUlOX1VORE86ICdyZXBsYXlnYWluX3VuZG8nXG59O1xuY2xhc3MgQVBFdjJUYWdNYXBwZXIgZXh0ZW5kcyBDYXNlSW5zZW5zaXRpdmVUYWdNYXBfMS5DYXNlSW5zZW5zaXRpdmVUYWdNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihbJ0FQRXYyJ10sIGFwZXYyVGFnTWFwKTtcbiAgICB9XG59XG5leHBvcnRzLkFQRXYyVGFnTWFwcGVyID0gQVBFdjJUYWdNYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BUEV2MlRhZ01hcHBlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/apev2/APEv2TagMapper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/apev2/APEv2Token.js":
/*!*************************************************************!*\
  !*** ./node_modules/music-metadata/lib/apev2/APEv2Token.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isBitSet = exports.parseTagFlags = exports.TagField = exports.TagItemHeader = exports.TagFooter = exports.Header = exports.DescriptorParser = exports.DataType = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/FourCC.js\");\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"text_utf8\"] = 0] = \"text_utf8\";\n    DataType[DataType[\"binary\"] = 1] = \"binary\";\n    DataType[DataType[\"external_info\"] = 2] = \"external_info\";\n    DataType[DataType[\"reserved\"] = 3] = \"reserved\";\n})(DataType = exports.DataType || (exports.DataType = {}));\n/**\n * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\n */\nexports.DescriptorParser = {\n    len: 52,\n    get: (buf, off) => {\n        return {\n            // should equal 'MAC '\n            ID: FourCC_1.FourCcToken.get(buf, off),\n            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\n            version: Token.UINT32_LE.get(buf, off + 4) / 1000,\n            // the number of descriptor bytes (allows later expansion of this header)\n            descriptorBytes: Token.UINT32_LE.get(buf, off + 8),\n            // the number of header APE_HEADER bytes\n            headerBytes: Token.UINT32_LE.get(buf, off + 12),\n            // the number of header APE_HEADER bytes\n            seekTableBytes: Token.UINT32_LE.get(buf, off + 16),\n            // the number of header data bytes (from original file)\n            headerDataBytes: Token.UINT32_LE.get(buf, off + 20),\n            // the number of bytes of APE frame data\n            apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),\n            // the high order number of APE frame data bytes\n            apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),\n            // the terminating data of the file (not including tag data)\n            terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),\n            // the MD5 hash of the file (see notes for usage... it's a little tricky)\n            fileMD5: new Token.Uint8ArrayType(16).get(buf, off + 36)\n        };\n    }\n};\n/**\n * APE_HEADER: describes all of the necessary information about the APE file\n */\nexports.Header = {\n    len: 24,\n    get: (buf, off) => {\n        return {\n            // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\n            compressionLevel: Token.UINT16_LE.get(buf, off),\n            // any format flags (for future use)\n            formatFlags: Token.UINT16_LE.get(buf, off + 2),\n            // the number of audio blocks in one frame\n            blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),\n            // the number of audio blocks in the final frame\n            finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),\n            // the total number of frames\n            totalFrames: Token.UINT32_LE.get(buf, off + 12),\n            // the bits per sample (typically 16)\n            bitsPerSample: Token.UINT16_LE.get(buf, off + 16),\n            // the number of channels (1 or 2)\n            channel: Token.UINT16_LE.get(buf, off + 18),\n            // the sample rate (typically 44100)\n            sampleRate: Token.UINT32_LE.get(buf, off + 20)\n        };\n    }\n};\n/**\n * APE Tag Header/Footer Version 2.0\n * TAG: describes all the properties of the file [optional]\n */\nexports.TagFooter = {\n    len: 32,\n    get: (buf, off) => {\n        return {\n            // should equal 'APETAGEX'\n            ID: new Token.StringType(8, 'ascii').get(buf, off),\n            // equals CURRENT_APE_TAG_VERSION\n            version: Token.UINT32_LE.get(buf, off + 8),\n            // the complete size of the tag, including this footer (excludes header)\n            size: Token.UINT32_LE.get(buf, off + 12),\n            // the number of fields in the tag\n            fields: Token.UINT32_LE.get(buf, off + 16),\n            // reserved for later use (must be zero),\n            flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 20))\n        };\n    }\n};\n/**\n * APE Tag v2.0 Item Header\n */\nexports.TagItemHeader = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            // Length of assigned value in bytes\n            size: Token.UINT32_LE.get(buf, off),\n            // reserved for later use (must be zero),\n            flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 4))\n        };\n    }\n};\nconst TagField = footer => {\n    return new Token.Uint8ArrayType(footer.size - exports.TagFooter.len);\n};\nexports.TagField = TagField;\nfunction parseTagFlags(flags) {\n    return {\n        containsHeader: isBitSet(flags, 31),\n        containsFooter: isBitSet(flags, 30),\n        isHeader: isBitSet(flags, 31),\n        readOnly: isBitSet(flags, 0),\n        dataType: (flags & 6) >> 1\n    };\n}\nexports.parseTagFlags = parseTagFlags;\n/**\n * @param num {number}\n * @param bit 0 is least significant bit (LSB)\n * @return {boolean} true if bit is 1; otherwise false\n */\nfunction isBitSet(num, bit) {\n    return (num & 1 << bit) !== 0;\n}\nexports.isBitSet = isBitSet;\n//# sourceMappingURL=APEv2Token.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYXBldjIvQVBFdjJUb2tlbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxxQkFBcUIsR0FBRyxnQkFBZ0IsR0FBRyxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRyxjQUFjLEdBQUcsd0JBQXdCLEdBQUcsZ0JBQWdCO0FBQ3RLLGNBQWMsbUJBQU8sQ0FBQyxnRkFBYTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxnR0FBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0MsZ0JBQWdCLEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxZQUFZLFNBQVMsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYXBldjIvQVBFdjJUb2tlbi5qcz8yOWI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0JpdFNldCA9IGV4cG9ydHMucGFyc2VUYWdGbGFncyA9IGV4cG9ydHMuVGFnRmllbGQgPSBleHBvcnRzLlRhZ0l0ZW1IZWFkZXIgPSBleHBvcnRzLlRhZ0Zvb3RlciA9IGV4cG9ydHMuSGVhZGVyID0gZXhwb3J0cy5EZXNjcmlwdG9yUGFyc2VyID0gZXhwb3J0cy5EYXRhVHlwZSA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgRm91ckNDXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0ZvdXJDQ1wiKTtcbnZhciBEYXRhVHlwZTtcbihmdW5jdGlvbiAoRGF0YVR5cGUpIHtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcInRleHRfdXRmOFwiXSA9IDBdID0gXCJ0ZXh0X3V0ZjhcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcImJpbmFyeVwiXSA9IDFdID0gXCJiaW5hcnlcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcImV4dGVybmFsX2luZm9cIl0gPSAyXSA9IFwiZXh0ZXJuYWxfaW5mb1wiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wicmVzZXJ2ZWRcIl0gPSAzXSA9IFwicmVzZXJ2ZWRcIjtcbn0pKERhdGFUeXBlID0gZXhwb3J0cy5EYXRhVHlwZSB8fCAoZXhwb3J0cy5EYXRhVHlwZSA9IHt9KSk7XG4vKipcbiAqIEFQRV9ERVNDUklQVE9SOiBkZWZpbmVzIHRoZSBzaXplcyAoYW5kIG9mZnNldHMpIG9mIGFsbCB0aGUgcGllY2VzLCBhcyB3ZWxsIGFzIHRoZSBNRDUgY2hlY2tzdW1cbiAqL1xuZXhwb3J0cy5EZXNjcmlwdG9yUGFyc2VyID0ge1xuICAgIGxlbjogNTIsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIHNob3VsZCBlcXVhbCAnTUFDICdcbiAgICAgICAgICAgIElEOiBGb3VyQ0NfMS5Gb3VyQ2NUb2tlbi5nZXQoYnVmLCBvZmYpLFxuICAgICAgICAgICAgLy8gdmVyc2lvbkluZGV4IG51bWJlciAqIDEwMDAgKDMuODEgPSAzODEwKSAocmVtZW1iZXIgdGhhdCA0LWJ5dGUgYWxpZ25tZW50IGNhdXNlcyB0aGlzIHRvIHRha2UgNC1ieXRlcylcbiAgICAgICAgICAgIHZlcnNpb246IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyA0KSAvIDEwMDAsXG4gICAgICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIGRlc2NyaXB0b3IgYnl0ZXMgKGFsbG93cyBsYXRlciBleHBhbnNpb24gb2YgdGhpcyBoZWFkZXIpXG4gICAgICAgICAgICBkZXNjcmlwdG9yQnl0ZXM6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyA4KSxcbiAgICAgICAgICAgIC8vIHRoZSBudW1iZXIgb2YgaGVhZGVyIEFQRV9IRUFERVIgYnl0ZXNcbiAgICAgICAgICAgIGhlYWRlckJ5dGVzOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgMTIpLFxuICAgICAgICAgICAgLy8gdGhlIG51bWJlciBvZiBoZWFkZXIgQVBFX0hFQURFUiBieXRlc1xuICAgICAgICAgICAgc2Vla1RhYmxlQnl0ZXM6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAxNiksXG4gICAgICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIGhlYWRlciBkYXRhIGJ5dGVzIChmcm9tIG9yaWdpbmFsIGZpbGUpXG4gICAgICAgICAgICBoZWFkZXJEYXRhQnl0ZXM6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAyMCksXG4gICAgICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIG9mIEFQRSBmcmFtZSBkYXRhXG4gICAgICAgICAgICBhcGVGcmFtZURhdGFCeXRlczogVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIG9mZiArIDI0KSxcbiAgICAgICAgICAgIC8vIHRoZSBoaWdoIG9yZGVyIG51bWJlciBvZiBBUEUgZnJhbWUgZGF0YSBieXRlc1xuICAgICAgICAgICAgYXBlRnJhbWVEYXRhQnl0ZXNIaWdoOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgMjgpLFxuICAgICAgICAgICAgLy8gdGhlIHRlcm1pbmF0aW5nIGRhdGEgb2YgdGhlIGZpbGUgKG5vdCBpbmNsdWRpbmcgdGFnIGRhdGEpXG4gICAgICAgICAgICB0ZXJtaW5hdGluZ0RhdGFCeXRlczogVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIG9mZiArIDMyKSxcbiAgICAgICAgICAgIC8vIHRoZSBNRDUgaGFzaCBvZiB0aGUgZmlsZSAoc2VlIG5vdGVzIGZvciB1c2FnZS4uLiBpdCdzIGEgbGl0dGxlIHRyaWNreSlcbiAgICAgICAgICAgIGZpbGVNRDU6IG5ldyBUb2tlbi5VaW50OEFycmF5VHlwZSgxNikuZ2V0KGJ1Ziwgb2ZmICsgMzYpXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogQVBFX0hFQURFUjogZGVzY3JpYmVzIGFsbCBvZiB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIGFib3V0IHRoZSBBUEUgZmlsZVxuICovXG5leHBvcnRzLkhlYWRlciA9IHtcbiAgICBsZW46IDI0LFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyB0aGUgY29tcHJlc3Npb24gbGV2ZWwgKHNlZSBkZWZpbmVzIEkuRS4gQ09NUFJFU1NJT05fTEVWRUxfRkFTVClcbiAgICAgICAgICAgIGNvbXByZXNzaW9uTGV2ZWw6IFRva2VuLlVJTlQxNl9MRS5nZXQoYnVmLCBvZmYpLFxuICAgICAgICAgICAgLy8gYW55IGZvcm1hdCBmbGFncyAoZm9yIGZ1dHVyZSB1c2UpXG4gICAgICAgICAgICBmb3JtYXRGbGFnczogVG9rZW4uVUlOVDE2X0xFLmdldChidWYsIG9mZiArIDIpLFxuICAgICAgICAgICAgLy8gdGhlIG51bWJlciBvZiBhdWRpbyBibG9ja3MgaW4gb25lIGZyYW1lXG4gICAgICAgICAgICBibG9ja3NQZXJGcmFtZTogVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIG9mZiArIDQpLFxuICAgICAgICAgICAgLy8gdGhlIG51bWJlciBvZiBhdWRpbyBibG9ja3MgaW4gdGhlIGZpbmFsIGZyYW1lXG4gICAgICAgICAgICBmaW5hbEZyYW1lQmxvY2tzOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgOCksXG4gICAgICAgICAgICAvLyB0aGUgdG90YWwgbnVtYmVyIG9mIGZyYW1lc1xuICAgICAgICAgICAgdG90YWxGcmFtZXM6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAxMiksXG4gICAgICAgICAgICAvLyB0aGUgYml0cyBwZXIgc2FtcGxlICh0eXBpY2FsbHkgMTYpXG4gICAgICAgICAgICBiaXRzUGVyU2FtcGxlOiBUb2tlbi5VSU5UMTZfTEUuZ2V0KGJ1Ziwgb2ZmICsgMTYpLFxuICAgICAgICAgICAgLy8gdGhlIG51bWJlciBvZiBjaGFubmVscyAoMSBvciAyKVxuICAgICAgICAgICAgY2hhbm5lbDogVG9rZW4uVUlOVDE2X0xFLmdldChidWYsIG9mZiArIDE4KSxcbiAgICAgICAgICAgIC8vIHRoZSBzYW1wbGUgcmF0ZSAodHlwaWNhbGx5IDQ0MTAwKVxuICAgICAgICAgICAgc2FtcGxlUmF0ZTogVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIG9mZiArIDIwKVxuICAgICAgICB9O1xuICAgIH1cbn07XG4vKipcbiAqIEFQRSBUYWcgSGVhZGVyL0Zvb3RlciBWZXJzaW9uIDIuMFxuICogVEFHOiBkZXNjcmliZXMgYWxsIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBmaWxlIFtvcHRpb25hbF1cbiAqL1xuZXhwb3J0cy5UYWdGb290ZXIgPSB7XG4gICAgbGVuOiAzMixcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gc2hvdWxkIGVxdWFsICdBUEVUQUdFWCdcbiAgICAgICAgICAgIElEOiBuZXcgVG9rZW4uU3RyaW5nVHlwZSg4LCAnYXNjaWknKS5nZXQoYnVmLCBvZmYpLFxuICAgICAgICAgICAgLy8gZXF1YWxzIENVUlJFTlRfQVBFX1RBR19WRVJTSU9OXG4gICAgICAgICAgICB2ZXJzaW9uOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgOCksXG4gICAgICAgICAgICAvLyB0aGUgY29tcGxldGUgc2l6ZSBvZiB0aGUgdGFnLCBpbmNsdWRpbmcgdGhpcyBmb290ZXIgKGV4Y2x1ZGVzIGhlYWRlcilcbiAgICAgICAgICAgIHNpemU6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAxMiksXG4gICAgICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIGZpZWxkcyBpbiB0aGUgdGFnXG4gICAgICAgICAgICBmaWVsZHM6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAxNiksXG4gICAgICAgICAgICAvLyByZXNlcnZlZCBmb3IgbGF0ZXIgdXNlIChtdXN0IGJlIHplcm8pLFxuICAgICAgICAgICAgZmxhZ3M6IHBhcnNlVGFnRmxhZ3MoVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIG9mZiArIDIwKSlcbiAgICAgICAgfTtcbiAgICB9XG59O1xuLyoqXG4gKiBBUEUgVGFnIHYyLjAgSXRlbSBIZWFkZXJcbiAqL1xuZXhwb3J0cy5UYWdJdGVtSGVhZGVyID0ge1xuICAgIGxlbjogOCxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gTGVuZ3RoIG9mIGFzc2lnbmVkIHZhbHVlIGluIGJ5dGVzXG4gICAgICAgICAgICBzaXplOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmKSxcbiAgICAgICAgICAgIC8vIHJlc2VydmVkIGZvciBsYXRlciB1c2UgKG11c3QgYmUgemVybyksXG4gICAgICAgICAgICBmbGFnczogcGFyc2VUYWdGbGFncyhUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgNCkpXG4gICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IFRhZ0ZpZWxkID0gZm9vdGVyID0+IHtcbiAgICByZXR1cm4gbmV3IFRva2VuLlVpbnQ4QXJyYXlUeXBlKGZvb3Rlci5zaXplIC0gZXhwb3J0cy5UYWdGb290ZXIubGVuKTtcbn07XG5leHBvcnRzLlRhZ0ZpZWxkID0gVGFnRmllbGQ7XG5mdW5jdGlvbiBwYXJzZVRhZ0ZsYWdzKGZsYWdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGFpbnNIZWFkZXI6IGlzQml0U2V0KGZsYWdzLCAzMSksXG4gICAgICAgIGNvbnRhaW5zRm9vdGVyOiBpc0JpdFNldChmbGFncywgMzApLFxuICAgICAgICBpc0hlYWRlcjogaXNCaXRTZXQoZmxhZ3MsIDMxKSxcbiAgICAgICAgcmVhZE9ubHk6IGlzQml0U2V0KGZsYWdzLCAwKSxcbiAgICAgICAgZGF0YVR5cGU6IChmbGFncyAmIDYpID4+IDFcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZVRhZ0ZsYWdzID0gcGFyc2VUYWdGbGFncztcbi8qKlxuICogQHBhcmFtIG51bSB7bnVtYmVyfVxuICogQHBhcmFtIGJpdCAwIGlzIGxlYXN0IHNpZ25pZmljYW50IGJpdCAoTFNCKVxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBiaXQgaXMgMTsgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQml0U2V0KG51bSwgYml0KSB7XG4gICAgcmV0dXJuIChudW0gJiAxIDw8IGJpdCkgIT09IDA7XG59XG5leHBvcnRzLmlzQml0U2V0ID0gaXNCaXRTZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BUEV2MlRva2VuLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/apev2/APEv2Token.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/asf/AsfObject.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/asf/AsfObject.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\n// ASF Objects\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WmPictureToken = exports.MetadataLibraryObjectState = exports.MetadataObjectState = exports.ExtendedStreamPropertiesObjectState = exports.ExtendedContentDescriptionObjectState = exports.ContentDescriptionObjectState = exports.readCodecEntries = exports.HeaderExtensionObject = exports.StreamPropertiesObject = exports.FilePropertiesObject = exports.IgnoreObjectState = exports.State = exports.HeaderObjectToken = exports.TopLevelHeaderObjectToken = exports.DataType = void 0;\nconst util = __webpack_require__(/*! ../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst GUID_1 = __webpack_require__(/*! ./GUID */ \"(app-pages-browser)/./node_modules/music-metadata/lib/asf/GUID.js\");\nconst AsfUtil_1 = __webpack_require__(/*! ./AsfUtil */ \"(app-pages-browser)/./node_modules/music-metadata/lib/asf/AsfUtil.js\");\nconst ID3v2Token_1 = __webpack_require__(/*! ../id3v2/ID3v2Token */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v2Token.js\");\n/**\n * Data Type: Specifies the type of information being stored. The following values are recognized.\n */\nvar DataType;\n(function (DataType) {\n    /**\n     * Unicode string. The data consists of a sequence of Unicode characters.\n     */\n    DataType[DataType[\"UnicodeString\"] = 0] = \"UnicodeString\";\n    /**\n     * BYTE array. The type of data is implementation-specific.\n     */\n    DataType[DataType[\"ByteArray\"] = 1] = \"ByteArray\";\n    /**\n     * BOOL. The data is 2 bytes long and should be interpreted as a 16-bit unsigned integer. Only 0x0000 or 0x0001 are permitted values.\n     */\n    DataType[DataType[\"Bool\"] = 2] = \"Bool\";\n    /**\n     * DWORD. The data is 4 bytes long and should be interpreted as a 32-bit unsigned integer.\n     */\n    DataType[DataType[\"DWord\"] = 3] = \"DWord\";\n    /**\n     * QWORD. The data is 8 bytes long and should be interpreted as a 64-bit unsigned integer.\n     */\n    DataType[DataType[\"QWord\"] = 4] = \"QWord\";\n    /**\n     * WORD. The data is 2 bytes long and should be interpreted as a 16-bit unsigned integer.\n     */\n    DataType[DataType[\"Word\"] = 5] = \"Word\";\n})(DataType = exports.DataType || (exports.DataType = {}));\n/**\n * Token for: 3. ASF top-level Header Object\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3\n */\nexports.TopLevelHeaderObjectToken = {\n    len: 30,\n    get: (buf, off) => {\n        return {\n            objectId: GUID_1.default.fromBin(new Token.BufferType(16).get(buf, off)),\n            objectSize: Number(Token.UINT64_LE.get(buf, off + 16)),\n            numberOfHeaderObjects: Token.UINT32_LE.get(buf, off + 24)\n            // Reserved: 2 bytes\n        };\n    }\n};\n/**\n * Token for: 3.1 Header Object (mandatory, one only)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_1\n */\nexports.HeaderObjectToken = {\n    len: 24,\n    get: (buf, off) => {\n        return {\n            objectId: GUID_1.default.fromBin(new Token.BufferType(16).get(buf, off)),\n            objectSize: Number(Token.UINT64_LE.get(buf, off + 16))\n        };\n    }\n};\nclass State {\n    constructor(header) {\n        this.len = Number(header.objectSize) - exports.HeaderObjectToken.len;\n    }\n    postProcessTag(tags, name, valueType, data) {\n        if (name === 'WM/Picture') {\n            tags.push({ id: name, value: WmPictureToken.fromBuffer(data) });\n        }\n        else {\n            const parseAttr = AsfUtil_1.AsfUtil.getParserForAttr(valueType);\n            if (!parseAttr) {\n                throw new Error('unexpected value headerType: ' + valueType);\n            }\n            tags.push({ id: name, value: parseAttr(data) });\n        }\n    }\n}\nexports.State = State;\n// ToDo: use ignore type\nclass IgnoreObjectState extends State {\n    constructor(header) {\n        super(header);\n    }\n    get(buf, off) {\n        return null;\n    }\n}\nexports.IgnoreObjectState = IgnoreObjectState;\n/**\n * Token for: 3.2: File Properties Object (mandatory, one only)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_2\n */\nclass FilePropertiesObject extends State {\n    constructor(header) {\n        super(header);\n    }\n    get(buf, off) {\n        return {\n            fileId: GUID_1.default.fromBin(buf, off),\n            fileSize: Token.UINT64_LE.get(buf, off + 16),\n            creationDate: Token.UINT64_LE.get(buf, off + 24),\n            dataPacketsCount: Token.UINT64_LE.get(buf, off + 32),\n            playDuration: Token.UINT64_LE.get(buf, off + 40),\n            sendDuration: Token.UINT64_LE.get(buf, off + 48),\n            preroll: Token.UINT64_LE.get(buf, off + 56),\n            flags: {\n                broadcast: util.getBit(buf, off + 64, 24),\n                seekable: util.getBit(buf, off + 64, 25)\n            },\n            // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),\n            minimumDataPacketSize: Token.UINT32_LE.get(buf, off + 68),\n            maximumDataPacketSize: Token.UINT32_LE.get(buf, off + 72),\n            maximumBitrate: Token.UINT32_LE.get(buf, off + 76)\n        };\n    }\n}\nFilePropertiesObject.guid = GUID_1.default.FilePropertiesObject;\nexports.FilePropertiesObject = FilePropertiesObject;\n/**\n * Token for: 3.3 Stream Properties Object (mandatory, one per stream)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_3\n */\nclass StreamPropertiesObject extends State {\n    constructor(header) {\n        super(header);\n    }\n    get(buf, off) {\n        return {\n            streamType: GUID_1.default.decodeMediaType(GUID_1.default.fromBin(buf, off)),\n            errorCorrectionType: GUID_1.default.fromBin(buf, off + 8)\n            // ToDo\n        };\n    }\n}\nStreamPropertiesObject.guid = GUID_1.default.StreamPropertiesObject;\nexports.StreamPropertiesObject = StreamPropertiesObject;\n/**\n * 3.4: Header Extension Object (mandatory, one only)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_4\n */\nclass HeaderExtensionObject {\n    constructor() {\n        this.len = 22;\n    }\n    get(buf, off) {\n        return {\n            reserved1: GUID_1.default.fromBin(buf, off),\n            reserved2: buf.readUInt16LE(off + 16),\n            extensionDataSize: buf.readUInt32LE(off + 18)\n        };\n    }\n}\nHeaderExtensionObject.guid = GUID_1.default.HeaderExtensionObject;\nexports.HeaderExtensionObject = HeaderExtensionObject;\n/**\n * 3.5: The Codec List Object provides user-friendly information about the codecs and formats used to encode the content found in the ASF file.\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_5\n */\nconst CodecListObjectHeader = {\n    len: 20,\n    get: (buf, off) => {\n        return {\n            entryCount: buf.readUInt16LE(off + 16)\n        };\n    }\n};\nasync function readString(tokenizer) {\n    const length = await tokenizer.readNumber(Token.UINT16_LE);\n    return (await tokenizer.readToken(new Token.StringType(length * 2, 'utf16le'))).replace('\\0', '');\n}\n/**\n * 3.5: Read the Codec-List-Object, which provides user-friendly information about the codecs and formats used to encode the content found in the ASF file.\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_5\n */\nasync function readCodecEntries(tokenizer) {\n    const codecHeader = await tokenizer.readToken(CodecListObjectHeader);\n    const entries = [];\n    for (let i = 0; i < codecHeader.entryCount; ++i) {\n        entries.push(await readCodecEntry(tokenizer));\n    }\n    return entries;\n}\nexports.readCodecEntries = readCodecEntries;\nasync function readInformation(tokenizer) {\n    const length = await tokenizer.readNumber(Token.UINT16_LE);\n    const buf = Buffer.alloc(length);\n    await tokenizer.readBuffer(buf);\n    return buf;\n}\n/**\n * Read Codec-Entries\n * @param tokenizer\n */\nasync function readCodecEntry(tokenizer) {\n    const type = await tokenizer.readNumber(Token.UINT16_LE);\n    return {\n        type: {\n            videoCodec: (type & 0x0001) === 0x0001,\n            audioCodec: (type & 0x0002) === 0x0002\n        },\n        codecName: await readString(tokenizer),\n        description: await readString(tokenizer),\n        information: await readInformation(tokenizer)\n    };\n}\n/**\n * 3.10 Content Description Object (optional, one only)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_10\n */\nclass ContentDescriptionObjectState extends State {\n    constructor(header) {\n        super(header);\n    }\n    get(buf, off) {\n        const tags = [];\n        let pos = off + 10;\n        for (let i = 0; i < ContentDescriptionObjectState.contentDescTags.length; ++i) {\n            const length = buf.readUInt16LE(off + i * 2);\n            if (length > 0) {\n                const tagName = ContentDescriptionObjectState.contentDescTags[i];\n                const end = pos + length;\n                tags.push({ id: tagName, value: AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, end)) });\n                pos = end;\n            }\n        }\n        return tags;\n    }\n}\nContentDescriptionObjectState.guid = GUID_1.default.ContentDescriptionObject;\nContentDescriptionObjectState.contentDescTags = ['Title', 'Author', 'Copyright', 'Description', 'Rating'];\nexports.ContentDescriptionObjectState = ContentDescriptionObjectState;\n/**\n * 3.11 Extended Content Description Object (optional, one only)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/03_asf_top_level_header_object.html#3_11\n */\nclass ExtendedContentDescriptionObjectState extends State {\n    constructor(header) {\n        super(header);\n    }\n    get(buf, off) {\n        const tags = [];\n        const attrCount = buf.readUInt16LE(off);\n        let pos = off + 2;\n        for (let i = 0; i < attrCount; i += 1) {\n            const nameLen = buf.readUInt16LE(pos);\n            pos += 2;\n            const name = AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, pos + nameLen));\n            pos += nameLen;\n            const valueType = buf.readUInt16LE(pos);\n            pos += 2;\n            const valueLen = buf.readUInt16LE(pos);\n            pos += 2;\n            const value = buf.slice(pos, pos + valueLen);\n            pos += valueLen;\n            this.postProcessTag(tags, name, valueType, value);\n        }\n        return tags;\n    }\n}\nExtendedContentDescriptionObjectState.guid = GUID_1.default.ExtendedContentDescriptionObject;\nexports.ExtendedContentDescriptionObjectState = ExtendedContentDescriptionObjectState;\n/**\n * 4.1 Extended Stream Properties Object (optional, 1 per media stream)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/04_objects_in_the_asf_header_extension_object.html#4_1\n */\nclass ExtendedStreamPropertiesObjectState extends State {\n    constructor(header) {\n        super(header);\n    }\n    get(buf, off) {\n        return {\n            startTime: Token.UINT64_LE.get(buf, off),\n            endTime: Token.UINT64_LE.get(buf, off + 8),\n            dataBitrate: buf.readInt32LE(off + 12),\n            bufferSize: buf.readInt32LE(off + 16),\n            initialBufferFullness: buf.readInt32LE(off + 20),\n            alternateDataBitrate: buf.readInt32LE(off + 24),\n            alternateBufferSize: buf.readInt32LE(off + 28),\n            alternateInitialBufferFullness: buf.readInt32LE(off + 32),\n            maximumObjectSize: buf.readInt32LE(off + 36),\n            flags: {\n                reliableFlag: util.getBit(buf, off + 40, 0),\n                seekableFlag: util.getBit(buf, off + 40, 1),\n                resendLiveCleanpointsFlag: util.getBit(buf, off + 40, 2)\n            },\n            // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),\n            streamNumber: buf.readInt16LE(off + 42),\n            streamLanguageId: buf.readInt16LE(off + 44),\n            averageTimePerFrame: buf.readInt32LE(off + 52),\n            streamNameCount: buf.readInt32LE(off + 54),\n            payloadExtensionSystems: buf.readInt32LE(off + 56),\n            streamNames: [],\n            streamPropertiesObject: null\n        };\n    }\n}\nExtendedStreamPropertiesObjectState.guid = GUID_1.default.ExtendedStreamPropertiesObject;\nexports.ExtendedStreamPropertiesObjectState = ExtendedStreamPropertiesObjectState;\n/**\n * 4.7  Metadata Object (optional, 0 or 1)\n * Ref: http://drang.s4.xrea.com/program/tips/id3tag/wmp/04_objects_in_the_asf_header_extension_object.html#4_7\n */\nclass MetadataObjectState extends State {\n    constructor(header) {\n        super(header);\n    }\n    get(uint8Array, off) {\n        const tags = [];\n        const buf = Buffer.from(uint8Array);\n        const descriptionRecordsCount = buf.readUInt16LE(off);\n        let pos = off + 2;\n        for (let i = 0; i < descriptionRecordsCount; i += 1) {\n            pos += 4;\n            const nameLen = buf.readUInt16LE(pos);\n            pos += 2;\n            const dataType = buf.readUInt16LE(pos);\n            pos += 2;\n            const dataLen = buf.readUInt32LE(pos);\n            pos += 4;\n            const name = AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, pos + nameLen));\n            pos += nameLen;\n            const data = buf.slice(pos, pos + dataLen);\n            pos += dataLen;\n            this.postProcessTag(tags, name, dataType, data);\n        }\n        return tags;\n    }\n}\nMetadataObjectState.guid = GUID_1.default.MetadataObject;\nexports.MetadataObjectState = MetadataObjectState;\n// 4.8\tMetadata Library Object (optional, 0 or 1)\nclass MetadataLibraryObjectState extends MetadataObjectState {\n    constructor(header) {\n        super(header);\n    }\n}\nMetadataLibraryObjectState.guid = GUID_1.default.MetadataLibraryObject;\nexports.MetadataLibraryObjectState = MetadataLibraryObjectState;\n/**\n * Ref: https://msdn.microsoft.com/en-us/library/windows/desktop/dd757977(v=vs.85).aspx\n */\nclass WmPictureToken {\n    static fromBase64(base64str) {\n        return this.fromBuffer(Buffer.from(base64str, 'base64'));\n    }\n    static fromBuffer(buffer) {\n        const pic = new WmPictureToken(buffer.length);\n        return pic.get(buffer, 0);\n    }\n    constructor(len) {\n        this.len = len;\n    }\n    get(buffer, offset) {\n        const typeId = buffer.readUInt8(offset++);\n        const size = buffer.readInt32LE(offset);\n        let index = 5;\n        while (buffer.readUInt16BE(index) !== 0) {\n            index += 2;\n        }\n        const format = buffer.slice(5, index).toString('utf16le');\n        while (buffer.readUInt16BE(index) !== 0) {\n            index += 2;\n        }\n        const description = buffer.slice(5, index).toString('utf16le');\n        return {\n            type: ID3v2Token_1.AttachedPictureType[typeId],\n            format,\n            description,\n            size,\n            data: buffer.slice(index + 4)\n        };\n    }\n}\nexports.WmPictureToken = WmPictureToken;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYXNmL0FzZk9iamVjdC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxrQ0FBa0MsR0FBRywyQkFBMkIsR0FBRywyQ0FBMkMsR0FBRyw2Q0FBNkMsR0FBRyxxQ0FBcUMsR0FBRyx3QkFBd0IsR0FBRyw2QkFBNkIsR0FBRyw4QkFBOEIsR0FBRyw0QkFBNEIsR0FBRyx5QkFBeUIsR0FBRyxhQUFhLEdBQUcseUJBQXlCLEdBQUcsaUNBQWlDLEdBQUcsZ0JBQWdCO0FBQ3pkLGFBQWEsbUJBQU8sQ0FBQyw0RkFBZ0I7QUFDckMsY0FBYyxtQkFBTyxDQUFDLGdGQUFhO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyxpRkFBUTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyx1RkFBVztBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyxzR0FBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDLGdCQUFnQixLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrREFBa0Q7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBEQUEwRDtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2RUFBNkU7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9hc2YvQXNmT2JqZWN0LmpzPzMxNzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBBU0YgT2JqZWN0c1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XbVBpY3R1cmVUb2tlbiA9IGV4cG9ydHMuTWV0YWRhdGFMaWJyYXJ5T2JqZWN0U3RhdGUgPSBleHBvcnRzLk1ldGFkYXRhT2JqZWN0U3RhdGUgPSBleHBvcnRzLkV4dGVuZGVkU3RyZWFtUHJvcGVydGllc09iamVjdFN0YXRlID0gZXhwb3J0cy5FeHRlbmRlZENvbnRlbnREZXNjcmlwdGlvbk9iamVjdFN0YXRlID0gZXhwb3J0cy5Db250ZW50RGVzY3JpcHRpb25PYmplY3RTdGF0ZSA9IGV4cG9ydHMucmVhZENvZGVjRW50cmllcyA9IGV4cG9ydHMuSGVhZGVyRXh0ZW5zaW9uT2JqZWN0ID0gZXhwb3J0cy5TdHJlYW1Qcm9wZXJ0aWVzT2JqZWN0ID0gZXhwb3J0cy5GaWxlUHJvcGVydGllc09iamVjdCA9IGV4cG9ydHMuSWdub3JlT2JqZWN0U3RhdGUgPSBleHBvcnRzLlN0YXRlID0gZXhwb3J0cy5IZWFkZXJPYmplY3RUb2tlbiA9IGV4cG9ydHMuVG9wTGV2ZWxIZWFkZXJPYmplY3RUb2tlbiA9IGV4cG9ydHMuRGF0YVR5cGUgPSB2b2lkIDA7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcIi4uL2NvbW1vbi9VdGlsXCIpO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBHVUlEXzEgPSByZXF1aXJlKFwiLi9HVUlEXCIpO1xuY29uc3QgQXNmVXRpbF8xID0gcmVxdWlyZShcIi4vQXNmVXRpbFwiKTtcbmNvbnN0IElEM3YyVG9rZW5fMSA9IHJlcXVpcmUoXCIuLi9pZDN2Mi9JRDN2MlRva2VuXCIpO1xuLyoqXG4gKiBEYXRhIFR5cGU6IFNwZWNpZmllcyB0aGUgdHlwZSBvZiBpbmZvcm1hdGlvbiBiZWluZyBzdG9yZWQuIFRoZSBmb2xsb3dpbmcgdmFsdWVzIGFyZSByZWNvZ25pemVkLlxuICovXG52YXIgRGF0YVR5cGU7XG4oZnVuY3Rpb24gKERhdGFUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVW5pY29kZSBzdHJpbmcuIFRoZSBkYXRhIGNvbnNpc3RzIG9mIGEgc2VxdWVuY2Ugb2YgVW5pY29kZSBjaGFyYWN0ZXJzLlxuICAgICAqL1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiVW5pY29kZVN0cmluZ1wiXSA9IDBdID0gXCJVbmljb2RlU3RyaW5nXCI7XG4gICAgLyoqXG4gICAgICogQllURSBhcnJheS4gVGhlIHR5cGUgb2YgZGF0YSBpcyBpbXBsZW1lbnRhdGlvbi1zcGVjaWZpYy5cbiAgICAgKi9cbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkJ5dGVBcnJheVwiXSA9IDFdID0gXCJCeXRlQXJyYXlcIjtcbiAgICAvKipcbiAgICAgKiBCT09MLiBUaGUgZGF0YSBpcyAyIGJ5dGVzIGxvbmcgYW5kIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBhIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBPbmx5IDB4MDAwMCBvciAweDAwMDEgYXJlIHBlcm1pdHRlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJCb29sXCJdID0gMl0gPSBcIkJvb2xcIjtcbiAgICAvKipcbiAgICAgKiBEV09SRC4gVGhlIGRhdGEgaXMgNCBieXRlcyBsb25nIGFuZCBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlci5cbiAgICAgKi9cbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIkRXb3JkXCJdID0gM10gPSBcIkRXb3JkXCI7XG4gICAgLyoqXG4gICAgICogUVdPUkQuIFRoZSBkYXRhIGlzIDggYnl0ZXMgbG9uZyBhbmQgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGEgNjQtYml0IHVuc2lnbmVkIGludGVnZXIuXG4gICAgICovXG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJRV29yZFwiXSA9IDRdID0gXCJRV29yZFwiO1xuICAgIC8qKlxuICAgICAqIFdPUkQuIFRoZSBkYXRhIGlzIDIgYnl0ZXMgbG9uZyBhbmQgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGEgMTYtYml0IHVuc2lnbmVkIGludGVnZXIuXG4gICAgICovXG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJXb3JkXCJdID0gNV0gPSBcIldvcmRcIjtcbn0pKERhdGFUeXBlID0gZXhwb3J0cy5EYXRhVHlwZSB8fCAoZXhwb3J0cy5EYXRhVHlwZSA9IHt9KSk7XG4vKipcbiAqIFRva2VuIGZvcjogMy4gQVNGIHRvcC1sZXZlbCBIZWFkZXIgT2JqZWN0XG4gKiBSZWY6IGh0dHA6Ly9kcmFuZy5zNC54cmVhLmNvbS9wcm9ncmFtL3RpcHMvaWQzdGFnL3dtcC8wM19hc2ZfdG9wX2xldmVsX2hlYWRlcl9vYmplY3QuaHRtbCMzXG4gKi9cbmV4cG9ydHMuVG9wTGV2ZWxIZWFkZXJPYmplY3RUb2tlbiA9IHtcbiAgICBsZW46IDMwLFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvYmplY3RJZDogR1VJRF8xLmRlZmF1bHQuZnJvbUJpbihuZXcgVG9rZW4uQnVmZmVyVHlwZSgxNikuZ2V0KGJ1Ziwgb2ZmKSksXG4gICAgICAgICAgICBvYmplY3RTaXplOiBOdW1iZXIoVG9rZW4uVUlOVDY0X0xFLmdldChidWYsIG9mZiArIDE2KSksXG4gICAgICAgICAgICBudW1iZXJPZkhlYWRlck9iamVjdHM6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAyNClcbiAgICAgICAgICAgIC8vIFJlc2VydmVkOiAyIGJ5dGVzXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogVG9rZW4gZm9yOiAzLjEgSGVhZGVyIE9iamVjdCAobWFuZGF0b3J5LCBvbmUgb25seSlcbiAqIFJlZjogaHR0cDovL2RyYW5nLnM0LnhyZWEuY29tL3Byb2dyYW0vdGlwcy9pZDN0YWcvd21wLzAzX2FzZl90b3BfbGV2ZWxfaGVhZGVyX29iamVjdC5odG1sIzNfMVxuICovXG5leHBvcnRzLkhlYWRlck9iamVjdFRva2VuID0ge1xuICAgIGxlbjogMjQsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9iamVjdElkOiBHVUlEXzEuZGVmYXVsdC5mcm9tQmluKG5ldyBUb2tlbi5CdWZmZXJUeXBlKDE2KS5nZXQoYnVmLCBvZmYpKSxcbiAgICAgICAgICAgIG9iamVjdFNpemU6IE51bWJlcihUb2tlbi5VSU5UNjRfTEUuZ2V0KGJ1Ziwgb2ZmICsgMTYpKVxuICAgICAgICB9O1xuICAgIH1cbn07XG5jbGFzcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoaGVhZGVyKSB7XG4gICAgICAgIHRoaXMubGVuID0gTnVtYmVyKGhlYWRlci5vYmplY3RTaXplKSAtIGV4cG9ydHMuSGVhZGVyT2JqZWN0VG9rZW4ubGVuO1xuICAgIH1cbiAgICBwb3N0UHJvY2Vzc1RhZyh0YWdzLCBuYW1lLCB2YWx1ZVR5cGUsIGRhdGEpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdXTS9QaWN0dXJlJykge1xuICAgICAgICAgICAgdGFncy5wdXNoKHsgaWQ6IG5hbWUsIHZhbHVlOiBXbVBpY3R1cmVUb2tlbi5mcm9tQnVmZmVyKGRhdGEpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VBdHRyID0gQXNmVXRpbF8xLkFzZlV0aWwuZ2V0UGFyc2VyRm9yQXR0cih2YWx1ZVR5cGUpO1xuICAgICAgICAgICAgaWYgKCFwYXJzZUF0dHIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgdmFsdWUgaGVhZGVyVHlwZTogJyArIHZhbHVlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWdzLnB1c2goeyBpZDogbmFtZSwgdmFsdWU6IHBhcnNlQXR0cihkYXRhKSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU3RhdGUgPSBTdGF0ZTtcbi8vIFRvRG86IHVzZSBpZ25vcmUgdHlwZVxuY2xhc3MgSWdub3JlT2JqZWN0U3RhdGUgZXh0ZW5kcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoaGVhZGVyKSB7XG4gICAgICAgIHN1cGVyKGhlYWRlcik7XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLklnbm9yZU9iamVjdFN0YXRlID0gSWdub3JlT2JqZWN0U3RhdGU7XG4vKipcbiAqIFRva2VuIGZvcjogMy4yOiBGaWxlIFByb3BlcnRpZXMgT2JqZWN0IChtYW5kYXRvcnksIG9uZSBvbmx5KVxuICogUmVmOiBodHRwOi8vZHJhbmcuczQueHJlYS5jb20vcHJvZ3JhbS90aXBzL2lkM3RhZy93bXAvMDNfYXNmX3RvcF9sZXZlbF9oZWFkZXJfb2JqZWN0Lmh0bWwjM18yXG4gKi9cbmNsYXNzIEZpbGVQcm9wZXJ0aWVzT2JqZWN0IGV4dGVuZHMgU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGhlYWRlcikge1xuICAgICAgICBzdXBlcihoZWFkZXIpO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpbGVJZDogR1VJRF8xLmRlZmF1bHQuZnJvbUJpbihidWYsIG9mZiksXG4gICAgICAgICAgICBmaWxlU2l6ZTogVG9rZW4uVUlOVDY0X0xFLmdldChidWYsIG9mZiArIDE2KSxcbiAgICAgICAgICAgIGNyZWF0aW9uRGF0ZTogVG9rZW4uVUlOVDY0X0xFLmdldChidWYsIG9mZiArIDI0KSxcbiAgICAgICAgICAgIGRhdGFQYWNrZXRzQ291bnQ6IFRva2VuLlVJTlQ2NF9MRS5nZXQoYnVmLCBvZmYgKyAzMiksXG4gICAgICAgICAgICBwbGF5RHVyYXRpb246IFRva2VuLlVJTlQ2NF9MRS5nZXQoYnVmLCBvZmYgKyA0MCksXG4gICAgICAgICAgICBzZW5kRHVyYXRpb246IFRva2VuLlVJTlQ2NF9MRS5nZXQoYnVmLCBvZmYgKyA0OCksXG4gICAgICAgICAgICBwcmVyb2xsOiBUb2tlbi5VSU5UNjRfTEUuZ2V0KGJ1Ziwgb2ZmICsgNTYpLFxuICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgICBicm9hZGNhc3Q6IHV0aWwuZ2V0Qml0KGJ1Ziwgb2ZmICsgNjQsIDI0KSxcbiAgICAgICAgICAgICAgICBzZWVrYWJsZTogdXRpbC5nZXRCaXQoYnVmLCBvZmYgKyA2NCwgMjUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZmxhZ3NOdW1lcmljOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgNjQpLFxuICAgICAgICAgICAgbWluaW11bURhdGFQYWNrZXRTaXplOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgNjgpLFxuICAgICAgICAgICAgbWF4aW11bURhdGFQYWNrZXRTaXplOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgNzIpLFxuICAgICAgICAgICAgbWF4aW11bUJpdHJhdGU6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyA3NilcbiAgICAgICAgfTtcbiAgICB9XG59XG5GaWxlUHJvcGVydGllc09iamVjdC5ndWlkID0gR1VJRF8xLmRlZmF1bHQuRmlsZVByb3BlcnRpZXNPYmplY3Q7XG5leHBvcnRzLkZpbGVQcm9wZXJ0aWVzT2JqZWN0ID0gRmlsZVByb3BlcnRpZXNPYmplY3Q7XG4vKipcbiAqIFRva2VuIGZvcjogMy4zIFN0cmVhbSBQcm9wZXJ0aWVzIE9iamVjdCAobWFuZGF0b3J5LCBvbmUgcGVyIHN0cmVhbSlcbiAqIFJlZjogaHR0cDovL2RyYW5nLnM0LnhyZWEuY29tL3Byb2dyYW0vdGlwcy9pZDN0YWcvd21wLzAzX2FzZl90b3BfbGV2ZWxfaGVhZGVyX29iamVjdC5odG1sIzNfM1xuICovXG5jbGFzcyBTdHJlYW1Qcm9wZXJ0aWVzT2JqZWN0IGV4dGVuZHMgU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGhlYWRlcikge1xuICAgICAgICBzdXBlcihoZWFkZXIpO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0cmVhbVR5cGU6IEdVSURfMS5kZWZhdWx0LmRlY29kZU1lZGlhVHlwZShHVUlEXzEuZGVmYXVsdC5mcm9tQmluKGJ1Ziwgb2ZmKSksXG4gICAgICAgICAgICBlcnJvckNvcnJlY3Rpb25UeXBlOiBHVUlEXzEuZGVmYXVsdC5mcm9tQmluKGJ1Ziwgb2ZmICsgOClcbiAgICAgICAgICAgIC8vIFRvRG9cbiAgICAgICAgfTtcbiAgICB9XG59XG5TdHJlYW1Qcm9wZXJ0aWVzT2JqZWN0Lmd1aWQgPSBHVUlEXzEuZGVmYXVsdC5TdHJlYW1Qcm9wZXJ0aWVzT2JqZWN0O1xuZXhwb3J0cy5TdHJlYW1Qcm9wZXJ0aWVzT2JqZWN0ID0gU3RyZWFtUHJvcGVydGllc09iamVjdDtcbi8qKlxuICogMy40OiBIZWFkZXIgRXh0ZW5zaW9uIE9iamVjdCAobWFuZGF0b3J5LCBvbmUgb25seSlcbiAqIFJlZjogaHR0cDovL2RyYW5nLnM0LnhyZWEuY29tL3Byb2dyYW0vdGlwcy9pZDN0YWcvd21wLzAzX2FzZl90b3BfbGV2ZWxfaGVhZGVyX29iamVjdC5odG1sIzNfNFxuICovXG5jbGFzcyBIZWFkZXJFeHRlbnNpb25PYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxlbiA9IDIyO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc2VydmVkMTogR1VJRF8xLmRlZmF1bHQuZnJvbUJpbihidWYsIG9mZiksXG4gICAgICAgICAgICByZXNlcnZlZDI6IGJ1Zi5yZWFkVUludDE2TEUob2ZmICsgMTYpLFxuICAgICAgICAgICAgZXh0ZW5zaW9uRGF0YVNpemU6IGJ1Zi5yZWFkVUludDMyTEUob2ZmICsgMTgpXG4gICAgICAgIH07XG4gICAgfVxufVxuSGVhZGVyRXh0ZW5zaW9uT2JqZWN0Lmd1aWQgPSBHVUlEXzEuZGVmYXVsdC5IZWFkZXJFeHRlbnNpb25PYmplY3Q7XG5leHBvcnRzLkhlYWRlckV4dGVuc2lvbk9iamVjdCA9IEhlYWRlckV4dGVuc2lvbk9iamVjdDtcbi8qKlxuICogMy41OiBUaGUgQ29kZWMgTGlzdCBPYmplY3QgcHJvdmlkZXMgdXNlci1mcmllbmRseSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY29kZWNzIGFuZCBmb3JtYXRzIHVzZWQgdG8gZW5jb2RlIHRoZSBjb250ZW50IGZvdW5kIGluIHRoZSBBU0YgZmlsZS5cbiAqIFJlZjogaHR0cDovL2RyYW5nLnM0LnhyZWEuY29tL3Byb2dyYW0vdGlwcy9pZDN0YWcvd21wLzAzX2FzZl90b3BfbGV2ZWxfaGVhZGVyX29iamVjdC5odG1sIzNfNVxuICovXG5jb25zdCBDb2RlY0xpc3RPYmplY3RIZWFkZXIgPSB7XG4gICAgbGVuOiAyMCxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW50cnlDb3VudDogYnVmLnJlYWRVSW50MTZMRShvZmYgKyAxNilcbiAgICAgICAgfTtcbiAgICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gcmVhZFN0cmluZyh0b2tlbml6ZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBhd2FpdCB0b2tlbml6ZXIucmVhZE51bWJlcihUb2tlbi5VSU5UMTZfTEUpO1xuICAgIHJldHVybiAoYXdhaXQgdG9rZW5pemVyLnJlYWRUb2tlbihuZXcgVG9rZW4uU3RyaW5nVHlwZShsZW5ndGggKiAyLCAndXRmMTZsZScpKSkucmVwbGFjZSgnXFwwJywgJycpO1xufVxuLyoqXG4gKiAzLjU6IFJlYWQgdGhlIENvZGVjLUxpc3QtT2JqZWN0LCB3aGljaCBwcm92aWRlcyB1c2VyLWZyaWVuZGx5IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb2RlY3MgYW5kIGZvcm1hdHMgdXNlZCB0byBlbmNvZGUgdGhlIGNvbnRlbnQgZm91bmQgaW4gdGhlIEFTRiBmaWxlLlxuICogUmVmOiBodHRwOi8vZHJhbmcuczQueHJlYS5jb20vcHJvZ3JhbS90aXBzL2lkM3RhZy93bXAvMDNfYXNmX3RvcF9sZXZlbF9oZWFkZXJfb2JqZWN0Lmh0bWwjM181XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRDb2RlY0VudHJpZXModG9rZW5pemVyKSB7XG4gICAgY29uc3QgY29kZWNIZWFkZXIgPSBhd2FpdCB0b2tlbml6ZXIucmVhZFRva2VuKENvZGVjTGlzdE9iamVjdEhlYWRlcik7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZWNIZWFkZXIuZW50cnlDb3VudDsgKytpKSB7XG4gICAgICAgIGVudHJpZXMucHVzaChhd2FpdCByZWFkQ29kZWNFbnRyeSh0b2tlbml6ZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJpZXM7XG59XG5leHBvcnRzLnJlYWRDb2RlY0VudHJpZXMgPSByZWFkQ29kZWNFbnRyaWVzO1xuYXN5bmMgZnVuY3Rpb24gcmVhZEluZm9ybWF0aW9uKHRva2VuaXplcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGF3YWl0IHRva2VuaXplci5yZWFkTnVtYmVyKFRva2VuLlVJTlQxNl9MRSk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGxlbmd0aCk7XG4gICAgYXdhaXQgdG9rZW5pemVyLnJlYWRCdWZmZXIoYnVmKTtcbiAgICByZXR1cm4gYnVmO1xufVxuLyoqXG4gKiBSZWFkIENvZGVjLUVudHJpZXNcbiAqIEBwYXJhbSB0b2tlbml6ZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVhZENvZGVjRW50cnkodG9rZW5pemVyKSB7XG4gICAgY29uc3QgdHlwZSA9IGF3YWl0IHRva2VuaXplci5yZWFkTnVtYmVyKFRva2VuLlVJTlQxNl9MRSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgdmlkZW9Db2RlYzogKHR5cGUgJiAweDAwMDEpID09PSAweDAwMDEsXG4gICAgICAgICAgICBhdWRpb0NvZGVjOiAodHlwZSAmIDB4MDAwMikgPT09IDB4MDAwMlxuICAgICAgICB9LFxuICAgICAgICBjb2RlY05hbWU6IGF3YWl0IHJlYWRTdHJpbmcodG9rZW5pemVyKSxcbiAgICAgICAgZGVzY3JpcHRpb246IGF3YWl0IHJlYWRTdHJpbmcodG9rZW5pemVyKSxcbiAgICAgICAgaW5mb3JtYXRpb246IGF3YWl0IHJlYWRJbmZvcm1hdGlvbih0b2tlbml6ZXIpXG4gICAgfTtcbn1cbi8qKlxuICogMy4xMCBDb250ZW50IERlc2NyaXB0aW9uIE9iamVjdCAob3B0aW9uYWwsIG9uZSBvbmx5KVxuICogUmVmOiBodHRwOi8vZHJhbmcuczQueHJlYS5jb20vcHJvZ3JhbS90aXBzL2lkM3RhZy93bXAvMDNfYXNmX3RvcF9sZXZlbF9oZWFkZXJfb2JqZWN0Lmh0bWwjM18xMFxuICovXG5jbGFzcyBDb250ZW50RGVzY3JpcHRpb25PYmplY3RTdGF0ZSBleHRlbmRzIFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihoZWFkZXIpIHtcbiAgICAgICAgc3VwZXIoaGVhZGVyKTtcbiAgICB9XG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIGNvbnN0IHRhZ3MgPSBbXTtcbiAgICAgICAgbGV0IHBvcyA9IG9mZiArIDEwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENvbnRlbnREZXNjcmlwdGlvbk9iamVjdFN0YXRlLmNvbnRlbnREZXNjVGFncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYnVmLnJlYWRVSW50MTZMRShvZmYgKyBpICogMik7XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSBDb250ZW50RGVzY3JpcHRpb25PYmplY3RTdGF0ZS5jb250ZW50RGVzY1RhZ3NbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gcG9zICsgbGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRhZ3MucHVzaCh7IGlkOiB0YWdOYW1lLCB2YWx1ZTogQXNmVXRpbF8xLkFzZlV0aWwucGFyc2VVbmljb2RlQXR0cihidWYuc2xpY2UocG9zLCBlbmQpKSB9KTtcbiAgICAgICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ3M7XG4gICAgfVxufVxuQ29udGVudERlc2NyaXB0aW9uT2JqZWN0U3RhdGUuZ3VpZCA9IEdVSURfMS5kZWZhdWx0LkNvbnRlbnREZXNjcmlwdGlvbk9iamVjdDtcbkNvbnRlbnREZXNjcmlwdGlvbk9iamVjdFN0YXRlLmNvbnRlbnREZXNjVGFncyA9IFsnVGl0bGUnLCAnQXV0aG9yJywgJ0NvcHlyaWdodCcsICdEZXNjcmlwdGlvbicsICdSYXRpbmcnXTtcbmV4cG9ydHMuQ29udGVudERlc2NyaXB0aW9uT2JqZWN0U3RhdGUgPSBDb250ZW50RGVzY3JpcHRpb25PYmplY3RTdGF0ZTtcbi8qKlxuICogMy4xMSBFeHRlbmRlZCBDb250ZW50IERlc2NyaXB0aW9uIE9iamVjdCAob3B0aW9uYWwsIG9uZSBvbmx5KVxuICogUmVmOiBodHRwOi8vZHJhbmcuczQueHJlYS5jb20vcHJvZ3JhbS90aXBzL2lkM3RhZy93bXAvMDNfYXNmX3RvcF9sZXZlbF9oZWFkZXJfb2JqZWN0Lmh0bWwjM18xMVxuICovXG5jbGFzcyBFeHRlbmRlZENvbnRlbnREZXNjcmlwdGlvbk9iamVjdFN0YXRlIGV4dGVuZHMgU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGhlYWRlcikge1xuICAgICAgICBzdXBlcihoZWFkZXIpO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgY29uc3QgdGFncyA9IFtdO1xuICAgICAgICBjb25zdCBhdHRyQ291bnQgPSBidWYucmVhZFVJbnQxNkxFKG9mZik7XG4gICAgICAgIGxldCBwb3MgPSBvZmYgKyAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJDb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lTGVuID0gYnVmLnJlYWRVSW50MTZMRShwb3MpO1xuICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gQXNmVXRpbF8xLkFzZlV0aWwucGFyc2VVbmljb2RlQXR0cihidWYuc2xpY2UocG9zLCBwb3MgKyBuYW1lTGVuKSk7XG4gICAgICAgICAgICBwb3MgKz0gbmFtZUxlbjtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGJ1Zi5yZWFkVUludDE2TEUocG9zKTtcbiAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSBidWYucmVhZFVJbnQxNkxFKHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYnVmLnNsaWNlKHBvcywgcG9zICsgdmFsdWVMZW4pO1xuICAgICAgICAgICAgcG9zICs9IHZhbHVlTGVuO1xuICAgICAgICAgICAgdGhpcy5wb3N0UHJvY2Vzc1RhZyh0YWdzLCBuYW1lLCB2YWx1ZVR5cGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFncztcbiAgICB9XG59XG5FeHRlbmRlZENvbnRlbnREZXNjcmlwdGlvbk9iamVjdFN0YXRlLmd1aWQgPSBHVUlEXzEuZGVmYXVsdC5FeHRlbmRlZENvbnRlbnREZXNjcmlwdGlvbk9iamVjdDtcbmV4cG9ydHMuRXh0ZW5kZWRDb250ZW50RGVzY3JpcHRpb25PYmplY3RTdGF0ZSA9IEV4dGVuZGVkQ29udGVudERlc2NyaXB0aW9uT2JqZWN0U3RhdGU7XG4vKipcbiAqIDQuMSBFeHRlbmRlZCBTdHJlYW0gUHJvcGVydGllcyBPYmplY3QgKG9wdGlvbmFsLCAxIHBlciBtZWRpYSBzdHJlYW0pXG4gKiBSZWY6IGh0dHA6Ly9kcmFuZy5zNC54cmVhLmNvbS9wcm9ncmFtL3RpcHMvaWQzdGFnL3dtcC8wNF9vYmplY3RzX2luX3RoZV9hc2ZfaGVhZGVyX2V4dGVuc2lvbl9vYmplY3QuaHRtbCM0XzFcbiAqL1xuY2xhc3MgRXh0ZW5kZWRTdHJlYW1Qcm9wZXJ0aWVzT2JqZWN0U3RhdGUgZXh0ZW5kcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoaGVhZGVyKSB7XG4gICAgICAgIHN1cGVyKGhlYWRlcik7XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnRUaW1lOiBUb2tlbi5VSU5UNjRfTEUuZ2V0KGJ1Ziwgb2ZmKSxcbiAgICAgICAgICAgIGVuZFRpbWU6IFRva2VuLlVJTlQ2NF9MRS5nZXQoYnVmLCBvZmYgKyA4KSxcbiAgICAgICAgICAgIGRhdGFCaXRyYXRlOiBidWYucmVhZEludDMyTEUob2ZmICsgMTIpLFxuICAgICAgICAgICAgYnVmZmVyU2l6ZTogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDE2KSxcbiAgICAgICAgICAgIGluaXRpYWxCdWZmZXJGdWxsbmVzczogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDIwKSxcbiAgICAgICAgICAgIGFsdGVybmF0ZURhdGFCaXRyYXRlOiBidWYucmVhZEludDMyTEUob2ZmICsgMjQpLFxuICAgICAgICAgICAgYWx0ZXJuYXRlQnVmZmVyU2l6ZTogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDI4KSxcbiAgICAgICAgICAgIGFsdGVybmF0ZUluaXRpYWxCdWZmZXJGdWxsbmVzczogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDMyKSxcbiAgICAgICAgICAgIG1heGltdW1PYmplY3RTaXplOiBidWYucmVhZEludDMyTEUob2ZmICsgMzYpLFxuICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgICByZWxpYWJsZUZsYWc6IHV0aWwuZ2V0Qml0KGJ1Ziwgb2ZmICsgNDAsIDApLFxuICAgICAgICAgICAgICAgIHNlZWthYmxlRmxhZzogdXRpbC5nZXRCaXQoYnVmLCBvZmYgKyA0MCwgMSksXG4gICAgICAgICAgICAgICAgcmVzZW5kTGl2ZUNsZWFucG9pbnRzRmxhZzogdXRpbC5nZXRCaXQoYnVmLCBvZmYgKyA0MCwgMilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBmbGFnc051bWVyaWM6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyA2NCksXG4gICAgICAgICAgICBzdHJlYW1OdW1iZXI6IGJ1Zi5yZWFkSW50MTZMRShvZmYgKyA0MiksXG4gICAgICAgICAgICBzdHJlYW1MYW5ndWFnZUlkOiBidWYucmVhZEludDE2TEUob2ZmICsgNDQpLFxuICAgICAgICAgICAgYXZlcmFnZVRpbWVQZXJGcmFtZTogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDUyKSxcbiAgICAgICAgICAgIHN0cmVhbU5hbWVDb3VudDogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDU0KSxcbiAgICAgICAgICAgIHBheWxvYWRFeHRlbnNpb25TeXN0ZW1zOiBidWYucmVhZEludDMyTEUob2ZmICsgNTYpLFxuICAgICAgICAgICAgc3RyZWFtTmFtZXM6IFtdLFxuICAgICAgICAgICAgc3RyZWFtUHJvcGVydGllc09iamVjdDogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbn1cbkV4dGVuZGVkU3RyZWFtUHJvcGVydGllc09iamVjdFN0YXRlLmd1aWQgPSBHVUlEXzEuZGVmYXVsdC5FeHRlbmRlZFN0cmVhbVByb3BlcnRpZXNPYmplY3Q7XG5leHBvcnRzLkV4dGVuZGVkU3RyZWFtUHJvcGVydGllc09iamVjdFN0YXRlID0gRXh0ZW5kZWRTdHJlYW1Qcm9wZXJ0aWVzT2JqZWN0U3RhdGU7XG4vKipcbiAqIDQuNyAgTWV0YWRhdGEgT2JqZWN0IChvcHRpb25hbCwgMCBvciAxKVxuICogUmVmOiBodHRwOi8vZHJhbmcuczQueHJlYS5jb20vcHJvZ3JhbS90aXBzL2lkM3RhZy93bXAvMDRfb2JqZWN0c19pbl90aGVfYXNmX2hlYWRlcl9leHRlbnNpb25fb2JqZWN0Lmh0bWwjNF83XG4gKi9cbmNsYXNzIE1ldGFkYXRhT2JqZWN0U3RhdGUgZXh0ZW5kcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoaGVhZGVyKSB7XG4gICAgICAgIHN1cGVyKGhlYWRlcik7XG4gICAgfVxuICAgIGdldCh1aW50OEFycmF5LCBvZmYpIHtcbiAgICAgICAgY29uc3QgdGFncyA9IFtdO1xuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbSh1aW50OEFycmF5KTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb25SZWNvcmRzQ291bnQgPSBidWYucmVhZFVJbnQxNkxFKG9mZik7XG4gICAgICAgIGxldCBwb3MgPSBvZmYgKyAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc2NyaXB0aW9uUmVjb3Jkc0NvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICAgIHBvcyArPSA0O1xuICAgICAgICAgICAgY29uc3QgbmFtZUxlbiA9IGJ1Zi5yZWFkVUludDE2TEUocG9zKTtcbiAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgY29uc3QgZGF0YVR5cGUgPSBidWYucmVhZFVJbnQxNkxFKHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFMZW4gPSBidWYucmVhZFVJbnQzMkxFKHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gNDtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBBc2ZVdGlsXzEuQXNmVXRpbC5wYXJzZVVuaWNvZGVBdHRyKGJ1Zi5zbGljZShwb3MsIHBvcyArIG5hbWVMZW4pKTtcbiAgICAgICAgICAgIHBvcyArPSBuYW1lTGVuO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGJ1Zi5zbGljZShwb3MsIHBvcyArIGRhdGFMZW4pO1xuICAgICAgICAgICAgcG9zICs9IGRhdGFMZW47XG4gICAgICAgICAgICB0aGlzLnBvc3RQcm9jZXNzVGFnKHRhZ3MsIG5hbWUsIGRhdGFUeXBlLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFncztcbiAgICB9XG59XG5NZXRhZGF0YU9iamVjdFN0YXRlLmd1aWQgPSBHVUlEXzEuZGVmYXVsdC5NZXRhZGF0YU9iamVjdDtcbmV4cG9ydHMuTWV0YWRhdGFPYmplY3RTdGF0ZSA9IE1ldGFkYXRhT2JqZWN0U3RhdGU7XG4vLyA0LjhcdE1ldGFkYXRhIExpYnJhcnkgT2JqZWN0IChvcHRpb25hbCwgMCBvciAxKVxuY2xhc3MgTWV0YWRhdGFMaWJyYXJ5T2JqZWN0U3RhdGUgZXh0ZW5kcyBNZXRhZGF0YU9iamVjdFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihoZWFkZXIpIHtcbiAgICAgICAgc3VwZXIoaGVhZGVyKTtcbiAgICB9XG59XG5NZXRhZGF0YUxpYnJhcnlPYmplY3RTdGF0ZS5ndWlkID0gR1VJRF8xLmRlZmF1bHQuTWV0YWRhdGFMaWJyYXJ5T2JqZWN0O1xuZXhwb3J0cy5NZXRhZGF0YUxpYnJhcnlPYmplY3RTdGF0ZSA9IE1ldGFkYXRhTGlicmFyeU9iamVjdFN0YXRlO1xuLyoqXG4gKiBSZWY6IGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2RkNzU3OTc3KHY9dnMuODUpLmFzcHhcbiAqL1xuY2xhc3MgV21QaWN0dXJlVG9rZW4ge1xuICAgIHN0YXRpYyBmcm9tQmFzZTY0KGJhc2U2NHN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tQnVmZmVyKEJ1ZmZlci5mcm9tKGJhc2U2NHN0ciwgJ2Jhc2U2NCcpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHBpYyA9IG5ldyBXbVBpY3R1cmVUb2tlbihidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHBpYy5nZXQoYnVmZmVyLCAwKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobGVuKSB7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICBnZXQoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgdHlwZUlkID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQrKyk7XG4gICAgICAgIGNvbnN0IHNpemUgPSBidWZmZXIucmVhZEludDMyTEUob2Zmc2V0KTtcbiAgICAgICAgbGV0IGluZGV4ID0gNTtcbiAgICAgICAgd2hpbGUgKGJ1ZmZlci5yZWFkVUludDE2QkUoaW5kZXgpICE9PSAwKSB7XG4gICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGJ1ZmZlci5zbGljZSg1LCBpbmRleCkudG9TdHJpbmcoJ3V0ZjE2bGUnKTtcbiAgICAgICAgd2hpbGUgKGJ1ZmZlci5yZWFkVUludDE2QkUoaW5kZXgpICE9PSAwKSB7XG4gICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gYnVmZmVyLnNsaWNlKDUsIGluZGV4KS50b1N0cmluZygndXRmMTZsZScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogSUQzdjJUb2tlbl8xLkF0dGFjaGVkUGljdHVyZVR5cGVbdHlwZUlkXSxcbiAgICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIGRhdGE6IGJ1ZmZlci5zbGljZShpbmRleCArIDQpXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5XbVBpY3R1cmVUb2tlbiA9IFdtUGljdHVyZVRva2VuO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/asf/AsfObject.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/asf/AsfParser.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/asf/AsfParser.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsfParser = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst type_1 = __webpack_require__(/*! ../type */ \"(app-pages-browser)/./node_modules/music-metadata/lib/type.js\");\nconst GUID_1 = __webpack_require__(/*! ./GUID */ \"(app-pages-browser)/./node_modules/music-metadata/lib/asf/GUID.js\");\nconst AsfObject = __webpack_require__(/*! ./AsfObject */ \"(app-pages-browser)/./node_modules/music-metadata/lib/asf/AsfObject.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:ASF');\nconst headerType = 'asf';\n/**\n * Windows Media Metadata Usage Guidelines\n * - Ref: https://msdn.microsoft.com/en-us/library/ms867702.aspx\n *\n * Ref:\n * - https://tools.ietf.org/html/draft-fleischman-asf-01\n * - https://hwiegman.home.xs4all.nl/fileformats/asf/ASF_Specification.pdf\n * - http://drang.s4.xrea.com/program/tips/id3tag/wmp/index.html\n * - https://msdn.microsoft.com/en-us/library/windows/desktop/ee663575(v=vs.85).aspx\n */\nclass AsfParser extends BasicParser_1.BasicParser {\n    async parse() {\n        const header = await this.tokenizer.readToken(AsfObject.TopLevelHeaderObjectToken);\n        if (!header.objectId.equals(GUID_1.default.HeaderObject)) {\n            throw new Error('expected asf header; but was not found; got: ' + header.objectId.str);\n        }\n        try {\n            await this.parseObjectHeader(header.numberOfHeaderObjects);\n        }\n        catch (err) {\n            debug('Error while parsing ASF: %s', err);\n        }\n    }\n    async parseObjectHeader(numberOfObjectHeaders) {\n        let tags;\n        do {\n            // Parse common header of the ASF Object (3.1)\n            const header = await this.tokenizer.readToken(AsfObject.HeaderObjectToken);\n            // Parse data part of the ASF Object\n            debug('header GUID=%s', header.objectId.str);\n            switch (header.objectId.str) {\n                case AsfObject.FilePropertiesObject.guid.str: // 3.2\n                    const fpo = await this.tokenizer.readToken(new AsfObject.FilePropertiesObject(header));\n                    this.metadata.setFormat('duration', Number(fpo.playDuration / BigInt(1000)) / 10000 - Number(fpo.preroll) / 1000);\n                    this.metadata.setFormat('bitrate', fpo.maximumBitrate);\n                    break;\n                case AsfObject.StreamPropertiesObject.guid.str: // 3.3\n                    const spo = await this.tokenizer.readToken(new AsfObject.StreamPropertiesObject(header));\n                    this.metadata.setFormat('container', 'ASF/' + spo.streamType);\n                    break;\n                case AsfObject.HeaderExtensionObject.guid.str: // 3.4\n                    const extHeader = await this.tokenizer.readToken(new AsfObject.HeaderExtensionObject());\n                    await this.parseExtensionObject(extHeader.extensionDataSize);\n                    break;\n                case AsfObject.ContentDescriptionObjectState.guid.str: // 3.10\n                    tags = await this.tokenizer.readToken(new AsfObject.ContentDescriptionObjectState(header));\n                    this.addTags(tags);\n                    break;\n                case AsfObject.ExtendedContentDescriptionObjectState.guid.str: // 3.11\n                    tags = await this.tokenizer.readToken(new AsfObject.ExtendedContentDescriptionObjectState(header));\n                    this.addTags(tags);\n                    break;\n                case GUID_1.default.CodecListObject.str:\n                    const codecs = await AsfObject.readCodecEntries(this.tokenizer);\n                    codecs.forEach(codec => {\n                        this.metadata.addStreamInfo({\n                            type: codec.type.videoCodec ? type_1.TrackType.video : type_1.TrackType.audio,\n                            codecName: codec.codecName\n                        });\n                    });\n                    const audioCodecs = codecs.filter(codec => codec.type.audioCodec).map(codec => codec.codecName).join('/');\n                    this.metadata.setFormat('codec', audioCodecs);\n                    break;\n                case GUID_1.default.StreamBitratePropertiesObject.str:\n                    // ToDo?\n                    await this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);\n                    break;\n                case GUID_1.default.PaddingObject.str:\n                    // ToDo: register bytes pad\n                    debug('Padding: %s bytes', header.objectSize - AsfObject.HeaderObjectToken.len);\n                    await this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);\n                    break;\n                default:\n                    this.metadata.addWarning('Ignore ASF-Object-GUID: ' + header.objectId.str);\n                    debug('Ignore ASF-Object-GUID: %s', header.objectId.str);\n                    await this.tokenizer.readToken(new AsfObject.IgnoreObjectState(header));\n            }\n        } while (--numberOfObjectHeaders);\n        // done\n    }\n    addTags(tags) {\n        tags.forEach(tag => {\n            this.metadata.addTag(headerType, tag.id, tag.value);\n        });\n    }\n    async parseExtensionObject(extensionSize) {\n        do {\n            // Parse common header of the ASF Object (3.1)\n            const header = await this.tokenizer.readToken(AsfObject.HeaderObjectToken);\n            const remaining = header.objectSize - AsfObject.HeaderObjectToken.len;\n            // Parse data part of the ASF Object\n            switch (header.objectId.str) {\n                case AsfObject.ExtendedStreamPropertiesObjectState.guid.str: // 4.1\n                    // ToDo: extended stream header properties are ignored\n                    await this.tokenizer.readToken(new AsfObject.ExtendedStreamPropertiesObjectState(header));\n                    break;\n                case AsfObject.MetadataObjectState.guid.str: // 4.7\n                    const moTags = await this.tokenizer.readToken(new AsfObject.MetadataObjectState(header));\n                    this.addTags(moTags);\n                    break;\n                case AsfObject.MetadataLibraryObjectState.guid.str: // 4.8\n                    const mlTags = await this.tokenizer.readToken(new AsfObject.MetadataLibraryObjectState(header));\n                    this.addTags(mlTags);\n                    break;\n                case GUID_1.default.PaddingObject.str:\n                    // ToDo: register bytes pad\n                    await this.tokenizer.ignore(remaining);\n                    break;\n                case GUID_1.default.CompatibilityObject.str:\n                    this.tokenizer.ignore(remaining);\n                    break;\n                case GUID_1.default.ASF_Index_Placeholder_Object.str:\n                    await this.tokenizer.ignore(remaining);\n                    break;\n                default:\n                    this.metadata.addWarning('Ignore ASF-Object-GUID: ' + header.objectId.str);\n                    // console.log(\"Ignore ASF-Object-GUID: %s\", header.objectId.str);\n                    await this.tokenizer.readToken(new AsfObject.IgnoreObjectState(header));\n                    break;\n            }\n            extensionSize -= header.objectSize;\n        } while (extensionSize > 0);\n    }\n}\nexports.AsfParser = AsfParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYXNmL0FzZlBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQU87QUFDL0IsZUFBZSxtQkFBTyxDQUFDLDhFQUFTO0FBQ2hDLGVBQWUsbUJBQU8sQ0FBQyxpRkFBUTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQywyRkFBYTtBQUN2QyxzQkFBc0IsbUJBQU8sQ0FBQywwR0FBdUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsbUJBQW1CO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FzZi9Bc2ZQYXJzZXIuanM/M2U1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNmUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IHR5cGVfMSA9IHJlcXVpcmUoXCIuLi90eXBlXCIpO1xuY29uc3QgR1VJRF8xID0gcmVxdWlyZShcIi4vR1VJRFwiKTtcbmNvbnN0IEFzZk9iamVjdCA9IHJlcXVpcmUoXCIuL0FzZk9iamVjdFwiKTtcbmNvbnN0IEJhc2ljUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0Jhc2ljUGFyc2VyXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbXVzaWMtbWV0YWRhdGE6cGFyc2VyOkFTRicpO1xuY29uc3QgaGVhZGVyVHlwZSA9ICdhc2YnO1xuLyoqXG4gKiBXaW5kb3dzIE1lZGlhIE1ldGFkYXRhIFVzYWdlIEd1aWRlbGluZXNcbiAqIC0gUmVmOiBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zODY3NzAyLmFzcHhcbiAqXG4gKiBSZWY6XG4gKiAtIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1mbGVpc2NobWFuLWFzZi0wMVxuICogLSBodHRwczovL2h3aWVnbWFuLmhvbWUueHM0YWxsLm5sL2ZpbGVmb3JtYXRzL2FzZi9BU0ZfU3BlY2lmaWNhdGlvbi5wZGZcbiAqIC0gaHR0cDovL2RyYW5nLnM0LnhyZWEuY29tL3Byb2dyYW0vdGlwcy9pZDN0YWcvd21wL2luZGV4Lmh0bWxcbiAqIC0gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvZWU2NjM1NzUodj12cy44NSkuYXNweFxuICovXG5jbGFzcyBBc2ZQYXJzZXIgZXh0ZW5kcyBCYXNpY1BhcnNlcl8xLkJhc2ljUGFyc2VyIHtcbiAgICBhc3luYyBwYXJzZSgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKEFzZk9iamVjdC5Ub3BMZXZlbEhlYWRlck9iamVjdFRva2VuKTtcbiAgICAgICAgaWYgKCFoZWFkZXIub2JqZWN0SWQuZXF1YWxzKEdVSURfMS5kZWZhdWx0LkhlYWRlck9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgYXNmIGhlYWRlcjsgYnV0IHdhcyBub3QgZm91bmQ7IGdvdDogJyArIGhlYWRlci5vYmplY3RJZC5zdHIpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBhcnNlT2JqZWN0SGVhZGVyKGhlYWRlci5udW1iZXJPZkhlYWRlck9iamVjdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRlYnVnKCdFcnJvciB3aGlsZSBwYXJzaW5nIEFTRjogJXMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlT2JqZWN0SGVhZGVyKG51bWJlck9mT2JqZWN0SGVhZGVycykge1xuICAgICAgICBsZXQgdGFncztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gUGFyc2UgY29tbW9uIGhlYWRlciBvZiB0aGUgQVNGIE9iamVjdCAoMy4xKVxuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKEFzZk9iamVjdC5IZWFkZXJPYmplY3RUb2tlbik7XG4gICAgICAgICAgICAvLyBQYXJzZSBkYXRhIHBhcnQgb2YgdGhlIEFTRiBPYmplY3RcbiAgICAgICAgICAgIGRlYnVnKCdoZWFkZXIgR1VJRD0lcycsIGhlYWRlci5vYmplY3RJZC5zdHIpO1xuICAgICAgICAgICAgc3dpdGNoIChoZWFkZXIub2JqZWN0SWQuc3RyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBBc2ZPYmplY3QuRmlsZVByb3BlcnRpZXNPYmplY3QuZ3VpZC5zdHI6IC8vIDMuMlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcG8gPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEFzZk9iamVjdC5GaWxlUHJvcGVydGllc09iamVjdChoZWFkZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2R1cmF0aW9uJywgTnVtYmVyKGZwby5wbGF5RHVyYXRpb24gLyBCaWdJbnQoMTAwMCkpIC8gMTAwMDAgLSBOdW1iZXIoZnBvLnByZXJvbGwpIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdiaXRyYXRlJywgZnBvLm1heGltdW1CaXRyYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBc2ZPYmplY3QuU3RyZWFtUHJvcGVydGllc09iamVjdC5ndWlkLnN0cjogLy8gMy4zXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwbyA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgQXNmT2JqZWN0LlN0cmVhbVByb3BlcnRpZXNPYmplY3QoaGVhZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb250YWluZXInLCAnQVNGLycgKyBzcG8uc3RyZWFtVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQXNmT2JqZWN0LkhlYWRlckV4dGVuc2lvbk9iamVjdC5ndWlkLnN0cjogLy8gMy40XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dEhlYWRlciA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgQXNmT2JqZWN0LkhlYWRlckV4dGVuc2lvbk9iamVjdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wYXJzZUV4dGVuc2lvbk9iamVjdChleHRIZWFkZXIuZXh0ZW5zaW9uRGF0YVNpemUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEFzZk9iamVjdC5Db250ZW50RGVzY3JpcHRpb25PYmplY3RTdGF0ZS5ndWlkLnN0cjogLy8gMy4xMFxuICAgICAgICAgICAgICAgICAgICB0YWdzID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBBc2ZPYmplY3QuQ29udGVudERlc2NyaXB0aW9uT2JqZWN0U3RhdGUoaGVhZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFncyh0YWdzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBc2ZPYmplY3QuRXh0ZW5kZWRDb250ZW50RGVzY3JpcHRpb25PYmplY3RTdGF0ZS5ndWlkLnN0cjogLy8gMy4xMVxuICAgICAgICAgICAgICAgICAgICB0YWdzID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBBc2ZPYmplY3QuRXh0ZW5kZWRDb250ZW50RGVzY3JpcHRpb25PYmplY3RTdGF0ZShoZWFkZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUYWdzKHRhZ3MpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEdVSURfMS5kZWZhdWx0LkNvZGVjTGlzdE9iamVjdC5zdHI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVjcyA9IGF3YWl0IEFzZk9iamVjdC5yZWFkQ29kZWNFbnRyaWVzKHRoaXMudG9rZW5pemVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRTdHJlYW1JbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBjb2RlYy50eXBlLnZpZGVvQ29kZWMgPyB0eXBlXzEuVHJhY2tUeXBlLnZpZGVvIDogdHlwZV8xLlRyYWNrVHlwZS5hdWRpbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlY05hbWU6IGNvZGVjLmNvZGVjTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdWRpb0NvZGVjcyA9IGNvZGVjcy5maWx0ZXIoY29kZWMgPT4gY29kZWMudHlwZS5hdWRpb0NvZGVjKS5tYXAoY29kZWMgPT4gY29kZWMuY29kZWNOYW1lKS5qb2luKCcvJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb2RlYycsIGF1ZGlvQ29kZWNzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBHVUlEXzEuZGVmYXVsdC5TdHJlYW1CaXRyYXRlUHJvcGVydGllc09iamVjdC5zdHI6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRvRG8/XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShoZWFkZXIub2JqZWN0U2l6ZSAtIEFzZk9iamVjdC5IZWFkZXJPYmplY3RUb2tlbi5sZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEdVSURfMS5kZWZhdWx0LlBhZGRpbmdPYmplY3Quc3RyOlxuICAgICAgICAgICAgICAgICAgICAvLyBUb0RvOiByZWdpc3RlciBieXRlcyBwYWRcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ1BhZGRpbmc6ICVzIGJ5dGVzJywgaGVhZGVyLm9iamVjdFNpemUgLSBBc2ZPYmplY3QuSGVhZGVyT2JqZWN0VG9rZW4ubGVuKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKGhlYWRlci5vYmplY3RTaXplIC0gQXNmT2JqZWN0LkhlYWRlck9iamVjdFRva2VuLmxlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuYWRkV2FybmluZygnSWdub3JlIEFTRi1PYmplY3QtR1VJRDogJyArIGhlYWRlci5vYmplY3RJZC5zdHIpO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnSWdub3JlIEFTRi1PYmplY3QtR1VJRDogJXMnLCBoZWFkZXIub2JqZWN0SWQuc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBBc2ZPYmplY3QuSWdub3JlT2JqZWN0U3RhdGUoaGVhZGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKC0tbnVtYmVyT2ZPYmplY3RIZWFkZXJzKTtcbiAgICAgICAgLy8gZG9uZVxuICAgIH1cbiAgICBhZGRUYWdzKHRhZ3MpIHtcbiAgICAgICAgdGFncy5mb3JFYWNoKHRhZyA9PiB7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFRhZyhoZWFkZXJUeXBlLCB0YWcuaWQsIHRhZy52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZUV4dGVuc2lvbk9iamVjdChleHRlbnNpb25TaXplKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGNvbW1vbiBoZWFkZXIgb2YgdGhlIEFTRiBPYmplY3QgKDMuMSlcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihBc2ZPYmplY3QuSGVhZGVyT2JqZWN0VG9rZW4pO1xuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nID0gaGVhZGVyLm9iamVjdFNpemUgLSBBc2ZPYmplY3QuSGVhZGVyT2JqZWN0VG9rZW4ubGVuO1xuICAgICAgICAgICAgLy8gUGFyc2UgZGF0YSBwYXJ0IG9mIHRoZSBBU0YgT2JqZWN0XG4gICAgICAgICAgICBzd2l0Y2ggKGhlYWRlci5vYmplY3RJZC5zdHIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEFzZk9iamVjdC5FeHRlbmRlZFN0cmVhbVByb3BlcnRpZXNPYmplY3RTdGF0ZS5ndWlkLnN0cjogLy8gNC4xXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvRG86IGV4dGVuZGVkIHN0cmVhbSBoZWFkZXIgcHJvcGVydGllcyBhcmUgaWdub3JlZFxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEFzZk9iamVjdC5FeHRlbmRlZFN0cmVhbVByb3BlcnRpZXNPYmplY3RTdGF0ZShoZWFkZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBc2ZPYmplY3QuTWV0YWRhdGFPYmplY3RTdGF0ZS5ndWlkLnN0cjogLy8gNC43XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vVGFncyA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgQXNmT2JqZWN0Lk1ldGFkYXRhT2JqZWN0U3RhdGUoaGVhZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFncyhtb1RhZ3MpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEFzZk9iamVjdC5NZXRhZGF0YUxpYnJhcnlPYmplY3RTdGF0ZS5ndWlkLnN0cjogLy8gNC44XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1sVGFncyA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgQXNmT2JqZWN0Lk1ldGFkYXRhTGlicmFyeU9iamVjdFN0YXRlKGhlYWRlcikpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZ3MobWxUYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBHVUlEXzEuZGVmYXVsdC5QYWRkaW5nT2JqZWN0LnN0cjpcbiAgICAgICAgICAgICAgICAgICAgLy8gVG9EbzogcmVnaXN0ZXIgYnl0ZXMgcGFkXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShyZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEdVSURfMS5kZWZhdWx0LkNvbXBhdGliaWxpdHlPYmplY3Quc3RyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2VuaXplci5pZ25vcmUocmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBHVUlEXzEuZGVmYXVsdC5BU0ZfSW5kZXhfUGxhY2Vob2xkZXJfT2JqZWN0LnN0cjpcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKHJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuYWRkV2FybmluZygnSWdub3JlIEFTRi1PYmplY3QtR1VJRDogJyArIGhlYWRlci5vYmplY3RJZC5zdHIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIklnbm9yZSBBU0YtT2JqZWN0LUdVSUQ6ICVzXCIsIGhlYWRlci5vYmplY3RJZC5zdHIpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEFzZk9iamVjdC5JZ25vcmVPYmplY3RTdGF0ZShoZWFkZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRlbnNpb25TaXplIC09IGhlYWRlci5vYmplY3RTaXplO1xuICAgICAgICB9IHdoaWxlIChleHRlbnNpb25TaXplID4gMCk7XG4gICAgfVxufVxuZXhwb3J0cy5Bc2ZQYXJzZXIgPSBBc2ZQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/asf/AsfParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/asf/AsfTagMapper.js":
/*!*************************************************************!*\
  !*** ./node_modules/music-metadata/lib/asf/AsfTagMapper.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsfTagMapper = void 0;\nconst GenericTagMapper_1 = __webpack_require__(/*! ../common/GenericTagMapper */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/GenericTagMapper.js\");\n/**\n * ASF Metadata tag mappings.\n * See http://msdn.microsoft.com/en-us/library/ms867702.aspx\n */\nconst asfTagMap = {\n    Title: 'title',\n    Author: 'artist',\n    'WM/AlbumArtist': 'albumartist',\n    'WM/AlbumTitle': 'album',\n    'WM/Year': 'date',\n    'WM/OriginalReleaseTime': 'originaldate',\n    'WM/OriginalReleaseYear': 'originalyear',\n    Description: 'comment',\n    'WM/TrackNumber': 'track',\n    'WM/PartOfSet': 'disk',\n    'WM/Genre': 'genre',\n    'WM/Composer': 'composer',\n    'WM/Lyrics': 'lyrics',\n    'WM/AlbumSortOrder': 'albumsort',\n    'WM/TitleSortOrder': 'titlesort',\n    'WM/ArtistSortOrder': 'artistsort',\n    'WM/AlbumArtistSortOrder': 'albumartistsort',\n    'WM/ComposerSortOrder': 'composersort',\n    'WM/Writer': 'lyricist',\n    'WM/Conductor': 'conductor',\n    'WM/ModifiedBy': 'remixer',\n    'WM/Engineer': 'engineer',\n    'WM/Producer': 'producer',\n    'WM/DJMixer': 'djmixer',\n    'WM/Mixer': 'mixer',\n    'WM/Publisher': 'label',\n    'WM/ContentGroupDescription': 'grouping',\n    'WM/SubTitle': 'subtitle',\n    'WM/SetSubTitle': 'discsubtitle',\n    // 'WM/PartOfSet': 'totaldiscs',\n    'WM/IsCompilation': 'compilation',\n    'WM/SharedUserRating': 'rating',\n    'WM/BeatsPerMinute': 'bpm',\n    'WM/Mood': 'mood',\n    'WM/Media': 'media',\n    'WM/CatalogNo': 'catalognumber',\n    'MusicBrainz/Album Status': 'releasestatus',\n    'MusicBrainz/Album Type': 'releasetype',\n    'MusicBrainz/Album Release Country': 'releasecountry',\n    'WM/Script': 'script',\n    'WM/Language': 'language',\n    Copyright: 'copyright',\n    LICENSE: 'license',\n    'WM/EncodedBy': 'encodedby',\n    'WM/EncodingSettings': 'encodersettings',\n    'WM/Barcode': 'barcode',\n    'WM/ISRC': 'isrc',\n    'MusicBrainz/Track Id': 'musicbrainz_recordingid',\n    'MusicBrainz/Release Track Id': 'musicbrainz_trackid',\n    'MusicBrainz/Album Id': 'musicbrainz_albumid',\n    'MusicBrainz/Artist Id': 'musicbrainz_artistid',\n    'MusicBrainz/Album Artist Id': 'musicbrainz_albumartistid',\n    'MusicBrainz/Release Group Id': 'musicbrainz_releasegroupid',\n    'MusicBrainz/Work Id': 'musicbrainz_workid',\n    'MusicBrainz/TRM Id': 'musicbrainz_trmid',\n    'MusicBrainz/Disc Id': 'musicbrainz_discid',\n    'Acoustid/Id': 'acoustid_id',\n    'Acoustid/Fingerprint': 'acoustid_fingerprint',\n    'MusicIP/PUID': 'musicip_puid',\n    'WM/ARTISTS': 'artists',\n    'WM/InitialKey': 'key',\n    ASIN: 'asin',\n    'WM/Work': 'work',\n    'WM/AuthorURL': 'website',\n    'WM/Picture': 'picture'\n};\nclass AsfTagMapper extends GenericTagMapper_1.CommonTagMapper {\n    static toRating(rating) {\n        return {\n            rating: parseFloat(rating + 1) / 5\n        };\n    }\n    constructor() {\n        super(['asf'], asfTagMap);\n    }\n    postMap(tag) {\n        switch (tag.id) {\n            case 'WM/SharedUserRating':\n                const keys = tag.id.split(':');\n                tag.value = AsfTagMapper.toRating(tag.value);\n                tag.id = keys[0];\n                break;\n        }\n    }\n}\nexports.AsfTagMapper = AsfTagMapper;\n//# sourceMappingURL=AsfTagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYXNmL0FzZlRhZ01hcHBlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsMkJBQTJCLG1CQUFPLENBQUMsb0hBQTRCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2FzZi9Bc2ZUYWdNYXBwZXIuanM/NjBmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNmVGFnTWFwcGVyID0gdm9pZCAwO1xuY29uc3QgR2VuZXJpY1RhZ01hcHBlcl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9HZW5lcmljVGFnTWFwcGVyXCIpO1xuLyoqXG4gKiBBU0YgTWV0YWRhdGEgdGFnIG1hcHBpbmdzLlxuICogU2VlIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczg2NzcwMi5hc3B4XG4gKi9cbmNvbnN0IGFzZlRhZ01hcCA9IHtcbiAgICBUaXRsZTogJ3RpdGxlJyxcbiAgICBBdXRob3I6ICdhcnRpc3QnLFxuICAgICdXTS9BbGJ1bUFydGlzdCc6ICdhbGJ1bWFydGlzdCcsXG4gICAgJ1dNL0FsYnVtVGl0bGUnOiAnYWxidW0nLFxuICAgICdXTS9ZZWFyJzogJ2RhdGUnLFxuICAgICdXTS9PcmlnaW5hbFJlbGVhc2VUaW1lJzogJ29yaWdpbmFsZGF0ZScsXG4gICAgJ1dNL09yaWdpbmFsUmVsZWFzZVllYXInOiAnb3JpZ2luYWx5ZWFyJyxcbiAgICBEZXNjcmlwdGlvbjogJ2NvbW1lbnQnLFxuICAgICdXTS9UcmFja051bWJlcic6ICd0cmFjaycsXG4gICAgJ1dNL1BhcnRPZlNldCc6ICdkaXNrJyxcbiAgICAnV00vR2VucmUnOiAnZ2VucmUnLFxuICAgICdXTS9Db21wb3Nlcic6ICdjb21wb3NlcicsXG4gICAgJ1dNL0x5cmljcyc6ICdseXJpY3MnLFxuICAgICdXTS9BbGJ1bVNvcnRPcmRlcic6ICdhbGJ1bXNvcnQnLFxuICAgICdXTS9UaXRsZVNvcnRPcmRlcic6ICd0aXRsZXNvcnQnLFxuICAgICdXTS9BcnRpc3RTb3J0T3JkZXInOiAnYXJ0aXN0c29ydCcsXG4gICAgJ1dNL0FsYnVtQXJ0aXN0U29ydE9yZGVyJzogJ2FsYnVtYXJ0aXN0c29ydCcsXG4gICAgJ1dNL0NvbXBvc2VyU29ydE9yZGVyJzogJ2NvbXBvc2Vyc29ydCcsXG4gICAgJ1dNL1dyaXRlcic6ICdseXJpY2lzdCcsXG4gICAgJ1dNL0NvbmR1Y3Rvcic6ICdjb25kdWN0b3InLFxuICAgICdXTS9Nb2RpZmllZEJ5JzogJ3JlbWl4ZXInLFxuICAgICdXTS9FbmdpbmVlcic6ICdlbmdpbmVlcicsXG4gICAgJ1dNL1Byb2R1Y2VyJzogJ3Byb2R1Y2VyJyxcbiAgICAnV00vREpNaXhlcic6ICdkam1peGVyJyxcbiAgICAnV00vTWl4ZXInOiAnbWl4ZXInLFxuICAgICdXTS9QdWJsaXNoZXInOiAnbGFiZWwnLFxuICAgICdXTS9Db250ZW50R3JvdXBEZXNjcmlwdGlvbic6ICdncm91cGluZycsXG4gICAgJ1dNL1N1YlRpdGxlJzogJ3N1YnRpdGxlJyxcbiAgICAnV00vU2V0U3ViVGl0bGUnOiAnZGlzY3N1YnRpdGxlJyxcbiAgICAvLyAnV00vUGFydE9mU2V0JzogJ3RvdGFsZGlzY3MnLFxuICAgICdXTS9Jc0NvbXBpbGF0aW9uJzogJ2NvbXBpbGF0aW9uJyxcbiAgICAnV00vU2hhcmVkVXNlclJhdGluZyc6ICdyYXRpbmcnLFxuICAgICdXTS9CZWF0c1Blck1pbnV0ZSc6ICdicG0nLFxuICAgICdXTS9Nb29kJzogJ21vb2QnLFxuICAgICdXTS9NZWRpYSc6ICdtZWRpYScsXG4gICAgJ1dNL0NhdGFsb2dObyc6ICdjYXRhbG9nbnVtYmVyJyxcbiAgICAnTXVzaWNCcmFpbnovQWxidW0gU3RhdHVzJzogJ3JlbGVhc2VzdGF0dXMnLFxuICAgICdNdXNpY0JyYWluei9BbGJ1bSBUeXBlJzogJ3JlbGVhc2V0eXBlJyxcbiAgICAnTXVzaWNCcmFpbnovQWxidW0gUmVsZWFzZSBDb3VudHJ5JzogJ3JlbGVhc2Vjb3VudHJ5JyxcbiAgICAnV00vU2NyaXB0JzogJ3NjcmlwdCcsXG4gICAgJ1dNL0xhbmd1YWdlJzogJ2xhbmd1YWdlJyxcbiAgICBDb3B5cmlnaHQ6ICdjb3B5cmlnaHQnLFxuICAgIExJQ0VOU0U6ICdsaWNlbnNlJyxcbiAgICAnV00vRW5jb2RlZEJ5JzogJ2VuY29kZWRieScsXG4gICAgJ1dNL0VuY29kaW5nU2V0dGluZ3MnOiAnZW5jb2RlcnNldHRpbmdzJyxcbiAgICAnV00vQmFyY29kZSc6ICdiYXJjb2RlJyxcbiAgICAnV00vSVNSQyc6ICdpc3JjJyxcbiAgICAnTXVzaWNCcmFpbnovVHJhY2sgSWQnOiAnbXVzaWNicmFpbnpfcmVjb3JkaW5naWQnLFxuICAgICdNdXNpY0JyYWluei9SZWxlYXNlIFRyYWNrIElkJzogJ211c2ljYnJhaW56X3RyYWNraWQnLFxuICAgICdNdXNpY0JyYWluei9BbGJ1bSBJZCc6ICdtdXNpY2JyYWluel9hbGJ1bWlkJyxcbiAgICAnTXVzaWNCcmFpbnovQXJ0aXN0IElkJzogJ211c2ljYnJhaW56X2FydGlzdGlkJyxcbiAgICAnTXVzaWNCcmFpbnovQWxidW0gQXJ0aXN0IElkJzogJ211c2ljYnJhaW56X2FsYnVtYXJ0aXN0aWQnLFxuICAgICdNdXNpY0JyYWluei9SZWxlYXNlIEdyb3VwIElkJzogJ211c2ljYnJhaW56X3JlbGVhc2Vncm91cGlkJyxcbiAgICAnTXVzaWNCcmFpbnovV29yayBJZCc6ICdtdXNpY2JyYWluel93b3JraWQnLFxuICAgICdNdXNpY0JyYWluei9UUk0gSWQnOiAnbXVzaWNicmFpbnpfdHJtaWQnLFxuICAgICdNdXNpY0JyYWluei9EaXNjIElkJzogJ211c2ljYnJhaW56X2Rpc2NpZCcsXG4gICAgJ0Fjb3VzdGlkL0lkJzogJ2Fjb3VzdGlkX2lkJyxcbiAgICAnQWNvdXN0aWQvRmluZ2VycHJpbnQnOiAnYWNvdXN0aWRfZmluZ2VycHJpbnQnLFxuICAgICdNdXNpY0lQL1BVSUQnOiAnbXVzaWNpcF9wdWlkJyxcbiAgICAnV00vQVJUSVNUUyc6ICdhcnRpc3RzJyxcbiAgICAnV00vSW5pdGlhbEtleSc6ICdrZXknLFxuICAgIEFTSU46ICdhc2luJyxcbiAgICAnV00vV29yayc6ICd3b3JrJyxcbiAgICAnV00vQXV0aG9yVVJMJzogJ3dlYnNpdGUnLFxuICAgICdXTS9QaWN0dXJlJzogJ3BpY3R1cmUnXG59O1xuY2xhc3MgQXNmVGFnTWFwcGVyIGV4dGVuZHMgR2VuZXJpY1RhZ01hcHBlcl8xLkNvbW1vblRhZ01hcHBlciB7XG4gICAgc3RhdGljIHRvUmF0aW5nKHJhdGluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF0aW5nOiBwYXJzZUZsb2F0KHJhdGluZyArIDEpIC8gNVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoWydhc2YnXSwgYXNmVGFnTWFwKTtcbiAgICB9XG4gICAgcG9zdE1hcCh0YWcpIHtcbiAgICAgICAgc3dpdGNoICh0YWcuaWQpIHtcbiAgICAgICAgICAgIGNhc2UgJ1dNL1NoYXJlZFVzZXJSYXRpbmcnOlxuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSB0YWcuaWQuc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICB0YWcudmFsdWUgPSBBc2ZUYWdNYXBwZXIudG9SYXRpbmcodGFnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB0YWcuaWQgPSBrZXlzWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Bc2ZUYWdNYXBwZXIgPSBBc2ZUYWdNYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc2ZUYWdNYXBwZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/asf/AsfTagMapper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/asf/AsfUtil.js":
/*!********************************************************!*\
  !*** ./node_modules/music-metadata/lib/asf/AsfUtil.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsfUtil = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst util = __webpack_require__(/*! ../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\nclass AsfUtil {\n    static getParserForAttr(i) {\n        return AsfUtil.attributeParsers[i];\n    }\n    static parseUnicodeAttr(uint8Array) {\n        return util.stripNulls(util.decodeString(uint8Array, 'utf16le'));\n    }\n    static parseByteArrayAttr(buf) {\n        return Buffer.from(buf);\n    }\n    static parseBoolAttr(buf, offset = 0) {\n        return AsfUtil.parseWordAttr(buf, offset) === 1;\n    }\n    static parseDWordAttr(buf, offset = 0) {\n        return buf.readUInt32LE(offset);\n    }\n    static parseQWordAttr(buf, offset = 0) {\n        return Token.UINT64_LE.get(buf, offset);\n    }\n    static parseWordAttr(buf, offset = 0) {\n        return buf.readUInt16LE(offset);\n    }\n}\nAsfUtil.attributeParsers = [\n    AsfUtil.parseUnicodeAttr,\n    AsfUtil.parseByteArrayAttr,\n    AsfUtil.parseBoolAttr,\n    AsfUtil.parseDWordAttr,\n    AsfUtil.parseQWordAttr,\n    AsfUtil.parseWordAttr,\n    AsfUtil.parseByteArrayAttr\n];\nexports.AsfUtil = AsfUtil;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYXNmL0FzZlV0aWwuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixjQUFjLG1CQUFPLENBQUMsZ0ZBQWE7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLDRGQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYXNmL0FzZlV0aWwuanM/OWM3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNmVXRpbCA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuLi9jb21tb24vVXRpbFwiKTtcbmNsYXNzIEFzZlV0aWwge1xuICAgIHN0YXRpYyBnZXRQYXJzZXJGb3JBdHRyKGkpIHtcbiAgICAgICAgcmV0dXJuIEFzZlV0aWwuYXR0cmlidXRlUGFyc2Vyc1tpXTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlVW5pY29kZUF0dHIodWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gdXRpbC5zdHJpcE51bGxzKHV0aWwuZGVjb2RlU3RyaW5nKHVpbnQ4QXJyYXksICd1dGYxNmxlJykpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VCeXRlQXJyYXlBdHRyKGJ1Zikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYnVmKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlQm9vbEF0dHIoYnVmLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiBBc2ZVdGlsLnBhcnNlV29yZEF0dHIoYnVmLCBvZmZzZXQpID09PSAxO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VEV29yZEF0dHIoYnVmLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiBidWYucmVhZFVJbnQzMkxFKG9mZnNldCk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZVFXb3JkQXR0cihidWYsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIFRva2VuLlVJTlQ2NF9MRS5nZXQoYnVmLCBvZmZzZXQpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VXb3JkQXR0cihidWYsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2TEUob2Zmc2V0KTtcbiAgICB9XG59XG5Bc2ZVdGlsLmF0dHJpYnV0ZVBhcnNlcnMgPSBbXG4gICAgQXNmVXRpbC5wYXJzZVVuaWNvZGVBdHRyLFxuICAgIEFzZlV0aWwucGFyc2VCeXRlQXJyYXlBdHRyLFxuICAgIEFzZlV0aWwucGFyc2VCb29sQXR0cixcbiAgICBBc2ZVdGlsLnBhcnNlRFdvcmRBdHRyLFxuICAgIEFzZlV0aWwucGFyc2VRV29yZEF0dHIsXG4gICAgQXNmVXRpbC5wYXJzZVdvcmRBdHRyLFxuICAgIEFzZlV0aWwucGFyc2VCeXRlQXJyYXlBdHRyXG5dO1xuZXhwb3J0cy5Bc2ZVdGlsID0gQXNmVXRpbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/asf/AsfUtil.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/asf/GUID.js":
/*!*****************************************************!*\
  !*** ./node_modules/music-metadata/lib/asf/GUID.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Ref:\n * - https://tools.ietf.org/html/draft-fleischman-asf-01, Appendix A: ASF GUIDs\n * - http://drang.s4.xrea.com/program/tips/id3tag/wmp/10_asf_guids.html\n * - http://drang.s4.xrea.com/program/tips/id3tag/wmp/index.html\n * - http://drang.s4.xrea.com/program/tips/id3tag/wmp/10_asf_guids.html\n *\n * ASF File Structure:\n * - https://msdn.microsoft.com/en-us/library/windows/desktop/ee663575(v=vs.85).aspx\n *\n * ASF GUIDs:\n * - http://drang.s4.xrea.com/program/tips/id3tag/wmp/10_asf_guids.html\n * - https://github.com/dji-sdk/FFmpeg/blob/master/libavformat/asf.c\n */\nclass GUID {\n    static fromBin(bin, offset = 0) {\n        return new GUID(this.decode(bin, offset));\n    }\n    /**\n     * Decode GUID in format like \"B503BF5F-2EA9-CF11-8EE3-00C00C205365\"\n     * @param objectId Binary GUID\n     * @param offset Read offset in bytes, default 0\n     * @returns GUID as dashed hexadecimal representation\n     */\n    static decode(objectId, offset = 0) {\n        const guid = objectId.readUInt32LE(offset).toString(16) + \"-\" +\n            objectId.readUInt16LE(offset + 4).toString(16) + \"-\" +\n            objectId.readUInt16LE(offset + 6).toString(16) + \"-\" +\n            objectId.readUInt16BE(offset + 8).toString(16) + \"-\" +\n            objectId.slice(offset + 10, offset + 16).toString('hex');\n        return guid.toUpperCase();\n    }\n    /**\n     * Decode stream type\n     * @param mediaType Media type GUID\n     * @returns Media type\n     */\n    static decodeMediaType(mediaType) {\n        switch (mediaType.str) {\n            case GUID.AudioMedia.str: return 'audio';\n            case GUID.VideoMedia.str: return 'video';\n            case GUID.CommandMedia.str: return 'command';\n            case GUID.Degradable_JPEG_Media.str: return 'degradable-jpeg';\n            case GUID.FileTransferMedia.str: return 'file-transfer';\n            case GUID.BinaryMedia.str: return 'binary';\n        }\n    }\n    /**\n     * Encode GUID\n     * @param guid GUID like: \"B503BF5F-2EA9-CF11-8EE3-00C00C205365\"\n     * @returns Encoded Binary GUID\n     */\n    static encode(str) {\n        const bin = Buffer.alloc(16);\n        bin.writeUInt32LE(parseInt(str.slice(0, 8), 16), 0);\n        bin.writeUInt16LE(parseInt(str.slice(9, 13), 16), 4);\n        bin.writeUInt16LE(parseInt(str.slice(14, 18), 16), 6);\n        Buffer.from(str.slice(19, 23), \"hex\").copy(bin, 8);\n        Buffer.from(str.slice(24), \"hex\").copy(bin, 10);\n        return bin;\n    }\n    constructor(str) {\n        this.str = str;\n    }\n    equals(guid) {\n        return this.str === guid.str;\n    }\n    toBin() {\n        return GUID.encode(this.str);\n    }\n}\n// 10.1 Top-level ASF object GUIDs\nGUID.HeaderObject = new GUID(\"75B22630-668E-11CF-A6D9-00AA0062CE6C\");\nGUID.DataObject = new GUID(\"75B22636-668E-11CF-A6D9-00AA0062CE6C\");\nGUID.SimpleIndexObject = new GUID(\"33000890-E5B1-11CF-89F4-00A0C90349CB\");\nGUID.IndexObject = new GUID(\"D6E229D3-35DA-11D1-9034-00A0C90349BE\");\nGUID.MediaObjectIndexObject = new GUID(\"FEB103F8-12AD-4C64-840F-2A1D2F7AD48C\");\nGUID.TimecodeIndexObject = new GUID(\"3CB73FD0-0C4A-4803-953D-EDF7B6228F0C\");\n// 10.2 Header Object GUIDs\nGUID.FilePropertiesObject = new GUID(\"8CABDCA1-A947-11CF-8EE4-00C00C205365\");\nGUID.StreamPropertiesObject = new GUID(\"B7DC0791-A9B7-11CF-8EE6-00C00C205365\");\nGUID.HeaderExtensionObject = new GUID(\"5FBF03B5-A92E-11CF-8EE3-00C00C205365\");\nGUID.CodecListObject = new GUID(\"86D15240-311D-11D0-A3A4-00A0C90348F6\");\nGUID.ScriptCommandObject = new GUID(\"1EFB1A30-0B62-11D0-A39B-00A0C90348F6\");\nGUID.MarkerObject = new GUID(\"F487CD01-A951-11CF-8EE6-00C00C205365\");\nGUID.BitrateMutualExclusionObject = new GUID(\"D6E229DC-35DA-11D1-9034-00A0C90349BE\");\nGUID.ErrorCorrectionObject = new GUID(\"75B22635-668E-11CF-A6D9-00AA0062CE6C\");\nGUID.ContentDescriptionObject = new GUID(\"75B22633-668E-11CF-A6D9-00AA0062CE6C\");\nGUID.ExtendedContentDescriptionObject = new GUID(\"D2D0A440-E307-11D2-97F0-00A0C95EA850\");\nGUID.ContentBrandingObject = new GUID(\"2211B3FA-BD23-11D2-B4B7-00A0C955FC6E\");\nGUID.StreamBitratePropertiesObject = new GUID(\"7BF875CE-468D-11D1-8D82-006097C9A2B2\");\nGUID.ContentEncryptionObject = new GUID(\"2211B3FB-BD23-11D2-B4B7-00A0C955FC6E\");\nGUID.ExtendedContentEncryptionObject = new GUID(\"298AE614-2622-4C17-B935-DAE07EE9289C\");\nGUID.DigitalSignatureObject = new GUID(\"2211B3FC-BD23-11D2-B4B7-00A0C955FC6E\");\nGUID.PaddingObject = new GUID(\"1806D474-CADF-4509-A4BA-9AABCB96AAE8\");\n// 10.3 Header Extension Object GUIDs\nGUID.ExtendedStreamPropertiesObject = new GUID(\"14E6A5CB-C672-4332-8399-A96952065B5A\");\nGUID.AdvancedMutualExclusionObject = new GUID(\"A08649CF-4775-4670-8A16-6E35357566CD\");\nGUID.GroupMutualExclusionObject = new GUID(\"D1465A40-5A79-4338-B71B-E36B8FD6C249\");\nGUID.StreamPrioritizationObject = new GUID(\"D4FED15B-88D3-454F-81F0-ED5C45999E24\");\nGUID.BandwidthSharingObject = new GUID(\"A69609E6-517B-11D2-B6AF-00C04FD908E9\");\nGUID.LanguageListObject = new GUID(\"7C4346A9-EFE0-4BFC-B229-393EDE415C85\");\nGUID.MetadataObject = new GUID(\"C5F8CBEA-5BAF-4877-8467-AA8C44FA4CCA\");\nGUID.MetadataLibraryObject = new GUID(\"44231C94-9498-49D1-A141-1D134E457054\");\nGUID.IndexParametersObject = new GUID(\"D6E229DF-35DA-11D1-9034-00A0C90349BE\");\nGUID.MediaObjectIndexParametersObject = new GUID(\"6B203BAD-3F11-48E4-ACA8-D7613DE2CFA7\");\nGUID.TimecodeIndexParametersObject = new GUID(\"F55E496D-9797-4B5D-8C8B-604DFE9BFB24\");\nGUID.CompatibilityObject = new GUID(\"26F18B5D-4584-47EC-9F5F-0E651F0452C9\");\nGUID.AdvancedContentEncryptionObject = new GUID(\"43058533-6981-49E6-9B74-AD12CB86D58C\");\n// 10.4 Stream Properties Object Stream Type GUIDs\nGUID.AudioMedia = new GUID(\"F8699E40-5B4D-11CF-A8FD-00805F5C442B\");\nGUID.VideoMedia = new GUID(\"BC19EFC0-5B4D-11CF-A8FD-00805F5C442B\");\nGUID.CommandMedia = new GUID(\"59DACFC0-59E6-11D0-A3AC-00A0C90348F6\");\nGUID.JFIF_Media = new GUID(\"B61BE100-5B4E-11CF-A8FD-00805F5C442B\");\nGUID.Degradable_JPEG_Media = new GUID(\"35907DE0-E415-11CF-A917-00805F5C442B\");\nGUID.FileTransferMedia = new GUID(\"91BD222C-F21C-497A-8B6D-5AA86BFC0185\");\nGUID.BinaryMedia = new GUID(\"3AFB65E2-47EF-40F2-AC2C-70A90D71D343\");\nGUID.ASF_Index_Placeholder_Object = new GUID(\"D9AADE20-7C17-4F9C-BC28-8555DD98E2A2\");\nexports[\"default\"] = GUID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvYXNmL0dVSUQuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLE1BQU07QUFDZCxRQUFRLE1BQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9hc2YvR1VJRC5qcz9iMDk4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBSZWY6XG4gKiAtIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1mbGVpc2NobWFuLWFzZi0wMSwgQXBwZW5kaXggQTogQVNGIEdVSURzXG4gKiAtIGh0dHA6Ly9kcmFuZy5zNC54cmVhLmNvbS9wcm9ncmFtL3RpcHMvaWQzdGFnL3dtcC8xMF9hc2ZfZ3VpZHMuaHRtbFxuICogLSBodHRwOi8vZHJhbmcuczQueHJlYS5jb20vcHJvZ3JhbS90aXBzL2lkM3RhZy93bXAvaW5kZXguaHRtbFxuICogLSBodHRwOi8vZHJhbmcuczQueHJlYS5jb20vcHJvZ3JhbS90aXBzL2lkM3RhZy93bXAvMTBfYXNmX2d1aWRzLmh0bWxcbiAqXG4gKiBBU0YgRmlsZSBTdHJ1Y3R1cmU6XG4gKiAtIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2VlNjYzNTc1KHY9dnMuODUpLmFzcHhcbiAqXG4gKiBBU0YgR1VJRHM6XG4gKiAtIGh0dHA6Ly9kcmFuZy5zNC54cmVhLmNvbS9wcm9ncmFtL3RpcHMvaWQzdGFnL3dtcC8xMF9hc2ZfZ3VpZHMuaHRtbFxuICogLSBodHRwczovL2dpdGh1Yi5jb20vZGppLXNkay9GRm1wZWcvYmxvYi9tYXN0ZXIvbGliYXZmb3JtYXQvYXNmLmNcbiAqL1xuY2xhc3MgR1VJRCB7XG4gICAgc3RhdGljIGZyb21CaW4oYmluLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgR1VJRCh0aGlzLmRlY29kZShiaW4sIG9mZnNldCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgR1VJRCBpbiBmb3JtYXQgbGlrZSBcIkI1MDNCRjVGLTJFQTktQ0YxMS04RUUzLTAwQzAwQzIwNTM2NVwiXG4gICAgICogQHBhcmFtIG9iamVjdElkIEJpbmFyeSBHVUlEXG4gICAgICogQHBhcmFtIG9mZnNldCBSZWFkIG9mZnNldCBpbiBieXRlcywgZGVmYXVsdCAwXG4gICAgICogQHJldHVybnMgR1VJRCBhcyBkYXNoZWQgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVjb2RlKG9iamVjdElkLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGd1aWQgPSBvYmplY3RJZC5yZWFkVUludDMyTEUob2Zmc2V0KS50b1N0cmluZygxNikgKyBcIi1cIiArXG4gICAgICAgICAgICBvYmplY3RJZC5yZWFkVUludDE2TEUob2Zmc2V0ICsgNCkudG9TdHJpbmcoMTYpICsgXCItXCIgK1xuICAgICAgICAgICAgb2JqZWN0SWQucmVhZFVJbnQxNkxFKG9mZnNldCArIDYpLnRvU3RyaW5nKDE2KSArIFwiLVwiICtcbiAgICAgICAgICAgIG9iamVjdElkLnJlYWRVSW50MTZCRShvZmZzZXQgKyA4KS50b1N0cmluZygxNikgKyBcIi1cIiArXG4gICAgICAgICAgICBvYmplY3RJZC5zbGljZShvZmZzZXQgKyAxMCwgb2Zmc2V0ICsgMTYpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgcmV0dXJuIGd1aWQudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlIHN0cmVhbSB0eXBlXG4gICAgICogQHBhcmFtIG1lZGlhVHlwZSBNZWRpYSB0eXBlIEdVSURcbiAgICAgKiBAcmV0dXJucyBNZWRpYSB0eXBlXG4gICAgICovXG4gICAgc3RhdGljIGRlY29kZU1lZGlhVHlwZShtZWRpYVR5cGUpIHtcbiAgICAgICAgc3dpdGNoIChtZWRpYVR5cGUuc3RyKSB7XG4gICAgICAgICAgICBjYXNlIEdVSUQuQXVkaW9NZWRpYS5zdHI6IHJldHVybiAnYXVkaW8nO1xuICAgICAgICAgICAgY2FzZSBHVUlELlZpZGVvTWVkaWEuc3RyOiByZXR1cm4gJ3ZpZGVvJztcbiAgICAgICAgICAgIGNhc2UgR1VJRC5Db21tYW5kTWVkaWEuc3RyOiByZXR1cm4gJ2NvbW1hbmQnO1xuICAgICAgICAgICAgY2FzZSBHVUlELkRlZ3JhZGFibGVfSlBFR19NZWRpYS5zdHI6IHJldHVybiAnZGVncmFkYWJsZS1qcGVnJztcbiAgICAgICAgICAgIGNhc2UgR1VJRC5GaWxlVHJhbnNmZXJNZWRpYS5zdHI6IHJldHVybiAnZmlsZS10cmFuc2Zlcic7XG4gICAgICAgICAgICBjYXNlIEdVSUQuQmluYXJ5TWVkaWEuc3RyOiByZXR1cm4gJ2JpbmFyeSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlIEdVSURcbiAgICAgKiBAcGFyYW0gZ3VpZCBHVUlEIGxpa2U6IFwiQjUwM0JGNUYtMkVBOS1DRjExLThFRTMtMDBDMDBDMjA1MzY1XCJcbiAgICAgKiBAcmV0dXJucyBFbmNvZGVkIEJpbmFyeSBHVUlEXG4gICAgICovXG4gICAgc3RhdGljIGVuY29kZShzdHIpIHtcbiAgICAgICAgY29uc3QgYmluID0gQnVmZmVyLmFsbG9jKDE2KTtcbiAgICAgICAgYmluLndyaXRlVUludDMyTEUocGFyc2VJbnQoc3RyLnNsaWNlKDAsIDgpLCAxNiksIDApO1xuICAgICAgICBiaW4ud3JpdGVVSW50MTZMRShwYXJzZUludChzdHIuc2xpY2UoOSwgMTMpLCAxNiksIDQpO1xuICAgICAgICBiaW4ud3JpdGVVSW50MTZMRShwYXJzZUludChzdHIuc2xpY2UoMTQsIDE4KSwgMTYpLCA2KTtcbiAgICAgICAgQnVmZmVyLmZyb20oc3RyLnNsaWNlKDE5LCAyMyksIFwiaGV4XCIpLmNvcHkoYmluLCA4KTtcbiAgICAgICAgQnVmZmVyLmZyb20oc3RyLnNsaWNlKDI0KSwgXCJoZXhcIikuY29weShiaW4sIDEwKTtcbiAgICAgICAgcmV0dXJuIGJpbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3RyKSB7XG4gICAgICAgIHRoaXMuc3RyID0gc3RyO1xuICAgIH1cbiAgICBlcXVhbHMoZ3VpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHIgPT09IGd1aWQuc3RyO1xuICAgIH1cbiAgICB0b0JpbigpIHtcbiAgICAgICAgcmV0dXJuIEdVSUQuZW5jb2RlKHRoaXMuc3RyKTtcbiAgICB9XG59XG4vLyAxMC4xIFRvcC1sZXZlbCBBU0Ygb2JqZWN0IEdVSURzXG5HVUlELkhlYWRlck9iamVjdCA9IG5ldyBHVUlEKFwiNzVCMjI2MzAtNjY4RS0xMUNGLUE2RDktMDBBQTAwNjJDRTZDXCIpO1xuR1VJRC5EYXRhT2JqZWN0ID0gbmV3IEdVSUQoXCI3NUIyMjYzNi02NjhFLTExQ0YtQTZEOS0wMEFBMDA2MkNFNkNcIik7XG5HVUlELlNpbXBsZUluZGV4T2JqZWN0ID0gbmV3IEdVSUQoXCIzMzAwMDg5MC1FNUIxLTExQ0YtODlGNC0wMEEwQzkwMzQ5Q0JcIik7XG5HVUlELkluZGV4T2JqZWN0ID0gbmV3IEdVSUQoXCJENkUyMjlEMy0zNURBLTExRDEtOTAzNC0wMEEwQzkwMzQ5QkVcIik7XG5HVUlELk1lZGlhT2JqZWN0SW5kZXhPYmplY3QgPSBuZXcgR1VJRChcIkZFQjEwM0Y4LTEyQUQtNEM2NC04NDBGLTJBMUQyRjdBRDQ4Q1wiKTtcbkdVSUQuVGltZWNvZGVJbmRleE9iamVjdCA9IG5ldyBHVUlEKFwiM0NCNzNGRDAtMEM0QS00ODAzLTk1M0QtRURGN0I2MjI4RjBDXCIpO1xuLy8gMTAuMiBIZWFkZXIgT2JqZWN0IEdVSURzXG5HVUlELkZpbGVQcm9wZXJ0aWVzT2JqZWN0ID0gbmV3IEdVSUQoXCI4Q0FCRENBMS1BOTQ3LTExQ0YtOEVFNC0wMEMwMEMyMDUzNjVcIik7XG5HVUlELlN0cmVhbVByb3BlcnRpZXNPYmplY3QgPSBuZXcgR1VJRChcIkI3REMwNzkxLUE5QjctMTFDRi04RUU2LTAwQzAwQzIwNTM2NVwiKTtcbkdVSUQuSGVhZGVyRXh0ZW5zaW9uT2JqZWN0ID0gbmV3IEdVSUQoXCI1RkJGMDNCNS1BOTJFLTExQ0YtOEVFMy0wMEMwMEMyMDUzNjVcIik7XG5HVUlELkNvZGVjTGlzdE9iamVjdCA9IG5ldyBHVUlEKFwiODZEMTUyNDAtMzExRC0xMUQwLUEzQTQtMDBBMEM5MDM0OEY2XCIpO1xuR1VJRC5TY3JpcHRDb21tYW5kT2JqZWN0ID0gbmV3IEdVSUQoXCIxRUZCMUEzMC0wQjYyLTExRDAtQTM5Qi0wMEEwQzkwMzQ4RjZcIik7XG5HVUlELk1hcmtlck9iamVjdCA9IG5ldyBHVUlEKFwiRjQ4N0NEMDEtQTk1MS0xMUNGLThFRTYtMDBDMDBDMjA1MzY1XCIpO1xuR1VJRC5CaXRyYXRlTXV0dWFsRXhjbHVzaW9uT2JqZWN0ID0gbmV3IEdVSUQoXCJENkUyMjlEQy0zNURBLTExRDEtOTAzNC0wMEEwQzkwMzQ5QkVcIik7XG5HVUlELkVycm9yQ29ycmVjdGlvbk9iamVjdCA9IG5ldyBHVUlEKFwiNzVCMjI2MzUtNjY4RS0xMUNGLUE2RDktMDBBQTAwNjJDRTZDXCIpO1xuR1VJRC5Db250ZW50RGVzY3JpcHRpb25PYmplY3QgPSBuZXcgR1VJRChcIjc1QjIyNjMzLTY2OEUtMTFDRi1BNkQ5LTAwQUEwMDYyQ0U2Q1wiKTtcbkdVSUQuRXh0ZW5kZWRDb250ZW50RGVzY3JpcHRpb25PYmplY3QgPSBuZXcgR1VJRChcIkQyRDBBNDQwLUUzMDctMTFEMi05N0YwLTAwQTBDOTVFQTg1MFwiKTtcbkdVSUQuQ29udGVudEJyYW5kaW5nT2JqZWN0ID0gbmV3IEdVSUQoXCIyMjExQjNGQS1CRDIzLTExRDItQjRCNy0wMEEwQzk1NUZDNkVcIik7XG5HVUlELlN0cmVhbUJpdHJhdGVQcm9wZXJ0aWVzT2JqZWN0ID0gbmV3IEdVSUQoXCI3QkY4NzVDRS00NjhELTExRDEtOEQ4Mi0wMDYwOTdDOUEyQjJcIik7XG5HVUlELkNvbnRlbnRFbmNyeXB0aW9uT2JqZWN0ID0gbmV3IEdVSUQoXCIyMjExQjNGQi1CRDIzLTExRDItQjRCNy0wMEEwQzk1NUZDNkVcIik7XG5HVUlELkV4dGVuZGVkQ29udGVudEVuY3J5cHRpb25PYmplY3QgPSBuZXcgR1VJRChcIjI5OEFFNjE0LTI2MjItNEMxNy1COTM1LURBRTA3RUU5Mjg5Q1wiKTtcbkdVSUQuRGlnaXRhbFNpZ25hdHVyZU9iamVjdCA9IG5ldyBHVUlEKFwiMjIxMUIzRkMtQkQyMy0xMUQyLUI0QjctMDBBMEM5NTVGQzZFXCIpO1xuR1VJRC5QYWRkaW5nT2JqZWN0ID0gbmV3IEdVSUQoXCIxODA2RDQ3NC1DQURGLTQ1MDktQTRCQS05QUFCQ0I5NkFBRThcIik7XG4vLyAxMC4zIEhlYWRlciBFeHRlbnNpb24gT2JqZWN0IEdVSURzXG5HVUlELkV4dGVuZGVkU3RyZWFtUHJvcGVydGllc09iamVjdCA9IG5ldyBHVUlEKFwiMTRFNkE1Q0ItQzY3Mi00MzMyLTgzOTktQTk2OTUyMDY1QjVBXCIpO1xuR1VJRC5BZHZhbmNlZE11dHVhbEV4Y2x1c2lvbk9iamVjdCA9IG5ldyBHVUlEKFwiQTA4NjQ5Q0YtNDc3NS00NjcwLThBMTYtNkUzNTM1NzU2NkNEXCIpO1xuR1VJRC5Hcm91cE11dHVhbEV4Y2x1c2lvbk9iamVjdCA9IG5ldyBHVUlEKFwiRDE0NjVBNDAtNUE3OS00MzM4LUI3MUItRTM2QjhGRDZDMjQ5XCIpO1xuR1VJRC5TdHJlYW1Qcmlvcml0aXphdGlvbk9iamVjdCA9IG5ldyBHVUlEKFwiRDRGRUQxNUItODhEMy00NTRGLTgxRjAtRUQ1QzQ1OTk5RTI0XCIpO1xuR1VJRC5CYW5kd2lkdGhTaGFyaW5nT2JqZWN0ID0gbmV3IEdVSUQoXCJBNjk2MDlFNi01MTdCLTExRDItQjZBRi0wMEMwNEZEOTA4RTlcIik7XG5HVUlELkxhbmd1YWdlTGlzdE9iamVjdCA9IG5ldyBHVUlEKFwiN0M0MzQ2QTktRUZFMC00QkZDLUIyMjktMzkzRURFNDE1Qzg1XCIpO1xuR1VJRC5NZXRhZGF0YU9iamVjdCA9IG5ldyBHVUlEKFwiQzVGOENCRUEtNUJBRi00ODc3LTg0NjctQUE4QzQ0RkE0Q0NBXCIpO1xuR1VJRC5NZXRhZGF0YUxpYnJhcnlPYmplY3QgPSBuZXcgR1VJRChcIjQ0MjMxQzk0LTk0OTgtNDlEMS1BMTQxLTFEMTM0RTQ1NzA1NFwiKTtcbkdVSUQuSW5kZXhQYXJhbWV0ZXJzT2JqZWN0ID0gbmV3IEdVSUQoXCJENkUyMjlERi0zNURBLTExRDEtOTAzNC0wMEEwQzkwMzQ5QkVcIik7XG5HVUlELk1lZGlhT2JqZWN0SW5kZXhQYXJhbWV0ZXJzT2JqZWN0ID0gbmV3IEdVSUQoXCI2QjIwM0JBRC0zRjExLTQ4RTQtQUNBOC1ENzYxM0RFMkNGQTdcIik7XG5HVUlELlRpbWVjb2RlSW5kZXhQYXJhbWV0ZXJzT2JqZWN0ID0gbmV3IEdVSUQoXCJGNTVFNDk2RC05Nzk3LTRCNUQtOEM4Qi02MDRERkU5QkZCMjRcIik7XG5HVUlELkNvbXBhdGliaWxpdHlPYmplY3QgPSBuZXcgR1VJRChcIjI2RjE4QjVELTQ1ODQtNDdFQy05RjVGLTBFNjUxRjA0NTJDOVwiKTtcbkdVSUQuQWR2YW5jZWRDb250ZW50RW5jcnlwdGlvbk9iamVjdCA9IG5ldyBHVUlEKFwiNDMwNTg1MzMtNjk4MS00OUU2LTlCNzQtQUQxMkNCODZENThDXCIpO1xuLy8gMTAuNCBTdHJlYW0gUHJvcGVydGllcyBPYmplY3QgU3RyZWFtIFR5cGUgR1VJRHNcbkdVSUQuQXVkaW9NZWRpYSA9IG5ldyBHVUlEKFwiRjg2OTlFNDAtNUI0RC0xMUNGLUE4RkQtMDA4MDVGNUM0NDJCXCIpO1xuR1VJRC5WaWRlb01lZGlhID0gbmV3IEdVSUQoXCJCQzE5RUZDMC01QjRELTExQ0YtQThGRC0wMDgwNUY1QzQ0MkJcIik7XG5HVUlELkNvbW1hbmRNZWRpYSA9IG5ldyBHVUlEKFwiNTlEQUNGQzAtNTlFNi0xMUQwLUEzQUMtMDBBMEM5MDM0OEY2XCIpO1xuR1VJRC5KRklGX01lZGlhID0gbmV3IEdVSUQoXCJCNjFCRTEwMC01QjRFLTExQ0YtQThGRC0wMDgwNUY1QzQ0MkJcIik7XG5HVUlELkRlZ3JhZGFibGVfSlBFR19NZWRpYSA9IG5ldyBHVUlEKFwiMzU5MDdERTAtRTQxNS0xMUNGLUE5MTctMDA4MDVGNUM0NDJCXCIpO1xuR1VJRC5GaWxlVHJhbnNmZXJNZWRpYSA9IG5ldyBHVUlEKFwiOTFCRDIyMkMtRjIxQy00OTdBLThCNkQtNUFBODZCRkMwMTg1XCIpO1xuR1VJRC5CaW5hcnlNZWRpYSA9IG5ldyBHVUlEKFwiM0FGQjY1RTItNDdFRi00MEYyLUFDMkMtNzBBOTBENzFEMzQzXCIpO1xuR1VJRC5BU0ZfSW5kZXhfUGxhY2Vob2xkZXJfT2JqZWN0ID0gbmV3IEdVSUQoXCJEOUFBREUyMC03QzE3LTRGOUMtQkMyOC04NTU1REQ5OEUyQTJcIik7XG5leHBvcnRzLmRlZmF1bHQgPSBHVUlEO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/asf/GUID.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/common/BasicParser.js":
/*!***************************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/BasicParser.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BasicParser = void 0;\nclass BasicParser {\n    /**\n     * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\n     * @param {INativeMetadataCollector} metadata Output\n     * @param {ITokenizer} tokenizer Input\n     * @param {IOptions} options Parsing options\n     */\n    init(metadata, tokenizer, options) {\n        this.metadata = metadata;\n        this.tokenizer = tokenizer;\n        this.options = options;\n        return this;\n    }\n}\nexports.BasicParser = BasicParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvY29tbW9uL0Jhc2ljUGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFlBQVk7QUFDM0IsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9jb21tb24vQmFzaWNQYXJzZXIuanM/NTU3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzaWNQYXJzZXIgPSB2b2lkIDA7XG5jbGFzcyBCYXNpY1BhcnNlciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBwYXJzZXIgd2l0aCBvdXRwdXQgKG1ldGFkYXRhKSwgaW5wdXQgKHRva2VuaXplcikgJiBwYXJzaW5nIG9wdGlvbnMgKG9wdGlvbnMpLlxuICAgICAqIEBwYXJhbSB7SU5hdGl2ZU1ldGFkYXRhQ29sbGVjdG9yfSBtZXRhZGF0YSBPdXRwdXRcbiAgICAgKiBAcGFyYW0ge0lUb2tlbml6ZXJ9IHRva2VuaXplciBJbnB1dFxuICAgICAqIEBwYXJhbSB7SU9wdGlvbnN9IG9wdGlvbnMgUGFyc2luZyBvcHRpb25zXG4gICAgICovXG4gICAgaW5pdChtZXRhZGF0YSwgdG9rZW5pemVyLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzaWNQYXJzZXIgPSBCYXNpY1BhcnNlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/common/BasicParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js":
/*!*************************************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CaseInsensitiveTagMap = void 0;\nconst GenericTagMapper_1 = __webpack_require__(/*! ./GenericTagMapper */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/GenericTagMapper.js\");\nclass CaseInsensitiveTagMap extends GenericTagMapper_1.CommonTagMapper {\n    constructor(tagTypes, tagMap) {\n        const upperCaseMap = {};\n        for (const tag of Object.keys(tagMap)) {\n            upperCaseMap[tag.toUpperCase()] = tagMap[tag];\n        }\n        super(tagTypes, upperCaseMap);\n    }\n    /**\n     * @tag  Native header tag\n     * @return common tag name (alias)\n     */\n    getCommonName(tag) {\n        return this.tagMap[tag.toUpperCase()];\n    }\n}\nexports.CaseInsensitiveTagMap = CaseInsensitiveTagMap;\n//# sourceMappingURL=CaseInsensitiveTagMap.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvY29tbW9uL0Nhc2VJbnNlbnNpdGl2ZVRhZ01hcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0IsMkJBQTJCLG1CQUFPLENBQUMsNEdBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvY29tbW9uL0Nhc2VJbnNlbnNpdGl2ZVRhZ01hcC5qcz8zY2UxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DYXNlSW5zZW5zaXRpdmVUYWdNYXAgPSB2b2lkIDA7XG5jb25zdCBHZW5lcmljVGFnTWFwcGVyXzEgPSByZXF1aXJlKFwiLi9HZW5lcmljVGFnTWFwcGVyXCIpO1xuY2xhc3MgQ2FzZUluc2Vuc2l0aXZlVGFnTWFwIGV4dGVuZHMgR2VuZXJpY1RhZ01hcHBlcl8xLkNvbW1vblRhZ01hcHBlciB7XG4gICAgY29uc3RydWN0b3IodGFnVHlwZXMsIHRhZ01hcCkge1xuICAgICAgICBjb25zdCB1cHBlckNhc2VNYXAgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgT2JqZWN0LmtleXModGFnTWFwKSkge1xuICAgICAgICAgICAgdXBwZXJDYXNlTWFwW3RhZy50b1VwcGVyQ2FzZSgpXSA9IHRhZ01hcFt0YWddO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHRhZ1R5cGVzLCB1cHBlckNhc2VNYXApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGFnICBOYXRpdmUgaGVhZGVyIHRhZ1xuICAgICAqIEByZXR1cm4gY29tbW9uIHRhZyBuYW1lIChhbGlhcylcbiAgICAgKi9cbiAgICBnZXRDb21tb25OYW1lKHRhZykge1xuICAgICAgICByZXR1cm4gdGhpcy50YWdNYXBbdGFnLnRvVXBwZXJDYXNlKCldO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FzZUluc2Vuc2l0aXZlVGFnTWFwID0gQ2FzZUluc2Vuc2l0aXZlVGFnTWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FzZUluc2Vuc2l0aXZlVGFnTWFwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/common/CombinedTagMapper.js":
/*!*********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/CombinedTagMapper.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CombinedTagMapper = void 0;\nconst ID3v1TagMap_1 = __webpack_require__(/*! ../id3v1/ID3v1TagMap */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v1/ID3v1TagMap.js\");\nconst ID3v24TagMapper_1 = __webpack_require__(/*! ../id3v2/ID3v24TagMapper */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v24TagMapper.js\");\nconst AsfTagMapper_1 = __webpack_require__(/*! ../asf/AsfTagMapper */ \"(app-pages-browser)/./node_modules/music-metadata/lib/asf/AsfTagMapper.js\");\nconst ID3v22TagMapper_1 = __webpack_require__(/*! ../id3v2/ID3v22TagMapper */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v22TagMapper.js\");\nconst APEv2TagMapper_1 = __webpack_require__(/*! ../apev2/APEv2TagMapper */ \"(app-pages-browser)/./node_modules/music-metadata/lib/apev2/APEv2TagMapper.js\");\nconst MP4TagMapper_1 = __webpack_require__(/*! ../mp4/MP4TagMapper */ \"(app-pages-browser)/./node_modules/music-metadata/lib/mp4/MP4TagMapper.js\");\nconst VorbisTagMapper_1 = __webpack_require__(/*! ../ogg/vorbis/VorbisTagMapper */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/VorbisTagMapper.js\");\nconst RiffInfoTagMap_1 = __webpack_require__(/*! ../riff/RiffInfoTagMap */ \"(app-pages-browser)/./node_modules/music-metadata/lib/riff/RiffInfoTagMap.js\");\nconst MatroskaTagMapper_1 = __webpack_require__(/*! ../matroska/MatroskaTagMapper */ \"(app-pages-browser)/./node_modules/music-metadata/lib/matroska/MatroskaTagMapper.js\");\nconst AiffTagMap_1 = __webpack_require__(/*! ../aiff/AiffTagMap */ \"(app-pages-browser)/./node_modules/music-metadata/lib/aiff/AiffTagMap.js\");\nclass CombinedTagMapper {\n    constructor() {\n        this.tagMappers = {};\n        [\n            new ID3v1TagMap_1.ID3v1TagMapper(),\n            new ID3v22TagMapper_1.ID3v22TagMapper(),\n            new ID3v24TagMapper_1.ID3v24TagMapper(),\n            new MP4TagMapper_1.MP4TagMapper(),\n            new MP4TagMapper_1.MP4TagMapper(),\n            new VorbisTagMapper_1.VorbisTagMapper(),\n            new APEv2TagMapper_1.APEv2TagMapper(),\n            new AsfTagMapper_1.AsfTagMapper(),\n            new RiffInfoTagMap_1.RiffInfoTagMapper(),\n            new MatroskaTagMapper_1.MatroskaTagMapper(),\n            new AiffTagMap_1.AiffTagMapper()\n        ].forEach(mapper => {\n            this.registerTagMapper(mapper);\n        });\n    }\n    /**\n     * Convert native to generic (common) tags\n     * @param tagType Originating tag format\n     * @param tag     Native tag to map to a generic tag id\n     * @param warnings\n     * @return Generic tag result (output of this function)\n     */\n    mapTag(tagType, tag, warnings) {\n        const tagMapper = this.tagMappers[tagType];\n        if (tagMapper) {\n            return this.tagMappers[tagType].mapGenericTag(tag, warnings);\n        }\n        throw new Error('No generic tag mapper defined for tag-format: ' + tagType);\n    }\n    registerTagMapper(genericTagMapper) {\n        for (const tagType of genericTagMapper.tagTypes) {\n            this.tagMappers[tagType] = genericTagMapper;\n        }\n    }\n}\nexports.CombinedTagMapper = CombinedTagMapper;\n//# sourceMappingURL=CombinedTagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvY29tbW9uL0NvbWJpbmVkVGFnTWFwcGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QixzQkFBc0IsbUJBQU8sQ0FBQyx3R0FBc0I7QUFDcEQsMEJBQTBCLG1CQUFPLENBQUMsZ0hBQTBCO0FBQzVELHVCQUF1QixtQkFBTyxDQUFDLHNHQUFxQjtBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQyxnSEFBMEI7QUFDNUQseUJBQXlCLG1CQUFPLENBQUMsOEdBQXlCO0FBQzFELHVCQUF1QixtQkFBTyxDQUFDLHNHQUFxQjtBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQywwSEFBK0I7QUFDakUseUJBQXlCLG1CQUFPLENBQUMsNEdBQXdCO0FBQ3pELDRCQUE0QixtQkFBTyxDQUFDLDBIQUErQjtBQUNuRSxxQkFBcUIsbUJBQU8sQ0FBQyxvR0FBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9jb21tb24vQ29tYmluZWRUYWdNYXBwZXIuanM/MDQ3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tYmluZWRUYWdNYXBwZXIgPSB2b2lkIDA7XG5jb25zdCBJRDN2MVRhZ01hcF8xID0gcmVxdWlyZShcIi4uL2lkM3YxL0lEM3YxVGFnTWFwXCIpO1xuY29uc3QgSUQzdjI0VGFnTWFwcGVyXzEgPSByZXF1aXJlKFwiLi4vaWQzdjIvSUQzdjI0VGFnTWFwcGVyXCIpO1xuY29uc3QgQXNmVGFnTWFwcGVyXzEgPSByZXF1aXJlKFwiLi4vYXNmL0FzZlRhZ01hcHBlclwiKTtcbmNvbnN0IElEM3YyMlRhZ01hcHBlcl8xID0gcmVxdWlyZShcIi4uL2lkM3YyL0lEM3YyMlRhZ01hcHBlclwiKTtcbmNvbnN0IEFQRXYyVGFnTWFwcGVyXzEgPSByZXF1aXJlKFwiLi4vYXBldjIvQVBFdjJUYWdNYXBwZXJcIik7XG5jb25zdCBNUDRUYWdNYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9tcDQvTVA0VGFnTWFwcGVyXCIpO1xuY29uc3QgVm9yYmlzVGFnTWFwcGVyXzEgPSByZXF1aXJlKFwiLi4vb2dnL3ZvcmJpcy9Wb3JiaXNUYWdNYXBwZXJcIik7XG5jb25zdCBSaWZmSW5mb1RhZ01hcF8xID0gcmVxdWlyZShcIi4uL3JpZmYvUmlmZkluZm9UYWdNYXBcIik7XG5jb25zdCBNYXRyb3NrYVRhZ01hcHBlcl8xID0gcmVxdWlyZShcIi4uL21hdHJvc2thL01hdHJvc2thVGFnTWFwcGVyXCIpO1xuY29uc3QgQWlmZlRhZ01hcF8xID0gcmVxdWlyZShcIi4uL2FpZmYvQWlmZlRhZ01hcFwiKTtcbmNsYXNzIENvbWJpbmVkVGFnTWFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50YWdNYXBwZXJzID0ge307XG4gICAgICAgIFtcbiAgICAgICAgICAgIG5ldyBJRDN2MVRhZ01hcF8xLklEM3YxVGFnTWFwcGVyKCksXG4gICAgICAgICAgICBuZXcgSUQzdjIyVGFnTWFwcGVyXzEuSUQzdjIyVGFnTWFwcGVyKCksXG4gICAgICAgICAgICBuZXcgSUQzdjI0VGFnTWFwcGVyXzEuSUQzdjI0VGFnTWFwcGVyKCksXG4gICAgICAgICAgICBuZXcgTVA0VGFnTWFwcGVyXzEuTVA0VGFnTWFwcGVyKCksXG4gICAgICAgICAgICBuZXcgTVA0VGFnTWFwcGVyXzEuTVA0VGFnTWFwcGVyKCksXG4gICAgICAgICAgICBuZXcgVm9yYmlzVGFnTWFwcGVyXzEuVm9yYmlzVGFnTWFwcGVyKCksXG4gICAgICAgICAgICBuZXcgQVBFdjJUYWdNYXBwZXJfMS5BUEV2MlRhZ01hcHBlcigpLFxuICAgICAgICAgICAgbmV3IEFzZlRhZ01hcHBlcl8xLkFzZlRhZ01hcHBlcigpLFxuICAgICAgICAgICAgbmV3IFJpZmZJbmZvVGFnTWFwXzEuUmlmZkluZm9UYWdNYXBwZXIoKSxcbiAgICAgICAgICAgIG5ldyBNYXRyb3NrYVRhZ01hcHBlcl8xLk1hdHJvc2thVGFnTWFwcGVyKCksXG4gICAgICAgICAgICBuZXcgQWlmZlRhZ01hcF8xLkFpZmZUYWdNYXBwZXIoKVxuICAgICAgICBdLmZvckVhY2gobWFwcGVyID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJUYWdNYXBwZXIobWFwcGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgbmF0aXZlIHRvIGdlbmVyaWMgKGNvbW1vbikgdGFnc1xuICAgICAqIEBwYXJhbSB0YWdUeXBlIE9yaWdpbmF0aW5nIHRhZyBmb3JtYXRcbiAgICAgKiBAcGFyYW0gdGFnICAgICBOYXRpdmUgdGFnIHRvIG1hcCB0byBhIGdlbmVyaWMgdGFnIGlkXG4gICAgICogQHBhcmFtIHdhcm5pbmdzXG4gICAgICogQHJldHVybiBHZW5lcmljIHRhZyByZXN1bHQgKG91dHB1dCBvZiB0aGlzIGZ1bmN0aW9uKVxuICAgICAqL1xuICAgIG1hcFRhZyh0YWdUeXBlLCB0YWcsIHdhcm5pbmdzKSB7XG4gICAgICAgIGNvbnN0IHRhZ01hcHBlciA9IHRoaXMudGFnTWFwcGVyc1t0YWdUeXBlXTtcbiAgICAgICAgaWYgKHRhZ01hcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFnTWFwcGVyc1t0YWdUeXBlXS5tYXBHZW5lcmljVGFnKHRhZywgd2FybmluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZ2VuZXJpYyB0YWcgbWFwcGVyIGRlZmluZWQgZm9yIHRhZy1mb3JtYXQ6ICcgKyB0YWdUeXBlKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJUYWdNYXBwZXIoZ2VuZXJpY1RhZ01hcHBlcikge1xuICAgICAgICBmb3IgKGNvbnN0IHRhZ1R5cGUgb2YgZ2VuZXJpY1RhZ01hcHBlci50YWdUeXBlcykge1xuICAgICAgICAgICAgdGhpcy50YWdNYXBwZXJzW3RhZ1R5cGVdID0gZ2VuZXJpY1RhZ01hcHBlcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29tYmluZWRUYWdNYXBwZXIgPSBDb21iaW5lZFRhZ01hcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbWJpbmVkVGFnTWFwcGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/common/CombinedTagMapper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/common/FourCC.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/FourCC.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FourCcToken = void 0;\nconst util = __webpack_require__(/*! ./Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\nconst validFourCC = /^[\\x21-\\x7e©][\\x20-\\x7e\\x00()]{3}/;\n/**\n * Token for read FourCC\n * Ref: https://en.wikipedia.org/wiki/FourCC\n */\nexports.FourCcToken = {\n    len: 4,\n    get: (buf, off) => {\n        const id = buf.toString('binary', off, off + exports.FourCcToken.len);\n        if (!id.match(validFourCC)) {\n            throw new Error(`FourCC contains invalid characters: ${util.a2hex(id)} \"${id}\"`);\n        }\n        return id;\n    },\n    put: (buffer, offset, id) => {\n        const str = Buffer.from(id, 'binary');\n        if (str.length !== 4)\n            throw new Error('Invalid length');\n        return str.copy(buffer, offset);\n    }\n};\n//# sourceMappingURL=FourCC.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvY29tbW9uL0ZvdXJDQy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLGFBQWEsbUJBQU8sQ0FBQyxvRkFBUTtBQUM3QixvREFBb0QsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxnQkFBZ0IsR0FBRyxHQUFHO0FBQ3pGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9jb21tb24vRm91ckNDLmpzPzA1MzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZvdXJDY1Rva2VuID0gdm9pZCAwO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuL1V0aWxcIik7XG5jb25zdCB2YWxpZEZvdXJDQyA9IC9eW1xceDIxLVxceDdlwqldW1xceDIwLVxceDdlXFx4MDAoKV17M30vO1xuLyoqXG4gKiBUb2tlbiBmb3IgcmVhZCBGb3VyQ0NcbiAqIFJlZjogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRm91ckNDXG4gKi9cbmV4cG9ydHMuRm91ckNjVG9rZW4gPSB7XG4gICAgbGVuOiA0LFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gYnVmLnRvU3RyaW5nKCdiaW5hcnknLCBvZmYsIG9mZiArIGV4cG9ydHMuRm91ckNjVG9rZW4ubGVuKTtcbiAgICAgICAgaWYgKCFpZC5tYXRjaCh2YWxpZEZvdXJDQykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm91ckNDIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyczogJHt1dGlsLmEyaGV4KGlkKX0gXCIke2lkfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG4gICAgcHV0OiAoYnVmZmVyLCBvZmZzZXQsIGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0ciA9IEJ1ZmZlci5mcm9tKGlkLCAnYmluYXJ5Jyk7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoICE9PSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxlbmd0aCcpO1xuICAgICAgICByZXR1cm4gc3RyLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gb3VyQ0MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/common/FourCC.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/common/GenericTagMapper.js":
/*!********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/GenericTagMapper.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CommonTagMapper = void 0;\nclass CommonTagMapper {\n    static toIntOrNull(str) {\n        const cleaned = parseInt(str, 10);\n        return isNaN(cleaned) ? null : cleaned;\n    }\n    // TODO: a string of 1of1 would fail to be converted\n    // converts 1/10 to no : 1, of : 10\n    // or 1 to no : 1, of : 0\n    static normalizeTrack(origVal) {\n        const split = origVal.toString().split('/');\n        return {\n            no: parseInt(split[0], 10) || null,\n            of: parseInt(split[1], 10) || null\n        };\n    }\n    constructor(tagTypes, tagMap) {\n        this.tagTypes = tagTypes;\n        this.tagMap = tagMap;\n    }\n    /**\n     * Process and set common tags\n     * write common tags to\n     * @param tag Native tag\n     * @param warnings Register warnings\n     * @return common name\n     */\n    mapGenericTag(tag, warnings) {\n        tag = { id: tag.id, value: tag.value }; // clone object\n        this.postMap(tag, warnings);\n        // Convert native tag event to generic 'alias' tag\n        const id = this.getCommonName(tag.id);\n        return id ? { id, value: tag.value } : null;\n    }\n    /**\n     * Convert native tag key to common tag key\n     * @tag  Native header tag\n     * @return common tag name (alias)\n     */\n    getCommonName(tag) {\n        return this.tagMap[tag];\n    }\n    /**\n     * Handle post mapping exceptions / correction\n     * @param tag Tag e.g. {\"©alb\", \"Buena Vista Social Club\")\n     * @param warnings Used to register warnings\n     */\n    postMap(tag, warnings) {\n        return;\n    }\n}\nCommonTagMapper.maxRatingScore = 1;\nexports.CommonTagMapper = CommonTagMapper;\n//# sourceMappingURL=GenericTagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvY29tbW9uL0dlbmVyaWNUYWdNYXBwZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvY29tbW9uL0dlbmVyaWNUYWdNYXBwZXIuanM/MDFlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tbW9uVGFnTWFwcGVyID0gdm9pZCAwO1xuY2xhc3MgQ29tbW9uVGFnTWFwcGVyIHtcbiAgICBzdGF0aWMgdG9JbnRPck51bGwoc3RyKSB7XG4gICAgICAgIGNvbnN0IGNsZWFuZWQgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgICAgICAgcmV0dXJuIGlzTmFOKGNsZWFuZWQpID8gbnVsbCA6IGNsZWFuZWQ7XG4gICAgfVxuICAgIC8vIFRPRE86IGEgc3RyaW5nIG9mIDFvZjEgd291bGQgZmFpbCB0byBiZSBjb252ZXJ0ZWRcbiAgICAvLyBjb252ZXJ0cyAxLzEwIHRvIG5vIDogMSwgb2YgOiAxMFxuICAgIC8vIG9yIDEgdG8gbm8gOiAxLCBvZiA6IDBcbiAgICBzdGF0aWMgbm9ybWFsaXplVHJhY2sob3JpZ1ZhbCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IG9yaWdWYWwudG9TdHJpbmcoKS5zcGxpdCgnLycpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm86IHBhcnNlSW50KHNwbGl0WzBdLCAxMCkgfHwgbnVsbCxcbiAgICAgICAgICAgIG9mOiBwYXJzZUludChzcGxpdFsxXSwgMTApIHx8IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodGFnVHlwZXMsIHRhZ01hcCkge1xuICAgICAgICB0aGlzLnRhZ1R5cGVzID0gdGFnVHlwZXM7XG4gICAgICAgIHRoaXMudGFnTWFwID0gdGFnTWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGFuZCBzZXQgY29tbW9uIHRhZ3NcbiAgICAgKiB3cml0ZSBjb21tb24gdGFncyB0b1xuICAgICAqIEBwYXJhbSB0YWcgTmF0aXZlIHRhZ1xuICAgICAqIEBwYXJhbSB3YXJuaW5ncyBSZWdpc3RlciB3YXJuaW5nc1xuICAgICAqIEByZXR1cm4gY29tbW9uIG5hbWVcbiAgICAgKi9cbiAgICBtYXBHZW5lcmljVGFnKHRhZywgd2FybmluZ3MpIHtcbiAgICAgICAgdGFnID0geyBpZDogdGFnLmlkLCB2YWx1ZTogdGFnLnZhbHVlIH07IC8vIGNsb25lIG9iamVjdFxuICAgICAgICB0aGlzLnBvc3RNYXAodGFnLCB3YXJuaW5ncyk7XG4gICAgICAgIC8vIENvbnZlcnQgbmF0aXZlIHRhZyBldmVudCB0byBnZW5lcmljICdhbGlhcycgdGFnXG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5nZXRDb21tb25OYW1lKHRhZy5pZCk7XG4gICAgICAgIHJldHVybiBpZCA/IHsgaWQsIHZhbHVlOiB0YWcudmFsdWUgfSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgbmF0aXZlIHRhZyBrZXkgdG8gY29tbW9uIHRhZyBrZXlcbiAgICAgKiBAdGFnICBOYXRpdmUgaGVhZGVyIHRhZ1xuICAgICAqIEByZXR1cm4gY29tbW9uIHRhZyBuYW1lIChhbGlhcylcbiAgICAgKi9cbiAgICBnZXRDb21tb25OYW1lKHRhZykge1xuICAgICAgICByZXR1cm4gdGhpcy50YWdNYXBbdGFnXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHBvc3QgbWFwcGluZyBleGNlcHRpb25zIC8gY29ycmVjdGlvblxuICAgICAqIEBwYXJhbSB0YWcgVGFnIGUuZy4ge1wiwqlhbGJcIiwgXCJCdWVuYSBWaXN0YSBTb2NpYWwgQ2x1YlwiKVxuICAgICAqIEBwYXJhbSB3YXJuaW5ncyBVc2VkIHRvIHJlZ2lzdGVyIHdhcm5pbmdzXG4gICAgICovXG4gICAgcG9zdE1hcCh0YWcsIHdhcm5pbmdzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5Db21tb25UYWdNYXBwZXIubWF4UmF0aW5nU2NvcmUgPSAxO1xuZXhwb3J0cy5Db21tb25UYWdNYXBwZXIgPSBDb21tb25UYWdNYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HZW5lcmljVGFnTWFwcGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/common/GenericTagMapper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/common/GenericTagTypes.js":
/*!*******************************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/GenericTagTypes.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isUnique = exports.isSingleton = exports.commonTags = void 0;\nexports.commonTags = {\n    year: { multiple: false },\n    track: { multiple: false },\n    disk: { multiple: false },\n    title: { multiple: false },\n    artist: { multiple: false },\n    artists: { multiple: true, unique: true },\n    albumartist: { multiple: false },\n    album: { multiple: false },\n    date: { multiple: false },\n    originaldate: { multiple: false },\n    originalyear: { multiple: false },\n    comment: { multiple: true, unique: false },\n    genre: { multiple: true, unique: true },\n    picture: { multiple: true, unique: true },\n    composer: { multiple: true, unique: true },\n    lyrics: { multiple: true, unique: false },\n    albumsort: { multiple: false, unique: true },\n    titlesort: { multiple: false, unique: true },\n    work: { multiple: false, unique: true },\n    artistsort: { multiple: false, unique: true },\n    albumartistsort: { multiple: false, unique: true },\n    composersort: { multiple: false, unique: true },\n    lyricist: { multiple: true, unique: true },\n    writer: { multiple: true, unique: true },\n    conductor: { multiple: true, unique: true },\n    remixer: { multiple: true, unique: true },\n    arranger: { multiple: true, unique: true },\n    engineer: { multiple: true, unique: true },\n    producer: { multiple: true, unique: true },\n    technician: { multiple: true, unique: true },\n    djmixer: { multiple: true, unique: true },\n    mixer: { multiple: true, unique: true },\n    label: { multiple: true, unique: true },\n    grouping: { multiple: false },\n    subtitle: { multiple: true },\n    discsubtitle: { multiple: false },\n    totaltracks: { multiple: false },\n    totaldiscs: { multiple: false },\n    compilation: { multiple: false },\n    rating: { multiple: true },\n    bpm: { multiple: false },\n    mood: { multiple: false },\n    media: { multiple: false },\n    catalognumber: { multiple: true, unique: true },\n    tvShow: { multiple: false },\n    tvShowSort: { multiple: false },\n    tvSeason: { multiple: false },\n    tvEpisode: { multiple: false },\n    tvEpisodeId: { multiple: false },\n    tvNetwork: { multiple: false },\n    podcast: { multiple: false },\n    podcasturl: { multiple: false },\n    releasestatus: { multiple: false },\n    releasetype: { multiple: true },\n    releasecountry: { multiple: false },\n    script: { multiple: false },\n    language: { multiple: false },\n    copyright: { multiple: false },\n    license: { multiple: false },\n    encodedby: { multiple: false },\n    encodersettings: { multiple: false },\n    gapless: { multiple: false },\n    barcode: { multiple: false },\n    isrc: { multiple: true },\n    asin: { multiple: false },\n    musicbrainz_recordingid: { multiple: false },\n    musicbrainz_trackid: { multiple: false },\n    musicbrainz_albumid: { multiple: false },\n    musicbrainz_artistid: { multiple: true },\n    musicbrainz_albumartistid: { multiple: true },\n    musicbrainz_releasegroupid: { multiple: false },\n    musicbrainz_workid: { multiple: false },\n    musicbrainz_trmid: { multiple: false },\n    musicbrainz_discid: { multiple: false },\n    acoustid_id: { multiple: false },\n    acoustid_fingerprint: { multiple: false },\n    musicip_puid: { multiple: false },\n    musicip_fingerprint: { multiple: false },\n    website: { multiple: false },\n    'performer:instrument': { multiple: true, unique: true },\n    averageLevel: { multiple: false },\n    peakLevel: { multiple: false },\n    notes: { multiple: true, unique: false },\n    key: { multiple: false },\n    originalalbum: { multiple: false },\n    originalartist: { multiple: false },\n    discogs_artist_id: { multiple: true, unique: true },\n    discogs_release_id: { multiple: false },\n    discogs_label_id: { multiple: false },\n    discogs_master_release_id: { multiple: false },\n    discogs_votes: { multiple: false },\n    discogs_rating: { multiple: false },\n    replaygain_track_peak: { multiple: false },\n    replaygain_track_gain: { multiple: false },\n    replaygain_album_peak: { multiple: false },\n    replaygain_album_gain: { multiple: false },\n    replaygain_track_minmax: { multiple: false },\n    replaygain_album_minmax: { multiple: false },\n    replaygain_undo: { multiple: false },\n    description: { multiple: true },\n    longDescription: { multiple: false },\n    category: { multiple: true },\n    hdVideo: { multiple: false },\n    keywords: { multiple: true },\n    movement: { multiple: false },\n    movementIndex: { multiple: false },\n    movementTotal: { multiple: false },\n    podcastId: { multiple: false },\n    showMovement: { multiple: false },\n    stik: { multiple: false }\n};\n/**\n * @param alias Name of common tag\n * @returns {boolean|*} true if given alias is mapped as a singleton', otherwise false\n */\nfunction isSingleton(alias) {\n    return exports.commonTags.hasOwnProperty(alias) && !exports.commonTags[alias].multiple;\n}\nexports.isSingleton = isSingleton;\n/**\n * @param alias Common (generic) tag\n * @returns {boolean|*} true if given alias is a singleton or explicitly marked as unique\n */\nfunction isUnique(alias) {\n    return !exports.commonTags[alias].multiple || exports.commonTags[alias].unique;\n}\nexports.isUnique = isUnique;\n//# sourceMappingURL=GenericTagTypes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvY29tbW9uL0dlbmVyaWNUYWdUeXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0I7QUFDM0Qsa0JBQWtCO0FBQ2xCLFlBQVksaUJBQWlCO0FBQzdCLGFBQWEsaUJBQWlCO0FBQzlCLFlBQVksaUJBQWlCO0FBQzdCLGFBQWEsaUJBQWlCO0FBQzlCLGNBQWMsaUJBQWlCO0FBQy9CLGVBQWUsOEJBQThCO0FBQzdDLG1CQUFtQixpQkFBaUI7QUFDcEMsYUFBYSxpQkFBaUI7QUFDOUIsWUFBWSxpQkFBaUI7QUFDN0Isb0JBQW9CLGlCQUFpQjtBQUNyQyxvQkFBb0IsaUJBQWlCO0FBQ3JDLGVBQWUsK0JBQStCO0FBQzlDLGFBQWEsOEJBQThCO0FBQzNDLGVBQWUsOEJBQThCO0FBQzdDLGdCQUFnQiw4QkFBOEI7QUFDOUMsY0FBYywrQkFBK0I7QUFDN0MsaUJBQWlCLCtCQUErQjtBQUNoRCxpQkFBaUIsK0JBQStCO0FBQ2hELFlBQVksK0JBQStCO0FBQzNDLGtCQUFrQiwrQkFBK0I7QUFDakQsdUJBQXVCLCtCQUErQjtBQUN0RCxvQkFBb0IsK0JBQStCO0FBQ25ELGdCQUFnQiw4QkFBOEI7QUFDOUMsY0FBYyw4QkFBOEI7QUFDNUMsaUJBQWlCLDhCQUE4QjtBQUMvQyxlQUFlLDhCQUE4QjtBQUM3QyxnQkFBZ0IsOEJBQThCO0FBQzlDLGdCQUFnQiw4QkFBOEI7QUFDOUMsZ0JBQWdCLDhCQUE4QjtBQUM5QyxrQkFBa0IsOEJBQThCO0FBQ2hELGVBQWUsOEJBQThCO0FBQzdDLGFBQWEsOEJBQThCO0FBQzNDLGFBQWEsOEJBQThCO0FBQzNDLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGdCQUFnQjtBQUNoQyxvQkFBb0IsaUJBQWlCO0FBQ3JDLG1CQUFtQixpQkFBaUI7QUFDcEMsa0JBQWtCLGlCQUFpQjtBQUNuQyxtQkFBbUIsaUJBQWlCO0FBQ3BDLGNBQWMsZ0JBQWdCO0FBQzlCLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVksaUJBQWlCO0FBQzdCLGFBQWEsaUJBQWlCO0FBQzlCLHFCQUFxQiw4QkFBOEI7QUFDbkQsY0FBYyxpQkFBaUI7QUFDL0Isa0JBQWtCLGlCQUFpQjtBQUNuQyxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGlCQUFpQixpQkFBaUI7QUFDbEMsbUJBQW1CLGlCQUFpQjtBQUNwQyxpQkFBaUIsaUJBQWlCO0FBQ2xDLGVBQWUsaUJBQWlCO0FBQ2hDLGtCQUFrQixpQkFBaUI7QUFDbkMscUJBQXFCLGlCQUFpQjtBQUN0QyxtQkFBbUIsZ0JBQWdCO0FBQ25DLHNCQUFzQixpQkFBaUI7QUFDdkMsY0FBYyxpQkFBaUI7QUFDL0IsZ0JBQWdCLGlCQUFpQjtBQUNqQyxpQkFBaUIsaUJBQWlCO0FBQ2xDLGVBQWUsaUJBQWlCO0FBQ2hDLGlCQUFpQixpQkFBaUI7QUFDbEMsdUJBQXVCLGlCQUFpQjtBQUN4QyxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGlCQUFpQjtBQUNoQyxZQUFZLGdCQUFnQjtBQUM1QixZQUFZLGlCQUFpQjtBQUM3QiwrQkFBK0IsaUJBQWlCO0FBQ2hELDJCQUEyQixpQkFBaUI7QUFDNUMsMkJBQTJCLGlCQUFpQjtBQUM1Qyw0QkFBNEIsZ0JBQWdCO0FBQzVDLGlDQUFpQyxnQkFBZ0I7QUFDakQsa0NBQWtDLGlCQUFpQjtBQUNuRCwwQkFBMEIsaUJBQWlCO0FBQzNDLHlCQUF5QixpQkFBaUI7QUFDMUMsMEJBQTBCLGlCQUFpQjtBQUMzQyxtQkFBbUIsaUJBQWlCO0FBQ3BDLDRCQUE0QixpQkFBaUI7QUFDN0Msb0JBQW9CLGlCQUFpQjtBQUNyQywyQkFBMkIsaUJBQWlCO0FBQzVDLGVBQWUsaUJBQWlCO0FBQ2hDLDhCQUE4Qiw4QkFBOEI7QUFDNUQsb0JBQW9CLGlCQUFpQjtBQUNyQyxpQkFBaUIsaUJBQWlCO0FBQ2xDLGFBQWEsK0JBQStCO0FBQzVDLFdBQVcsaUJBQWlCO0FBQzVCLHFCQUFxQixpQkFBaUI7QUFDdEMsc0JBQXNCLGlCQUFpQjtBQUN2Qyx5QkFBeUIsOEJBQThCO0FBQ3ZELDBCQUEwQixpQkFBaUI7QUFDM0Msd0JBQXdCLGlCQUFpQjtBQUN6QyxpQ0FBaUMsaUJBQWlCO0FBQ2xELHFCQUFxQixpQkFBaUI7QUFDdEMsc0JBQXNCLGlCQUFpQjtBQUN2Qyw2QkFBNkIsaUJBQWlCO0FBQzlDLDZCQUE2QixpQkFBaUI7QUFDOUMsNkJBQTZCLGlCQUFpQjtBQUM5Qyw2QkFBNkIsaUJBQWlCO0FBQzlDLCtCQUErQixpQkFBaUI7QUFDaEQsK0JBQStCLGlCQUFpQjtBQUNoRCx1QkFBdUIsaUJBQWlCO0FBQ3hDLG1CQUFtQixnQkFBZ0I7QUFDbkMsdUJBQXVCLGlCQUFpQjtBQUN4QyxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDLGdCQUFnQixnQkFBZ0I7QUFDaEMsZ0JBQWdCLGlCQUFpQjtBQUNqQyxxQkFBcUIsaUJBQWlCO0FBQ3RDLHFCQUFxQixpQkFBaUI7QUFDdEMsaUJBQWlCLGlCQUFpQjtBQUNsQyxvQkFBb0IsaUJBQWlCO0FBQ3JDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvbW1vbi9HZW5lcmljVGFnVHlwZXMuanM/MDQyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNVbmlxdWUgPSBleHBvcnRzLmlzU2luZ2xldG9uID0gZXhwb3J0cy5jb21tb25UYWdzID0gdm9pZCAwO1xuZXhwb3J0cy5jb21tb25UYWdzID0ge1xuICAgIHllYXI6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgdHJhY2s6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgZGlzazogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICB0aXRsZTogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBhcnRpc3Q6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgYXJ0aXN0czogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgYWxidW1hcnRpc3Q6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgYWxidW06IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgZGF0ZTogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBvcmlnaW5hbGRhdGU6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgb3JpZ2luYWx5ZWFyOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIGNvbW1lbnQ6IHsgbXVsdGlwbGU6IHRydWUsIHVuaXF1ZTogZmFsc2UgfSxcbiAgICBnZW5yZTogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgcGljdHVyZTogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgY29tcG9zZXI6IHsgbXVsdGlwbGU6IHRydWUsIHVuaXF1ZTogdHJ1ZSB9LFxuICAgIGx5cmljczogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiBmYWxzZSB9LFxuICAgIGFsYnVtc29ydDogeyBtdWx0aXBsZTogZmFsc2UsIHVuaXF1ZTogdHJ1ZSB9LFxuICAgIHRpdGxlc29ydDogeyBtdWx0aXBsZTogZmFsc2UsIHVuaXF1ZTogdHJ1ZSB9LFxuICAgIHdvcms6IHsgbXVsdGlwbGU6IGZhbHNlLCB1bmlxdWU6IHRydWUgfSxcbiAgICBhcnRpc3Rzb3J0OiB7IG11bHRpcGxlOiBmYWxzZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgYWxidW1hcnRpc3Rzb3J0OiB7IG11bHRpcGxlOiBmYWxzZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgY29tcG9zZXJzb3J0OiB7IG11bHRpcGxlOiBmYWxzZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgbHlyaWNpc3Q6IHsgbXVsdGlwbGU6IHRydWUsIHVuaXF1ZTogdHJ1ZSB9LFxuICAgIHdyaXRlcjogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgY29uZHVjdG9yOiB7IG11bHRpcGxlOiB0cnVlLCB1bmlxdWU6IHRydWUgfSxcbiAgICByZW1peGVyOiB7IG11bHRpcGxlOiB0cnVlLCB1bmlxdWU6IHRydWUgfSxcbiAgICBhcnJhbmdlcjogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgZW5naW5lZXI6IHsgbXVsdGlwbGU6IHRydWUsIHVuaXF1ZTogdHJ1ZSB9LFxuICAgIHByb2R1Y2VyOiB7IG11bHRpcGxlOiB0cnVlLCB1bmlxdWU6IHRydWUgfSxcbiAgICB0ZWNobmljaWFuOiB7IG11bHRpcGxlOiB0cnVlLCB1bmlxdWU6IHRydWUgfSxcbiAgICBkam1peGVyOiB7IG11bHRpcGxlOiB0cnVlLCB1bmlxdWU6IHRydWUgfSxcbiAgICBtaXhlcjogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgbGFiZWw6IHsgbXVsdGlwbGU6IHRydWUsIHVuaXF1ZTogdHJ1ZSB9LFxuICAgIGdyb3VwaW5nOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHN1YnRpdGxlOiB7IG11bHRpcGxlOiB0cnVlIH0sXG4gICAgZGlzY3N1YnRpdGxlOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHRvdGFsdHJhY2tzOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHRvdGFsZGlzY3M6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgY29tcGlsYXRpb246IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgcmF0aW5nOiB7IG11bHRpcGxlOiB0cnVlIH0sXG4gICAgYnBtOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIG1vb2Q6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgbWVkaWE6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgY2F0YWxvZ251bWJlcjogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgdHZTaG93OiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHR2U2hvd1NvcnQ6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgdHZTZWFzb246IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgdHZFcGlzb2RlOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHR2RXBpc29kZUlkOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHR2TmV0d29yazogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBwb2RjYXN0OiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHBvZGNhc3R1cmw6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgcmVsZWFzZXN0YXR1czogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICByZWxlYXNldHlwZTogeyBtdWx0aXBsZTogdHJ1ZSB9LFxuICAgIHJlbGVhc2Vjb3VudHJ5OiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHNjcmlwdDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBsYW5ndWFnZTogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBjb3B5cmlnaHQ6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgbGljZW5zZTogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBlbmNvZGVkYnk6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgZW5jb2RlcnNldHRpbmdzOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIGdhcGxlc3M6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgYmFyY29kZTogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBpc3JjOiB7IG11bHRpcGxlOiB0cnVlIH0sXG4gICAgYXNpbjogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBtdXNpY2JyYWluel9yZWNvcmRpbmdpZDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBtdXNpY2JyYWluel90cmFja2lkOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIG11c2ljYnJhaW56X2FsYnVtaWQ6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgbXVzaWNicmFpbnpfYXJ0aXN0aWQ6IHsgbXVsdGlwbGU6IHRydWUgfSxcbiAgICBtdXNpY2JyYWluel9hbGJ1bWFydGlzdGlkOiB7IG11bHRpcGxlOiB0cnVlIH0sXG4gICAgbXVzaWNicmFpbnpfcmVsZWFzZWdyb3VwaWQ6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgbXVzaWNicmFpbnpfd29ya2lkOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIG11c2ljYnJhaW56X3RybWlkOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIG11c2ljYnJhaW56X2Rpc2NpZDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBhY291c3RpZF9pZDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBhY291c3RpZF9maW5nZXJwcmludDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBtdXNpY2lwX3B1aWQ6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgbXVzaWNpcF9maW5nZXJwcmludDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICB3ZWJzaXRlOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgICdwZXJmb3JtZXI6aW5zdHJ1bWVudCc6IHsgbXVsdGlwbGU6IHRydWUsIHVuaXF1ZTogdHJ1ZSB9LFxuICAgIGF2ZXJhZ2VMZXZlbDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBwZWFrTGV2ZWw6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgbm90ZXM6IHsgbXVsdGlwbGU6IHRydWUsIHVuaXF1ZTogZmFsc2UgfSxcbiAgICBrZXk6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgb3JpZ2luYWxhbGJ1bTogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBvcmlnaW5hbGFydGlzdDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBkaXNjb2dzX2FydGlzdF9pZDogeyBtdWx0aXBsZTogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gICAgZGlzY29nc19yZWxlYXNlX2lkOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIGRpc2NvZ3NfbGFiZWxfaWQ6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgZGlzY29nc19tYXN0ZXJfcmVsZWFzZV9pZDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBkaXNjb2dzX3ZvdGVzOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIGRpc2NvZ3NfcmF0aW5nOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHJlcGxheWdhaW5fdHJhY2tfcGVhazogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICByZXBsYXlnYWluX3RyYWNrX2dhaW46IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgcmVwbGF5Z2Fpbl9hbGJ1bV9wZWFrOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHJlcGxheWdhaW5fYWxidW1fZ2FpbjogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICByZXBsYXlnYWluX3RyYWNrX21pbm1heDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICByZXBsYXlnYWluX2FsYnVtX21pbm1heDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICByZXBsYXlnYWluX3VuZG86IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgZGVzY3JpcHRpb246IHsgbXVsdGlwbGU6IHRydWUgfSxcbiAgICBsb25nRGVzY3JpcHRpb246IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgY2F0ZWdvcnk6IHsgbXVsdGlwbGU6IHRydWUgfSxcbiAgICBoZFZpZGVvOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIGtleXdvcmRzOiB7IG11bHRpcGxlOiB0cnVlIH0sXG4gICAgbW92ZW1lbnQ6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgbW92ZW1lbnRJbmRleDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBtb3ZlbWVudFRvdGFsOiB7IG11bHRpcGxlOiBmYWxzZSB9LFxuICAgIHBvZGNhc3RJZDogeyBtdWx0aXBsZTogZmFsc2UgfSxcbiAgICBzaG93TW92ZW1lbnQ6IHsgbXVsdGlwbGU6IGZhbHNlIH0sXG4gICAgc3RpazogeyBtdWx0aXBsZTogZmFsc2UgfVxufTtcbi8qKlxuICogQHBhcmFtIGFsaWFzIE5hbWUgb2YgY29tbW9uIHRhZ1xuICogQHJldHVybnMge2Jvb2xlYW58Kn0gdHJ1ZSBpZiBnaXZlbiBhbGlhcyBpcyBtYXBwZWQgYXMgYSBzaW5nbGV0b24nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTaW5nbGV0b24oYWxpYXMpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5jb21tb25UYWdzLmhhc093blByb3BlcnR5KGFsaWFzKSAmJiAhZXhwb3J0cy5jb21tb25UYWdzW2FsaWFzXS5tdWx0aXBsZTtcbn1cbmV4cG9ydHMuaXNTaW5nbGV0b24gPSBpc1NpbmdsZXRvbjtcbi8qKlxuICogQHBhcmFtIGFsaWFzIENvbW1vbiAoZ2VuZXJpYykgdGFnXG4gKiBAcmV0dXJucyB7Ym9vbGVhbnwqfSB0cnVlIGlmIGdpdmVuIGFsaWFzIGlzIGEgc2luZ2xldG9uIG9yIGV4cGxpY2l0bHkgbWFya2VkIGFzIHVuaXF1ZVxuICovXG5mdW5jdGlvbiBpc1VuaXF1ZShhbGlhcykge1xuICAgIHJldHVybiAhZXhwb3J0cy5jb21tb25UYWdzW2FsaWFzXS5tdWx0aXBsZSB8fCBleHBvcnRzLmNvbW1vblRhZ3NbYWxpYXNdLnVuaXF1ZTtcbn1cbmV4cG9ydHMuaXNVbmlxdWUgPSBpc1VuaXF1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdlbmVyaWNUYWdUeXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/common/GenericTagTypes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/common/MetadataCollector.js":
/*!*********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/MetadataCollector.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.joinArtists = exports.MetadataCollector = void 0;\nconst type_1 = __webpack_require__(/*! ../type */ \"(app-pages-browser)/./node_modules/music-metadata/lib/type.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst GenericTagTypes_1 = __webpack_require__(/*! ./GenericTagTypes */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/GenericTagTypes.js\");\nconst CombinedTagMapper_1 = __webpack_require__(/*! ./CombinedTagMapper */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/CombinedTagMapper.js\");\nconst GenericTagMapper_1 = __webpack_require__(/*! ./GenericTagMapper */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/GenericTagMapper.js\");\nconst Util_1 = __webpack_require__(/*! ./Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\nconst FileType = __webpack_require__(/*! file-type/core */ \"(app-pages-browser)/./node_modules/file-type/core.js\");\nconst debug = (0, debug_1.default)('music-metadata:collector');\nconst TagPriority = ['matroska', 'APEv2', 'vorbis', 'ID3v2.4', 'ID3v2.3', 'ID3v2.2', 'exif', 'asf', 'iTunes', 'AIFF', 'ID3v1'];\n/**\n * Provided to the parser to uodate the metadata result.\n * Responsible for triggering async updates\n */\nclass MetadataCollector {\n    constructor(opts) {\n        this.opts = opts;\n        this.format = {\n            tagTypes: [],\n            trackInfo: []\n        };\n        this.native = {};\n        this.common = {\n            track: { no: null, of: null },\n            disk: { no: null, of: null },\n            movementIndex: {}\n        };\n        this.quality = {\n            warnings: []\n        };\n        /**\n         * Keeps track of origin priority for each mapped id\n         */\n        this.commonOrigin = {};\n        /**\n         * Maps a tag type to a priority\n         */\n        this.originPriority = {};\n        this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();\n        let priority = 1;\n        for (const tagType of TagPriority) {\n            this.originPriority[tagType] = priority++;\n        }\n        this.originPriority.artificial = 500; // Filled using alternative tags\n        this.originPriority.id3v1 = 600; // Consider as the worst because of the field length limit\n    }\n    /**\n     * @returns {boolean} true if one or more tags have been found\n     */\n    hasAny() {\n        return Object.keys(this.native).length > 0;\n    }\n    addStreamInfo(streamInfo) {\n        debug(`streamInfo: type=${type_1.TrackType[streamInfo.type]}, codec=${streamInfo.codecName}`);\n        this.format.trackInfo.push(streamInfo);\n    }\n    setFormat(key, value) {\n        debug(`format: ${key} = ${value}`);\n        this.format[key] = value; // as any to override readonly\n        if (this.opts.observer) {\n            this.opts.observer({ metadata: this, tag: { type: 'format', id: key, value } });\n        }\n    }\n    addTag(tagType, tagId, value) {\n        debug(`tag ${tagType}.${tagId} = ${value}`);\n        if (!this.native[tagType]) {\n            this.format.tagTypes.push(tagType);\n            this.native[tagType] = [];\n        }\n        this.native[tagType].push({ id: tagId, value });\n        this.toCommon(tagType, tagId, value);\n    }\n    addWarning(warning) {\n        this.quality.warnings.push({ message: warning });\n    }\n    postMap(tagType, tag) {\n        // Common tag (alias) found\n        // check if we need to do something special with common tag\n        // if the event has been aliased then we need to clean it before\n        // it is emitted to the user. e.g. genre (20) -> Electronic\n        switch (tag.id) {\n            case 'artist':\n                if (this.commonOrigin.artist === this.originPriority[tagType]) {\n                    // Assume the artist field is used as artists\n                    return this.postMap('artificial', { id: 'artists', value: tag.value });\n                }\n                if (!this.common.artists) {\n                    // Fill artists using artist source\n                    this.setGenericTag('artificial', { id: 'artists', value: tag.value });\n                }\n                break;\n            case 'artists':\n                if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {\n                    if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {\n                        // Fill artist using artists source\n                        const artists = (this.common.artists || []).concat([tag.value]);\n                        const value = joinArtists(artists);\n                        const artistTag = { id: 'artist', value };\n                        this.setGenericTag('artificial', artistTag);\n                    }\n                }\n                break;\n            case 'picture':\n                this.postFixPicture(tag.value).then(picture => {\n                    if (picture !== null) {\n                        tag.value = picture;\n                        this.setGenericTag(tagType, tag);\n                    }\n                });\n                return;\n            case 'totaltracks':\n                this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n                return;\n            case 'totaldiscs':\n                this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n                return;\n            case 'movementTotal':\n                this.common.movementIndex.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n                return;\n            case 'track':\n            case 'disk':\n            case 'movementIndex':\n                const of = this.common[tag.id].of; // store of value, maybe maybe overwritten\n                this.common[tag.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(tag.value);\n                this.common[tag.id].of = of != null ? of : this.common[tag.id].of;\n                return;\n            case 'bpm':\n            case 'year':\n            case 'originalyear':\n                tag.value = parseInt(tag.value, 10);\n                break;\n            case 'date':\n                // ToDo: be more strict on 'YYYY...'\n                const year = parseInt(tag.value.substr(0, 4), 10);\n                if (!isNaN(year)) {\n                    this.common.year = year;\n                }\n                break;\n            case 'discogs_label_id':\n            case 'discogs_release_id':\n            case 'discogs_master_release_id':\n            case 'discogs_artist_id':\n            case 'discogs_votes':\n                tag.value = typeof tag.value === 'string' ? parseInt(tag.value, 10) : tag.value;\n                break;\n            case 'replaygain_track_gain':\n            case 'replaygain_track_peak':\n            case 'replaygain_album_gain':\n            case 'replaygain_album_peak':\n                tag.value = (0, Util_1.toRatio)(tag.value);\n                break;\n            case 'replaygain_track_minmax':\n                tag.value = tag.value.split(',').map(v => parseInt(v, 10));\n                break;\n            case 'replaygain_undo':\n                const minMix = tag.value.split(',').map(v => parseInt(v, 10));\n                tag.value = {\n                    leftChannel: minMix[0],\n                    rightChannel: minMix[1]\n                };\n                break;\n            case 'gapless': // iTunes gap-less flag\n            case 'compilation':\n            case 'podcast':\n            case 'showMovement':\n                tag.value = tag.value === '1' || tag.value === 1; // boolean\n                break;\n            case 'isrc': // Only keep unique values\n                if (this.common[tag.id] && this.common[tag.id].indexOf(tag.value) !== -1)\n                    return;\n                break;\n            default:\n            // nothing to do\n        }\n        if (tag.value !== null) {\n            this.setGenericTag(tagType, tag);\n        }\n    }\n    /**\n     * Convert native tags to common tags\n     * @returns {IAudioMetadata} Native + common tags\n     */\n    toCommonMetadata() {\n        return {\n            format: this.format,\n            native: this.native,\n            quality: this.quality,\n            common: this.common\n        };\n    }\n    /**\n     * Fix some common issues with picture object\n     * @param picture Picture\n     */\n    async postFixPicture(picture) {\n        if (picture.data && picture.data.length > 0) {\n            if (!picture.format) {\n                const fileType = await FileType.fromBuffer(picture.data);\n                if (fileType) {\n                    picture.format = fileType.mime;\n                }\n                else {\n                    return null;\n                }\n            }\n            picture.format = picture.format.toLocaleLowerCase();\n            switch (picture.format) {\n                case 'image/jpg':\n                    picture.format = 'image/jpeg'; // ToDo: register warning\n            }\n            return picture;\n        }\n        this.addWarning(`Empty picture tag found`);\n        return null;\n    }\n    /**\n     * Convert native tag to common tags\n     */\n    toCommon(tagType, tagId, value) {\n        const tag = { id: tagId, value };\n        const genericTag = this.tagMapper.mapTag(tagType, tag, this);\n        if (genericTag) {\n            this.postMap(tagType, genericTag);\n        }\n    }\n    /**\n     * Set generic tag\n     */\n    setGenericTag(tagType, tag) {\n        debug(`common.${tag.id} = ${tag.value}`);\n        const prio0 = this.commonOrigin[tag.id] || 1000;\n        const prio1 = this.originPriority[tagType];\n        if ((0, GenericTagTypes_1.isSingleton)(tag.id)) {\n            if (prio1 <= prio0) {\n                this.common[tag.id] = tag.value;\n                this.commonOrigin[tag.id] = prio1;\n            }\n            else {\n                return debug(`Ignore native tag (singleton): ${tagType}.${tag.id} = ${tag.value}`);\n            }\n        }\n        else {\n            if (prio1 === prio0) {\n                if (!(0, GenericTagTypes_1.isUnique)(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {\n                    this.common[tag.id].push(tag.value);\n                }\n                else {\n                    debug(`Ignore duplicate value: ${tagType}.${tag.id} = ${tag.value}`);\n                }\n                // no effect? this.commonOrigin[tag.id] = prio1;\n            }\n            else if (prio1 < prio0) {\n                this.common[tag.id] = [tag.value];\n                this.commonOrigin[tag.id] = prio1;\n            }\n            else {\n                return debug(`Ignore native tag (list): ${tagType}.${tag.id} = ${tag.value}`);\n            }\n        }\n        if (this.opts.observer) {\n            this.opts.observer({ metadata: this, tag: { type: 'common', id: tag.id, value: tag.value } });\n        }\n        // ToDo: trigger metadata event\n    }\n}\nexports.MetadataCollector = MetadataCollector;\nfunction joinArtists(artists) {\n    if (artists.length > 2) {\n        return artists.slice(0, artists.length - 1).join(', ') + ' & ' + artists[artists.length - 1];\n    }\n    return artists.join(' & ');\n}\nexports.joinArtists = joinArtists;\n//# sourceMappingURL=MetadataCollector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvY29tbW9uL01ldGFkYXRhQ29sbGVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLHlCQUF5QjtBQUMvQyxlQUFlLG1CQUFPLENBQUMsOEVBQVM7QUFDaEMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQU87QUFDL0IsMEJBQTBCLG1CQUFPLENBQUMsMEdBQW1CO0FBQ3JELDRCQUE0QixtQkFBTyxDQUFDLDhHQUFxQjtBQUN6RCwyQkFBMkIsbUJBQU8sQ0FBQyw0R0FBb0I7QUFDdkQsZUFBZSxtQkFBTyxDQUFDLG9GQUFRO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLDRFQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQ0FBa0MsVUFBVSxxQkFBcUI7QUFDbkc7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQUssSUFBSSxNQUFNO0FBQ3hDLGtDQUFrQztBQUNsQztBQUNBLGlDQUFpQyx1QkFBdUIsa0NBQWtDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRLEdBQUcsT0FBTyxJQUFJLE1BQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsaUNBQWlDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxpQ0FBaUM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRLElBQUksVUFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFFBQVEsR0FBRyxRQUFRLElBQUksVUFBVTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFFBQVEsR0FBRyxRQUFRLElBQUksVUFBVTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFFBQVEsR0FBRyxRQUFRLElBQUksVUFBVTtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCLGdEQUFnRDtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9jb21tb24vTWV0YWRhdGFDb2xsZWN0b3IuanM/ZjJiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuam9pbkFydGlzdHMgPSBleHBvcnRzLk1ldGFkYXRhQ29sbGVjdG9yID0gdm9pZCAwO1xuY29uc3QgdHlwZV8xID0gcmVxdWlyZShcIi4uL3R5cGVcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgR2VuZXJpY1RhZ1R5cGVzXzEgPSByZXF1aXJlKFwiLi9HZW5lcmljVGFnVHlwZXNcIik7XG5jb25zdCBDb21iaW5lZFRhZ01hcHBlcl8xID0gcmVxdWlyZShcIi4vQ29tYmluZWRUYWdNYXBwZXJcIik7XG5jb25zdCBHZW5lcmljVGFnTWFwcGVyXzEgPSByZXF1aXJlKFwiLi9HZW5lcmljVGFnTWFwcGVyXCIpO1xuY29uc3QgVXRpbF8xID0gcmVxdWlyZShcIi4vVXRpbFwiKTtcbmNvbnN0IEZpbGVUeXBlID0gcmVxdWlyZShcImZpbGUtdHlwZS9jb3JlXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbXVzaWMtbWV0YWRhdGE6Y29sbGVjdG9yJyk7XG5jb25zdCBUYWdQcmlvcml0eSA9IFsnbWF0cm9za2EnLCAnQVBFdjInLCAndm9yYmlzJywgJ0lEM3YyLjQnLCAnSUQzdjIuMycsICdJRDN2Mi4yJywgJ2V4aWYnLCAnYXNmJywgJ2lUdW5lcycsICdBSUZGJywgJ0lEM3YxJ107XG4vKipcbiAqIFByb3ZpZGVkIHRvIHRoZSBwYXJzZXIgdG8gdW9kYXRlIHRoZSBtZXRhZGF0YSByZXN1bHQuXG4gKiBSZXNwb25zaWJsZSBmb3IgdHJpZ2dlcmluZyBhc3luYyB1cGRhdGVzXG4gKi9cbmNsYXNzIE1ldGFkYXRhQ29sbGVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuZm9ybWF0ID0ge1xuICAgICAgICAgICAgdGFnVHlwZXM6IFtdLFxuICAgICAgICAgICAgdHJhY2tJbmZvOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hdGl2ZSA9IHt9O1xuICAgICAgICB0aGlzLmNvbW1vbiA9IHtcbiAgICAgICAgICAgIHRyYWNrOiB7IG5vOiBudWxsLCBvZjogbnVsbCB9LFxuICAgICAgICAgICAgZGlzazogeyBubzogbnVsbCwgb2Y6IG51bGwgfSxcbiAgICAgICAgICAgIG1vdmVtZW50SW5kZXg6IHt9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucXVhbGl0eSA9IHtcbiAgICAgICAgICAgIHdhcm5pbmdzOiBbXVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2Ygb3JpZ2luIHByaW9yaXR5IGZvciBlYWNoIG1hcHBlZCBpZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb21tb25PcmlnaW4gPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcHMgYSB0YWcgdHlwZSB0byBhIHByaW9yaXR5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWdpblByaW9yaXR5ID0ge307XG4gICAgICAgIHRoaXMudGFnTWFwcGVyID0gbmV3IENvbWJpbmVkVGFnTWFwcGVyXzEuQ29tYmluZWRUYWdNYXBwZXIoKTtcbiAgICAgICAgbGV0IHByaW9yaXR5ID0gMTtcbiAgICAgICAgZm9yIChjb25zdCB0YWdUeXBlIG9mIFRhZ1ByaW9yaXR5KSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpblByaW9yaXR5W3RhZ1R5cGVdID0gcHJpb3JpdHkrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9yaWdpblByaW9yaXR5LmFydGlmaWNpYWwgPSA1MDA7IC8vIEZpbGxlZCB1c2luZyBhbHRlcm5hdGl2ZSB0YWdzXG4gICAgICAgIHRoaXMub3JpZ2luUHJpb3JpdHkuaWQzdjEgPSA2MDA7IC8vIENvbnNpZGVyIGFzIHRoZSB3b3JzdCBiZWNhdXNlIG9mIHRoZSBmaWVsZCBsZW5ndGggbGltaXRcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgb25lIG9yIG1vcmUgdGFncyBoYXZlIGJlZW4gZm91bmRcbiAgICAgKi9cbiAgICBoYXNBbnkoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm5hdGl2ZSkubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgYWRkU3RyZWFtSW5mbyhzdHJlYW1JbmZvKSB7XG4gICAgICAgIGRlYnVnKGBzdHJlYW1JbmZvOiB0eXBlPSR7dHlwZV8xLlRyYWNrVHlwZVtzdHJlYW1JbmZvLnR5cGVdfSwgY29kZWM9JHtzdHJlYW1JbmZvLmNvZGVjTmFtZX1gKTtcbiAgICAgICAgdGhpcy5mb3JtYXQudHJhY2tJbmZvLnB1c2goc3RyZWFtSW5mbyk7XG4gICAgfVxuICAgIHNldEZvcm1hdChrZXksIHZhbHVlKSB7XG4gICAgICAgIGRlYnVnKGBmb3JtYXQ6ICR7a2V5fSA9ICR7dmFsdWV9YCk7XG4gICAgICAgIHRoaXMuZm9ybWF0W2tleV0gPSB2YWx1ZTsgLy8gYXMgYW55IHRvIG92ZXJyaWRlIHJlYWRvbmx5XG4gICAgICAgIGlmICh0aGlzLm9wdHMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5vYnNlcnZlcih7IG1ldGFkYXRhOiB0aGlzLCB0YWc6IHsgdHlwZTogJ2Zvcm1hdCcsIGlkOiBrZXksIHZhbHVlIH0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVGFnKHRhZ1R5cGUsIHRhZ0lkLCB2YWx1ZSkge1xuICAgICAgICBkZWJ1ZyhgdGFnICR7dGFnVHlwZX0uJHt0YWdJZH0gPSAke3ZhbHVlfWApO1xuICAgICAgICBpZiAoIXRoaXMubmF0aXZlW3RhZ1R5cGVdKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdC50YWdUeXBlcy5wdXNoKHRhZ1R5cGUpO1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVbdGFnVHlwZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hdGl2ZVt0YWdUeXBlXS5wdXNoKHsgaWQ6IHRhZ0lkLCB2YWx1ZSB9KTtcbiAgICAgICAgdGhpcy50b0NvbW1vbih0YWdUeXBlLCB0YWdJZCwgdmFsdWUpO1xuICAgIH1cbiAgICBhZGRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgICAgICAgdGhpcy5xdWFsaXR5Lndhcm5pbmdzLnB1c2goeyBtZXNzYWdlOiB3YXJuaW5nIH0pO1xuICAgIH1cbiAgICBwb3N0TWFwKHRhZ1R5cGUsIHRhZykge1xuICAgICAgICAvLyBDb21tb24gdGFnIChhbGlhcykgZm91bmRcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBkbyBzb21ldGhpbmcgc3BlY2lhbCB3aXRoIGNvbW1vbiB0YWdcbiAgICAgICAgLy8gaWYgdGhlIGV2ZW50IGhhcyBiZWVuIGFsaWFzZWQgdGhlbiB3ZSBuZWVkIHRvIGNsZWFuIGl0IGJlZm9yZVxuICAgICAgICAvLyBpdCBpcyBlbWl0dGVkIHRvIHRoZSB1c2VyLiBlLmcuIGdlbnJlICgyMCkgLT4gRWxlY3Ryb25pY1xuICAgICAgICBzd2l0Y2ggKHRhZy5pZCkge1xuICAgICAgICAgICAgY2FzZSAnYXJ0aXN0JzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21tb25PcmlnaW4uYXJ0aXN0ID09PSB0aGlzLm9yaWdpblByaW9yaXR5W3RhZ1R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzc3VtZSB0aGUgYXJ0aXN0IGZpZWxkIGlzIHVzZWQgYXMgYXJ0aXN0c1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3N0TWFwKCdhcnRpZmljaWFsJywgeyBpZDogJ2FydGlzdHMnLCB2YWx1ZTogdGFnLnZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29tbW9uLmFydGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlsbCBhcnRpc3RzIHVzaW5nIGFydGlzdCBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRHZW5lcmljVGFnKCdhcnRpZmljaWFsJywgeyBpZDogJ2FydGlzdHMnLCB2YWx1ZTogdGFnLnZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FydGlzdHMnOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb21tb24uYXJ0aXN0IHx8IHRoaXMuY29tbW9uT3JpZ2luLmFydGlzdCA9PT0gdGhpcy5vcmlnaW5Qcmlvcml0eS5hcnRpZmljaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb21tb24uYXJ0aXN0cyB8fCB0aGlzLmNvbW1vbi5hcnRpc3RzLmluZGV4T2YodGFnLnZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbGwgYXJ0aXN0IHVzaW5nIGFydGlzdHMgc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnRpc3RzID0gKHRoaXMuY29tbW9uLmFydGlzdHMgfHwgW10pLmNvbmNhdChbdGFnLnZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGpvaW5BcnRpc3RzKGFydGlzdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJ0aXN0VGFnID0geyBpZDogJ2FydGlzdCcsIHZhbHVlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEdlbmVyaWNUYWcoJ2FydGlmaWNpYWwnLCBhcnRpc3RUYWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncGljdHVyZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5wb3N0Rml4UGljdHVyZSh0YWcudmFsdWUpLnRoZW4ocGljdHVyZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwaWN0dXJlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcudmFsdWUgPSBwaWN0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRHZW5lcmljVGFnKHRhZ1R5cGUsIHRhZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICd0b3RhbHRyYWNrcyc6XG4gICAgICAgICAgICAgICAgdGhpcy5jb21tb24udHJhY2sub2YgPSBHZW5lcmljVGFnTWFwcGVyXzEuQ29tbW9uVGFnTWFwcGVyLnRvSW50T3JOdWxsKHRhZy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAndG90YWxkaXNjcyc6XG4gICAgICAgICAgICAgICAgdGhpcy5jb21tb24uZGlzay5vZiA9IEdlbmVyaWNUYWdNYXBwZXJfMS5Db21tb25UYWdNYXBwZXIudG9JbnRPck51bGwodGFnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdtb3ZlbWVudFRvdGFsJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1vbi5tb3ZlbWVudEluZGV4Lm9mID0gR2VuZXJpY1RhZ01hcHBlcl8xLkNvbW1vblRhZ01hcHBlci50b0ludE9yTnVsbCh0YWcudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3RyYWNrJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2snOlxuICAgICAgICAgICAgY2FzZSAnbW92ZW1lbnRJbmRleCc6XG4gICAgICAgICAgICAgICAgY29uc3Qgb2YgPSB0aGlzLmNvbW1vblt0YWcuaWRdLm9mOyAvLyBzdG9yZSBvZiB2YWx1ZSwgbWF5YmUgbWF5YmUgb3ZlcndyaXR0ZW5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1vblt0YWcuaWRdID0gR2VuZXJpY1RhZ01hcHBlcl8xLkNvbW1vblRhZ01hcHBlci5ub3JtYWxpemVUcmFjayh0YWcudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbW9uW3RhZy5pZF0ub2YgPSBvZiAhPSBudWxsID8gb2YgOiB0aGlzLmNvbW1vblt0YWcuaWRdLm9mO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2JwbSc6XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIGNhc2UgJ29yaWdpbmFseWVhcic6XG4gICAgICAgICAgICAgICAgdGFnLnZhbHVlID0gcGFyc2VJbnQodGFnLnZhbHVlLCAxMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICAvLyBUb0RvOiBiZSBtb3JlIHN0cmljdCBvbiAnWVlZWS4uLidcbiAgICAgICAgICAgICAgICBjb25zdCB5ZWFyID0gcGFyc2VJbnQodGFnLnZhbHVlLnN1YnN0cigwLCA0KSwgMTApO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oeWVhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tb24ueWVhciA9IHllYXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGlzY29nc19sYWJlbF9pZCc6XG4gICAgICAgICAgICBjYXNlICdkaXNjb2dzX3JlbGVhc2VfaWQnOlxuICAgICAgICAgICAgY2FzZSAnZGlzY29nc19tYXN0ZXJfcmVsZWFzZV9pZCc6XG4gICAgICAgICAgICBjYXNlICdkaXNjb2dzX2FydGlzdF9pZCc6XG4gICAgICAgICAgICBjYXNlICdkaXNjb2dzX3ZvdGVzJzpcbiAgICAgICAgICAgICAgICB0YWcudmFsdWUgPSB0eXBlb2YgdGFnLnZhbHVlID09PSAnc3RyaW5nJyA/IHBhcnNlSW50KHRhZy52YWx1ZSwgMTApIDogdGFnLnZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVwbGF5Z2Fpbl90cmFja19nYWluJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlcGxheWdhaW5fdHJhY2tfcGVhayc6XG4gICAgICAgICAgICBjYXNlICdyZXBsYXlnYWluX2FsYnVtX2dhaW4nOlxuICAgICAgICAgICAgY2FzZSAncmVwbGF5Z2Fpbl9hbGJ1bV9wZWFrJzpcbiAgICAgICAgICAgICAgICB0YWcudmFsdWUgPSAoMCwgVXRpbF8xLnRvUmF0aW8pKHRhZy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZXBsYXlnYWluX3RyYWNrX21pbm1heCc6XG4gICAgICAgICAgICAgICAgdGFnLnZhbHVlID0gdGFnLnZhbHVlLnNwbGl0KCcsJykubWFwKHYgPT4gcGFyc2VJbnQodiwgMTApKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JlcGxheWdhaW5fdW5kbyc6XG4gICAgICAgICAgICAgICAgY29uc3QgbWluTWl4ID0gdGFnLnZhbHVlLnNwbGl0KCcsJykubWFwKHYgPT4gcGFyc2VJbnQodiwgMTApKTtcbiAgICAgICAgICAgICAgICB0YWcudmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRDaGFubmVsOiBtaW5NaXhbMF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Q2hhbm5lbDogbWluTWl4WzFdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2dhcGxlc3MnOiAvLyBpVHVuZXMgZ2FwLWxlc3MgZmxhZ1xuICAgICAgICAgICAgY2FzZSAnY29tcGlsYXRpb24nOlxuICAgICAgICAgICAgY2FzZSAncG9kY2FzdCc6XG4gICAgICAgICAgICBjYXNlICdzaG93TW92ZW1lbnQnOlxuICAgICAgICAgICAgICAgIHRhZy52YWx1ZSA9IHRhZy52YWx1ZSA9PT0gJzEnIHx8IHRhZy52YWx1ZSA9PT0gMTsgLy8gYm9vbGVhblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNyYyc6IC8vIE9ubHkga2VlcCB1bmlxdWUgdmFsdWVzXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tbW9uW3RhZy5pZF0gJiYgdGhpcy5jb21tb25bdGFnLmlkXS5pbmRleE9mKHRhZy52YWx1ZSkgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0R2VuZXJpY1RhZyh0YWdUeXBlLCB0YWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgbmF0aXZlIHRhZ3MgdG8gY29tbW9uIHRhZ3NcbiAgICAgKiBAcmV0dXJucyB7SUF1ZGlvTWV0YWRhdGF9IE5hdGl2ZSArIGNvbW1vbiB0YWdzXG4gICAgICovXG4gICAgdG9Db21tb25NZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5mb3JtYXQsXG4gICAgICAgICAgICBuYXRpdmU6IHRoaXMubmF0aXZlLFxuICAgICAgICAgICAgcXVhbGl0eTogdGhpcy5xdWFsaXR5LFxuICAgICAgICAgICAgY29tbW9uOiB0aGlzLmNvbW1vblxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaXggc29tZSBjb21tb24gaXNzdWVzIHdpdGggcGljdHVyZSBvYmplY3RcbiAgICAgKiBAcGFyYW0gcGljdHVyZSBQaWN0dXJlXG4gICAgICovXG4gICAgYXN5bmMgcG9zdEZpeFBpY3R1cmUocGljdHVyZSkge1xuICAgICAgICBpZiAocGljdHVyZS5kYXRhICYmIHBpY3R1cmUuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXBpY3R1cmUuZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZVR5cGUgPSBhd2FpdCBGaWxlVHlwZS5mcm9tQnVmZmVyKHBpY3R1cmUuZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBpY3R1cmUuZm9ybWF0ID0gZmlsZVR5cGUubWltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBpY3R1cmUuZm9ybWF0ID0gcGljdHVyZS5mb3JtYXQudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHN3aXRjaCAocGljdHVyZS5mb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpbWFnZS9qcGcnOlxuICAgICAgICAgICAgICAgICAgICBwaWN0dXJlLmZvcm1hdCA9ICdpbWFnZS9qcGVnJzsgLy8gVG9EbzogcmVnaXN0ZXIgd2FybmluZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBpY3R1cmU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRXYXJuaW5nKGBFbXB0eSBwaWN0dXJlIHRhZyBmb3VuZGApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBuYXRpdmUgdGFnIHRvIGNvbW1vbiB0YWdzXG4gICAgICovXG4gICAgdG9Db21tb24odGFnVHlwZSwgdGFnSWQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IHsgaWQ6IHRhZ0lkLCB2YWx1ZSB9O1xuICAgICAgICBjb25zdCBnZW5lcmljVGFnID0gdGhpcy50YWdNYXBwZXIubWFwVGFnKHRhZ1R5cGUsIHRhZywgdGhpcyk7XG4gICAgICAgIGlmIChnZW5lcmljVGFnKSB7XG4gICAgICAgICAgICB0aGlzLnBvc3RNYXAodGFnVHlwZSwgZ2VuZXJpY1RhZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGdlbmVyaWMgdGFnXG4gICAgICovXG4gICAgc2V0R2VuZXJpY1RhZyh0YWdUeXBlLCB0YWcpIHtcbiAgICAgICAgZGVidWcoYGNvbW1vbi4ke3RhZy5pZH0gPSAke3RhZy52YWx1ZX1gKTtcbiAgICAgICAgY29uc3QgcHJpbzAgPSB0aGlzLmNvbW1vbk9yaWdpblt0YWcuaWRdIHx8IDEwMDA7XG4gICAgICAgIGNvbnN0IHByaW8xID0gdGhpcy5vcmlnaW5Qcmlvcml0eVt0YWdUeXBlXTtcbiAgICAgICAgaWYgKCgwLCBHZW5lcmljVGFnVHlwZXNfMS5pc1NpbmdsZXRvbikodGFnLmlkKSkge1xuICAgICAgICAgICAgaWYgKHByaW8xIDw9IHByaW8wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21tb25bdGFnLmlkXSA9IHRhZy52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1vbk9yaWdpblt0YWcuaWRdID0gcHJpbzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVidWcoYElnbm9yZSBuYXRpdmUgdGFnIChzaW5nbGV0b24pOiAke3RhZ1R5cGV9LiR7dGFnLmlkfSA9ICR7dGFnLnZhbHVlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByaW8xID09PSBwcmlvMCkge1xuICAgICAgICAgICAgICAgIGlmICghKDAsIEdlbmVyaWNUYWdUeXBlc18xLmlzVW5pcXVlKSh0YWcuaWQpIHx8IHRoaXMuY29tbW9uW3RhZy5pZF0uaW5kZXhPZih0YWcudmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1vblt0YWcuaWRdLnB1c2godGFnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKGBJZ25vcmUgZHVwbGljYXRlIHZhbHVlOiAke3RhZ1R5cGV9LiR7dGFnLmlkfSA9ICR7dGFnLnZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBubyBlZmZlY3Q/IHRoaXMuY29tbW9uT3JpZ2luW3RhZy5pZF0gPSBwcmlvMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByaW8xIDwgcHJpbzApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1vblt0YWcuaWRdID0gW3RhZy52YWx1ZV07XG4gICAgICAgICAgICAgICAgdGhpcy5jb21tb25PcmlnaW5bdGFnLmlkXSA9IHByaW8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlYnVnKGBJZ25vcmUgbmF0aXZlIHRhZyAobGlzdCk6ICR7dGFnVHlwZX0uJHt0YWcuaWR9ID0gJHt0YWcudmFsdWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy5vYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRzLm9ic2VydmVyKHsgbWV0YWRhdGE6IHRoaXMsIHRhZzogeyB0eXBlOiAnY29tbW9uJywgaWQ6IHRhZy5pZCwgdmFsdWU6IHRhZy52YWx1ZSB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvRG86IHRyaWdnZXIgbWV0YWRhdGEgZXZlbnRcbiAgICB9XG59XG5leHBvcnRzLk1ldGFkYXRhQ29sbGVjdG9yID0gTWV0YWRhdGFDb2xsZWN0b3I7XG5mdW5jdGlvbiBqb2luQXJ0aXN0cyhhcnRpc3RzKSB7XG4gICAgaWYgKGFydGlzdHMubGVuZ3RoID4gMikge1xuICAgICAgICByZXR1cm4gYXJ0aXN0cy5zbGljZSgwLCBhcnRpc3RzLmxlbmd0aCAtIDEpLmpvaW4oJywgJykgKyAnICYgJyArIGFydGlzdHNbYXJ0aXN0cy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIGFydGlzdHMuam9pbignICYgJyk7XG59XG5leHBvcnRzLmpvaW5BcnRpc3RzID0gam9pbkFydGlzdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXRhZGF0YUNvbGxlY3Rvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/common/MetadataCollector.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/common/RandomUint8ArrayReader.js":
/*!**************************************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/RandomUint8ArrayReader.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RandomUint8ArrayReader = void 0;\n/**\n * Provides abstract Uint8Array access via the IRandomRead interface\n */\nclass RandomUint8ArrayReader {\n    constructor(uint8Array) {\n        this.uint8Array = uint8Array;\n        this.fileSize = uint8Array.length;\n    }\n    /**\n     * Read from a given position of an abstracted file or buffer.\n     * @param uint8Array - Uint8Array that the data will be written to.\n     * @param offset - Offset in the buffer to start writing at.\n     * @param length - Integer specifying the number of bytes to read.\n     * @param position - Specifies where to begin reading from in the file.\n     * @return Promise providing bytes read\n     */\n    async randomRead(uint8Array, offset, length, position) {\n        uint8Array.set(this.uint8Array.subarray(position, position + length), offset);\n        return length;\n    }\n}\nexports.RandomUint8ArrayReader = RandomUint8ArrayReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvY29tbW9uL1JhbmRvbVVpbnQ4QXJyYXlSZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2NvbW1vbi9SYW5kb21VaW50OEFycmF5UmVhZGVyLmpzPzZjYmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJhbmRvbVVpbnQ4QXJyYXlSZWFkZXIgPSB2b2lkIDA7XG4vKipcbiAqIFByb3ZpZGVzIGFic3RyYWN0IFVpbnQ4QXJyYXkgYWNjZXNzIHZpYSB0aGUgSVJhbmRvbVJlYWQgaW50ZXJmYWNlXG4gKi9cbmNsYXNzIFJhbmRvbVVpbnQ4QXJyYXlSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKHVpbnQ4QXJyYXkpIHtcbiAgICAgICAgdGhpcy51aW50OEFycmF5ID0gdWludDhBcnJheTtcbiAgICAgICAgdGhpcy5maWxlU2l6ZSA9IHVpbnQ4QXJyYXkubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGZyb20gYSBnaXZlbiBwb3NpdGlvbiBvZiBhbiBhYnN0cmFjdGVkIGZpbGUgb3IgYnVmZmVyLlxuICAgICAqIEBwYXJhbSB1aW50OEFycmF5IC0gVWludDhBcnJheSB0aGF0IHRoZSBkYXRhIHdpbGwgYmUgd3JpdHRlbiB0by5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IC0gT2Zmc2V0IGluIHRoZSBidWZmZXIgdG8gc3RhcnQgd3JpdGluZyBhdC5cbiAgICAgKiBAcGFyYW0gbGVuZ3RoIC0gSW50ZWdlciBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gLSBTcGVjaWZpZXMgd2hlcmUgdG8gYmVnaW4gcmVhZGluZyBmcm9tIGluIHRoZSBmaWxlLlxuICAgICAqIEByZXR1cm4gUHJvbWlzZSBwcm92aWRpbmcgYnl0ZXMgcmVhZFxuICAgICAqL1xuICAgIGFzeW5jIHJhbmRvbVJlYWQodWludDhBcnJheSwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgIHVpbnQ4QXJyYXkuc2V0KHRoaXMudWludDhBcnJheS5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbn1cbmV4cG9ydHMuUmFuZG9tVWludDhBcnJheVJlYWRlciA9IFJhbmRvbVVpbnQ4QXJyYXlSZWFkZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/common/RandomUint8ArrayReader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js":
/*!********************************************************!*\
  !*** ./node_modules/music-metadata/lib/common/Util.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toRatio = exports.dbToRatio = exports.ratioToDb = exports.a2hex = exports.isBitSet = exports.getBitAllignedNumber = exports.stripNulls = exports.decodeString = exports.trimRightNull = exports.findZero = exports.getBit = void 0;\nfunction getBit(buf, off, bit) {\n    return (buf[off] & (1 << bit)) !== 0;\n}\nexports.getBit = getBit;\n/**\n * Found delimiting zero in uint8Array\n * @param uint8Array Uint8Array to find the zero delimiter in\n * @param start Offset in uint8Array\n * @param end Last position to parse in uint8Array\n * @param encoding The string encoding used\n * @return Absolute position on uint8Array where zero found\n */\nfunction findZero(uint8Array, start, end, encoding) {\n    let i = start;\n    if (encoding === 'utf16le') {\n        while (uint8Array[i] !== 0 || uint8Array[i + 1] !== 0) {\n            if (i >= end)\n                return end;\n            i += 2;\n        }\n        return i;\n    }\n    else {\n        while (uint8Array[i] !== 0) {\n            if (i >= end)\n                return end;\n            i++;\n        }\n        return i;\n    }\n}\nexports.findZero = findZero;\nfunction trimRightNull(x) {\n    const pos0 = x.indexOf('\\0');\n    return pos0 === -1 ? x : x.substr(0, pos0);\n}\nexports.trimRightNull = trimRightNull;\nfunction swapBytes(uint8Array) {\n    const l = uint8Array.length;\n    if ((l & 1) !== 0)\n        throw new Error('Buffer length must be even');\n    for (let i = 0; i < l; i += 2) {\n        const a = uint8Array[i];\n        uint8Array[i] = uint8Array[i + 1];\n        uint8Array[i + 1] = a;\n    }\n    return uint8Array;\n}\n/**\n * Decode string\n */\nfunction decodeString(uint8Array, encoding) {\n    // annoying workaround for a double BOM issue\n    // https://github.com/leetreveil/musicmetadata/issues/84\n    if (uint8Array[0] === 0xFF && uint8Array[1] === 0xFE) { // little endian\n        return decodeString(uint8Array.subarray(2), encoding);\n    }\n    else if (encoding === 'utf16le' && uint8Array[0] === 0xFE && uint8Array[1] === 0xFF) {\n        // BOM, indicating big endian decoding\n        if ((uint8Array.length & 1) !== 0)\n            throw new Error('Expected even number of octets for 16-bit unicode string');\n        return decodeString(swapBytes(uint8Array), encoding);\n    }\n    return Buffer.from(uint8Array).toString(encoding);\n}\nexports.decodeString = decodeString;\nfunction stripNulls(str) {\n    str = str.replace(/^\\x00+/g, '');\n    str = str.replace(/\\x00+$/g, '');\n    return str;\n}\nexports.stripNulls = stripNulls;\n/**\n * Read bit-aligned number start from buffer\n * Total offset in bits = byteOffset * 8 + bitOffset\n * @param source Byte buffer\n * @param byteOffset Starting offset in bytes\n * @param bitOffset Starting offset in bits: 0 = lsb\n * @param len Length of number in bits\n * @return Decoded bit aligned number\n */\nfunction getBitAllignedNumber(source, byteOffset, bitOffset, len) {\n    const byteOff = byteOffset + ~~(bitOffset / 8);\n    const bitOff = bitOffset % 8;\n    let value = source[byteOff];\n    value &= 0xff >> bitOff;\n    const bitsRead = 8 - bitOff;\n    const bitsLeft = len - bitsRead;\n    if (bitsLeft < 0) {\n        value >>= (8 - bitOff - len);\n    }\n    else if (bitsLeft > 0) {\n        value <<= bitsLeft;\n        value |= getBitAllignedNumber(source, byteOffset, bitOffset + bitsRead, bitsLeft);\n    }\n    return value;\n}\nexports.getBitAllignedNumber = getBitAllignedNumber;\n/**\n * Read bit-aligned number start from buffer\n * Total offset in bits = byteOffset * 8 + bitOffset\n * @param source Byte Uint8Array\n * @param byteOffset Starting offset in bytes\n * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is the least significant bit\n * @return True if bit is set\n */\nfunction isBitSet(source, byteOffset, bitOffset) {\n    return getBitAllignedNumber(source, byteOffset, bitOffset, 1) === 1;\n}\nexports.isBitSet = isBitSet;\nfunction a2hex(str) {\n    const arr = [];\n    for (let i = 0, l = str.length; i < l; i++) {\n        const hex = Number(str.charCodeAt(i)).toString(16);\n        arr.push(hex.length === 1 ? '0' + hex : hex);\n    }\n    return arr.join(' ');\n}\nexports.a2hex = a2hex;\n/**\n * Convert power ratio to DB\n * ratio: [0..1]\n */\nfunction ratioToDb(ratio) {\n    return 10 * Math.log10(ratio);\n}\nexports.ratioToDb = ratioToDb;\n/**\n * Convert dB to ratio\n * db Decibels\n */\nfunction dbToRatio(dB) {\n    return Math.pow(10, dB / 10);\n}\nexports.dbToRatio = dbToRatio;\n/**\n * Convert replay gain to ratio and Decibel\n * @param value string holding a ratio like '0.034' or '-7.54 dB'\n */\nfunction toRatio(value) {\n    const ps = value.split(' ').map(p => p.trim().toLowerCase());\n    // @ts-ignore\n    if (ps.length >= 1) {\n        const v = parseFloat(ps[0]);\n        return ps.length === 2 && ps[1] === 'db' ? {\n            dB: v,\n            ratio: dbToRatio(v)\n        } : {\n            dB: ratioToDb(v),\n            ratio: v\n        };\n    }\n}\nexports.toRatio = toRatio;\n//# sourceMappingURL=Util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvY29tbW9uL1V0aWwuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxhQUFhLEdBQUcsZ0JBQWdCLEdBQUcsNEJBQTRCLEdBQUcsa0JBQWtCLEdBQUcsb0JBQW9CLEdBQUcscUJBQXFCLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYztBQUNqTztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvY29tbW9uL1V0aWwuanM/MzNmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9SYXRpbyA9IGV4cG9ydHMuZGJUb1JhdGlvID0gZXhwb3J0cy5yYXRpb1RvRGIgPSBleHBvcnRzLmEyaGV4ID0gZXhwb3J0cy5pc0JpdFNldCA9IGV4cG9ydHMuZ2V0Qml0QWxsaWduZWROdW1iZXIgPSBleHBvcnRzLnN0cmlwTnVsbHMgPSBleHBvcnRzLmRlY29kZVN0cmluZyA9IGV4cG9ydHMudHJpbVJpZ2h0TnVsbCA9IGV4cG9ydHMuZmluZFplcm8gPSBleHBvcnRzLmdldEJpdCA9IHZvaWQgMDtcbmZ1bmN0aW9uIGdldEJpdChidWYsIG9mZiwgYml0KSB7XG4gICAgcmV0dXJuIChidWZbb2ZmXSAmICgxIDw8IGJpdCkpICE9PSAwO1xufVxuZXhwb3J0cy5nZXRCaXQgPSBnZXRCaXQ7XG4vKipcbiAqIEZvdW5kIGRlbGltaXRpbmcgemVybyBpbiB1aW50OEFycmF5XG4gKiBAcGFyYW0gdWludDhBcnJheSBVaW50OEFycmF5IHRvIGZpbmQgdGhlIHplcm8gZGVsaW1pdGVyIGluXG4gKiBAcGFyYW0gc3RhcnQgT2Zmc2V0IGluIHVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBlbmQgTGFzdCBwb3NpdGlvbiB0byBwYXJzZSBpbiB1aW50OEFycmF5XG4gKiBAcGFyYW0gZW5jb2RpbmcgVGhlIHN0cmluZyBlbmNvZGluZyB1c2VkXG4gKiBAcmV0dXJuIEFic29sdXRlIHBvc2l0aW9uIG9uIHVpbnQ4QXJyYXkgd2hlcmUgemVybyBmb3VuZFxuICovXG5mdW5jdGlvbiBmaW5kWmVybyh1aW50OEFycmF5LCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAgIGxldCBpID0gc3RhcnQ7XG4gICAgaWYgKGVuY29kaW5nID09PSAndXRmMTZsZScpIHtcbiAgICAgICAgd2hpbGUgKHVpbnQ4QXJyYXlbaV0gIT09IDAgfHwgdWludDhBcnJheVtpICsgMV0gIT09IDApIHtcbiAgICAgICAgICAgIGlmIChpID49IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2hpbGUgKHVpbnQ4QXJyYXlbaV0gIT09IDApIHtcbiAgICAgICAgICAgIGlmIChpID49IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbn1cbmV4cG9ydHMuZmluZFplcm8gPSBmaW5kWmVybztcbmZ1bmN0aW9uIHRyaW1SaWdodE51bGwoeCkge1xuICAgIGNvbnN0IHBvczAgPSB4LmluZGV4T2YoJ1xcMCcpO1xuICAgIHJldHVybiBwb3MwID09PSAtMSA/IHggOiB4LnN1YnN0cigwLCBwb3MwKTtcbn1cbmV4cG9ydHMudHJpbVJpZ2h0TnVsbCA9IHRyaW1SaWdodE51bGw7XG5mdW5jdGlvbiBzd2FwQnl0ZXModWludDhBcnJheSkge1xuICAgIGNvbnN0IGwgPSB1aW50OEFycmF5Lmxlbmd0aDtcbiAgICBpZiAoKGwgJiAxKSAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIgbGVuZ3RoIG11c3QgYmUgZXZlbicpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IGEgPSB1aW50OEFycmF5W2ldO1xuICAgICAgICB1aW50OEFycmF5W2ldID0gdWludDhBcnJheVtpICsgMV07XG4gICAgICAgIHVpbnQ4QXJyYXlbaSArIDFdID0gYTtcbiAgICB9XG4gICAgcmV0dXJuIHVpbnQ4QXJyYXk7XG59XG4vKipcbiAqIERlY29kZSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHVpbnQ4QXJyYXksIGVuY29kaW5nKSB7XG4gICAgLy8gYW5ub3lpbmcgd29ya2Fyb3VuZCBmb3IgYSBkb3VibGUgQk9NIGlzc3VlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xlZXRyZXZlaWwvbXVzaWNtZXRhZGF0YS9pc3N1ZXMvODRcbiAgICBpZiAodWludDhBcnJheVswXSA9PT0gMHhGRiAmJiB1aW50OEFycmF5WzFdID09PSAweEZFKSB7IC8vIGxpdHRsZSBlbmRpYW5cbiAgICAgICAgcmV0dXJuIGRlY29kZVN0cmluZyh1aW50OEFycmF5LnN1YmFycmF5KDIpLCBlbmNvZGluZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVuY29kaW5nID09PSAndXRmMTZsZScgJiYgdWludDhBcnJheVswXSA9PT0gMHhGRSAmJiB1aW50OEFycmF5WzFdID09PSAweEZGKSB7XG4gICAgICAgIC8vIEJPTSwgaW5kaWNhdGluZyBiaWcgZW5kaWFuIGRlY29kaW5nXG4gICAgICAgIGlmICgodWludDhBcnJheS5sZW5ndGggJiAxKSAhPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZXZlbiBudW1iZXIgb2Ygb2N0ZXRzIGZvciAxNi1iaXQgdW5pY29kZSBzdHJpbmcnKTtcbiAgICAgICAgcmV0dXJuIGRlY29kZVN0cmluZyhzd2FwQnl0ZXModWludDhBcnJheSksIGVuY29kaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHVpbnQ4QXJyYXkpLnRvU3RyaW5nKGVuY29kaW5nKTtcbn1cbmV4cG9ydHMuZGVjb2RlU3RyaW5nID0gZGVjb2RlU3RyaW5nO1xuZnVuY3Rpb24gc3RyaXBOdWxscyhzdHIpIHtcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvXlxceDAwKy9nLCAnJyk7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL1xceDAwKyQvZywgJycpO1xuICAgIHJldHVybiBzdHI7XG59XG5leHBvcnRzLnN0cmlwTnVsbHMgPSBzdHJpcE51bGxzO1xuLyoqXG4gKiBSZWFkIGJpdC1hbGlnbmVkIG51bWJlciBzdGFydCBmcm9tIGJ1ZmZlclxuICogVG90YWwgb2Zmc2V0IGluIGJpdHMgPSBieXRlT2Zmc2V0ICogOCArIGJpdE9mZnNldFxuICogQHBhcmFtIHNvdXJjZSBCeXRlIGJ1ZmZlclxuICogQHBhcmFtIGJ5dGVPZmZzZXQgU3RhcnRpbmcgb2Zmc2V0IGluIGJ5dGVzXG4gKiBAcGFyYW0gYml0T2Zmc2V0IFN0YXJ0aW5nIG9mZnNldCBpbiBiaXRzOiAwID0gbHNiXG4gKiBAcGFyYW0gbGVuIExlbmd0aCBvZiBudW1iZXIgaW4gYml0c1xuICogQHJldHVybiBEZWNvZGVkIGJpdCBhbGlnbmVkIG51bWJlclxuICovXG5mdW5jdGlvbiBnZXRCaXRBbGxpZ25lZE51bWJlcihzb3VyY2UsIGJ5dGVPZmZzZXQsIGJpdE9mZnNldCwgbGVuKSB7XG4gICAgY29uc3QgYnl0ZU9mZiA9IGJ5dGVPZmZzZXQgKyB+fihiaXRPZmZzZXQgLyA4KTtcbiAgICBjb25zdCBiaXRPZmYgPSBiaXRPZmZzZXQgJSA4O1xuICAgIGxldCB2YWx1ZSA9IHNvdXJjZVtieXRlT2ZmXTtcbiAgICB2YWx1ZSAmPSAweGZmID4+IGJpdE9mZjtcbiAgICBjb25zdCBiaXRzUmVhZCA9IDggLSBiaXRPZmY7XG4gICAgY29uc3QgYml0c0xlZnQgPSBsZW4gLSBiaXRzUmVhZDtcbiAgICBpZiAoYml0c0xlZnQgPCAwKSB7XG4gICAgICAgIHZhbHVlID4+PSAoOCAtIGJpdE9mZiAtIGxlbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgICB2YWx1ZSA8PD0gYml0c0xlZnQ7XG4gICAgICAgIHZhbHVlIHw9IGdldEJpdEFsbGlnbmVkTnVtYmVyKHNvdXJjZSwgYnl0ZU9mZnNldCwgYml0T2Zmc2V0ICsgYml0c1JlYWQsIGJpdHNMZWZ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy5nZXRCaXRBbGxpZ25lZE51bWJlciA9IGdldEJpdEFsbGlnbmVkTnVtYmVyO1xuLyoqXG4gKiBSZWFkIGJpdC1hbGlnbmVkIG51bWJlciBzdGFydCBmcm9tIGJ1ZmZlclxuICogVG90YWwgb2Zmc2V0IGluIGJpdHMgPSBieXRlT2Zmc2V0ICogOCArIGJpdE9mZnNldFxuICogQHBhcmFtIHNvdXJjZSBCeXRlIFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBieXRlT2Zmc2V0IFN0YXJ0aW5nIG9mZnNldCBpbiBieXRlc1xuICogQHBhcmFtIGJpdE9mZnNldCBTdGFydGluZyBvZmZzZXQgaW4gYml0czogMCA9IG1vc3Qgc2lnbmlmaWNhbnQgYml0LCA3IGlzIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXRcbiAqIEByZXR1cm4gVHJ1ZSBpZiBiaXQgaXMgc2V0XG4gKi9cbmZ1bmN0aW9uIGlzQml0U2V0KHNvdXJjZSwgYnl0ZU9mZnNldCwgYml0T2Zmc2V0KSB7XG4gICAgcmV0dXJuIGdldEJpdEFsbGlnbmVkTnVtYmVyKHNvdXJjZSwgYnl0ZU9mZnNldCwgYml0T2Zmc2V0LCAxKSA9PT0gMTtcbn1cbmV4cG9ydHMuaXNCaXRTZXQgPSBpc0JpdFNldDtcbmZ1bmN0aW9uIGEyaGV4KHN0cikge1xuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb25zdCBoZXggPSBOdW1iZXIoc3RyLmNoYXJDb2RlQXQoaSkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgYXJyLnB1c2goaGV4Lmxlbmd0aCA9PT0gMSA/ICcwJyArIGhleCA6IGhleCk7XG4gICAgfVxuICAgIHJldHVybiBhcnIuam9pbignICcpO1xufVxuZXhwb3J0cy5hMmhleCA9IGEyaGV4O1xuLyoqXG4gKiBDb252ZXJ0IHBvd2VyIHJhdGlvIHRvIERCXG4gKiByYXRpbzogWzAuLjFdXG4gKi9cbmZ1bmN0aW9uIHJhdGlvVG9EYihyYXRpbykge1xuICAgIHJldHVybiAxMCAqIE1hdGgubG9nMTAocmF0aW8pO1xufVxuZXhwb3J0cy5yYXRpb1RvRGIgPSByYXRpb1RvRGI7XG4vKipcbiAqIENvbnZlcnQgZEIgdG8gcmF0aW9cbiAqIGRiIERlY2liZWxzXG4gKi9cbmZ1bmN0aW9uIGRiVG9SYXRpbyhkQikge1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgZEIgLyAxMCk7XG59XG5leHBvcnRzLmRiVG9SYXRpbyA9IGRiVG9SYXRpbztcbi8qKlxuICogQ29udmVydCByZXBsYXkgZ2FpbiB0byByYXRpbyBhbmQgRGVjaWJlbFxuICogQHBhcmFtIHZhbHVlIHN0cmluZyBob2xkaW5nIGEgcmF0aW8gbGlrZSAnMC4wMzQnIG9yICctNy41NCBkQidcbiAqL1xuZnVuY3Rpb24gdG9SYXRpbyh2YWx1ZSkge1xuICAgIGNvbnN0IHBzID0gdmFsdWUuc3BsaXQoJyAnKS5tYXAocCA9PiBwLnRyaW0oKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHBzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgIGNvbnN0IHYgPSBwYXJzZUZsb2F0KHBzWzBdKTtcbiAgICAgICAgcmV0dXJuIHBzLmxlbmd0aCA9PT0gMiAmJiBwc1sxXSA9PT0gJ2RiJyA/IHtcbiAgICAgICAgICAgIGRCOiB2LFxuICAgICAgICAgICAgcmF0aW86IGRiVG9SYXRpbyh2KVxuICAgICAgICB9IDoge1xuICAgICAgICAgICAgZEI6IHJhdGlvVG9EYih2KSxcbiAgICAgICAgICAgIHJhdGlvOiB2XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy50b1JhdGlvID0gdG9SYXRpbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVV0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/core.js":
/*!*************************************************!*\
  !*** ./node_modules/music-metadata/lib/core.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.scanAppendingHeaders = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = exports.parseStream = void 0;\nconst strtok3 = __webpack_require__(/*! strtok3/lib/core */ \"(app-pages-browser)/./node_modules/strtok3/lib/core.js\");\nconst ParserFactory_1 = __webpack_require__(/*! ./ParserFactory */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ParserFactory.js\");\nconst RandomUint8ArrayReader_1 = __webpack_require__(/*! ./common/RandomUint8ArrayReader */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/RandomUint8ArrayReader.js\");\nconst APEv2Parser_1 = __webpack_require__(/*! ./apev2/APEv2Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/apev2/APEv2Parser.js\");\nconst ID3v1Parser_1 = __webpack_require__(/*! ./id3v1/ID3v1Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js\");\nconst Lyrics3_1 = __webpack_require__(/*! ./lyrics3/Lyrics3 */ \"(app-pages-browser)/./node_modules/music-metadata/lib/lyrics3/Lyrics3.js\");\n/**\n * Parse audio from Node Stream.Readable\n * @param stream - Stream to read the audio track from\n * @param options - Parsing options\n * @param fileInfo - File information object or MIME-type string\n * @returns Metadata\n */\nfunction parseStream(stream, fileInfo, options = {}) {\n    return parseFromTokenizer(strtok3.fromStream(stream, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo), options);\n}\nexports.parseStream = parseStream;\n/**\n * Parse audio from Node Buffer\n * @param uint8Array - Uint8Array holding audio data\n * @param fileInfo - File information object or MIME-type string\n * @param options - Parsing options\n * @returns Metadata\n * Ref: https://github.com/Borewit/strtok3/blob/e6938c81ff685074d5eb3064a11c0b03ca934c1d/src/index.ts#L15\n */\nasync function parseBuffer(uint8Array, fileInfo, options = {}) {\n    const bufferReader = new RandomUint8ArrayReader_1.RandomUint8ArrayReader(uint8Array);\n    await scanAppendingHeaders(bufferReader, options);\n    const tokenizer = strtok3.fromBuffer(uint8Array, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo);\n    return parseFromTokenizer(tokenizer, options);\n}\nexports.parseBuffer = parseBuffer;\n/**\n * Parse audio from ITokenizer source\n * @param tokenizer - Audio source implementing the tokenizer interface\n * @param options - Parsing options\n * @returns Metadata\n */\nfunction parseFromTokenizer(tokenizer, options) {\n    return ParserFactory_1.ParserFactory.parseOnContentType(tokenizer, options);\n}\nexports.parseFromTokenizer = parseFromTokenizer;\n/**\n * Create a dictionary ordered by their tag id (key)\n * @param nativeTags list of tags\n * @returns tags indexed by id\n */\nfunction orderTags(nativeTags) {\n    const tags = {};\n    for (const tag of nativeTags) {\n        (tags[tag.id] = (tags[tag.id] || [])).push(tag.value);\n    }\n    return tags;\n}\nexports.orderTags = orderTags;\n/**\n * Convert rating to 1-5 star rating\n * @param rating: Normalized rating [0..1] (common.rating[n].rating)\n * @returns Number of stars: 1, 2, 3, 4 or 5 stars\n */\nfunction ratingToStars(rating) {\n    return rating === undefined ? 0 : 1 + Math.round(rating * 4);\n}\nexports.ratingToStars = ratingToStars;\n/**\n * Select most likely cover image.\n * @param pictures Usually metadata.common.picture\n * @return Cover image, if any, otherwise null\n */\nfunction selectCover(pictures) {\n    return pictures ? pictures.reduce((acc, cur) => {\n        if (cur.name && cur.name.toLowerCase() in ['front', 'cover', 'cover (front)'])\n            return cur;\n        return acc;\n    }) : null;\n}\nexports.selectCover = selectCover;\nasync function scanAppendingHeaders(randomReader, options = {}) {\n    let apeOffset = randomReader.fileSize;\n    if (await (0, ID3v1Parser_1.hasID3v1Header)(randomReader)) {\n        apeOffset -= 128;\n        const lyricsLen = await (0, Lyrics3_1.getLyricsHeaderLength)(randomReader);\n        apeOffset -= lyricsLen;\n    }\n    options.apeHeader = await APEv2Parser_1.APEv2Parser.findApeFooterOffset(randomReader, apeOffset);\n}\nexports.scanAppendingHeaders = scanAppendingHeaders;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvY29yZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEIsR0FBRyxtQkFBbUIsR0FBRyxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRywwQkFBMEIsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUI7QUFDdkssZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQWtCO0FBQzFDLHdCQUF3QixtQkFBTyxDQUFDLCtGQUFpQjtBQUNqRCxpQ0FBaUMsbUJBQU8sQ0FBQywrSEFBaUM7QUFDMUUsc0JBQXNCLG1CQUFPLENBQUMsdUdBQXFCO0FBQ25ELHNCQUFzQixtQkFBTyxDQUFDLHVHQUFxQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyxtR0FBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsMEZBQTBGLHFCQUFxQjtBQUMvRztBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxzRkFBc0YscUJBQXFCO0FBQzNHO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUJBQW1CO0FBQ25CLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvY29yZS5qcz9mMjNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zY2FuQXBwZW5kaW5nSGVhZGVycyA9IGV4cG9ydHMuc2VsZWN0Q292ZXIgPSBleHBvcnRzLnJhdGluZ1RvU3RhcnMgPSBleHBvcnRzLm9yZGVyVGFncyA9IGV4cG9ydHMucGFyc2VGcm9tVG9rZW5pemVyID0gZXhwb3J0cy5wYXJzZUJ1ZmZlciA9IGV4cG9ydHMucGFyc2VTdHJlYW0gPSB2b2lkIDA7XG5jb25zdCBzdHJ0b2szID0gcmVxdWlyZShcInN0cnRvazMvbGliL2NvcmVcIik7XG5jb25zdCBQYXJzZXJGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9QYXJzZXJGYWN0b3J5XCIpO1xuY29uc3QgUmFuZG9tVWludDhBcnJheVJlYWRlcl8xID0gcmVxdWlyZShcIi4vY29tbW9uL1JhbmRvbVVpbnQ4QXJyYXlSZWFkZXJcIik7XG5jb25zdCBBUEV2MlBhcnNlcl8xID0gcmVxdWlyZShcIi4vYXBldjIvQVBFdjJQYXJzZXJcIik7XG5jb25zdCBJRDN2MVBhcnNlcl8xID0gcmVxdWlyZShcIi4vaWQzdjEvSUQzdjFQYXJzZXJcIik7XG5jb25zdCBMeXJpY3MzXzEgPSByZXF1aXJlKFwiLi9seXJpY3MzL0x5cmljczNcIik7XG4vKipcbiAqIFBhcnNlIGF1ZGlvIGZyb20gTm9kZSBTdHJlYW0uUmVhZGFibGVcbiAqIEBwYXJhbSBzdHJlYW0gLSBTdHJlYW0gdG8gcmVhZCB0aGUgYXVkaW8gdHJhY2sgZnJvbVxuICogQHBhcmFtIG9wdGlvbnMgLSBQYXJzaW5nIG9wdGlvbnNcbiAqIEBwYXJhbSBmaWxlSW5mbyAtIEZpbGUgaW5mb3JtYXRpb24gb2JqZWN0IG9yIE1JTUUtdHlwZSBzdHJpbmdcbiAqIEByZXR1cm5zIE1ldGFkYXRhXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3RyZWFtKHN0cmVhbSwgZmlsZUluZm8sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBwYXJzZUZyb21Ub2tlbml6ZXIoc3RydG9rMy5mcm9tU3RyZWFtKHN0cmVhbSwgdHlwZW9mIGZpbGVJbmZvID09PSAnc3RyaW5nJyA/IHsgbWltZVR5cGU6IGZpbGVJbmZvIH0gOiBmaWxlSW5mbyksIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5wYXJzZVN0cmVhbSA9IHBhcnNlU3RyZWFtO1xuLyoqXG4gKiBQYXJzZSBhdWRpbyBmcm9tIE5vZGUgQnVmZmVyXG4gKiBAcGFyYW0gdWludDhBcnJheSAtIFVpbnQ4QXJyYXkgaG9sZGluZyBhdWRpbyBkYXRhXG4gKiBAcGFyYW0gZmlsZUluZm8gLSBGaWxlIGluZm9ybWF0aW9uIG9iamVjdCBvciBNSU1FLXR5cGUgc3RyaW5nXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFBhcnNpbmcgb3B0aW9uc1xuICogQHJldHVybnMgTWV0YWRhdGFcbiAqIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL0JvcmV3aXQvc3RydG9rMy9ibG9iL2U2OTM4YzgxZmY2ODUwNzRkNWViMzA2NGExMWMwYjAzY2E5MzRjMWQvc3JjL2luZGV4LnRzI0wxNVxuICovXG5hc3luYyBmdW5jdGlvbiBwYXJzZUJ1ZmZlcih1aW50OEFycmF5LCBmaWxlSW5mbywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYnVmZmVyUmVhZGVyID0gbmV3IFJhbmRvbVVpbnQ4QXJyYXlSZWFkZXJfMS5SYW5kb21VaW50OEFycmF5UmVhZGVyKHVpbnQ4QXJyYXkpO1xuICAgIGF3YWl0IHNjYW5BcHBlbmRpbmdIZWFkZXJzKGJ1ZmZlclJlYWRlciwgb3B0aW9ucyk7XG4gICAgY29uc3QgdG9rZW5pemVyID0gc3RydG9rMy5mcm9tQnVmZmVyKHVpbnQ4QXJyYXksIHR5cGVvZiBmaWxlSW5mbyA9PT0gJ3N0cmluZycgPyB7IG1pbWVUeXBlOiBmaWxlSW5mbyB9IDogZmlsZUluZm8pO1xuICAgIHJldHVybiBwYXJzZUZyb21Ub2tlbml6ZXIodG9rZW5pemVyLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucGFyc2VCdWZmZXIgPSBwYXJzZUJ1ZmZlcjtcbi8qKlxuICogUGFyc2UgYXVkaW8gZnJvbSBJVG9rZW5pemVyIHNvdXJjZVxuICogQHBhcmFtIHRva2VuaXplciAtIEF1ZGlvIHNvdXJjZSBpbXBsZW1lbnRpbmcgdGhlIHRva2VuaXplciBpbnRlcmZhY2VcbiAqIEBwYXJhbSBvcHRpb25zIC0gUGFyc2luZyBvcHRpb25zXG4gKiBAcmV0dXJucyBNZXRhZGF0YVxuICovXG5mdW5jdGlvbiBwYXJzZUZyb21Ub2tlbml6ZXIodG9rZW5pemVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFBhcnNlckZhY3RvcnlfMS5QYXJzZXJGYWN0b3J5LnBhcnNlT25Db250ZW50VHlwZSh0b2tlbml6ZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5wYXJzZUZyb21Ub2tlbml6ZXIgPSBwYXJzZUZyb21Ub2tlbml6ZXI7XG4vKipcbiAqIENyZWF0ZSBhIGRpY3Rpb25hcnkgb3JkZXJlZCBieSB0aGVpciB0YWcgaWQgKGtleSlcbiAqIEBwYXJhbSBuYXRpdmVUYWdzIGxpc3Qgb2YgdGFnc1xuICogQHJldHVybnMgdGFncyBpbmRleGVkIGJ5IGlkXG4gKi9cbmZ1bmN0aW9uIG9yZGVyVGFncyhuYXRpdmVUYWdzKSB7XG4gICAgY29uc3QgdGFncyA9IHt9O1xuICAgIGZvciAoY29uc3QgdGFnIG9mIG5hdGl2ZVRhZ3MpIHtcbiAgICAgICAgKHRhZ3NbdGFnLmlkXSA9ICh0YWdzW3RhZy5pZF0gfHwgW10pKS5wdXNoKHRhZy52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0YWdzO1xufVxuZXhwb3J0cy5vcmRlclRhZ3MgPSBvcmRlclRhZ3M7XG4vKipcbiAqIENvbnZlcnQgcmF0aW5nIHRvIDEtNSBzdGFyIHJhdGluZ1xuICogQHBhcmFtIHJhdGluZzogTm9ybWFsaXplZCByYXRpbmcgWzAuLjFdIChjb21tb24ucmF0aW5nW25dLnJhdGluZylcbiAqIEByZXR1cm5zIE51bWJlciBvZiBzdGFyczogMSwgMiwgMywgNCBvciA1IHN0YXJzXG4gKi9cbmZ1bmN0aW9uIHJhdGluZ1RvU3RhcnMocmF0aW5nKSB7XG4gICAgcmV0dXJuIHJhdGluZyA9PT0gdW5kZWZpbmVkID8gMCA6IDEgKyBNYXRoLnJvdW5kKHJhdGluZyAqIDQpO1xufVxuZXhwb3J0cy5yYXRpbmdUb1N0YXJzID0gcmF0aW5nVG9TdGFycztcbi8qKlxuICogU2VsZWN0IG1vc3QgbGlrZWx5IGNvdmVyIGltYWdlLlxuICogQHBhcmFtIHBpY3R1cmVzIFVzdWFsbHkgbWV0YWRhdGEuY29tbW9uLnBpY3R1cmVcbiAqIEByZXR1cm4gQ292ZXIgaW1hZ2UsIGlmIGFueSwgb3RoZXJ3aXNlIG51bGxcbiAqL1xuZnVuY3Rpb24gc2VsZWN0Q292ZXIocGljdHVyZXMpIHtcbiAgICByZXR1cm4gcGljdHVyZXMgPyBwaWN0dXJlcy5yZWR1Y2UoKGFjYywgY3VyKSA9PiB7XG4gICAgICAgIGlmIChjdXIubmFtZSAmJiBjdXIubmFtZS50b0xvd2VyQ2FzZSgpIGluIFsnZnJvbnQnLCAnY292ZXInLCAnY292ZXIgKGZyb250KSddKVxuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9KSA6IG51bGw7XG59XG5leHBvcnRzLnNlbGVjdENvdmVyID0gc2VsZWN0Q292ZXI7XG5hc3luYyBmdW5jdGlvbiBzY2FuQXBwZW5kaW5nSGVhZGVycyhyYW5kb21SZWFkZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBhcGVPZmZzZXQgPSByYW5kb21SZWFkZXIuZmlsZVNpemU7XG4gICAgaWYgKGF3YWl0ICgwLCBJRDN2MVBhcnNlcl8xLmhhc0lEM3YxSGVhZGVyKShyYW5kb21SZWFkZXIpKSB7XG4gICAgICAgIGFwZU9mZnNldCAtPSAxMjg7XG4gICAgICAgIGNvbnN0IGx5cmljc0xlbiA9IGF3YWl0ICgwLCBMeXJpY3MzXzEuZ2V0THlyaWNzSGVhZGVyTGVuZ3RoKShyYW5kb21SZWFkZXIpO1xuICAgICAgICBhcGVPZmZzZXQgLT0gbHlyaWNzTGVuO1xuICAgIH1cbiAgICBvcHRpb25zLmFwZUhlYWRlciA9IGF3YWl0IEFQRXYyUGFyc2VyXzEuQVBFdjJQYXJzZXIuZmluZEFwZUZvb3Rlck9mZnNldChyYW5kb21SZWFkZXIsIGFwZU9mZnNldCk7XG59XG5leHBvcnRzLnNjYW5BcHBlbmRpbmdIZWFkZXJzID0gc2NhbkFwcGVuZGluZ0hlYWRlcnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/core.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/dsdiff/DsdiffParser.js":
/*!****************************************************************!*\
  !*** ./node_modules/music-metadata/lib/dsdiff/DsdiffParser.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DsdiffParser = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst strtok3 = __webpack_require__(/*! strtok3/lib/core */ \"(app-pages-browser)/./node_modules/strtok3/lib/core.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/FourCC.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst ID3v2Parser_1 = __webpack_require__(/*! ../id3v2/ID3v2Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js\");\nconst DsdiffToken_1 = __webpack_require__(/*! ./DsdiffToken */ \"(app-pages-browser)/./node_modules/music-metadata/lib/dsdiff/DsdiffToken.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:aiff');\n/**\n * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)\n *\n * Ref:\n * - http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\n */\nclass DsdiffParser extends BasicParser_1.BasicParser {\n    async parse() {\n        const header = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n        if (header.chunkID !== 'FRM8')\n            throw new Error('Unexpected chunk-ID');\n        const type = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n        switch (type) {\n            case 'DSD':\n                this.metadata.setFormat('container', `DSDIFF/${type}`);\n                this.metadata.setFormat('lossless', true);\n                return this.readFmt8Chunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));\n            default:\n                throw Error(`Unsupported DSDIFF type: ${type}`);\n        }\n    }\n    async readFmt8Chunks(remainingSize) {\n        while (remainingSize >= DsdiffToken_1.ChunkHeader64.len) {\n            const chunkHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n            //  If the data is an odd number of bytes in length, a pad byte must be added at the end\n            debug(`Chunk id=${chunkHeader.chunkID}`);\n            await this.readData(chunkHeader);\n            remainingSize -= (BigInt(DsdiffToken_1.ChunkHeader64.len) + chunkHeader.chunkSize);\n        }\n    }\n    async readData(header) {\n        debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n        const p0 = this.tokenizer.position;\n        switch (header.chunkID.trim()) {\n            case 'FVER': // 3.1 FORMAT VERSION CHUNK\n                const version = await this.tokenizer.readToken(Token.UINT32_LE);\n                debug(`DSDIFF version=${version}`);\n                break;\n            case 'PROP': // 3.2 PROPERTY CHUNK\n                const propType = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n                if (propType !== 'SND ')\n                    throw new Error('Unexpected PROP-chunk ID');\n                await this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCC_1.FourCcToken.len));\n                break;\n            case 'ID3': // Unofficial ID3 tag support\n                const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(Number(header.chunkSize)));\n                const rst = strtok3.fromBuffer(id3_data);\n                await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n                break;\n            default:\n                debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n                break;\n            case 'DSD':\n                this.metadata.setFormat('numberOfSamples', Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels)));\n                this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n                break;\n        }\n        const remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);\n        if (remaining > 0) {\n            debug(`After Parsing chunk, remaining ${remaining} bytes`);\n            await this.tokenizer.ignore(Number(remaining));\n        }\n    }\n    async handleSoundPropertyChunks(remainingSize) {\n        debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n        while (remainingSize > 0) {\n            const sndPropHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader64);\n            debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n            const p0 = this.tokenizer.position;\n            switch (sndPropHeader.chunkID.trim()) {\n                case 'FS': // 3.2.1 Sample Rate Chunk\n                    const sampleRate = await this.tokenizer.readToken(Token.UINT32_BE);\n                    this.metadata.setFormat('sampleRate', sampleRate);\n                    break;\n                case 'CHNL': // 3.2.2 Channels Chunk\n                    const numChannels = await this.tokenizer.readToken(Token.UINT16_BE);\n                    this.metadata.setFormat('numberOfChannels', numChannels);\n                    await this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(Token.UINT16_BE.len));\n                    break;\n                case 'CMPR': // 3.2.3 Compression Type Chunk\n                    const compressionIdCode = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n                    const count = await this.tokenizer.readToken(Token.UINT8);\n                    const compressionName = await this.tokenizer.readToken(new Token.StringType(count, 'ascii'));\n                    if (compressionIdCode === 'DSD') {\n                        this.metadata.setFormat('lossless', true);\n                        this.metadata.setFormat('bitsPerSample', 1);\n                    }\n                    this.metadata.setFormat('codec', `${compressionIdCode} (${compressionName})`);\n                    break;\n                case 'ABSS': // 3.2.4 Absolute Start Time Chunk\n                    const hours = await this.tokenizer.readToken(Token.UINT16_BE);\n                    const minutes = await this.tokenizer.readToken(Token.UINT8);\n                    const seconds = await this.tokenizer.readToken(Token.UINT8);\n                    const samples = await this.tokenizer.readToken(Token.UINT32_BE);\n                    debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);\n                    break;\n                case 'LSCO': // 3.2.5 Loudspeaker Configuration Chunk\n                    const lsConfig = await this.tokenizer.readToken(Token.UINT16_BE);\n                    debug(`LSCO lsConfig=${lsConfig}`);\n                    break;\n                case 'COMT':\n                default:\n                    debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n                    await this.tokenizer.ignore(Number(sndPropHeader.chunkSize));\n            }\n            const remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);\n            if (remaining > 0) {\n                debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);\n                await this.tokenizer.ignore(Number(remaining));\n            }\n            remainingSize -= BigInt(DsdiffToken_1.ChunkHeader64.len) + sndPropHeader.chunkSize;\n            debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n        }\n        if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {\n            const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;\n            this.metadata.setFormat('bitrate', bitrate);\n        }\n    }\n    async handleChannelChunks(remainingSize) {\n        debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);\n        const channels = [];\n        while (remainingSize >= FourCC_1.FourCcToken.len) {\n            const channelId = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n            debug(`Channel[ID=${channelId}]`);\n            channels.push(channelId);\n            remainingSize -= BigInt(FourCC_1.FourCcToken.len);\n        }\n        debug(`Channels: ${channels.join(', ')}`);\n        return channels;\n    }\n}\nexports.DsdiffParser = DsdiffParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvZHNkaWZmL0RzZGlmZlBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsY0FBYyxtQkFBTyxDQUFDLGdGQUFhO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFPO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLGdGQUFrQjtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyxnR0FBa0I7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsMEdBQXVCO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLHdHQUFzQjtBQUNwRCxzQkFBc0IsbUJBQU8sQ0FBQyxrR0FBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsS0FBSztBQUNwRTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZUFBZSxTQUFTLGlCQUFpQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGVBQWUsU0FBUyxpQkFBaUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGNBQWM7QUFDNUU7QUFDQTtBQUNBLDZDQUE2QyxzQkFBc0IsU0FBUyx3QkFBd0I7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsbUJBQW1CLEdBQUcsZ0JBQWdCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNLEdBQUcsUUFBUSxHQUFHLFFBQVEsR0FBRyxRQUFRO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxzQkFBc0IsU0FBUyx3QkFBd0I7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsd0JBQXdCLGNBQWMsV0FBVztBQUM3RztBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsY0FBYztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvZHNkaWZmL0RzZGlmZlBhcnNlci5qcz9lNDBjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ec2RpZmZQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBzdHJ0b2szID0gcmVxdWlyZShcInN0cnRvazMvbGliL2NvcmVcIik7XG5jb25zdCBGb3VyQ0NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vRm91ckNDXCIpO1xuY29uc3QgQmFzaWNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vQmFzaWNQYXJzZXJcIik7XG5jb25zdCBJRDN2MlBhcnNlcl8xID0gcmVxdWlyZShcIi4uL2lkM3YyL0lEM3YyUGFyc2VyXCIpO1xuY29uc3QgRHNkaWZmVG9rZW5fMSA9IHJlcXVpcmUoXCIuL0RzZGlmZlRva2VuXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbXVzaWMtbWV0YWRhdGE6cGFyc2VyOmFpZmYnKTtcbi8qKlxuICogRFNESUZGIC0gRGlyZWN0IFN0cmVhbSBEaWdpdGFsIEludGVyY2hhbmdlIEZpbGUgRm9ybWF0IChQaGlsbGlwcylcbiAqXG4gKiBSZWY6XG4gKiAtIGh0dHA6Ly93d3cuc29uaWNzdHVkaW8uY29tL3BkZi9kc2QvRFNESUZGXzEuNV9TcGVjLnBkZlxuICovXG5jbGFzcyBEc2RpZmZQYXJzZXIgZXh0ZW5kcyBCYXNpY1BhcnNlcl8xLkJhc2ljUGFyc2VyIHtcbiAgICBhc3luYyBwYXJzZSgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKERzZGlmZlRva2VuXzEuQ2h1bmtIZWFkZXI2NCk7XG4gICAgICAgIGlmIChoZWFkZXIuY2h1bmtJRCAhPT0gJ0ZSTTgnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGNodW5rLUlEJyk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSAoYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKEZvdXJDQ18xLkZvdXJDY1Rva2VuKSkudHJpbSgpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0RTRCc6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvbnRhaW5lcicsIGBEU0RJRkYvJHt0eXBlfWApO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdsb3NzbGVzcycsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGbXQ4Q2h1bmtzKGhlYWRlci5jaHVua1NpemUgLSBCaWdJbnQoRm91ckNDXzEuRm91ckNjVG9rZW4ubGVuKSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBEU0RJRkYgdHlwZTogJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlYWRGbXQ4Q2h1bmtzKHJlbWFpbmluZ1NpemUpIHtcbiAgICAgICAgd2hpbGUgKHJlbWFpbmluZ1NpemUgPj0gRHNkaWZmVG9rZW5fMS5DaHVua0hlYWRlcjY0Lmxlbikge1xuICAgICAgICAgICAgY29uc3QgY2h1bmtIZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oRHNkaWZmVG9rZW5fMS5DaHVua0hlYWRlcjY0KTtcbiAgICAgICAgICAgIC8vICBJZiB0aGUgZGF0YSBpcyBhbiBvZGQgbnVtYmVyIG9mIGJ5dGVzIGluIGxlbmd0aCwgYSBwYWQgYnl0ZSBtdXN0IGJlIGFkZGVkIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIGRlYnVnKGBDaHVuayBpZD0ke2NodW5rSGVhZGVyLmNodW5rSUR9YCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlYWREYXRhKGNodW5rSGVhZGVyKTtcbiAgICAgICAgICAgIHJlbWFpbmluZ1NpemUgLT0gKEJpZ0ludChEc2RpZmZUb2tlbl8xLkNodW5rSGVhZGVyNjQubGVuKSArIGNodW5rSGVhZGVyLmNodW5rU2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGEoaGVhZGVyKSB7XG4gICAgICAgIGRlYnVnKGBSZWFkaW5nIGRhdGEgb2YgY2h1bmtbSUQ9JHtoZWFkZXIuY2h1bmtJRH0sIHNpemU9JHtoZWFkZXIuY2h1bmtTaXplfV1gKTtcbiAgICAgICAgY29uc3QgcDAgPSB0aGlzLnRva2VuaXplci5wb3NpdGlvbjtcbiAgICAgICAgc3dpdGNoIChoZWFkZXIuY2h1bmtJRC50cmltKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ0ZWRVInOiAvLyAzLjEgRk9STUFUIFZFUlNJT04gQ0hVTktcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKFRva2VuLlVJTlQzMl9MRSk7XG4gICAgICAgICAgICAgICAgZGVidWcoYERTRElGRiB2ZXJzaW9uPSR7dmVyc2lvbn1gKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BST1AnOiAvLyAzLjIgUFJPUEVSVFkgQ0hVTktcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wVHlwZSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihGb3VyQ0NfMS5Gb3VyQ2NUb2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BUeXBlICE9PSAnU05EICcpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBQUk9QLWNodW5rIElEJyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVTb3VuZFByb3BlcnR5Q2h1bmtzKGhlYWRlci5jaHVua1NpemUgLSBCaWdJbnQoRm91ckNDXzEuRm91ckNjVG9rZW4ubGVuKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdJRDMnOiAvLyBVbm9mZmljaWFsIElEMyB0YWcgc3VwcG9ydFxuICAgICAgICAgICAgICAgIGNvbnN0IGlkM19kYXRhID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBUb2tlbi5VaW50OEFycmF5VHlwZShOdW1iZXIoaGVhZGVyLmNodW5rU2l6ZSkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCByc3QgPSBzdHJ0b2szLmZyb21CdWZmZXIoaWQzX2RhdGEpO1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBJRDN2MlBhcnNlcl8xLklEM3YyUGFyc2VyKCkucGFyc2UodGhpcy5tZXRhZGF0YSwgcnN0LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBkZWJ1ZyhgSWdub3JlIGNodW5rW0lEPSR7aGVhZGVyLmNodW5rSUR9LCBzaXplPSR7aGVhZGVyLmNodW5rU2l6ZX1dYCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdEU0QnOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZlNhbXBsZXMnLCBOdW1iZXIoaGVhZGVyLmNodW5rU2l6ZSAqIEJpZ0ludCg4KSAvIEJpZ0ludCh0aGlzLm1ldGFkYXRhLmZvcm1hdC5udW1iZXJPZkNoYW5uZWxzKSkpO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdkdXJhdGlvbicsIHRoaXMubWV0YWRhdGEuZm9ybWF0Lm51bWJlck9mU2FtcGxlcyAvIHRoaXMubWV0YWRhdGEuZm9ybWF0LnNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IGhlYWRlci5jaHVua1NpemUgLSBCaWdJbnQodGhpcy50b2tlbml6ZXIucG9zaXRpb24gLSBwMCk7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgICBkZWJ1ZyhgQWZ0ZXIgUGFyc2luZyBjaHVuaywgcmVtYWluaW5nICR7cmVtYWluaW5nfSBieXRlc2ApO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKE51bWJlcihyZW1haW5pbmcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBoYW5kbGVTb3VuZFByb3BlcnR5Q2h1bmtzKHJlbWFpbmluZ1NpemUpIHtcbiAgICAgICAgZGVidWcoYFBhcnNpbmcgc291bmQtcHJvcGVydHktY2h1bmtzLCByZW1haW5pbmdTaXplPSR7cmVtYWluaW5nU2l6ZX1gKTtcbiAgICAgICAgd2hpbGUgKHJlbWFpbmluZ1NpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzbmRQcm9wSGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKERzZGlmZlRva2VuXzEuQ2h1bmtIZWFkZXI2NCk7XG4gICAgICAgICAgICBkZWJ1ZyhgU291bmQtcHJvcGVydHktY2h1bmtbSUQ9JHtzbmRQcm9wSGVhZGVyLmNodW5rSUR9LCBzaXplPSR7c25kUHJvcEhlYWRlci5jaHVua1NpemV9XWApO1xuICAgICAgICAgICAgY29uc3QgcDAgPSB0aGlzLnRva2VuaXplci5wb3NpdGlvbjtcbiAgICAgICAgICAgIHN3aXRjaCAoc25kUHJvcEhlYWRlci5jaHVua0lELnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0ZTJzogLy8gMy4yLjEgU2FtcGxlIFJhdGUgQ2h1bmtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FtcGxlUmF0ZSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihUb2tlbi5VSU5UMzJfQkUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnc2FtcGxlUmF0ZScsIHNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdDSE5MJzogLy8gMy4yLjIgQ2hhbm5lbHMgQ2h1bmtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtQ2hhbm5lbHMgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oVG9rZW4uVUlOVDE2X0JFKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ251bWJlck9mQ2hhbm5lbHMnLCBudW1DaGFubmVscyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlQ2hhbm5lbENodW5rcyhzbmRQcm9wSGVhZGVyLmNodW5rU2l6ZSAtIEJpZ0ludChUb2tlbi5VSU5UMTZfQkUubGVuKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0NNUFInOiAvLyAzLjIuMyBDb21wcmVzc2lvbiBUeXBlIENodW5rXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzaW9uSWRDb2RlID0gKGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihGb3VyQ0NfMS5Gb3VyQ2NUb2tlbikpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oVG9rZW4uVUlOVDgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzc2lvbk5hbWUgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IFRva2VuLlN0cmluZ1R5cGUoY291bnQsICdhc2NpaScpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXByZXNzaW9uSWRDb2RlID09PSAnRFNEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2xvc3NsZXNzJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYml0c1BlclNhbXBsZScsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb2RlYycsIGAke2NvbXByZXNzaW9uSWRDb2RlfSAoJHtjb21wcmVzc2lvbk5hbWV9KWApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdBQlNTJzogLy8gMy4yLjQgQWJzb2x1dGUgU3RhcnQgVGltZSBDaHVua1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3VycyA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihUb2tlbi5VSU5UMTZfQkUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaW51dGVzID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKFRva2VuLlVJTlQ4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Vjb25kcyA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihUb2tlbi5VSU5UOCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNhbXBsZXMgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oVG9rZW4uVUlOVDMyX0JFKTtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoYEFCU1MgJHtob3Vyc306JHttaW51dGVzfToke3NlY29uZHN9LiR7c2FtcGxlc31gKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnTFNDTyc6IC8vIDMuMi41IExvdWRzcGVha2VyIENvbmZpZ3VyYXRpb24gQ2h1bmtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbHNDb25maWcgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oVG9rZW4uVUlOVDE2X0JFKTtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoYExTQ08gbHNDb25maWc9JHtsc0NvbmZpZ31gKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQ09NVCc6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoYFVua25vd24gc291bmQtcHJvcGVydHktY2h1bmtbSUQ9JHtzbmRQcm9wSGVhZGVyLmNodW5rSUR9LCBzaXplPSR7c25kUHJvcEhlYWRlci5jaHVua1NpemV9XWApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUoTnVtYmVyKHNuZFByb3BIZWFkZXIuY2h1bmtTaXplKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmcgPSBzbmRQcm9wSGVhZGVyLmNodW5rU2l6ZSAtIEJpZ0ludCh0aGlzLnRva2VuaXplci5wb3NpdGlvbiAtIHAwKTtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoYEFmdGVyIFBhcnNpbmcgc291bmQtcHJvcGVydHktY2h1bmsgJHtzbmRQcm9wSGVhZGVyLmNodW5rU2l6ZX0sIHJlbWFpbmluZyAke3JlbWFpbmluZ30gYnl0ZXNgKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUoTnVtYmVyKHJlbWFpbmluZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtYWluaW5nU2l6ZSAtPSBCaWdJbnQoRHNkaWZmVG9rZW5fMS5DaHVua0hlYWRlcjY0LmxlbikgKyBzbmRQcm9wSGVhZGVyLmNodW5rU2l6ZTtcbiAgICAgICAgICAgIGRlYnVnKGBQYXJzaW5nIHNvdW5kLXByb3BlcnR5LWNodW5rcywgcmVtYWluaW5nU2l6ZT0ke3JlbWFpbmluZ1NpemV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEuZm9ybWF0Lmxvc3NsZXNzICYmIHRoaXMubWV0YWRhdGEuZm9ybWF0LnNhbXBsZVJhdGUgJiYgdGhpcy5tZXRhZGF0YS5mb3JtYXQubnVtYmVyT2ZDaGFubmVscyAmJiB0aGlzLm1ldGFkYXRhLmZvcm1hdC5iaXRzUGVyU2FtcGxlKSB7XG4gICAgICAgICAgICBjb25zdCBiaXRyYXRlID0gdGhpcy5tZXRhZGF0YS5mb3JtYXQuc2FtcGxlUmF0ZSAqIHRoaXMubWV0YWRhdGEuZm9ybWF0Lm51bWJlck9mQ2hhbm5lbHMgKiB0aGlzLm1ldGFkYXRhLmZvcm1hdC5iaXRzUGVyU2FtcGxlO1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCBiaXRyYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFubmVsQ2h1bmtzKHJlbWFpbmluZ1NpemUpIHtcbiAgICAgICAgZGVidWcoYFBhcnNpbmcgY2hhbm5lbC1jaHVua3MsIHJlbWFpbmluZ1NpemU9JHtyZW1haW5pbmdTaXplfWApO1xuICAgICAgICBjb25zdCBjaGFubmVscyA9IFtdO1xuICAgICAgICB3aGlsZSAocmVtYWluaW5nU2l6ZSA+PSBGb3VyQ0NfMS5Gb3VyQ2NUb2tlbi5sZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxJZCA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihGb3VyQ0NfMS5Gb3VyQ2NUb2tlbik7XG4gICAgICAgICAgICBkZWJ1ZyhgQ2hhbm5lbFtJRD0ke2NoYW5uZWxJZH1dYCk7XG4gICAgICAgICAgICBjaGFubmVscy5wdXNoKGNoYW5uZWxJZCk7XG4gICAgICAgICAgICByZW1haW5pbmdTaXplIC09IEJpZ0ludChGb3VyQ0NfMS5Gb3VyQ2NUb2tlbi5sZW4pO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKGBDaGFubmVsczogJHtjaGFubmVscy5qb2luKCcsICcpfWApO1xuICAgICAgICByZXR1cm4gY2hhbm5lbHM7XG4gICAgfVxufVxuZXhwb3J0cy5Ec2RpZmZQYXJzZXIgPSBEc2RpZmZQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/dsdiff/DsdiffParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/dsdiff/DsdiffToken.js":
/*!***************************************************************!*\
  !*** ./node_modules/music-metadata/lib/dsdiff/DsdiffToken.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChunkHeader64 = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/FourCC.js\");\n/**\n * DSDIFF chunk header\n * The data-size encoding is deviating from EA-IFF 85\n * Ref: http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\n */\nexports.ChunkHeader64 = {\n    len: 12,\n    get: (buf, off) => {\n        return {\n            // Group-ID\n            chunkID: FourCC_1.FourCcToken.get(buf, off),\n            // Size\n            chunkSize: Token.INT64_BE.get(buf, off + 4)\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvZHNkaWZmL0RzZGlmZlRva2VuLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixjQUFjLG1CQUFPLENBQUMsZ0ZBQWE7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsZ0dBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9kc2RpZmYvRHNkaWZmVG9rZW4uanM/N2QzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2h1bmtIZWFkZXI2NCA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgRm91ckNDXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0ZvdXJDQ1wiKTtcbi8qKlxuICogRFNESUZGIGNodW5rIGhlYWRlclxuICogVGhlIGRhdGEtc2l6ZSBlbmNvZGluZyBpcyBkZXZpYXRpbmcgZnJvbSBFQS1JRkYgODVcbiAqIFJlZjogaHR0cDovL3d3dy5zb25pY3N0dWRpby5jb20vcGRmL2RzZC9EU0RJRkZfMS41X1NwZWMucGRmXG4gKi9cbmV4cG9ydHMuQ2h1bmtIZWFkZXI2NCA9IHtcbiAgICBsZW46IDEyLFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBHcm91cC1JRFxuICAgICAgICAgICAgY2h1bmtJRDogRm91ckNDXzEuRm91ckNjVG9rZW4uZ2V0KGJ1Ziwgb2ZmKSxcbiAgICAgICAgICAgIC8vIFNpemVcbiAgICAgICAgICAgIGNodW5rU2l6ZTogVG9rZW4uSU5UNjRfQkUuZ2V0KGJ1Ziwgb2ZmICsgNClcbiAgICAgICAgfTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/dsdiff/DsdiffToken.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/dsf/DsfChunk.js":
/*!*********************************************************!*\
  !*** ./node_modules/music-metadata/lib/dsf/DsfChunk.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FormatChunk = exports.ChannelType = exports.DsdChunk = exports.ChunkHeader = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/FourCC.js\");\n/**\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\n */\nexports.ChunkHeader = {\n    len: 12,\n    get: (buf, off) => {\n        return { id: FourCC_1.FourCcToken.get(buf, off), size: Token.UINT64_LE.get(buf, off + 4) };\n    }\n};\n/**\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\n */\nexports.DsdChunk = {\n    len: 16,\n    get: (buf, off) => {\n        return {\n            fileSize: Token.INT64_LE.get(buf, off),\n            metadataPointer: Token.INT64_LE.get(buf, off + 8)\n        };\n    }\n};\nvar ChannelType;\n(function (ChannelType) {\n    ChannelType[ChannelType[\"mono\"] = 1] = \"mono\";\n    ChannelType[ChannelType[\"stereo\"] = 2] = \"stereo\";\n    ChannelType[ChannelType[\"channels\"] = 3] = \"channels\";\n    ChannelType[ChannelType[\"quad\"] = 4] = \"quad\";\n    ChannelType[ChannelType[\"4 channels\"] = 5] = \"4 channels\";\n    ChannelType[ChannelType[\"5 channels\"] = 6] = \"5 channels\";\n    ChannelType[ChannelType[\"5.1 channels\"] = 7] = \"5.1 channels\";\n})(ChannelType = exports.ChannelType || (exports.ChannelType = {}));\n/**\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\n */\nexports.FormatChunk = {\n    len: 40,\n    get: (buf, off) => {\n        return {\n            formatVersion: Token.INT32_LE.get(buf, off),\n            formatID: Token.INT32_LE.get(buf, off + 4),\n            channelType: Token.INT32_LE.get(buf, off + 8),\n            channelNum: Token.INT32_LE.get(buf, off + 12),\n            samplingFrequency: Token.INT32_LE.get(buf, off + 16),\n            bitsPerSample: Token.INT32_LE.get(buf, off + 20),\n            sampleCount: Token.INT64_LE.get(buf, off + 24),\n            blockSizePerChannel: Token.INT32_LE.get(buf, off + 32)\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvZHNmL0RzZkNodW5rLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLGdCQUFnQixHQUFHLG1CQUFtQjtBQUNsRixjQUFjLG1CQUFPLENBQUMsZ0ZBQWE7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsZ0dBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDLG1CQUFtQixLQUFLO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvZHNmL0RzZkNodW5rLmpzPzc0MzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZvcm1hdENodW5rID0gZXhwb3J0cy5DaGFubmVsVHlwZSA9IGV4cG9ydHMuRHNkQ2h1bmsgPSBleHBvcnRzLkNodW5rSGVhZGVyID0gdm9pZCAwO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBGb3VyQ0NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vRm91ckNDXCIpO1xuLyoqXG4gKiBDb21tb24gY2h1bmsgRFNEIGhlYWRlcjogdGhlICdjaHVuayBuYW1lIChGb3VyLUNDKScgJiBjaHVuayBzaXplXG4gKi9cbmV4cG9ydHMuQ2h1bmtIZWFkZXIgPSB7XG4gICAgbGVuOiAxMixcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4geyBpZDogRm91ckNDXzEuRm91ckNjVG9rZW4uZ2V0KGJ1Ziwgb2ZmKSwgc2l6ZTogVG9rZW4uVUlOVDY0X0xFLmdldChidWYsIG9mZiArIDQpIH07XG4gICAgfVxufTtcbi8qKlxuICogQ29tbW9uIGNodW5rIERTRCBoZWFkZXI6IHRoZSAnY2h1bmsgbmFtZSAoRm91ci1DQyknICYgY2h1bmsgc2l6ZVxuICovXG5leHBvcnRzLkRzZENodW5rID0ge1xuICAgIGxlbjogMTYsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpbGVTaXplOiBUb2tlbi5JTlQ2NF9MRS5nZXQoYnVmLCBvZmYpLFxuICAgICAgICAgICAgbWV0YWRhdGFQb2ludGVyOiBUb2tlbi5JTlQ2NF9MRS5nZXQoYnVmLCBvZmYgKyA4KVxuICAgICAgICB9O1xuICAgIH1cbn07XG52YXIgQ2hhbm5lbFR5cGU7XG4oZnVuY3Rpb24gKENoYW5uZWxUeXBlKSB7XG4gICAgQ2hhbm5lbFR5cGVbQ2hhbm5lbFR5cGVbXCJtb25vXCJdID0gMV0gPSBcIm1vbm9cIjtcbiAgICBDaGFubmVsVHlwZVtDaGFubmVsVHlwZVtcInN0ZXJlb1wiXSA9IDJdID0gXCJzdGVyZW9cIjtcbiAgICBDaGFubmVsVHlwZVtDaGFubmVsVHlwZVtcImNoYW5uZWxzXCJdID0gM10gPSBcImNoYW5uZWxzXCI7XG4gICAgQ2hhbm5lbFR5cGVbQ2hhbm5lbFR5cGVbXCJxdWFkXCJdID0gNF0gPSBcInF1YWRcIjtcbiAgICBDaGFubmVsVHlwZVtDaGFubmVsVHlwZVtcIjQgY2hhbm5lbHNcIl0gPSA1XSA9IFwiNCBjaGFubmVsc1wiO1xuICAgIENoYW5uZWxUeXBlW0NoYW5uZWxUeXBlW1wiNSBjaGFubmVsc1wiXSA9IDZdID0gXCI1IGNoYW5uZWxzXCI7XG4gICAgQ2hhbm5lbFR5cGVbQ2hhbm5lbFR5cGVbXCI1LjEgY2hhbm5lbHNcIl0gPSA3XSA9IFwiNS4xIGNoYW5uZWxzXCI7XG59KShDaGFubmVsVHlwZSA9IGV4cG9ydHMuQ2hhbm5lbFR5cGUgfHwgKGV4cG9ydHMuQ2hhbm5lbFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBDb21tb24gY2h1bmsgRFNEIGhlYWRlcjogdGhlICdjaHVuayBuYW1lIChGb3VyLUNDKScgJiBjaHVuayBzaXplXG4gKi9cbmV4cG9ydHMuRm9ybWF0Q2h1bmsgPSB7XG4gICAgbGVuOiA0MCxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0VmVyc2lvbjogVG9rZW4uSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmKSxcbiAgICAgICAgICAgIGZvcm1hdElEOiBUb2tlbi5JTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyA0KSxcbiAgICAgICAgICAgIGNoYW5uZWxUeXBlOiBUb2tlbi5JTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyA4KSxcbiAgICAgICAgICAgIGNoYW5uZWxOdW06IFRva2VuLklOVDMyX0xFLmdldChidWYsIG9mZiArIDEyKSxcbiAgICAgICAgICAgIHNhbXBsaW5nRnJlcXVlbmN5OiBUb2tlbi5JTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAxNiksXG4gICAgICAgICAgICBiaXRzUGVyU2FtcGxlOiBUb2tlbi5JTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAyMCksXG4gICAgICAgICAgICBzYW1wbGVDb3VudDogVG9rZW4uSU5UNjRfTEUuZ2V0KGJ1Ziwgb2ZmICsgMjQpLFxuICAgICAgICAgICAgYmxvY2tTaXplUGVyQ2hhbm5lbDogVG9rZW4uSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgMzIpXG4gICAgICAgIH07XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/dsf/DsfChunk.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/dsf/DsfParser.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/dsf/DsfParser.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DsfParser = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst AbstractID3Parser_1 = __webpack_require__(/*! ../id3v2/AbstractID3Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js\");\nconst DsfChunk_1 = __webpack_require__(/*! ./DsfChunk */ \"(app-pages-browser)/./node_modules/music-metadata/lib/dsf/DsfChunk.js\");\nconst ID3v2Parser_1 = __webpack_require__(/*! ../id3v2/ID3v2Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:DSF');\n/**\n * DSF (dsd stream file) File Parser\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\n */\nclass DsfParser extends AbstractID3Parser_1.AbstractID3Parser {\n    async postId3v2Parse() {\n        const p0 = this.tokenizer.position; // mark start position, normally 0\n        const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n        if (chunkHeader.id !== 'DSD ')\n            throw new Error('Invalid chunk signature');\n        this.metadata.setFormat('container', 'DSF');\n        this.metadata.setFormat('lossless', true);\n        const dsdChunk = await this.tokenizer.readToken(DsfChunk_1.DsdChunk);\n        if (dsdChunk.metadataPointer === BigInt(0)) {\n            debug(`No ID3v2 tag present`);\n        }\n        else {\n            debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);\n            await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);\n            // Jump to ID3 header\n            await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);\n            return new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);\n        }\n    }\n    async parseChunks(bytesRemaining) {\n        while (bytesRemaining >= DsfChunk_1.ChunkHeader.len) {\n            const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n            debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);\n            switch (chunkHeader.id) {\n                case 'fmt ':\n                    const formatChunk = await this.tokenizer.readToken(DsfChunk_1.FormatChunk);\n                    this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\n                    this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\n                    this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\n                    this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\n                    this.metadata.setFormat('duration', Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);\n                    const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\n                    this.metadata.setFormat('bitrate', bitrate);\n                    return; // We got what we want, stop further processing of chunks\n                default:\n                    this.tokenizer.ignore(Number(chunkHeader.size) - DsfChunk_1.ChunkHeader.len);\n                    break;\n            }\n            bytesRemaining -= chunkHeader.size;\n        }\n    }\n}\nexports.DsfParser = DsfParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvZHNmL0RzZlBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQU87QUFDL0IsNEJBQTRCLG1CQUFPLENBQUMsb0hBQTRCO0FBQ2hFLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDLHNCQUFzQixtQkFBTyxDQUFDLHdHQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5QkFBeUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQixPQUFPLGlCQUFpQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvZHNmL0RzZlBhcnNlci5qcz9iY2QwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ec2ZQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgQWJzdHJhY3RJRDNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9pZDN2Mi9BYnN0cmFjdElEM1BhcnNlclwiKTtcbmNvbnN0IERzZkNodW5rXzEgPSByZXF1aXJlKFwiLi9Ec2ZDaHVua1wiKTtcbmNvbnN0IElEM3YyUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vaWQzdjIvSUQzdjJQYXJzZXJcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6RFNGJyk7XG4vKipcbiAqIERTRiAoZHNkIHN0cmVhbSBmaWxlKSBGaWxlIFBhcnNlclxuICogUmVmOiBodHRwczovL2RzZC1ndWlkZS5jb20vc2l0ZXMvZGVmYXVsdC9maWxlcy93aGl0ZS1wYXBlcnMvRFNGRmlsZUZvcm1hdFNwZWNfRS5wZGZcbiAqL1xuY2xhc3MgRHNmUGFyc2VyIGV4dGVuZHMgQWJzdHJhY3RJRDNQYXJzZXJfMS5BYnN0cmFjdElEM1BhcnNlciB7XG4gICAgYXN5bmMgcG9zdElkM3YyUGFyc2UoKSB7XG4gICAgICAgIGNvbnN0IHAwID0gdGhpcy50b2tlbml6ZXIucG9zaXRpb247IC8vIG1hcmsgc3RhcnQgcG9zaXRpb24sIG5vcm1hbGx5IDBcbiAgICAgICAgY29uc3QgY2h1bmtIZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oRHNmQ2h1bmtfMS5DaHVua0hlYWRlcik7XG4gICAgICAgIGlmIChjaHVua0hlYWRlci5pZCAhPT0gJ0RTRCAnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNodW5rIHNpZ25hdHVyZScpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29udGFpbmVyJywgJ0RTRicpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbG9zc2xlc3MnLCB0cnVlKTtcbiAgICAgICAgY29uc3QgZHNkQ2h1bmsgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oRHNmQ2h1bmtfMS5Ec2RDaHVuayk7XG4gICAgICAgIGlmIChkc2RDaHVuay5tZXRhZGF0YVBvaW50ZXIgPT09IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgZGVidWcoYE5vIElEM3YyIHRhZyBwcmVzZW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhgZXhwZWN0IElEM3YyIGF0IG9mZnNldD0ke2RzZENodW5rLm1ldGFkYXRhUG9pbnRlcn1gKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGFyc2VDaHVua3MoZHNkQ2h1bmsuZmlsZVNpemUgLSBjaHVua0hlYWRlci5zaXplKTtcbiAgICAgICAgICAgIC8vIEp1bXAgdG8gSUQzIGhlYWRlclxuICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKE51bWJlcihkc2RDaHVuay5tZXRhZGF0YVBvaW50ZXIpIC0gdGhpcy50b2tlbml6ZXIucG9zaXRpb24gLSBwMCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElEM3YyUGFyc2VyXzEuSUQzdjJQYXJzZXIoKS5wYXJzZSh0aGlzLm1ldGFkYXRhLCB0aGlzLnRva2VuaXplciwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXJzZUNodW5rcyhieXRlc1JlbWFpbmluZykge1xuICAgICAgICB3aGlsZSAoYnl0ZXNSZW1haW5pbmcgPj0gRHNmQ2h1bmtfMS5DaHVua0hlYWRlci5sZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rSGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKERzZkNodW5rXzEuQ2h1bmtIZWFkZXIpO1xuICAgICAgICAgICAgZGVidWcoYFBhcnNpbmcgY2h1bmsgbmFtZT0ke2NodW5rSGVhZGVyLmlkfSBzaXplPSR7Y2h1bmtIZWFkZXIuc2l6ZX1gKTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2h1bmtIZWFkZXIuaWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdmbXQgJzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0Q2h1bmsgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oRHNmQ2h1bmtfMS5Gb3JtYXRDaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZkNoYW5uZWxzJywgZm9ybWF0Q2h1bmsuY2hhbm5lbE51bSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdzYW1wbGVSYXRlJywgZm9ybWF0Q2h1bmsuc2FtcGxpbmdGcmVxdWVuY3kpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYml0c1BlclNhbXBsZScsIGZvcm1hdENodW5rLmJpdHNQZXJTYW1wbGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZTYW1wbGVzJywgZm9ybWF0Q2h1bmsuc2FtcGxlQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnZHVyYXRpb24nLCBOdW1iZXIoZm9ybWF0Q2h1bmsuc2FtcGxlQ291bnQpIC8gZm9ybWF0Q2h1bmsuc2FtcGxpbmdGcmVxdWVuY3kpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiaXRyYXRlID0gZm9ybWF0Q2h1bmsuYml0c1BlclNhbXBsZSAqIGZvcm1hdENodW5rLnNhbXBsaW5nRnJlcXVlbmN5ICogZm9ybWF0Q2h1bmsuY2hhbm5lbE51bTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCBiaXRyYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBXZSBnb3Qgd2hhdCB3ZSB3YW50LCBzdG9wIGZ1cnRoZXIgcHJvY2Vzc2luZyBvZiBjaHVua3NcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2VuaXplci5pZ25vcmUoTnVtYmVyKGNodW5rSGVhZGVyLnNpemUpIC0gRHNmQ2h1bmtfMS5DaHVua0hlYWRlci5sZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ5dGVzUmVtYWluaW5nIC09IGNodW5rSGVhZGVyLnNpemU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkRzZlBhcnNlciA9IERzZlBhcnNlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/dsf/DsfParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/flac/FlacParser.js":
/*!************************************************************!*\
  !*** ./node_modules/music-metadata/lib/flac/FlacParser.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FlacParser = void 0;\nconst token_types_1 = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst util = __webpack_require__(/*! ../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\nconst Vorbis_1 = __webpack_require__(/*! ../ogg/vorbis/Vorbis */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js\");\nconst AbstractID3Parser_1 = __webpack_require__(/*! ../id3v2/AbstractID3Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/FourCC.js\");\nconst VorbisParser_1 = __webpack_require__(/*! ../ogg/vorbis/VorbisParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js\");\nconst VorbisDecoder_1 = __webpack_require__(/*! ../ogg/vorbis/VorbisDecoder */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:FLAC');\n/**\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\n * ref: https://xiph.org/flac/format.html#metadata_block\n */\nvar BlockType;\n(function (BlockType) {\n    BlockType[BlockType[\"STREAMINFO\"] = 0] = \"STREAMINFO\";\n    BlockType[BlockType[\"PADDING\"] = 1] = \"PADDING\";\n    BlockType[BlockType[\"APPLICATION\"] = 2] = \"APPLICATION\";\n    BlockType[BlockType[\"SEEKTABLE\"] = 3] = \"SEEKTABLE\";\n    BlockType[BlockType[\"VORBIS_COMMENT\"] = 4] = \"VORBIS_COMMENT\";\n    BlockType[BlockType[\"CUESHEET\"] = 5] = \"CUESHEET\";\n    BlockType[BlockType[\"PICTURE\"] = 6] = \"PICTURE\";\n})(BlockType || (BlockType = {}));\nclass FlacParser extends AbstractID3Parser_1.AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.padding = 0;\n    }\n    /**\n     * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\n     * @param {INativeMetadataCollector} metadata Output\n     * @param {ITokenizer} tokenizer Input\n     * @param {IOptions} options Parsing options\n     */\n    init(metadata, tokenizer, options) {\n        super.init(metadata, tokenizer, options);\n        this.vorbisParser = new VorbisParser_1.VorbisParser(metadata, options);\n        return this;\n    }\n    async postId3v2Parse() {\n        const fourCC = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        if (fourCC.toString() !== 'fLaC') {\n            throw new Error('Invalid FLAC preamble');\n        }\n        let blockHeader;\n        do {\n            // Read block header\n            blockHeader = await this.tokenizer.readToken(Metadata.BlockHeader);\n            // Parse block data\n            await this.parseDataBlock(blockHeader);\n        } while (!blockHeader.lastBlock);\n        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n        }\n    }\n    parseDataBlock(blockHeader) {\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n        switch (blockHeader.type) {\n            case BlockType.STREAMINFO:\n                return this.parseBlockStreamInfo(blockHeader.length);\n            case BlockType.PADDING:\n                this.padding += blockHeader.length;\n                break;\n            case BlockType.APPLICATION:\n                break;\n            case BlockType.SEEKTABLE:\n                break;\n            case BlockType.VORBIS_COMMENT:\n                return this.parseComment(blockHeader.length);\n            case BlockType.CUESHEET:\n                break;\n            case BlockType.PICTURE:\n                return this.parsePicture(blockHeader.length).then();\n            default:\n                this.metadata.addWarning('Unknown block type: ' + blockHeader.type);\n        }\n        // Ignore data block\n        return this.tokenizer.ignore(blockHeader.length).then();\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    async parseBlockStreamInfo(dataLen) {\n        if (dataLen !== Metadata.BlockStreamInfo.len)\n            throw new Error('Unexpected block-stream-info length');\n        const streamInfo = await this.tokenizer.readToken(Metadata.BlockStreamInfo);\n        this.metadata.setFormat('container', 'FLAC');\n        this.metadata.setFormat('codec', 'FLAC');\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n        if (streamInfo.totalSamples > 0) {\n            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n        }\n    }\n    /**\n     * Parse VORBIS_COMMENT\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async parseComment(dataLen) {\n        const data = await this.tokenizer.readToken(new token_types_1.Uint8ArrayType(dataLen));\n        const decoder = new VorbisDecoder_1.VorbisDecoder(data, 0);\n        decoder.readStringUtf8(); // vendor (skip)\n        const commentListLength = decoder.readInt32();\n        for (let i = 0; i < commentListLength; i++) {\n            const tag = decoder.parseUserComment();\n            this.vorbisParser.addTag(tag.key, tag.value);\n        }\n    }\n    async parsePicture(dataLen) {\n        if (this.options.skipCovers) {\n            return this.tokenizer.ignore(dataLen);\n        }\n        else {\n            const picture = await this.tokenizer.readToken(new Vorbis_1.VorbisPictureToken(dataLen));\n            this.vorbisParser.addTag('METADATA_BLOCK_PICTURE', picture);\n        }\n    }\n}\nexports.FlacParser = FlacParser;\nclass Metadata {\n}\nMetadata.BlockHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            lastBlock: util.getBit(buf, off, 7),\n            type: util.getBitAllignedNumber(buf, off, 1, 7),\n            length: token_types_1.UINT24_BE.get(buf, off + 1)\n        };\n    }\n};\n/**\n * METADATA_BLOCK_DATA\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\n */\nMetadata.BlockStreamInfo = {\n    len: 34,\n    get: (buf, off) => {\n        return {\n            // The minimum block size (in samples) used in the stream.\n            minimumBlockSize: token_types_1.UINT16_BE.get(buf, off),\n            // The maximum block size (in samples) used in the stream.\n            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\n            maximumBlockSize: token_types_1.UINT16_BE.get(buf, off + 2) / 1000,\n            // The minimum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            minimumFrameSize: token_types_1.UINT24_BE.get(buf, off + 4),\n            // The maximum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            maximumFrameSize: token_types_1.UINT24_BE.get(buf, off + 7),\n            // Sample rate in Hz. Though 20 bits are available,\n            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\n            // Also, a value of 0 is invalid.\n            sampleRate: token_types_1.UINT24_BE.get(buf, off + 10) >> 4,\n            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\n            // (number of channels)-1. FLAC supports from 1 to 8 channels\n            channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\n            // bits per sample)-1.\n            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\n            bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\n            // Total samples in stream.\n            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\n            // A value of zero here means the number of total samples is unknown.\n            totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n            fileMD5: new token_types_1.Uint8ArrayType(16).get(buf, off + 18)\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvZmxhYy9GbGFjUGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixzQkFBc0IsbUJBQU8sQ0FBQyxnRkFBYTtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBTztBQUMvQixhQUFhLG1CQUFPLENBQUMsNEZBQWdCO0FBQ3JDLGlCQUFpQixtQkFBTyxDQUFDLHdHQUFzQjtBQUMvQyw0QkFBNEIsbUJBQU8sQ0FBQyxvSEFBNEI7QUFDaEUsaUJBQWlCLG1CQUFPLENBQUMsZ0dBQWtCO0FBQzNDLHVCQUF1QixtQkFBTyxDQUFDLG9IQUE0QjtBQUMzRCx3QkFBd0IsbUJBQU8sQ0FBQyxzSEFBNkI7QUFDN0Q7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFlBQVk7QUFDM0IsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQixXQUFXLG1CQUFtQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvZmxhYy9GbGFjUGFyc2VyLmpzP2VmZGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZsYWNQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCB0b2tlbl90eXBlc18xID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi4vY29tbW9uL1V0aWxcIik7XG5jb25zdCBWb3JiaXNfMSA9IHJlcXVpcmUoXCIuLi9vZ2cvdm9yYmlzL1ZvcmJpc1wiKTtcbmNvbnN0IEFic3RyYWN0SUQzUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vaWQzdjIvQWJzdHJhY3RJRDNQYXJzZXJcIik7XG5jb25zdCBGb3VyQ0NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vRm91ckNDXCIpO1xuY29uc3QgVm9yYmlzUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vb2dnL3ZvcmJpcy9Wb3JiaXNQYXJzZXJcIik7XG5jb25zdCBWb3JiaXNEZWNvZGVyXzEgPSByZXF1aXJlKFwiLi4vb2dnL3ZvcmJpcy9Wb3JiaXNEZWNvZGVyXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbXVzaWMtbWV0YWRhdGE6cGFyc2VyOkZMQUMnKTtcbi8qKlxuICogRkxBQyBzdXBwb3J0cyB1cCB0byAxMjgga2luZHMgb2YgbWV0YWRhdGEgYmxvY2tzOyBjdXJyZW50bHkgdGhlIGZvbGxvd2luZyBhcmUgZGVmaW5lZDpcbiAqIHJlZjogaHR0cHM6Ly94aXBoLm9yZy9mbGFjL2Zvcm1hdC5odG1sI21ldGFkYXRhX2Jsb2NrXG4gKi9cbnZhciBCbG9ja1R5cGU7XG4oZnVuY3Rpb24gKEJsb2NrVHlwZSkge1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJTVFJFQU1JTkZPXCJdID0gMF0gPSBcIlNUUkVBTUlORk9cIjtcbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiUEFERElOR1wiXSA9IDFdID0gXCJQQURESU5HXCI7XG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIkFQUExJQ0FUSU9OXCJdID0gMl0gPSBcIkFQUExJQ0FUSU9OXCI7XG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIlNFRUtUQUJMRVwiXSA9IDNdID0gXCJTRUVLVEFCTEVcIjtcbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiVk9SQklTX0NPTU1FTlRcIl0gPSA0XSA9IFwiVk9SQklTX0NPTU1FTlRcIjtcbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiQ1VFU0hFRVRcIl0gPSA1XSA9IFwiQ1VFU0hFRVRcIjtcbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiUElDVFVSRVwiXSA9IDZdID0gXCJQSUNUVVJFXCI7XG59KShCbG9ja1R5cGUgfHwgKEJsb2NrVHlwZSA9IHt9KSk7XG5jbGFzcyBGbGFjUGFyc2VyIGV4dGVuZHMgQWJzdHJhY3RJRDNQYXJzZXJfMS5BYnN0cmFjdElEM1BhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucGFkZGluZyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgcGFyc2VyIHdpdGggb3V0cHV0IChtZXRhZGF0YSksIGlucHV0ICh0b2tlbml6ZXIpICYgcGFyc2luZyBvcHRpb25zIChvcHRpb25zKS5cbiAgICAgKiBAcGFyYW0ge0lOYXRpdmVNZXRhZGF0YUNvbGxlY3Rvcn0gbWV0YWRhdGEgT3V0cHV0XG4gICAgICogQHBhcmFtIHtJVG9rZW5pemVyfSB0b2tlbml6ZXIgSW5wdXRcbiAgICAgKiBAcGFyYW0ge0lPcHRpb25zfSBvcHRpb25zIFBhcnNpbmcgb3B0aW9uc1xuICAgICAqL1xuICAgIGluaXQobWV0YWRhdGEsIHRva2VuaXplciwgb3B0aW9ucykge1xuICAgICAgICBzdXBlci5pbml0KG1ldGFkYXRhLCB0b2tlbml6ZXIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnZvcmJpc1BhcnNlciA9IG5ldyBWb3JiaXNQYXJzZXJfMS5Wb3JiaXNQYXJzZXIobWV0YWRhdGEsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXN5bmMgcG9zdElkM3YyUGFyc2UoKSB7XG4gICAgICAgIGNvbnN0IGZvdXJDQyA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihGb3VyQ0NfMS5Gb3VyQ2NUb2tlbik7XG4gICAgICAgIGlmIChmb3VyQ0MudG9TdHJpbmcoKSAhPT0gJ2ZMYUMnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRkxBQyBwcmVhbWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBibG9ja0hlYWRlcjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gUmVhZCBibG9jayBoZWFkZXJcbiAgICAgICAgICAgIGJsb2NrSGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKE1ldGFkYXRhLkJsb2NrSGVhZGVyKTtcbiAgICAgICAgICAgIC8vIFBhcnNlIGJsb2NrIGRhdGFcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGFyc2VEYXRhQmxvY2soYmxvY2tIZWFkZXIpO1xuICAgICAgICB9IHdoaWxlICghYmxvY2tIZWFkZXIubGFzdEJsb2NrKTtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5pemVyLmZpbGVJbmZvLnNpemUgJiYgdGhpcy5tZXRhZGF0YS5mb3JtYXQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFTaXplID0gdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSAtIHRoaXMudG9rZW5pemVyLnBvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCA4ICogZGF0YVNpemUgLyB0aGlzLm1ldGFkYXRhLmZvcm1hdC5kdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VEYXRhQmxvY2soYmxvY2tIZWFkZXIpIHtcbiAgICAgICAgZGVidWcoYGJsb2NrSGVhZGVyIHR5cGU9JHtibG9ja0hlYWRlci50eXBlfSwgbGVuZ3RoPSR7YmxvY2tIZWFkZXIubGVuZ3RofWApO1xuICAgICAgICBzd2l0Y2ggKGJsb2NrSGVhZGVyLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQmxvY2tUeXBlLlNUUkVBTUlORk86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCbG9ja1N0cmVhbUluZm8oYmxvY2tIZWFkZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIGNhc2UgQmxvY2tUeXBlLlBBRERJTkc6XG4gICAgICAgICAgICAgICAgdGhpcy5wYWRkaW5nICs9IGJsb2NrSGVhZGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmxvY2tUeXBlLkFQUExJQ0FUSU9OOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCbG9ja1R5cGUuU0VFS1RBQkxFOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCbG9ja1R5cGUuVk9SQklTX0NPTU1FTlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb21tZW50KGJsb2NrSGVhZGVyLmxlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIEJsb2NrVHlwZS5DVUVTSEVFVDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmxvY2tUeXBlLlBJQ1RVUkU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQaWN0dXJlKGJsb2NrSGVhZGVyLmxlbmd0aCkudGhlbigpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFdhcm5pbmcoJ1Vua25vd24gYmxvY2sgdHlwZTogJyArIGJsb2NrSGVhZGVyLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElnbm9yZSBkYXRhIGJsb2NrXG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuaXplci5pZ25vcmUoYmxvY2tIZWFkZXIubGVuZ3RoKS50aGVuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIFNUUkVBTUlORk9cbiAgICAgKi9cbiAgICBhc3luYyBwYXJzZUJsb2NrU3RyZWFtSW5mbyhkYXRhTGVuKSB7XG4gICAgICAgIGlmIChkYXRhTGVuICE9PSBNZXRhZGF0YS5CbG9ja1N0cmVhbUluZm8ubGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGJsb2NrLXN0cmVhbS1pbmZvIGxlbmd0aCcpO1xuICAgICAgICBjb25zdCBzdHJlYW1JbmZvID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKE1ldGFkYXRhLkJsb2NrU3RyZWFtSW5mbyk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb250YWluZXInLCAnRkxBQycpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29kZWMnLCAnRkxBQycpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbG9zc2xlc3MnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ251bWJlck9mQ2hhbm5lbHMnLCBzdHJlYW1JbmZvLmNoYW5uZWxzKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHNQZXJTYW1wbGUnLCBzdHJlYW1JbmZvLmJpdHNQZXJTYW1wbGUpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnc2FtcGxlUmF0ZScsIHN0cmVhbUluZm8uc2FtcGxlUmF0ZSk7XG4gICAgICAgIGlmIChzdHJlYW1JbmZvLnRvdGFsU2FtcGxlcyA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdkdXJhdGlvbicsIHN0cmVhbUluZm8udG90YWxTYW1wbGVzIC8gc3RyZWFtSW5mby5zYW1wbGVSYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBWT1JCSVNfQ09NTUVOVFxuICAgICAqIFJlZjogaHR0cHM6Ly93d3cueGlwaC5vcmcvdm9yYmlzL2RvYy9Wb3JiaXNfSV9zcGVjLmh0bWwjeDEtNjQwMDA0LjIuM1xuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlQ29tbWVudChkYXRhTGVuKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IHRva2VuX3R5cGVzXzEuVWludDhBcnJheVR5cGUoZGF0YUxlbikpO1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFZvcmJpc0RlY29kZXJfMS5Wb3JiaXNEZWNvZGVyKGRhdGEsIDApO1xuICAgICAgICBkZWNvZGVyLnJlYWRTdHJpbmdVdGY4KCk7IC8vIHZlbmRvciAoc2tpcClcbiAgICAgICAgY29uc3QgY29tbWVudExpc3RMZW5ndGggPSBkZWNvZGVyLnJlYWRJbnQzMigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1lbnRMaXN0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IGRlY29kZXIucGFyc2VVc2VyQ29tbWVudCgpO1xuICAgICAgICAgICAgdGhpcy52b3JiaXNQYXJzZXIuYWRkVGFnKHRhZy5rZXksIHRhZy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGFyc2VQaWN0dXJlKGRhdGFMZW4pIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5za2lwQ292ZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbml6ZXIuaWdub3JlKGRhdGFMZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGljdHVyZSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgVm9yYmlzXzEuVm9yYmlzUGljdHVyZVRva2VuKGRhdGFMZW4pKTtcbiAgICAgICAgICAgIHRoaXMudm9yYmlzUGFyc2VyLmFkZFRhZygnTUVUQURBVEFfQkxPQ0tfUElDVFVSRScsIHBpY3R1cmUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5GbGFjUGFyc2VyID0gRmxhY1BhcnNlcjtcbmNsYXNzIE1ldGFkYXRhIHtcbn1cbk1ldGFkYXRhLkJsb2NrSGVhZGVyID0ge1xuICAgIGxlbjogNCxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFzdEJsb2NrOiB1dGlsLmdldEJpdChidWYsIG9mZiwgNyksXG4gICAgICAgICAgICB0eXBlOiB1dGlsLmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmLCAxLCA3KSxcbiAgICAgICAgICAgIGxlbmd0aDogdG9rZW5fdHlwZXNfMS5VSU5UMjRfQkUuZ2V0KGJ1Ziwgb2ZmICsgMSlcbiAgICAgICAgfTtcbiAgICB9XG59O1xuLyoqXG4gKiBNRVRBREFUQV9CTE9DS19EQVRBXG4gKiBSZWY6IGh0dHBzOi8veGlwaC5vcmcvZmxhYy9mb3JtYXQuaHRtbCNtZXRhZGF0YV9ibG9ja19zdHJlYW1pbmZvXG4gKi9cbk1ldGFkYXRhLkJsb2NrU3RyZWFtSW5mbyA9IHtcbiAgICBsZW46IDM0LFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBUaGUgbWluaW11bSBibG9jayBzaXplIChpbiBzYW1wbGVzKSB1c2VkIGluIHRoZSBzdHJlYW0uXG4gICAgICAgICAgICBtaW5pbXVtQmxvY2tTaXplOiB0b2tlbl90eXBlc18xLlVJTlQxNl9CRS5nZXQoYnVmLCBvZmYpLFxuICAgICAgICAgICAgLy8gVGhlIG1heGltdW0gYmxvY2sgc2l6ZSAoaW4gc2FtcGxlcykgdXNlZCBpbiB0aGUgc3RyZWFtLlxuICAgICAgICAgICAgLy8gKE1pbmltdW0gYmxvY2tzaXplID09IG1heGltdW0gYmxvY2tzaXplKSBpbXBsaWVzIGEgZml4ZWQtYmxvY2tzaXplIHN0cmVhbS5cbiAgICAgICAgICAgIG1heGltdW1CbG9ja1NpemU6IHRva2VuX3R5cGVzXzEuVUlOVDE2X0JFLmdldChidWYsIG9mZiArIDIpIC8gMTAwMCxcbiAgICAgICAgICAgIC8vIFRoZSBtaW5pbXVtIGZyYW1lIHNpemUgKGluIGJ5dGVzKSB1c2VkIGluIHRoZSBzdHJlYW0uXG4gICAgICAgICAgICAvLyBNYXkgYmUgMCB0byBpbXBseSB0aGUgdmFsdWUgaXMgbm90IGtub3duLlxuICAgICAgICAgICAgbWluaW11bUZyYW1lU2l6ZTogdG9rZW5fdHlwZXNfMS5VSU5UMjRfQkUuZ2V0KGJ1Ziwgb2ZmICsgNCksXG4gICAgICAgICAgICAvLyBUaGUgbWF4aW11bSBmcmFtZSBzaXplIChpbiBieXRlcykgdXNlZCBpbiB0aGUgc3RyZWFtLlxuICAgICAgICAgICAgLy8gTWF5IGJlIDAgdG8gaW1wbHkgdGhlIHZhbHVlIGlzIG5vdCBrbm93bi5cbiAgICAgICAgICAgIG1heGltdW1GcmFtZVNpemU6IHRva2VuX3R5cGVzXzEuVUlOVDI0X0JFLmdldChidWYsIG9mZiArIDcpLFxuICAgICAgICAgICAgLy8gU2FtcGxlIHJhdGUgaW4gSHouIFRob3VnaCAyMCBiaXRzIGFyZSBhdmFpbGFibGUsXG4gICAgICAgICAgICAvLyB0aGUgbWF4aW11bSBzYW1wbGUgcmF0ZSBpcyBsaW1pdGVkIGJ5IHRoZSBzdHJ1Y3R1cmUgb2YgZnJhbWUgaGVhZGVycyB0byA2NTUzNTBIei5cbiAgICAgICAgICAgIC8vIEFsc28sIGEgdmFsdWUgb2YgMCBpcyBpbnZhbGlkLlxuICAgICAgICAgICAgc2FtcGxlUmF0ZTogdG9rZW5fdHlwZXNfMS5VSU5UMjRfQkUuZ2V0KGJ1Ziwgb2ZmICsgMTApID4+IDQsXG4gICAgICAgICAgICAvLyBwcm9iYWJseSBzbG93ZXI6IHNhbXBsZVJhdGU6IGNvbW1vbi5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDEwLCAwLCAyMCksXG4gICAgICAgICAgICAvLyAobnVtYmVyIG9mIGNoYW5uZWxzKS0xLiBGTEFDIHN1cHBvcnRzIGZyb20gMSB0byA4IGNoYW5uZWxzXG4gICAgICAgICAgICBjaGFubmVsczogdXRpbC5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDEyLCA0LCAzKSArIDEsXG4gICAgICAgICAgICAvLyBiaXRzIHBlciBzYW1wbGUpLTEuXG4gICAgICAgICAgICAvLyBGTEFDIHN1cHBvcnRzIGZyb20gNCB0byAzMiBiaXRzIHBlciBzYW1wbGUuIEN1cnJlbnRseSB0aGUgcmVmZXJlbmNlIGVuY29kZXIgYW5kIGRlY29kZXJzIG9ubHkgc3VwcG9ydCB1cCB0byAyNCBiaXRzIHBlciBzYW1wbGUuXG4gICAgICAgICAgICBiaXRzUGVyU2FtcGxlOiB1dGlsLmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmICsgMTIsIDcsIDUpICsgMSxcbiAgICAgICAgICAgIC8vIFRvdGFsIHNhbXBsZXMgaW4gc3RyZWFtLlxuICAgICAgICAgICAgLy8gJ1NhbXBsZXMnIG1lYW5zIGludGVyLWNoYW5uZWwgc2FtcGxlLCBpLmUuIG9uZSBzZWNvbmQgb2YgNDQuMUtoeiBhdWRpbyB3aWxsIGhhdmUgNDQxMDAgc2FtcGxlcyByZWdhcmRsZXNzIG9mIHRoZSBudW1iZXIgb2YgY2hhbm5lbHMuXG4gICAgICAgICAgICAvLyBBIHZhbHVlIG9mIHplcm8gaGVyZSBtZWFucyB0aGUgbnVtYmVyIG9mIHRvdGFsIHNhbXBsZXMgaXMgdW5rbm93bi5cbiAgICAgICAgICAgIHRvdGFsU2FtcGxlczogdXRpbC5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDEzLCA0LCAzNiksXG4gICAgICAgICAgICAvLyB0aGUgTUQ1IGhhc2ggb2YgdGhlIGZpbGUgKHNlZSBub3RlcyBmb3IgdXNhZ2UuLi4gaXQncyBhIGxpdHRseSB0cmlja3kpXG4gICAgICAgICAgICBmaWxlTUQ1OiBuZXcgdG9rZW5fdHlwZXNfMS5VaW50OEFycmF5VHlwZSgxNikuZ2V0KGJ1Ziwgb2ZmICsgMTgpXG4gICAgICAgIH07XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/flac/FlacParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js":
/*!**************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hasID3v1Header = exports.ID3v1Parser = exports.Genres = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst token_types_1 = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst util = __webpack_require__(/*! ../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst APEv2Parser_1 = __webpack_require__(/*! ../apev2/APEv2Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/apev2/APEv2Parser.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:ID3v1');\n/**\n * ID3v1 Genre mappings\n * Ref: https://de.wikipedia.org/wiki/Liste_der_ID3v1-Genres\n */\nexports.Genres = [\n    'Blues', 'Classic Rock', 'Country', 'Dance', 'Disco', 'Funk', 'Grunge', 'Hip-Hop',\n    'Jazz', 'Metal', 'New Age', 'Oldies', 'Other', 'Pop', 'R&B', 'Rap', 'Reggae', 'Rock',\n    'Techno', 'Industrial', 'Alternative', 'Ska', 'Death Metal', 'Pranks', 'Soundtrack',\n    'Euro-Techno', 'Ambient', 'Trip-Hop', 'Vocal', 'Jazz+Funk', 'Fusion', 'Trance',\n    'Classical', 'Instrumental', 'Acid', 'House', 'Game', 'Sound Clip', 'Gospel', 'Noise',\n    'Alt. Rock', 'Bass', 'Soul', 'Punk', 'Space', 'Meditative', 'Instrumental Pop',\n    'Instrumental Rock', 'Ethnic', 'Gothic', 'Darkwave', 'Techno-Industrial',\n    'Electronic', 'Pop-Folk', 'Eurodance', 'Dream', 'Southern Rock', 'Comedy', 'Cult',\n    'Gangsta Rap', 'Top 40', 'Christian Rap', 'Pop/Funk', 'Jungle', 'Native American',\n    'Cabaret', 'New Wave', 'Psychedelic', 'Rave', 'Showtunes', 'Trailer', 'Lo-Fi', 'Tribal',\n    'Acid Punk', 'Acid Jazz', 'Polka', 'Retro', 'Musical', 'Rock & Roll', 'Hard Rock',\n    'Folk', 'Folk/Rock', 'National Folk', 'Swing', 'Fast-Fusion', 'Bebob', 'Latin', 'Revival',\n    'Celtic', 'Bluegrass', 'Avantgarde', 'Gothic Rock', 'Progressive Rock', 'Psychedelic Rock',\n    'Symphonic Rock', 'Slow Rock', 'Big Band', 'Chorus', 'Easy Listening', 'Acoustic', 'Humour',\n    'Speech', 'Chanson', 'Opera', 'Chamber Music', 'Sonata', 'Symphony', 'Booty Bass', 'Primus',\n    'Porn Groove', 'Satire', 'Slow Jam', 'Club', 'Tango', 'Samba', 'Folklore',\n    'Ballad', 'Power Ballad', 'Rhythmic Soul', 'Freestyle', 'Duet', 'Punk Rock', 'Drum Solo',\n    'A Cappella', 'Euro-House', 'Dance Hall', 'Goa', 'Drum & Bass', 'Club-House',\n    'Hardcore', 'Terror', 'Indie', 'BritPop', 'Negerpunk', 'Polsk Punk', 'Beat',\n    'Christian Gangsta Rap', 'Heavy Metal', 'Black Metal', 'Crossover', 'Contemporary Christian',\n    'Christian Rock', 'Merengue', 'Salsa', 'Thrash Metal', 'Anime', 'JPop', 'Synthpop',\n    'Abstract', 'Art Rock', 'Baroque', 'Bhangra', 'Big Beat', 'Breakbeat', 'Chillout',\n    'Downtempo', 'Dub', 'EBM', 'Eclectic', 'Electro', 'Electroclash', 'Emo', 'Experimental',\n    'Garage', 'Global', 'IDM', 'Illbient', 'Industro-Goth', 'Jam Band', 'Krautrock',\n    'Leftfield', 'Lounge', 'Math Rock', 'New Romantic', 'Nu-Breakz', 'Post-Punk', 'Post-Rock',\n    'Psytrance', 'Shoegaze', 'Space Rock', 'Trop Rock', 'World Music', 'Neoclassical', 'Audiobook',\n    'Audio Theatre', 'Neue Deutsche Welle', 'Podcast', 'Indie Rock', 'G-Funk', 'Dubstep',\n    'Garage Rock', 'Psybient'\n];\n/**\n * Spec: http://id3.org/ID3v1\n * Wiki: https://en.wikipedia.org/wiki/ID3\n */\nconst Iid3v1Token = {\n    len: 128,\n    /**\n     * @param buf Buffer possibly holding the 128 bytes ID3v1.1 metadata header\n     * @param off Offset in buffer in bytes\n     * @returns ID3v1.1 header if first 3 bytes equals 'TAG', otherwise null is returned\n     */\n    get: (buf, off) => {\n        const header = new Id3v1StringType(3).get(buf, off);\n        return header === 'TAG' ? {\n            header,\n            title: new Id3v1StringType(30).get(buf, off + 3),\n            artist: new Id3v1StringType(30).get(buf, off + 33),\n            album: new Id3v1StringType(30).get(buf, off + 63),\n            year: new Id3v1StringType(4).get(buf, off + 93),\n            comment: new Id3v1StringType(28).get(buf, off + 97),\n            // ID3v1.1 separator for track\n            zeroByte: token_types_1.UINT8.get(buf, off + 127),\n            // track: ID3v1.1 field added by Michael Mutschler\n            track: token_types_1.UINT8.get(buf, off + 126),\n            genre: token_types_1.UINT8.get(buf, off + 127)\n        } : null;\n    }\n};\nclass Id3v1StringType extends token_types_1.StringType {\n    constructor(len) {\n        super(len, 'binary');\n    }\n    get(buf, off) {\n        let value = super.get(buf, off);\n        value = util.trimRightNull(value);\n        value = value.trim();\n        return value.length > 0 ? value : undefined;\n    }\n}\nclass ID3v1Parser extends BasicParser_1.BasicParser {\n    static getGenre(genreIndex) {\n        if (genreIndex < exports.Genres.length) {\n            return exports.Genres[genreIndex];\n        }\n        return undefined; // ToDO: generate warning\n    }\n    async parse() {\n        if (!this.tokenizer.fileInfo.size) {\n            debug('Skip checking for ID3v1 because the file-size is unknown');\n            return;\n        }\n        if (this.options.apeHeader) {\n            this.tokenizer.ignore(this.options.apeHeader.offset - this.tokenizer.position);\n            const apeParser = new APEv2Parser_1.APEv2Parser();\n            apeParser.init(this.metadata, this.tokenizer, this.options);\n            await apeParser.parseTags(this.options.apeHeader.footer);\n        }\n        const offset = this.tokenizer.fileInfo.size - Iid3v1Token.len;\n        if (this.tokenizer.position > offset) {\n            debug('Already consumed the last 128 bytes');\n            return;\n        }\n        const header = await this.tokenizer.readToken(Iid3v1Token, offset);\n        if (header) {\n            debug('ID3v1 header found at: pos=%s', this.tokenizer.fileInfo.size - Iid3v1Token.len);\n            for (const id of ['title', 'artist', 'album', 'comment', 'track', 'year']) {\n                if (header[id] && header[id] !== '')\n                    this.addTag(id, header[id]);\n            }\n            const genre = ID3v1Parser.getGenre(header.genre);\n            if (genre)\n                this.addTag('genre', genre);\n        }\n        else {\n            debug('ID3v1 header not found at: pos=%s', this.tokenizer.fileInfo.size - Iid3v1Token.len);\n        }\n    }\n    addTag(id, value) {\n        this.metadata.addTag('ID3v1', id, value);\n    }\n}\nexports.ID3v1Parser = ID3v1Parser;\nasync function hasID3v1Header(reader) {\n    if (reader.fileSize >= 128) {\n        const tag = Buffer.alloc(3);\n        await reader.randomRead(tag, 0, tag.length, reader.fileSize - 128);\n        return tag.toString('binary') === 'TAG';\n    }\n    return false;\n}\nexports.hasID3v1Header = hasID3v1Header;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvaWQzdjEvSUQzdjFQYXJzZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLGNBQWM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQU87QUFDL0Isc0JBQXNCLG1CQUFPLENBQUMsZ0ZBQWE7QUFDM0MsYUFBYSxtQkFBTyxDQUFDLDRGQUFnQjtBQUNyQyxzQkFBc0IsbUJBQU8sQ0FBQywwR0FBdUI7QUFDckQsc0JBQXNCLG1CQUFPLENBQUMsd0dBQXNCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9pZDN2MS9JRDN2MVBhcnNlci5qcz9jZDVmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNJRDN2MUhlYWRlciA9IGV4cG9ydHMuSUQzdjFQYXJzZXIgPSBleHBvcnRzLkdlbnJlcyA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCB0b2tlbl90eXBlc18xID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuLi9jb21tb24vVXRpbFwiKTtcbmNvbnN0IEJhc2ljUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0Jhc2ljUGFyc2VyXCIpO1xuY29uc3QgQVBFdjJQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9hcGV2Mi9BUEV2MlBhcnNlclwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjpJRDN2MScpO1xuLyoqXG4gKiBJRDN2MSBHZW5yZSBtYXBwaW5nc1xuICogUmVmOiBodHRwczovL2RlLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0ZV9kZXJfSUQzdjEtR2VucmVzXG4gKi9cbmV4cG9ydHMuR2VucmVzID0gW1xuICAgICdCbHVlcycsICdDbGFzc2ljIFJvY2snLCAnQ291bnRyeScsICdEYW5jZScsICdEaXNjbycsICdGdW5rJywgJ0dydW5nZScsICdIaXAtSG9wJyxcbiAgICAnSmF6eicsICdNZXRhbCcsICdOZXcgQWdlJywgJ09sZGllcycsICdPdGhlcicsICdQb3AnLCAnUiZCJywgJ1JhcCcsICdSZWdnYWUnLCAnUm9jaycsXG4gICAgJ1RlY2hubycsICdJbmR1c3RyaWFsJywgJ0FsdGVybmF0aXZlJywgJ1NrYScsICdEZWF0aCBNZXRhbCcsICdQcmFua3MnLCAnU291bmR0cmFjaycsXG4gICAgJ0V1cm8tVGVjaG5vJywgJ0FtYmllbnQnLCAnVHJpcC1Ib3AnLCAnVm9jYWwnLCAnSmF6eitGdW5rJywgJ0Z1c2lvbicsICdUcmFuY2UnLFxuICAgICdDbGFzc2ljYWwnLCAnSW5zdHJ1bWVudGFsJywgJ0FjaWQnLCAnSG91c2UnLCAnR2FtZScsICdTb3VuZCBDbGlwJywgJ0dvc3BlbCcsICdOb2lzZScsXG4gICAgJ0FsdC4gUm9jaycsICdCYXNzJywgJ1NvdWwnLCAnUHVuaycsICdTcGFjZScsICdNZWRpdGF0aXZlJywgJ0luc3RydW1lbnRhbCBQb3AnLFxuICAgICdJbnN0cnVtZW50YWwgUm9jaycsICdFdGhuaWMnLCAnR290aGljJywgJ0Rhcmt3YXZlJywgJ1RlY2huby1JbmR1c3RyaWFsJyxcbiAgICAnRWxlY3Ryb25pYycsICdQb3AtRm9saycsICdFdXJvZGFuY2UnLCAnRHJlYW0nLCAnU291dGhlcm4gUm9jaycsICdDb21lZHknLCAnQ3VsdCcsXG4gICAgJ0dhbmdzdGEgUmFwJywgJ1RvcCA0MCcsICdDaHJpc3RpYW4gUmFwJywgJ1BvcC9GdW5rJywgJ0p1bmdsZScsICdOYXRpdmUgQW1lcmljYW4nLFxuICAgICdDYWJhcmV0JywgJ05ldyBXYXZlJywgJ1BzeWNoZWRlbGljJywgJ1JhdmUnLCAnU2hvd3R1bmVzJywgJ1RyYWlsZXInLCAnTG8tRmknLCAnVHJpYmFsJyxcbiAgICAnQWNpZCBQdW5rJywgJ0FjaWQgSmF6eicsICdQb2xrYScsICdSZXRybycsICdNdXNpY2FsJywgJ1JvY2sgJiBSb2xsJywgJ0hhcmQgUm9jaycsXG4gICAgJ0ZvbGsnLCAnRm9say9Sb2NrJywgJ05hdGlvbmFsIEZvbGsnLCAnU3dpbmcnLCAnRmFzdC1GdXNpb24nLCAnQmVib2InLCAnTGF0aW4nLCAnUmV2aXZhbCcsXG4gICAgJ0NlbHRpYycsICdCbHVlZ3Jhc3MnLCAnQXZhbnRnYXJkZScsICdHb3RoaWMgUm9jaycsICdQcm9ncmVzc2l2ZSBSb2NrJywgJ1BzeWNoZWRlbGljIFJvY2snLFxuICAgICdTeW1waG9uaWMgUm9jaycsICdTbG93IFJvY2snLCAnQmlnIEJhbmQnLCAnQ2hvcnVzJywgJ0Vhc3kgTGlzdGVuaW5nJywgJ0Fjb3VzdGljJywgJ0h1bW91cicsXG4gICAgJ1NwZWVjaCcsICdDaGFuc29uJywgJ09wZXJhJywgJ0NoYW1iZXIgTXVzaWMnLCAnU29uYXRhJywgJ1N5bXBob255JywgJ0Jvb3R5IEJhc3MnLCAnUHJpbXVzJyxcbiAgICAnUG9ybiBHcm9vdmUnLCAnU2F0aXJlJywgJ1Nsb3cgSmFtJywgJ0NsdWInLCAnVGFuZ28nLCAnU2FtYmEnLCAnRm9sa2xvcmUnLFxuICAgICdCYWxsYWQnLCAnUG93ZXIgQmFsbGFkJywgJ1JoeXRobWljIFNvdWwnLCAnRnJlZXN0eWxlJywgJ0R1ZXQnLCAnUHVuayBSb2NrJywgJ0RydW0gU29sbycsXG4gICAgJ0EgQ2FwcGVsbGEnLCAnRXVyby1Ib3VzZScsICdEYW5jZSBIYWxsJywgJ0dvYScsICdEcnVtICYgQmFzcycsICdDbHViLUhvdXNlJyxcbiAgICAnSGFyZGNvcmUnLCAnVGVycm9yJywgJ0luZGllJywgJ0JyaXRQb3AnLCAnTmVnZXJwdW5rJywgJ1BvbHNrIFB1bmsnLCAnQmVhdCcsXG4gICAgJ0NocmlzdGlhbiBHYW5nc3RhIFJhcCcsICdIZWF2eSBNZXRhbCcsICdCbGFjayBNZXRhbCcsICdDcm9zc292ZXInLCAnQ29udGVtcG9yYXJ5IENocmlzdGlhbicsXG4gICAgJ0NocmlzdGlhbiBSb2NrJywgJ01lcmVuZ3VlJywgJ1NhbHNhJywgJ1RocmFzaCBNZXRhbCcsICdBbmltZScsICdKUG9wJywgJ1N5bnRocG9wJyxcbiAgICAnQWJzdHJhY3QnLCAnQXJ0IFJvY2snLCAnQmFyb3F1ZScsICdCaGFuZ3JhJywgJ0JpZyBCZWF0JywgJ0JyZWFrYmVhdCcsICdDaGlsbG91dCcsXG4gICAgJ0Rvd250ZW1wbycsICdEdWInLCAnRUJNJywgJ0VjbGVjdGljJywgJ0VsZWN0cm8nLCAnRWxlY3Ryb2NsYXNoJywgJ0VtbycsICdFeHBlcmltZW50YWwnLFxuICAgICdHYXJhZ2UnLCAnR2xvYmFsJywgJ0lETScsICdJbGxiaWVudCcsICdJbmR1c3Ryby1Hb3RoJywgJ0phbSBCYW5kJywgJ0tyYXV0cm9jaycsXG4gICAgJ0xlZnRmaWVsZCcsICdMb3VuZ2UnLCAnTWF0aCBSb2NrJywgJ05ldyBSb21hbnRpYycsICdOdS1CcmVha3onLCAnUG9zdC1QdW5rJywgJ1Bvc3QtUm9jaycsXG4gICAgJ1BzeXRyYW5jZScsICdTaG9lZ2F6ZScsICdTcGFjZSBSb2NrJywgJ1Ryb3AgUm9jaycsICdXb3JsZCBNdXNpYycsICdOZW9jbGFzc2ljYWwnLCAnQXVkaW9ib29rJyxcbiAgICAnQXVkaW8gVGhlYXRyZScsICdOZXVlIERldXRzY2hlIFdlbGxlJywgJ1BvZGNhc3QnLCAnSW5kaWUgUm9jaycsICdHLUZ1bmsnLCAnRHVic3RlcCcsXG4gICAgJ0dhcmFnZSBSb2NrJywgJ1BzeWJpZW50J1xuXTtcbi8qKlxuICogU3BlYzogaHR0cDovL2lkMy5vcmcvSUQzdjFcbiAqIFdpa2k6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lEM1xuICovXG5jb25zdCBJaWQzdjFUb2tlbiA9IHtcbiAgICBsZW46IDEyOCxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYnVmIEJ1ZmZlciBwb3NzaWJseSBob2xkaW5nIHRoZSAxMjggYnl0ZXMgSUQzdjEuMSBtZXRhZGF0YSBoZWFkZXJcbiAgICAgKiBAcGFyYW0gb2ZmIE9mZnNldCBpbiBidWZmZXIgaW4gYnl0ZXNcbiAgICAgKiBAcmV0dXJucyBJRDN2MS4xIGhlYWRlciBpZiBmaXJzdCAzIGJ5dGVzIGVxdWFscyAnVEFHJywgb3RoZXJ3aXNlIG51bGwgaXMgcmV0dXJuZWRcbiAgICAgKi9cbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBuZXcgSWQzdjFTdHJpbmdUeXBlKDMpLmdldChidWYsIG9mZik7XG4gICAgICAgIHJldHVybiBoZWFkZXIgPT09ICdUQUcnID8ge1xuICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgdGl0bGU6IG5ldyBJZDN2MVN0cmluZ1R5cGUoMzApLmdldChidWYsIG9mZiArIDMpLFxuICAgICAgICAgICAgYXJ0aXN0OiBuZXcgSWQzdjFTdHJpbmdUeXBlKDMwKS5nZXQoYnVmLCBvZmYgKyAzMyksXG4gICAgICAgICAgICBhbGJ1bTogbmV3IElkM3YxU3RyaW5nVHlwZSgzMCkuZ2V0KGJ1Ziwgb2ZmICsgNjMpLFxuICAgICAgICAgICAgeWVhcjogbmV3IElkM3YxU3RyaW5nVHlwZSg0KS5nZXQoYnVmLCBvZmYgKyA5MyksXG4gICAgICAgICAgICBjb21tZW50OiBuZXcgSWQzdjFTdHJpbmdUeXBlKDI4KS5nZXQoYnVmLCBvZmYgKyA5NyksXG4gICAgICAgICAgICAvLyBJRDN2MS4xIHNlcGFyYXRvciBmb3IgdHJhY2tcbiAgICAgICAgICAgIHplcm9CeXRlOiB0b2tlbl90eXBlc18xLlVJTlQ4LmdldChidWYsIG9mZiArIDEyNyksXG4gICAgICAgICAgICAvLyB0cmFjazogSUQzdjEuMSBmaWVsZCBhZGRlZCBieSBNaWNoYWVsIE11dHNjaGxlclxuICAgICAgICAgICAgdHJhY2s6IHRva2VuX3R5cGVzXzEuVUlOVDguZ2V0KGJ1Ziwgb2ZmICsgMTI2KSxcbiAgICAgICAgICAgIGdlbnJlOiB0b2tlbl90eXBlc18xLlVJTlQ4LmdldChidWYsIG9mZiArIDEyNylcbiAgICAgICAgfSA6IG51bGw7XG4gICAgfVxufTtcbmNsYXNzIElkM3YxU3RyaW5nVHlwZSBleHRlbmRzIHRva2VuX3R5cGVzXzEuU3RyaW5nVHlwZSB7XG4gICAgY29uc3RydWN0b3IobGVuKSB7XG4gICAgICAgIHN1cGVyKGxlbiwgJ2JpbmFyeScpO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gc3VwZXIuZ2V0KGJ1Ziwgb2ZmKTtcbiAgICAgICAgdmFsdWUgPSB1dGlsLnRyaW1SaWdodE51bGwodmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+IDAgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG5jbGFzcyBJRDN2MVBhcnNlciBleHRlbmRzIEJhc2ljUGFyc2VyXzEuQmFzaWNQYXJzZXIge1xuICAgIHN0YXRpYyBnZXRHZW5yZShnZW5yZUluZGV4KSB7XG4gICAgICAgIGlmIChnZW5yZUluZGV4IDwgZXhwb3J0cy5HZW5yZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5HZW5yZXNbZ2VucmVJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gVG9ETzogZ2VuZXJhdGUgd2FybmluZ1xuICAgIH1cbiAgICBhc3luYyBwYXJzZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRva2VuaXplci5maWxlSW5mby5zaXplKSB7XG4gICAgICAgICAgICBkZWJ1ZygnU2tpcCBjaGVja2luZyBmb3IgSUQzdjEgYmVjYXVzZSB0aGUgZmlsZS1zaXplIGlzIHVua25vd24nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFwZUhlYWRlcikge1xuICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIuaWdub3JlKHRoaXMub3B0aW9ucy5hcGVIZWFkZXIub2Zmc2V0IC0gdGhpcy50b2tlbml6ZXIucG9zaXRpb24pO1xuICAgICAgICAgICAgY29uc3QgYXBlUGFyc2VyID0gbmV3IEFQRXYyUGFyc2VyXzEuQVBFdjJQYXJzZXIoKTtcbiAgICAgICAgICAgIGFwZVBhcnNlci5pbml0KHRoaXMubWV0YWRhdGEsIHRoaXMudG9rZW5pemVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgYXdhaXQgYXBlUGFyc2VyLnBhcnNlVGFncyh0aGlzLm9wdGlvbnMuYXBlSGVhZGVyLmZvb3Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSAtIElpZDN2MVRva2VuLmxlbjtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5pemVyLnBvc2l0aW9uID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICBkZWJ1ZygnQWxyZWFkeSBjb25zdW1lZCB0aGUgbGFzdCAxMjggYnl0ZXMnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oSWlkM3YxVG9rZW4sIG9mZnNldCk7XG4gICAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgICAgIGRlYnVnKCdJRDN2MSBoZWFkZXIgZm91bmQgYXQ6IHBvcz0lcycsIHRoaXMudG9rZW5pemVyLmZpbGVJbmZvLnNpemUgLSBJaWQzdjFUb2tlbi5sZW4pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZCBvZiBbJ3RpdGxlJywgJ2FydGlzdCcsICdhbGJ1bScsICdjb21tZW50JywgJ3RyYWNrJywgJ3llYXInXSkge1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJbaWRdICYmIGhlYWRlcltpZF0gIT09ICcnKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZyhpZCwgaGVhZGVyW2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBnZW5yZSA9IElEM3YxUGFyc2VyLmdldEdlbnJlKGhlYWRlci5nZW5yZSk7XG4gICAgICAgICAgICBpZiAoZ2VucmUpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUYWcoJ2dlbnJlJywgZ2VucmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoJ0lEM3YxIGhlYWRlciBub3QgZm91bmQgYXQ6IHBvcz0lcycsIHRoaXMudG9rZW5pemVyLmZpbGVJbmZvLnNpemUgLSBJaWQzdjFUb2tlbi5sZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFRhZyhpZCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRUYWcoJ0lEM3YxJywgaWQsIHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLklEM3YxUGFyc2VyID0gSUQzdjFQYXJzZXI7XG5hc3luYyBmdW5jdGlvbiBoYXNJRDN2MUhlYWRlcihyZWFkZXIpIHtcbiAgICBpZiAocmVhZGVyLmZpbGVTaXplID49IDEyOCkge1xuICAgICAgICBjb25zdCB0YWcgPSBCdWZmZXIuYWxsb2MoMyk7XG4gICAgICAgIGF3YWl0IHJlYWRlci5yYW5kb21SZWFkKHRhZywgMCwgdGFnLmxlbmd0aCwgcmVhZGVyLmZpbGVTaXplIC0gMTI4KTtcbiAgICAgICAgcmV0dXJuIHRhZy50b1N0cmluZygnYmluYXJ5JykgPT09ICdUQUcnO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmhhc0lEM3YxSGVhZGVyID0gaGFzSUQzdjFIZWFkZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/id3v1/ID3v1TagMap.js":
/*!**************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v1/ID3v1TagMap.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ID3v1TagMapper = void 0;\nconst GenericTagMapper_1 = __webpack_require__(/*! ../common/GenericTagMapper */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/GenericTagMapper.js\");\n/**\n * ID3v1 tag mappings\n */\nconst id3v1TagMap = {\n    title: 'title',\n    artist: 'artist',\n    album: 'album',\n    year: 'year',\n    comment: 'comment',\n    track: 'track',\n    genre: 'genre'\n};\nclass ID3v1TagMapper extends GenericTagMapper_1.CommonTagMapper {\n    constructor() {\n        super(['ID3v1'], id3v1TagMap);\n    }\n}\nexports.ID3v1TagMapper = ID3v1TagMapper;\n//# sourceMappingURL=ID3v1TagMap.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvaWQzdjEvSUQzdjFUYWdNYXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLDJCQUEyQixtQkFBTyxDQUFDLG9IQUE0QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvaWQzdjEvSUQzdjFUYWdNYXAuanM/NzU3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSUQzdjFUYWdNYXBwZXIgPSB2b2lkIDA7XG5jb25zdCBHZW5lcmljVGFnTWFwcGVyXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0dlbmVyaWNUYWdNYXBwZXJcIik7XG4vKipcbiAqIElEM3YxIHRhZyBtYXBwaW5nc1xuICovXG5jb25zdCBpZDN2MVRhZ01hcCA9IHtcbiAgICB0aXRsZTogJ3RpdGxlJyxcbiAgICBhcnRpc3Q6ICdhcnRpc3QnLFxuICAgIGFsYnVtOiAnYWxidW0nLFxuICAgIHllYXI6ICd5ZWFyJyxcbiAgICBjb21tZW50OiAnY29tbWVudCcsXG4gICAgdHJhY2s6ICd0cmFjaycsXG4gICAgZ2VucmU6ICdnZW5yZSdcbn07XG5jbGFzcyBJRDN2MVRhZ01hcHBlciBleHRlbmRzIEdlbmVyaWNUYWdNYXBwZXJfMS5Db21tb25UYWdNYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihbJ0lEM3YxJ10sIGlkM3YxVGFnTWFwKTtcbiAgICB9XG59XG5leHBvcnRzLklEM3YxVGFnTWFwcGVyID0gSUQzdjFUYWdNYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JRDN2MVRhZ01hcC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/id3v1/ID3v1TagMap.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js":
/*!********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AbstractID3Parser = void 0;\nconst core_1 = __webpack_require__(/*! strtok3/lib/core */ \"(app-pages-browser)/./node_modules/strtok3/lib/core.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst ID3v2Token_1 = __webpack_require__(/*! ./ID3v2Token */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v2Token.js\");\nconst ID3v2Parser_1 = __webpack_require__(/*! ./ID3v2Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js\");\nconst ID3v1Parser_1 = __webpack_require__(/*! ../id3v1/ID3v1Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:ID3');\n/**\n * Abstract parser which tries take ID3v2 and ID3v1 headers.\n */\nclass AbstractID3Parser extends BasicParser_1.BasicParser {\n    constructor() {\n        super(...arguments);\n        this.id3parser = new ID3v2Parser_1.ID3v2Parser();\n    }\n    static async startsWithID3v2Header(tokenizer) {\n        return (await tokenizer.peekToken(ID3v2Token_1.ID3v2Header)).fileIdentifier === 'ID3';\n    }\n    async parse() {\n        try {\n            await this.parseID3v2();\n        }\n        catch (err) {\n            if (err instanceof core_1.EndOfStreamError) {\n                debug(`End-of-stream`);\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    finalize() {\n        return;\n    }\n    async parseID3v2() {\n        await this.tryReadId3v2Headers();\n        debug('End of ID3v2 header, go to MPEG-parser: pos=%s', this.tokenizer.position);\n        await this.postId3v2Parse();\n        if (this.options.skipPostHeaders && this.metadata.hasAny()) {\n            this.finalize();\n        }\n        else {\n            const id3v1parser = new ID3v1Parser_1.ID3v1Parser();\n            await id3v1parser.init(this.metadata, this.tokenizer, this.options).parse();\n            this.finalize();\n        }\n    }\n    async tryReadId3v2Headers() {\n        const id3Header = await this.tokenizer.peekToken(ID3v2Token_1.ID3v2Header);\n        if (id3Header.fileIdentifier === 'ID3') {\n            debug('Found ID3v2 header, pos=%s', this.tokenizer.position);\n            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);\n            return this.tryReadId3v2Headers();\n        }\n    }\n}\nexports.AbstractID3Parser = AbstractID3Parser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvaWQzdjIvQWJzdHJhY3RJRDNQYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLGVBQWUsbUJBQU8sQ0FBQyxnRkFBa0I7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQU87QUFDL0IscUJBQXFCLG1CQUFPLENBQUMsK0ZBQWM7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsaUdBQWU7QUFDN0Msc0JBQXNCLG1CQUFPLENBQUMsd0dBQXNCO0FBQ3BELHNCQUFzQixtQkFBTyxDQUFDLDBHQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvaWQzdjIvQWJzdHJhY3RJRDNQYXJzZXIuanM/MmU3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWJzdHJhY3RJRDNQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwic3RydG9rMy9saWIvY29yZVwiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBJRDN2MlRva2VuXzEgPSByZXF1aXJlKFwiLi9JRDN2MlRva2VuXCIpO1xuY29uc3QgSUQzdjJQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL0lEM3YyUGFyc2VyXCIpO1xuY29uc3QgSUQzdjFQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9pZDN2MS9JRDN2MVBhcnNlclwiKTtcbmNvbnN0IEJhc2ljUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0Jhc2ljUGFyc2VyXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbXVzaWMtbWV0YWRhdGE6cGFyc2VyOklEMycpO1xuLyoqXG4gKiBBYnN0cmFjdCBwYXJzZXIgd2hpY2ggdHJpZXMgdGFrZSBJRDN2MiBhbmQgSUQzdjEgaGVhZGVycy5cbiAqL1xuY2xhc3MgQWJzdHJhY3RJRDNQYXJzZXIgZXh0ZW5kcyBCYXNpY1BhcnNlcl8xLkJhc2ljUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pZDNwYXJzZXIgPSBuZXcgSUQzdjJQYXJzZXJfMS5JRDN2MlBhcnNlcigpO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgc3RhcnRzV2l0aElEM3YySGVhZGVyKHRva2VuaXplcikge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRva2VuaXplci5wZWVrVG9rZW4oSUQzdjJUb2tlbl8xLklEM3YySGVhZGVyKSkuZmlsZUlkZW50aWZpZXIgPT09ICdJRDMnO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGFyc2VJRDN2MigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBjb3JlXzEuRW5kT2ZTdHJlYW1FcnJvcikge1xuICAgICAgICAgICAgICAgIGRlYnVnKGBFbmQtb2Ytc3RyZWFtYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxpemUoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VJRDN2MigpIHtcbiAgICAgICAgYXdhaXQgdGhpcy50cnlSZWFkSWQzdjJIZWFkZXJzKCk7XG4gICAgICAgIGRlYnVnKCdFbmQgb2YgSUQzdjIgaGVhZGVyLCBnbyB0byBNUEVHLXBhcnNlcjogcG9zPSVzJywgdGhpcy50b2tlbml6ZXIucG9zaXRpb24pO1xuICAgICAgICBhd2FpdCB0aGlzLnBvc3RJZDN2MlBhcnNlKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2tpcFBvc3RIZWFkZXJzICYmIHRoaXMubWV0YWRhdGEuaGFzQW55KCkpIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlkM3YxcGFyc2VyID0gbmV3IElEM3YxUGFyc2VyXzEuSUQzdjFQYXJzZXIoKTtcbiAgICAgICAgICAgIGF3YWl0IGlkM3YxcGFyc2VyLmluaXQodGhpcy5tZXRhZGF0YSwgdGhpcy50b2tlbml6ZXIsIHRoaXMub3B0aW9ucykucGFyc2UoKTtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB0cnlSZWFkSWQzdjJIZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBpZDNIZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5wZWVrVG9rZW4oSUQzdjJUb2tlbl8xLklEM3YySGVhZGVyKTtcbiAgICAgICAgaWYgKGlkM0hlYWRlci5maWxlSWRlbnRpZmllciA9PT0gJ0lEMycpIHtcbiAgICAgICAgICAgIGRlYnVnKCdGb3VuZCBJRDN2MiBoZWFkZXIsIHBvcz0lcycsIHRoaXMudG9rZW5pemVyLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaWQzcGFyc2VyLnBhcnNlKHRoaXMubWV0YWRhdGEsIHRoaXMudG9rZW5pemVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJ5UmVhZElkM3YySGVhZGVycygpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdElEM1BhcnNlciA9IEFic3RyYWN0SUQzUGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/FrameParser.js":
/*!**************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v2/FrameParser.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FrameParser = exports.parseGenre = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst util = __webpack_require__(/*! ../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\nconst ID3v2Token_1 = __webpack_require__(/*! ./ID3v2Token */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v2Token.js\");\nconst ID3v1Parser_1 = __webpack_require__(/*! ../id3v1/ID3v1Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js\");\nconst debug = (0, debug_1.default)('music-metadata:id3v2:frame-parser');\nconst defaultEnc = 'latin1'; // latin1 == iso-8859-1;\nfunction parseGenre(origVal) {\n    // match everything inside parentheses\n    const genres = [];\n    let code;\n    let word = '';\n    for (const c of origVal) {\n        if (typeof code === 'string') {\n            if (c === '(' && code === '') {\n                word += '(';\n                code = undefined;\n            }\n            else if (c === ')') {\n                if (word !== '') {\n                    genres.push(word);\n                    word = '';\n                }\n                const genre = parseGenreCode(code);\n                if (genre) {\n                    genres.push(genre);\n                }\n                code = undefined;\n            }\n            else\n                code += c;\n        }\n        else if (c === '(') {\n            code = '';\n        }\n        else {\n            word += c;\n        }\n    }\n    if (word) {\n        if (genres.length === 0 && word.match(/^\\d*$/)) {\n            word = ID3v1Parser_1.Genres[word];\n        }\n        genres.push(word);\n    }\n    return genres;\n}\nexports.parseGenre = parseGenre;\nfunction parseGenreCode(code) {\n    if (code === 'RX')\n        return 'Remix';\n    if (code === 'CR')\n        return 'Cover';\n    if (code.match(/^\\d*$/)) {\n        return ID3v1Parser_1.Genres[code];\n    }\n}\nclass FrameParser {\n    /**\n     * Create id3v2 frame parser\n     * @param major - Major version, e.g. (4) for  id3v2.4\n     * @param warningCollector - Used to collect decode issue\n     */\n    constructor(major, warningCollector) {\n        this.major = major;\n        this.warningCollector = warningCollector;\n    }\n    readData(uint8Array, type, includeCovers) {\n        if (uint8Array.length === 0) {\n            this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${type}`);\n            return;\n        }\n        const { encoding, bom } = ID3v2Token_1.TextEncodingToken.get(uint8Array, 0);\n        const length = uint8Array.length;\n        let offset = 0;\n        let output = []; // ToDo\n        const nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);\n        let fzero;\n        const out = {};\n        debug(`Parsing tag type=${type}, encoding=${encoding}, bom=${bom}`);\n        switch (type !== 'TXXX' && type[0] === 'T' ? 'T*' : type) {\n            case 'T*': // 4.2.1. Text information frames - details\n            case 'IPLS': // v2.3: Involved people list\n            case 'MVIN':\n            case 'MVNM':\n            case 'PCS':\n            case 'PCST':\n                let text;\n                try {\n                    text = util.decodeString(uint8Array.slice(1), encoding).replace(/\\x00+$/, '');\n                }\n                catch (error) {\n                    this.warningCollector.addWarning(`id3v2.${this.major} type=${type} header has invalid string value: ${error.message}`);\n                }\n                switch (type) {\n                    case 'TMCL': // Musician credits list\n                    case 'TIPL': // Involved people list\n                    case 'IPLS': // Involved people list\n                        output = this.splitValue(type, text);\n                        output = FrameParser.functionList(output);\n                        break;\n                    case 'TRK':\n                    case 'TRCK':\n                    case 'TPOS':\n                        output = text;\n                        break;\n                    case 'TCOM':\n                    case 'TEXT':\n                    case 'TOLY':\n                    case 'TOPE':\n                    case 'TPE1':\n                    case 'TSRC':\n                        // id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /\n                        output = this.splitValue(type, text);\n                        break;\n                    case 'TCO':\n                    case 'TCON':\n                        output = this.splitValue(type, text).map(v => parseGenre(v)).reduce((acc, val) => acc.concat(val), []);\n                        break;\n                    case 'PCS':\n                    case 'PCST':\n                        // TODO: Why `default` not results `1` but `''`?\n                        output = this.major >= 4 ? this.splitValue(type, text) : [text];\n                        output = (Array.isArray(output) && output[0] === '') ? 1 : 0;\n                        break;\n                    default:\n                        output = this.major >= 4 ? this.splitValue(type, text) : [text];\n                }\n                break;\n            case 'TXXX':\n                output = FrameParser.readIdentifierAndData(uint8Array, offset + 1, length, encoding);\n                output = {\n                    description: output.id,\n                    text: this.splitValue(type, util.decodeString(output.data, encoding).replace(/\\x00+$/, ''))\n                };\n                break;\n            case 'PIC':\n            case 'APIC':\n                if (includeCovers) {\n                    const pic = {};\n                    offset += 1;\n                    switch (this.major) {\n                        case 2:\n                            pic.format = util.decodeString(uint8Array.slice(offset, offset + 3), 'latin1'); // 'latin1'; // latin1 == iso-8859-1;\n                            offset += 3;\n                            break;\n                        case 3:\n                        case 4:\n                            fzero = util.findZero(uint8Array, offset, length, defaultEnc);\n                            pic.format = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n                            offset = fzero + 1;\n                            break;\n                        default:\n                            throw new Error('Warning: unexpected major versionIndex: ' + this.major);\n                    }\n                    pic.format = FrameParser.fixPictureMimeType(pic.format);\n                    pic.type = ID3v2Token_1.AttachedPictureType[uint8Array[offset]];\n                    offset += 1;\n                    fzero = util.findZero(uint8Array, offset, length, encoding);\n                    pic.description = util.decodeString(uint8Array.slice(offset, fzero), encoding);\n                    offset = fzero + nullTerminatorLength;\n                    pic.data = Buffer.from(uint8Array.slice(offset, length));\n                    output = pic;\n                }\n                break;\n            case 'CNT':\n            case 'PCNT':\n                output = Token.UINT32_BE.get(uint8Array, 0);\n                break;\n            case 'SYLT':\n                // skip text encoding (1 byte),\n                //      language (3 bytes),\n                //      time stamp format (1 byte),\n                //      content tagTypes (1 byte),\n                //      content descriptor (1 byte)\n                offset += 7;\n                output = [];\n                while (offset < length) {\n                    const txt = uint8Array.slice(offset, offset = util.findZero(uint8Array, offset, length, encoding));\n                    offset += 5; // push offset forward one +  4 byte timestamp\n                    output.push(util.decodeString(txt, encoding));\n                }\n                break;\n            case 'ULT':\n            case 'USLT':\n            case 'COM':\n            case 'COMM':\n                offset += 1;\n                out.language = util.decodeString(uint8Array.slice(offset, offset + 3), defaultEnc);\n                offset += 3;\n                fzero = util.findZero(uint8Array, offset, length, encoding);\n                out.description = util.decodeString(uint8Array.slice(offset, fzero), encoding);\n                offset = fzero + nullTerminatorLength;\n                out.text = util.decodeString(uint8Array.slice(offset, length), encoding).replace(/\\x00+$/, '');\n                output = [out];\n                break;\n            case 'UFID':\n                output = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);\n                output = { owner_identifier: output.id, identifier: output.data };\n                break;\n            case 'PRIV': // private frame\n                output = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);\n                output = { owner_identifier: output.id, data: output.data };\n                break;\n            case 'POPM': // Popularimeter\n                fzero = util.findZero(uint8Array, offset, length, defaultEnc);\n                const email = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n                offset = fzero + 1;\n                const dataLen = length - offset;\n                output = {\n                    email,\n                    rating: Token.UINT8.get(uint8Array, offset),\n                    counter: dataLen >= 5 ? Token.UINT32_BE.get(uint8Array, offset + 1) : undefined\n                };\n                break;\n            case 'GEOB': { // General encapsulated object\n                fzero = util.findZero(uint8Array, offset + 1, length, encoding);\n                const mimeType = util.decodeString(uint8Array.slice(offset + 1, fzero), defaultEnc);\n                offset = fzero + 1;\n                fzero = util.findZero(uint8Array, offset, length - offset, encoding);\n                const filename = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n                offset = fzero + 1;\n                fzero = util.findZero(uint8Array, offset, length - offset, encoding);\n                const description = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n                output = {\n                    type: mimeType,\n                    filename,\n                    description,\n                    data: uint8Array.slice(offset + 1, length)\n                };\n                break;\n            }\n            // W-Frames:\n            case 'WCOM':\n            case 'WCOP':\n            case 'WOAF':\n            case 'WOAR':\n            case 'WOAS':\n            case 'WORS':\n            case 'WPAY':\n            case 'WPUB':\n                // Decode URL\n                output = util.decodeString(uint8Array.slice(offset, fzero), defaultEnc);\n                break;\n            case 'WXXX': {\n                // Decode URL\n                fzero = util.findZero(uint8Array, offset + 1, length, encoding);\n                const description = util.decodeString(uint8Array.slice(offset + 1, fzero), encoding);\n                offset = fzero + (encoding === 'utf16le' ? 2 : 1);\n                output = { description, url: util.decodeString(uint8Array.slice(offset, length), defaultEnc) };\n                break;\n            }\n            case 'WFD':\n            case 'WFED':\n                output = util.decodeString(uint8Array.slice(offset + 1, util.findZero(uint8Array, offset + 1, length, encoding)), encoding);\n                break;\n            case 'MCDI': {\n                // Music CD identifier\n                output = uint8Array.slice(0, length);\n                break;\n            }\n            default:\n                debug('Warning: unsupported id3v2-tag-type: ' + type);\n                break;\n        }\n        return output;\n    }\n    static fixPictureMimeType(pictureType) {\n        pictureType = pictureType.toLocaleLowerCase();\n        switch (pictureType) {\n            case 'jpg':\n                return 'image/jpeg';\n            case 'png':\n                return 'image/png';\n        }\n        return pictureType;\n    }\n    /**\n     * Converts TMCL (Musician credits list) or TIPL (Involved people list)\n     * @param entries\n     */\n    static functionList(entries) {\n        const res = {};\n        for (let i = 0; i + 1 < entries.length; i += 2) {\n            const names = entries[i + 1].split(',');\n            res[entries[i]] = res.hasOwnProperty(entries[i]) ? res[entries[i]].concat(names) : names;\n        }\n        return res;\n    }\n    /**\n     * id3v2.4 defines that multiple T* values are separated by 0x00\n     * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /\n     * @param tag - Tag name\n     * @param text - Concatenated tag value\n     * @returns Split tag value\n     */\n    splitValue(tag, text) {\n        let values;\n        if (this.major < 4) {\n            values = text.split(/\\x00/g);\n            if (values.length > 1) {\n                this.warningCollector.addWarning(`ID3v2.${this.major} ${tag} uses non standard null-separator.`);\n            }\n            else {\n                values = text.split(/\\//g);\n            }\n        }\n        else {\n            values = text.split(/\\x00/g);\n        }\n        return FrameParser.trimArray(values);\n    }\n    static trimArray(values) {\n        return values.map(value => value.replace(/\\x00+$/, '').trim());\n    }\n    static readIdentifierAndData(uint8Array, offset, length, encoding) {\n        const fzero = util.findZero(uint8Array, offset, length, encoding);\n        const id = util.decodeString(uint8Array.slice(offset, fzero), encoding);\n        offset = fzero + FrameParser.getNullTerminatorLength(encoding);\n        return { id, data: uint8Array.slice(offset, length) };\n    }\n    static getNullTerminatorLength(enc) {\n        return enc === 'utf16le' ? 2 : 1;\n    }\n}\nexports.FrameParser = FrameParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvaWQzdjIvRnJhbWVQYXJzZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLGtCQUFrQjtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBTztBQUMvQixjQUFjLG1CQUFPLENBQUMsZ0ZBQWE7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLDRGQUFnQjtBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBYztBQUMzQyxzQkFBc0IsbUJBQU8sQ0FBQyx3R0FBc0I7QUFDcEQ7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFlBQVksNEJBQTRCLEtBQUs7QUFDbkc7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSyxhQUFhLFNBQVMsUUFBUSxJQUFJO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxZQUFZLE9BQU8sTUFBTSxtQ0FBbUMsY0FBYztBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHLGFBQWE7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxZQUFZLEVBQUUsS0FBSztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9pZDN2Mi9GcmFtZVBhcnNlci5qcz9jODkxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GcmFtZVBhcnNlciA9IGV4cG9ydHMucGFyc2VHZW5yZSA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi4vY29tbW9uL1V0aWxcIik7XG5jb25zdCBJRDN2MlRva2VuXzEgPSByZXF1aXJlKFwiLi9JRDN2MlRva2VuXCIpO1xuY29uc3QgSUQzdjFQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9pZDN2MS9JRDN2MVBhcnNlclwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ211c2ljLW1ldGFkYXRhOmlkM3YyOmZyYW1lLXBhcnNlcicpO1xuY29uc3QgZGVmYXVsdEVuYyA9ICdsYXRpbjEnOyAvLyBsYXRpbjEgPT0gaXNvLTg4NTktMTtcbmZ1bmN0aW9uIHBhcnNlR2VucmUob3JpZ1ZhbCkge1xuICAgIC8vIG1hdGNoIGV2ZXJ5dGhpbmcgaW5zaWRlIHBhcmVudGhlc2VzXG4gICAgY29uc3QgZ2VucmVzID0gW107XG4gICAgbGV0IGNvZGU7XG4gICAgbGV0IHdvcmQgPSAnJztcbiAgICBmb3IgKGNvbnN0IGMgb2Ygb3JpZ1ZhbCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gJygnICYmIGNvZGUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgd29yZCArPSAnKCc7XG4gICAgICAgICAgICAgICAgY29kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICcpJykge1xuICAgICAgICAgICAgICAgIGlmICh3b3JkICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBnZW5yZXMucHVzaCh3b3JkKTtcbiAgICAgICAgICAgICAgICAgICAgd29yZCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBnZW5yZSA9IHBhcnNlR2VucmVDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgIGlmIChnZW5yZSkge1xuICAgICAgICAgICAgICAgICAgICBnZW5yZXMucHVzaChnZW5yZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29kZSArPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPT09ICcoJykge1xuICAgICAgICAgICAgY29kZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd29yZCArPSBjO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh3b3JkKSB7XG4gICAgICAgIGlmIChnZW5yZXMubGVuZ3RoID09PSAwICYmIHdvcmQubWF0Y2goL15cXGQqJC8pKSB7XG4gICAgICAgICAgICB3b3JkID0gSUQzdjFQYXJzZXJfMS5HZW5yZXNbd29yZF07XG4gICAgICAgIH1cbiAgICAgICAgZ2VucmVzLnB1c2god29yZCk7XG4gICAgfVxuICAgIHJldHVybiBnZW5yZXM7XG59XG5leHBvcnRzLnBhcnNlR2VucmUgPSBwYXJzZUdlbnJlO1xuZnVuY3Rpb24gcGFyc2VHZW5yZUNvZGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSAnUlgnKVxuICAgICAgICByZXR1cm4gJ1JlbWl4JztcbiAgICBpZiAoY29kZSA9PT0gJ0NSJylcbiAgICAgICAgcmV0dXJuICdDb3Zlcic7XG4gICAgaWYgKGNvZGUubWF0Y2goL15cXGQqJC8pKSB7XG4gICAgICAgIHJldHVybiBJRDN2MVBhcnNlcl8xLkdlbnJlc1tjb2RlXTtcbiAgICB9XG59XG5jbGFzcyBGcmFtZVBhcnNlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGlkM3YyIGZyYW1lIHBhcnNlclxuICAgICAqIEBwYXJhbSBtYWpvciAtIE1ham9yIHZlcnNpb24sIGUuZy4gKDQpIGZvciAgaWQzdjIuNFxuICAgICAqIEBwYXJhbSB3YXJuaW5nQ29sbGVjdG9yIC0gVXNlZCB0byBjb2xsZWN0IGRlY29kZSBpc3N1ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1ham9yLCB3YXJuaW5nQ29sbGVjdG9yKSB7XG4gICAgICAgIHRoaXMubWFqb3IgPSBtYWpvcjtcbiAgICAgICAgdGhpcy53YXJuaW5nQ29sbGVjdG9yID0gd2FybmluZ0NvbGxlY3RvcjtcbiAgICB9XG4gICAgcmVhZERhdGEodWludDhBcnJheSwgdHlwZSwgaW5jbHVkZUNvdmVycykge1xuICAgICAgICBpZiAodWludDhBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMud2FybmluZ0NvbGxlY3Rvci5hZGRXYXJuaW5nKGBpZDN2Mi4ke3RoaXMubWFqb3J9IGhlYWRlciBoYXMgZW1wdHkgdGFnIHR5cGU9JHt0eXBlfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZW5jb2RpbmcsIGJvbSB9ID0gSUQzdjJUb2tlbl8xLlRleHRFbmNvZGluZ1Rva2VuLmdldCh1aW50OEFycmF5LCAwKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdWludDhBcnJheS5sZW5ndGg7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgb3V0cHV0ID0gW107IC8vIFRvRG9cbiAgICAgICAgY29uc3QgbnVsbFRlcm1pbmF0b3JMZW5ndGggPSBGcmFtZVBhcnNlci5nZXROdWxsVGVybWluYXRvckxlbmd0aChlbmNvZGluZyk7XG4gICAgICAgIGxldCBmemVybztcbiAgICAgICAgY29uc3Qgb3V0ID0ge307XG4gICAgICAgIGRlYnVnKGBQYXJzaW5nIHRhZyB0eXBlPSR7dHlwZX0sIGVuY29kaW5nPSR7ZW5jb2Rpbmd9LCBib209JHtib219YCk7XG4gICAgICAgIHN3aXRjaCAodHlwZSAhPT0gJ1RYWFgnICYmIHR5cGVbMF0gPT09ICdUJyA/ICdUKicgOiB0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdUKic6IC8vIDQuMi4xLiBUZXh0IGluZm9ybWF0aW9uIGZyYW1lcyAtIGRldGFpbHNcbiAgICAgICAgICAgIGNhc2UgJ0lQTFMnOiAvLyB2Mi4zOiBJbnZvbHZlZCBwZW9wbGUgbGlzdFxuICAgICAgICAgICAgY2FzZSAnTVZJTic6XG4gICAgICAgICAgICBjYXNlICdNVk5NJzpcbiAgICAgICAgICAgIGNhc2UgJ1BDUyc6XG4gICAgICAgICAgICBjYXNlICdQQ1NUJzpcbiAgICAgICAgICAgICAgICBsZXQgdGV4dDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdXRpbC5kZWNvZGVTdHJpbmcodWludDhBcnJheS5zbGljZSgxKSwgZW5jb2RpbmcpLnJlcGxhY2UoL1xceDAwKyQvLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndhcm5pbmdDb2xsZWN0b3IuYWRkV2FybmluZyhgaWQzdjIuJHt0aGlzLm1ham9yfSB0eXBlPSR7dHlwZX0gaGVhZGVyIGhhcyBpbnZhbGlkIHN0cmluZyB2YWx1ZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVE1DTCc6IC8vIE11c2ljaWFuIGNyZWRpdHMgbGlzdFxuICAgICAgICAgICAgICAgICAgICBjYXNlICdUSVBMJzogLy8gSW52b2x2ZWQgcGVvcGxlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSVBMUyc6IC8vIEludm9sdmVkIHBlb3BsZSBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLnNwbGl0VmFsdWUodHlwZSwgdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBGcmFtZVBhcnNlci5mdW5jdGlvbkxpc3Qob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdUUksnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdUUkNLJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVFBPUyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RDT00nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdURVhUJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVE9MWSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RPUEUnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdUUEUxJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVFNSQyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZDN2Mi4zIGRlZmluZXMgdGhhdCBUQ09NLCBURVhULCBUT0xZLCBUT1BFICYgVFBFMSB2YWx1ZXMgYXJlIHNlcGFyYXRlZCBieSAvXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLnNwbGl0VmFsdWUodHlwZSwgdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVENPJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVENPTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLnNwbGl0VmFsdWUodHlwZSwgdGV4dCkubWFwKHYgPT4gcGFyc2VHZW5yZSh2KSkucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjLmNvbmNhdCh2YWwpLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUENTJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUENTVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBXaHkgYGRlZmF1bHRgIG5vdCByZXN1bHRzIGAxYCBidXQgYCcnYD9cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHRoaXMubWFqb3IgPj0gNCA/IHRoaXMuc3BsaXRWYWx1ZSh0eXBlLCB0ZXh0KSA6IFt0ZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IChBcnJheS5pc0FycmF5KG91dHB1dCkgJiYgb3V0cHV0WzBdID09PSAnJykgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcy5tYWpvciA+PSA0ID8gdGhpcy5zcGxpdFZhbHVlKHR5cGUsIHRleHQpIDogW3RleHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1RYWFgnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IEZyYW1lUGFyc2VyLnJlYWRJZGVudGlmaWVyQW5kRGF0YSh1aW50OEFycmF5LCBvZmZzZXQgKyAxLCBsZW5ndGgsIGVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBvdXRwdXQuaWQsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuc3BsaXRWYWx1ZSh0eXBlLCB1dGlsLmRlY29kZVN0cmluZyhvdXRwdXQuZGF0YSwgZW5jb2RpbmcpLnJlcGxhY2UoL1xceDAwKyQvLCAnJykpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BJQyc6XG4gICAgICAgICAgICBjYXNlICdBUElDJzpcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZUNvdmVycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaWMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5tYWpvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpYy5mb3JtYXQgPSB1dGlsLmRlY29kZVN0cmluZyh1aW50OEFycmF5LnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgMyksICdsYXRpbjEnKTsgLy8gJ2xhdGluMSc7IC8vIGxhdGluMSA9PSBpc28tODg1OS0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ6ZXJvID0gdXRpbC5maW5kWmVybyh1aW50OEFycmF5LCBvZmZzZXQsIGxlbmd0aCwgZGVmYXVsdEVuYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGljLmZvcm1hdCA9IHV0aWwuZGVjb2RlU3RyaW5nKHVpbnQ4QXJyYXkuc2xpY2Uob2Zmc2V0LCBmemVybyksIGRlZmF1bHRFbmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGZ6ZXJvICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYXJuaW5nOiB1bmV4cGVjdGVkIG1ham9yIHZlcnNpb25JbmRleDogJyArIHRoaXMubWFqb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBpYy5mb3JtYXQgPSBGcmFtZVBhcnNlci5maXhQaWN0dXJlTWltZVR5cGUocGljLmZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIHBpYy50eXBlID0gSUQzdjJUb2tlbl8xLkF0dGFjaGVkUGljdHVyZVR5cGVbdWludDhBcnJheVtvZmZzZXRdXTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGZ6ZXJvID0gdXRpbC5maW5kWmVybyh1aW50OEFycmF5LCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgICAgICBwaWMuZGVzY3JpcHRpb24gPSB1dGlsLmRlY29kZVN0cmluZyh1aW50OEFycmF5LnNsaWNlKG9mZnNldCwgZnplcm8pLCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGZ6ZXJvICsgbnVsbFRlcm1pbmF0b3JMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHBpYy5kYXRhID0gQnVmZmVyLmZyb20odWludDhBcnJheS5zbGljZShvZmZzZXQsIGxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBwaWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQ05UJzpcbiAgICAgICAgICAgIGNhc2UgJ1BDTlQnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IFRva2VuLlVJTlQzMl9CRS5nZXQodWludDhBcnJheSwgMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdTWUxUJzpcbiAgICAgICAgICAgICAgICAvLyBza2lwIHRleHQgZW5jb2RpbmcgKDEgYnl0ZSksXG4gICAgICAgICAgICAgICAgLy8gICAgICBsYW5ndWFnZSAoMyBieXRlcyksXG4gICAgICAgICAgICAgICAgLy8gICAgICB0aW1lIHN0YW1wIGZvcm1hdCAoMSBieXRlKSxcbiAgICAgICAgICAgICAgICAvLyAgICAgIGNvbnRlbnQgdGFnVHlwZXMgKDEgYnl0ZSksXG4gICAgICAgICAgICAgICAgLy8gICAgICBjb250ZW50IGRlc2NyaXB0b3IgKDEgYnl0ZSlcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNztcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4dCA9IHVpbnQ4QXJyYXkuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgPSB1dGlsLmZpbmRaZXJvKHVpbnQ4QXJyYXksIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNTsgLy8gcHVzaCBvZmZzZXQgZm9yd2FyZCBvbmUgKyAgNCBieXRlIHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh1dGlsLmRlY29kZVN0cmluZyh0eHQsIGVuY29kaW5nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVUxUJzpcbiAgICAgICAgICAgIGNhc2UgJ1VTTFQnOlxuICAgICAgICAgICAgY2FzZSAnQ09NJzpcbiAgICAgICAgICAgIGNhc2UgJ0NPTU0nOlxuICAgICAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgIG91dC5sYW5ndWFnZSA9IHV0aWwuZGVjb2RlU3RyaW5nKHVpbnQ4QXJyYXkuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyAzKSwgZGVmYXVsdEVuYyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICAgICAgZnplcm8gPSB1dGlsLmZpbmRaZXJvKHVpbnQ4QXJyYXksIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgb3V0LmRlc2NyaXB0aW9uID0gdXRpbC5kZWNvZGVTdHJpbmcodWludDhBcnJheS5zbGljZShvZmZzZXQsIGZ6ZXJvKSwgZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGZ6ZXJvICsgbnVsbFRlcm1pbmF0b3JMZW5ndGg7XG4gICAgICAgICAgICAgICAgb3V0LnRleHQgPSB1dGlsLmRlY29kZVN0cmluZyh1aW50OEFycmF5LnNsaWNlKG9mZnNldCwgbGVuZ3RoKSwgZW5jb2RpbmcpLnJlcGxhY2UoL1xceDAwKyQvLCAnJyk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gW291dF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdVRklEJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBGcmFtZVBhcnNlci5yZWFkSWRlbnRpZmllckFuZERhdGEodWludDhBcnJheSwgb2Zmc2V0LCBsZW5ndGgsIGRlZmF1bHRFbmMpO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHsgb3duZXJfaWRlbnRpZmllcjogb3V0cHV0LmlkLCBpZGVudGlmaWVyOiBvdXRwdXQuZGF0YSB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUFJJVic6IC8vIHByaXZhdGUgZnJhbWVcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBGcmFtZVBhcnNlci5yZWFkSWRlbnRpZmllckFuZERhdGEodWludDhBcnJheSwgb2Zmc2V0LCBsZW5ndGgsIGRlZmF1bHRFbmMpO1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHsgb3duZXJfaWRlbnRpZmllcjogb3V0cHV0LmlkLCBkYXRhOiBvdXRwdXQuZGF0YSB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUE9QTSc6IC8vIFBvcHVsYXJpbWV0ZXJcbiAgICAgICAgICAgICAgICBmemVybyA9IHV0aWwuZmluZFplcm8odWludDhBcnJheSwgb2Zmc2V0LCBsZW5ndGgsIGRlZmF1bHRFbmMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtYWlsID0gdXRpbC5kZWNvZGVTdHJpbmcodWludDhBcnJheS5zbGljZShvZmZzZXQsIGZ6ZXJvKSwgZGVmYXVsdEVuYyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZnplcm8gKyAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFMZW4gPSBsZW5ndGggLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgcmF0aW5nOiBUb2tlbi5VSU5UOC5nZXQodWludDhBcnJheSwgb2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcjogZGF0YUxlbiA+PSA1ID8gVG9rZW4uVUlOVDMyX0JFLmdldCh1aW50OEFycmF5LCBvZmZzZXQgKyAxKSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdHRU9CJzogeyAvLyBHZW5lcmFsIGVuY2Fwc3VsYXRlZCBvYmplY3RcbiAgICAgICAgICAgICAgICBmemVybyA9IHV0aWwuZmluZFplcm8odWludDhBcnJheSwgb2Zmc2V0ICsgMSwgbGVuZ3RoLCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWltZVR5cGUgPSB1dGlsLmRlY29kZVN0cmluZyh1aW50OEFycmF5LnNsaWNlKG9mZnNldCArIDEsIGZ6ZXJvKSwgZGVmYXVsdEVuYyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZnplcm8gKyAxO1xuICAgICAgICAgICAgICAgIGZ6ZXJvID0gdXRpbC5maW5kWmVybyh1aW50OEFycmF5LCBvZmZzZXQsIGxlbmd0aCAtIG9mZnNldCwgZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gdXRpbC5kZWNvZGVTdHJpbmcodWludDhBcnJheS5zbGljZShvZmZzZXQsIGZ6ZXJvKSwgZGVmYXVsdEVuYyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZnplcm8gKyAxO1xuICAgICAgICAgICAgICAgIGZ6ZXJvID0gdXRpbC5maW5kWmVybyh1aW50OEFycmF5LCBvZmZzZXQsIGxlbmd0aCAtIG9mZnNldCwgZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdXRpbC5kZWNvZGVTdHJpbmcodWludDhBcnJheS5zbGljZShvZmZzZXQsIGZ6ZXJvKSwgZGVmYXVsdEVuYyk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBtaW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB1aW50OEFycmF5LnNsaWNlKG9mZnNldCArIDEsIGxlbmd0aClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVy1GcmFtZXM6XG4gICAgICAgICAgICBjYXNlICdXQ09NJzpcbiAgICAgICAgICAgIGNhc2UgJ1dDT1AnOlxuICAgICAgICAgICAgY2FzZSAnV09BRic6XG4gICAgICAgICAgICBjYXNlICdXT0FSJzpcbiAgICAgICAgICAgIGNhc2UgJ1dPQVMnOlxuICAgICAgICAgICAgY2FzZSAnV09SUyc6XG4gICAgICAgICAgICBjYXNlICdXUEFZJzpcbiAgICAgICAgICAgIGNhc2UgJ1dQVUInOlxuICAgICAgICAgICAgICAgIC8vIERlY29kZSBVUkxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB1dGlsLmRlY29kZVN0cmluZyh1aW50OEFycmF5LnNsaWNlKG9mZnNldCwgZnplcm8pLCBkZWZhdWx0RW5jKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1dYWFgnOiB7XG4gICAgICAgICAgICAgICAgLy8gRGVjb2RlIFVSTFxuICAgICAgICAgICAgICAgIGZ6ZXJvID0gdXRpbC5maW5kWmVybyh1aW50OEFycmF5LCBvZmZzZXQgKyAxLCBsZW5ndGgsIGVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHV0aWwuZGVjb2RlU3RyaW5nKHVpbnQ4QXJyYXkuc2xpY2Uob2Zmc2V0ICsgMSwgZnplcm8pLCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZnplcm8gKyAoZW5jb2RpbmcgPT09ICd1dGYxNmxlJyA/IDIgOiAxKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7IGRlc2NyaXB0aW9uLCB1cmw6IHV0aWwuZGVjb2RlU3RyaW5nKHVpbnQ4QXJyYXkuc2xpY2Uob2Zmc2V0LCBsZW5ndGgpLCBkZWZhdWx0RW5jKSB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnV0ZEJzpcbiAgICAgICAgICAgIGNhc2UgJ1dGRUQnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IHV0aWwuZGVjb2RlU3RyaW5nKHVpbnQ4QXJyYXkuc2xpY2Uob2Zmc2V0ICsgMSwgdXRpbC5maW5kWmVybyh1aW50OEFycmF5LCBvZmZzZXQgKyAxLCBsZW5ndGgsIGVuY29kaW5nKSksIGVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ01DREknOiB7XG4gICAgICAgICAgICAgICAgLy8gTXVzaWMgQ0QgaWRlbnRpZmllclxuICAgICAgICAgICAgICAgIG91dHB1dCA9IHVpbnQ4QXJyYXkuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZGVidWcoJ1dhcm5pbmc6IHVuc3VwcG9ydGVkIGlkM3YyLXRhZy10eXBlOiAnICsgdHlwZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgc3RhdGljIGZpeFBpY3R1cmVNaW1lVHlwZShwaWN0dXJlVHlwZSkge1xuICAgICAgICBwaWN0dXJlVHlwZSA9IHBpY3R1cmVUeXBlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIHN3aXRjaCAocGljdHVyZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2pwZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdpbWFnZS9qcGVnJztcbiAgICAgICAgICAgIGNhc2UgJ3BuZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdpbWFnZS9wbmcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWN0dXJlVHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgVE1DTCAoTXVzaWNpYW4gY3JlZGl0cyBsaXN0KSBvciBUSVBMIChJbnZvbHZlZCBwZW9wbGUgbGlzdClcbiAgICAgKiBAcGFyYW0gZW50cmllc1xuICAgICAqL1xuICAgIHN0YXRpYyBmdW5jdGlvbkxpc3QoZW50cmllcykge1xuICAgICAgICBjb25zdCByZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgKyAxIDwgZW50cmllcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBlbnRyaWVzW2kgKyAxXS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgcmVzW2VudHJpZXNbaV1dID0gcmVzLmhhc093blByb3BlcnR5KGVudHJpZXNbaV0pID8gcmVzW2VudHJpZXNbaV1dLmNvbmNhdChuYW1lcykgOiBuYW1lcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBpZDN2Mi40IGRlZmluZXMgdGhhdCBtdWx0aXBsZSBUKiB2YWx1ZXMgYXJlIHNlcGFyYXRlZCBieSAweDAwXG4gICAgICogaWQzdjIuMyBkZWZpbmVzIHRoYXQgVENPTSwgVEVYVCwgVE9MWSwgVE9QRSAmIFRQRTEgdmFsdWVzIGFyZSBzZXBhcmF0ZWQgYnkgL1xuICAgICAqIEBwYXJhbSB0YWcgLSBUYWcgbmFtZVxuICAgICAqIEBwYXJhbSB0ZXh0IC0gQ29uY2F0ZW5hdGVkIHRhZyB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFNwbGl0IHRhZyB2YWx1ZVxuICAgICAqL1xuICAgIHNwbGl0VmFsdWUodGFnLCB0ZXh0KSB7XG4gICAgICAgIGxldCB2YWx1ZXM7XG4gICAgICAgIGlmICh0aGlzLm1ham9yIDwgNCkge1xuICAgICAgICAgICAgdmFsdWVzID0gdGV4dC5zcGxpdCgvXFx4MDAvZyk7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhcm5pbmdDb2xsZWN0b3IuYWRkV2FybmluZyhgSUQzdjIuJHt0aGlzLm1ham9yfSAke3RhZ30gdXNlcyBub24gc3RhbmRhcmQgbnVsbC1zZXBhcmF0b3IuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSB0ZXh0LnNwbGl0KC9cXC8vZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB0ZXh0LnNwbGl0KC9cXHgwMC9nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRnJhbWVQYXJzZXIudHJpbUFycmF5KHZhbHVlcyk7XG4gICAgfVxuICAgIHN0YXRpYyB0cmltQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXMubWFwKHZhbHVlID0+IHZhbHVlLnJlcGxhY2UoL1xceDAwKyQvLCAnJykudHJpbSgpKTtcbiAgICB9XG4gICAgc3RhdGljIHJlYWRJZGVudGlmaWVyQW5kRGF0YSh1aW50OEFycmF5LCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgICAgICAgY29uc3QgZnplcm8gPSB1dGlsLmZpbmRaZXJvKHVpbnQ4QXJyYXksIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZyk7XG4gICAgICAgIGNvbnN0IGlkID0gdXRpbC5kZWNvZGVTdHJpbmcodWludDhBcnJheS5zbGljZShvZmZzZXQsIGZ6ZXJvKSwgZW5jb2RpbmcpO1xuICAgICAgICBvZmZzZXQgPSBmemVybyArIEZyYW1lUGFyc2VyLmdldE51bGxUZXJtaW5hdG9yTGVuZ3RoKGVuY29kaW5nKTtcbiAgICAgICAgcmV0dXJuIHsgaWQsIGRhdGE6IHVpbnQ4QXJyYXkuc2xpY2Uob2Zmc2V0LCBsZW5ndGgpIH07XG4gICAgfVxuICAgIHN0YXRpYyBnZXROdWxsVGVybWluYXRvckxlbmd0aChlbmMpIHtcbiAgICAgICAgcmV0dXJuIGVuYyA9PT0gJ3V0ZjE2bGUnID8gMiA6IDE7XG4gICAgfVxufVxuZXhwb3J0cy5GcmFtZVBhcnNlciA9IEZyYW1lUGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/FrameParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v22TagMapper.js":
/*!******************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v2/ID3v22TagMapper.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ID3v22TagMapper = exports.id3v22TagMap = void 0;\nconst CaseInsensitiveTagMap_1 = __webpack_require__(/*! ../common/CaseInsensitiveTagMap */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js\");\n/**\n * ID3v2.2 tag mappings\n */\nexports.id3v22TagMap = {\n    TT2: 'title',\n    TP1: 'artist',\n    TP2: 'albumartist',\n    TAL: 'album',\n    TYE: 'year',\n    COM: 'comment',\n    TRK: 'track',\n    TPA: 'disk',\n    TCO: 'genre',\n    PIC: 'picture',\n    TCM: 'composer',\n    TOR: 'originaldate',\n    TOT: 'originalalbum',\n    TXT: 'lyricist',\n    TP3: 'conductor',\n    TPB: 'label',\n    TT1: 'grouping',\n    TT3: 'subtitle',\n    TLA: 'language',\n    TCR: 'copyright',\n    WCP: 'license',\n    TEN: 'encodedby',\n    TSS: 'encodersettings',\n    WAR: 'website',\n    'COM:iTunPGAP': 'gapless'\n    /* ToDo: iTunes tags:\n    'COM:iTunNORM': ,\n    'COM:iTunSMPB': 'encoder delay',\n    'COM:iTunes_CDDB_IDs'\n    */ ,\n    PCS: 'podcast',\n    TCP: \"compilation\",\n    TDR: 'date',\n    TS2: 'albumartistsort',\n    TSA: 'albumsort',\n    TSC: 'composersort',\n    TSP: 'artistsort',\n    TST: 'titlesort',\n    WFD: 'podcasturl',\n    TBP: 'bpm'\n};\nclass ID3v22TagMapper extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {\n    constructor() {\n        super(['ID3v2.2'], exports.id3v22TagMap);\n    }\n}\nexports.ID3v22TagMapper = ID3v22TagMapper;\n//# sourceMappingURL=ID3v22TagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvaWQzdjIvSUQzdjIyVGFnTWFwcGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLG9CQUFvQjtBQUM5QyxnQ0FBZ0MsbUJBQU8sQ0FBQyw4SEFBaUM7QUFDekU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvaWQzdjIvSUQzdjIyVGFnTWFwcGVyLmpzPzlkNjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklEM3YyMlRhZ01hcHBlciA9IGV4cG9ydHMuaWQzdjIyVGFnTWFwID0gdm9pZCAwO1xuY29uc3QgQ2FzZUluc2Vuc2l0aXZlVGFnTWFwXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0Nhc2VJbnNlbnNpdGl2ZVRhZ01hcFwiKTtcbi8qKlxuICogSUQzdjIuMiB0YWcgbWFwcGluZ3NcbiAqL1xuZXhwb3J0cy5pZDN2MjJUYWdNYXAgPSB7XG4gICAgVFQyOiAndGl0bGUnLFxuICAgIFRQMTogJ2FydGlzdCcsXG4gICAgVFAyOiAnYWxidW1hcnRpc3QnLFxuICAgIFRBTDogJ2FsYnVtJyxcbiAgICBUWUU6ICd5ZWFyJyxcbiAgICBDT006ICdjb21tZW50JyxcbiAgICBUUks6ICd0cmFjaycsXG4gICAgVFBBOiAnZGlzaycsXG4gICAgVENPOiAnZ2VucmUnLFxuICAgIFBJQzogJ3BpY3R1cmUnLFxuICAgIFRDTTogJ2NvbXBvc2VyJyxcbiAgICBUT1I6ICdvcmlnaW5hbGRhdGUnLFxuICAgIFRPVDogJ29yaWdpbmFsYWxidW0nLFxuICAgIFRYVDogJ2x5cmljaXN0JyxcbiAgICBUUDM6ICdjb25kdWN0b3InLFxuICAgIFRQQjogJ2xhYmVsJyxcbiAgICBUVDE6ICdncm91cGluZycsXG4gICAgVFQzOiAnc3VidGl0bGUnLFxuICAgIFRMQTogJ2xhbmd1YWdlJyxcbiAgICBUQ1I6ICdjb3B5cmlnaHQnLFxuICAgIFdDUDogJ2xpY2Vuc2UnLFxuICAgIFRFTjogJ2VuY29kZWRieScsXG4gICAgVFNTOiAnZW5jb2RlcnNldHRpbmdzJyxcbiAgICBXQVI6ICd3ZWJzaXRlJyxcbiAgICAnQ09NOmlUdW5QR0FQJzogJ2dhcGxlc3MnXG4gICAgLyogVG9EbzogaVR1bmVzIHRhZ3M6XG4gICAgJ0NPTTppVHVuTk9STSc6ICxcbiAgICAnQ09NOmlUdW5TTVBCJzogJ2VuY29kZXIgZGVsYXknLFxuICAgICdDT006aVR1bmVzX0NEREJfSURzJ1xuICAgICovICxcbiAgICBQQ1M6ICdwb2RjYXN0JyxcbiAgICBUQ1A6IFwiY29tcGlsYXRpb25cIixcbiAgICBURFI6ICdkYXRlJyxcbiAgICBUUzI6ICdhbGJ1bWFydGlzdHNvcnQnLFxuICAgIFRTQTogJ2FsYnVtc29ydCcsXG4gICAgVFNDOiAnY29tcG9zZXJzb3J0JyxcbiAgICBUU1A6ICdhcnRpc3Rzb3J0JyxcbiAgICBUU1Q6ICd0aXRsZXNvcnQnLFxuICAgIFdGRDogJ3BvZGNhc3R1cmwnLFxuICAgIFRCUDogJ2JwbSdcbn07XG5jbGFzcyBJRDN2MjJUYWdNYXBwZXIgZXh0ZW5kcyBDYXNlSW5zZW5zaXRpdmVUYWdNYXBfMS5DYXNlSW5zZW5zaXRpdmVUYWdNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihbJ0lEM3YyLjInXSwgZXhwb3J0cy5pZDN2MjJUYWdNYXApO1xuICAgIH1cbn1cbmV4cG9ydHMuSUQzdjIyVGFnTWFwcGVyID0gSUQzdjIyVGFnTWFwcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUQzdjIyVGFnTWFwcGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v22TagMapper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v24TagMapper.js":
/*!******************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v2/ID3v24TagMapper.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ID3v24TagMapper = void 0;\nconst GenericTagMapper_1 = __webpack_require__(/*! ../common/GenericTagMapper */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/GenericTagMapper.js\");\nconst CaseInsensitiveTagMap_1 = __webpack_require__(/*! ../common/CaseInsensitiveTagMap */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js\");\nconst util = __webpack_require__(/*! ../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\n/**\n * ID3v2.3/ID3v2.4 tag mappings\n */\nconst id3v24TagMap = {\n    // id3v2.3\n    TIT2: 'title',\n    TPE1: 'artist',\n    'TXXX:Artists': 'artists',\n    TPE2: 'albumartist',\n    TALB: 'album',\n    TDRV: 'date',\n    /**\n     * Original release year\n     */\n    TORY: 'originalyear',\n    TPOS: 'disk',\n    TCON: 'genre',\n    APIC: 'picture',\n    TCOM: 'composer',\n    'USLT:description': 'lyrics',\n    TSOA: 'albumsort',\n    TSOT: 'titlesort',\n    TOAL: 'originalalbum',\n    TSOP: 'artistsort',\n    TSO2: 'albumartistsort',\n    TSOC: 'composersort',\n    TEXT: 'lyricist',\n    'TXXX:Writer': 'writer',\n    TPE3: 'conductor',\n    // 'IPLS:instrument': 'performer:instrument', // ToDo\n    TPE4: 'remixer',\n    'IPLS:arranger': 'arranger',\n    'IPLS:engineer': 'engineer',\n    'IPLS:producer': 'producer',\n    'IPLS:DJ-mix': 'djmixer',\n    'IPLS:mix': 'mixer',\n    TPUB: 'label',\n    TIT1: 'grouping',\n    TIT3: 'subtitle',\n    TRCK: 'track',\n    TCMP: 'compilation',\n    POPM: 'rating',\n    TBPM: 'bpm',\n    TMED: 'media',\n    'TXXX:CATALOGNUMBER': 'catalognumber',\n    'TXXX:MusicBrainz Album Status': 'releasestatus',\n    'TXXX:MusicBrainz Album Type': 'releasetype',\n    /**\n     * Release country as documented: https://picard.musicbrainz.org/docs/mappings/#cite_note-0\n     */\n    'TXXX:MusicBrainz Album Release Country': 'releasecountry',\n    /**\n     * Release country as implemented // ToDo: report\n     */\n    'TXXX:RELEASECOUNTRY': 'releasecountry',\n    'TXXX:SCRIPT': 'script',\n    TLAN: 'language',\n    TCOP: 'copyright',\n    WCOP: 'license',\n    TENC: 'encodedby',\n    TSSE: 'encodersettings',\n    'TXXX:BARCODE': 'barcode',\n    'TXXX:ISRC': 'isrc',\n    TSRC: 'isrc',\n    'TXXX:ASIN': 'asin',\n    'TXXX:originalyear': 'originalyear',\n    'UFID:http://musicbrainz.org': 'musicbrainz_recordingid',\n    'TXXX:MusicBrainz Release Track Id': 'musicbrainz_trackid',\n    'TXXX:MusicBrainz Album Id': 'musicbrainz_albumid',\n    'TXXX:MusicBrainz Artist Id': 'musicbrainz_artistid',\n    'TXXX:MusicBrainz Album Artist Id': 'musicbrainz_albumartistid',\n    'TXXX:MusicBrainz Release Group Id': 'musicbrainz_releasegroupid',\n    'TXXX:MusicBrainz Work Id': 'musicbrainz_workid',\n    'TXXX:MusicBrainz TRM Id': 'musicbrainz_trmid',\n    'TXXX:MusicBrainz Disc Id': 'musicbrainz_discid',\n    'TXXX:ACOUSTID_ID': 'acoustid_id',\n    'TXXX:Acoustid Id': 'acoustid_id',\n    'TXXX:Acoustid Fingerprint': 'acoustid_fingerprint',\n    'TXXX:MusicIP PUID': 'musicip_puid',\n    'TXXX:MusicMagic Fingerprint': 'musicip_fingerprint',\n    WOAR: 'website',\n    // id3v2.4\n    // ToDo: In same sequence as defined at http://id3.org/id3v2.4.0-frames\n    TDRC: 'date',\n    TYER: 'year',\n    TDOR: 'originaldate',\n    // 'TMCL:instrument': 'performer:instrument',\n    'TIPL:arranger': 'arranger',\n    'TIPL:engineer': 'engineer',\n    'TIPL:producer': 'producer',\n    'TIPL:DJ-mix': 'djmixer',\n    'TIPL:mix': 'mixer',\n    TMOO: 'mood',\n    // additional mappings:\n    SYLT: 'lyrics',\n    TSST: 'discsubtitle',\n    TKEY: 'key',\n    COMM: 'comment',\n    TOPE: 'originalartist',\n    // Windows Media Player\n    'PRIV:AverageLevel': 'averageLevel',\n    'PRIV:PeakLevel': 'peakLevel',\n    // Discogs\n    'TXXX:DISCOGS_ARTIST_ID': 'discogs_artist_id',\n    'TXXX:DISCOGS_ARTISTS': 'artists',\n    'TXXX:DISCOGS_ARTIST_NAME': 'artists',\n    'TXXX:DISCOGS_ALBUM_ARTISTS': 'albumartist',\n    'TXXX:DISCOGS_CATALOG': 'catalognumber',\n    'TXXX:DISCOGS_COUNTRY': 'releasecountry',\n    'TXXX:DISCOGS_DATE': 'originaldate',\n    'TXXX:DISCOGS_LABEL': 'label',\n    'TXXX:DISCOGS_LABEL_ID': 'discogs_label_id',\n    'TXXX:DISCOGS_MASTER_RELEASE_ID': 'discogs_master_release_id',\n    'TXXX:DISCOGS_RATING': 'discogs_rating',\n    'TXXX:DISCOGS_RELEASED': 'date',\n    'TXXX:DISCOGS_RELEASE_ID': 'discogs_release_id',\n    'TXXX:DISCOGS_VOTES': 'discogs_votes',\n    'TXXX:CATALOGID': 'catalognumber',\n    'TXXX:STYLE': 'genre',\n    'TXXX:REPLAYGAIN_TRACK_PEAK': 'replaygain_track_peak',\n    'TXXX:REPLAYGAIN_TRACK_GAIN': 'replaygain_track_gain',\n    'TXXX:REPLAYGAIN_ALBUM_PEAK': 'replaygain_album_peak',\n    'TXXX:REPLAYGAIN_ALBUM_GAIN': 'replaygain_album_gain',\n    'TXXX:MP3GAIN_MINMAX': 'replaygain_track_minmax',\n    'TXXX:MP3GAIN_ALBUM_MINMAX': 'replaygain_album_minmax',\n    'TXXX:MP3GAIN_UNDO': 'replaygain_undo',\n    MVNM: 'movement',\n    MVIN: 'movementIndex',\n    PCST: 'podcast',\n    TCAT: 'category',\n    TDES: 'description',\n    TDRL: 'date',\n    TGID: 'podcastId',\n    TKWD: 'keywords',\n    WFED: 'podcasturl'\n};\nclass ID3v24TagMapper extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {\n    static toRating(popm) {\n        return {\n            source: popm.email,\n            rating: popm.rating > 0 ? (popm.rating - 1) / 254 * GenericTagMapper_1.CommonTagMapper.maxRatingScore : undefined\n        };\n    }\n    constructor() {\n        super(['ID3v2.3', 'ID3v2.4'], id3v24TagMap);\n    }\n    /**\n     * Handle post mapping exceptions / correction\n     * @param tag to post map\n     * @param warnings Wil be used to register (collect) warnings\n     * @return Common value e.g. \"Buena Vista Social Club\"\n     */\n    postMap(tag, warnings) {\n        switch (tag.id) {\n            case 'UFID': // decode MusicBrainz Recording Id\n                if (tag.value.owner_identifier === 'http://musicbrainz.org') {\n                    tag.id += ':' + tag.value.owner_identifier;\n                    tag.value = util.decodeString(tag.value.identifier, 'latin1'); // latin1 == iso-8859-1\n                }\n                break;\n            case 'PRIV':\n                switch (tag.value.owner_identifier) {\n                    // decode Windows Media Player\n                    case 'AverageLevel':\n                    case 'PeakValue':\n                        tag.id += ':' + tag.value.owner_identifier;\n                        tag.value = tag.value.data.length === 4 ? tag.value.data.readUInt32LE(0) : null;\n                        if (tag.value === null) {\n                            warnings.addWarning(`Failed to parse PRIV:PeakValue`);\n                        }\n                        break;\n                    default:\n                        warnings.addWarning(`Unknown PRIV owner-identifier: ${tag.value.owner_identifier}`);\n                }\n                break;\n            case 'COMM':\n                tag.value = tag.value ? tag.value.text : null;\n                break;\n            case 'POPM':\n                tag.value = ID3v24TagMapper.toRating(tag.value);\n                break;\n            default:\n                break;\n        }\n    }\n}\nexports.ID3v24TagMapper = ID3v24TagMapper;\n//# sourceMappingURL=ID3v24TagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvaWQzdjIvSUQzdjI0VGFnTWFwcGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QiwyQkFBMkIsbUJBQU8sQ0FBQyxvSEFBNEI7QUFDL0QsZ0NBQWdDLG1CQUFPLENBQUMsOEhBQWlDO0FBQ3pFLGFBQWEsbUJBQU8sQ0FBQyw0RkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSwyQkFBMkI7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9pZDN2Mi9JRDN2MjRUYWdNYXBwZXIuanM/MjBkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSUQzdjI0VGFnTWFwcGVyID0gdm9pZCAwO1xuY29uc3QgR2VuZXJpY1RhZ01hcHBlcl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9HZW5lcmljVGFnTWFwcGVyXCIpO1xuY29uc3QgQ2FzZUluc2Vuc2l0aXZlVGFnTWFwXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0Nhc2VJbnNlbnNpdGl2ZVRhZ01hcFwiKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi4vY29tbW9uL1V0aWxcIik7XG4vKipcbiAqIElEM3YyLjMvSUQzdjIuNCB0YWcgbWFwcGluZ3NcbiAqL1xuY29uc3QgaWQzdjI0VGFnTWFwID0ge1xuICAgIC8vIGlkM3YyLjNcbiAgICBUSVQyOiAndGl0bGUnLFxuICAgIFRQRTE6ICdhcnRpc3QnLFxuICAgICdUWFhYOkFydGlzdHMnOiAnYXJ0aXN0cycsXG4gICAgVFBFMjogJ2FsYnVtYXJ0aXN0JyxcbiAgICBUQUxCOiAnYWxidW0nLFxuICAgIFREUlY6ICdkYXRlJyxcbiAgICAvKipcbiAgICAgKiBPcmlnaW5hbCByZWxlYXNlIHllYXJcbiAgICAgKi9cbiAgICBUT1JZOiAnb3JpZ2luYWx5ZWFyJyxcbiAgICBUUE9TOiAnZGlzaycsXG4gICAgVENPTjogJ2dlbnJlJyxcbiAgICBBUElDOiAncGljdHVyZScsXG4gICAgVENPTTogJ2NvbXBvc2VyJyxcbiAgICAnVVNMVDpkZXNjcmlwdGlvbic6ICdseXJpY3MnLFxuICAgIFRTT0E6ICdhbGJ1bXNvcnQnLFxuICAgIFRTT1Q6ICd0aXRsZXNvcnQnLFxuICAgIFRPQUw6ICdvcmlnaW5hbGFsYnVtJyxcbiAgICBUU09QOiAnYXJ0aXN0c29ydCcsXG4gICAgVFNPMjogJ2FsYnVtYXJ0aXN0c29ydCcsXG4gICAgVFNPQzogJ2NvbXBvc2Vyc29ydCcsXG4gICAgVEVYVDogJ2x5cmljaXN0JyxcbiAgICAnVFhYWDpXcml0ZXInOiAnd3JpdGVyJyxcbiAgICBUUEUzOiAnY29uZHVjdG9yJyxcbiAgICAvLyAnSVBMUzppbnN0cnVtZW50JzogJ3BlcmZvcm1lcjppbnN0cnVtZW50JywgLy8gVG9Eb1xuICAgIFRQRTQ6ICdyZW1peGVyJyxcbiAgICAnSVBMUzphcnJhbmdlcic6ICdhcnJhbmdlcicsXG4gICAgJ0lQTFM6ZW5naW5lZXInOiAnZW5naW5lZXInLFxuICAgICdJUExTOnByb2R1Y2VyJzogJ3Byb2R1Y2VyJyxcbiAgICAnSVBMUzpESi1taXgnOiAnZGptaXhlcicsXG4gICAgJ0lQTFM6bWl4JzogJ21peGVyJyxcbiAgICBUUFVCOiAnbGFiZWwnLFxuICAgIFRJVDE6ICdncm91cGluZycsXG4gICAgVElUMzogJ3N1YnRpdGxlJyxcbiAgICBUUkNLOiAndHJhY2snLFxuICAgIFRDTVA6ICdjb21waWxhdGlvbicsXG4gICAgUE9QTTogJ3JhdGluZycsXG4gICAgVEJQTTogJ2JwbScsXG4gICAgVE1FRDogJ21lZGlhJyxcbiAgICAnVFhYWDpDQVRBTE9HTlVNQkVSJzogJ2NhdGFsb2dudW1iZXInLFxuICAgICdUWFhYOk11c2ljQnJhaW56IEFsYnVtIFN0YXR1cyc6ICdyZWxlYXNlc3RhdHVzJyxcbiAgICAnVFhYWDpNdXNpY0JyYWlueiBBbGJ1bSBUeXBlJzogJ3JlbGVhc2V0eXBlJyxcbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIGNvdW50cnkgYXMgZG9jdW1lbnRlZDogaHR0cHM6Ly9waWNhcmQubXVzaWNicmFpbnoub3JnL2RvY3MvbWFwcGluZ3MvI2NpdGVfbm90ZS0wXG4gICAgICovXG4gICAgJ1RYWFg6TXVzaWNCcmFpbnogQWxidW0gUmVsZWFzZSBDb3VudHJ5JzogJ3JlbGVhc2Vjb3VudHJ5JyxcbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIGNvdW50cnkgYXMgaW1wbGVtZW50ZWQgLy8gVG9EbzogcmVwb3J0XG4gICAgICovXG4gICAgJ1RYWFg6UkVMRUFTRUNPVU5UUlknOiAncmVsZWFzZWNvdW50cnknLFxuICAgICdUWFhYOlNDUklQVCc6ICdzY3JpcHQnLFxuICAgIFRMQU46ICdsYW5ndWFnZScsXG4gICAgVENPUDogJ2NvcHlyaWdodCcsXG4gICAgV0NPUDogJ2xpY2Vuc2UnLFxuICAgIFRFTkM6ICdlbmNvZGVkYnknLFxuICAgIFRTU0U6ICdlbmNvZGVyc2V0dGluZ3MnLFxuICAgICdUWFhYOkJBUkNPREUnOiAnYmFyY29kZScsXG4gICAgJ1RYWFg6SVNSQyc6ICdpc3JjJyxcbiAgICBUU1JDOiAnaXNyYycsXG4gICAgJ1RYWFg6QVNJTic6ICdhc2luJyxcbiAgICAnVFhYWDpvcmlnaW5hbHllYXInOiAnb3JpZ2luYWx5ZWFyJyxcbiAgICAnVUZJRDpodHRwOi8vbXVzaWNicmFpbnoub3JnJzogJ211c2ljYnJhaW56X3JlY29yZGluZ2lkJyxcbiAgICAnVFhYWDpNdXNpY0JyYWlueiBSZWxlYXNlIFRyYWNrIElkJzogJ211c2ljYnJhaW56X3RyYWNraWQnLFxuICAgICdUWFhYOk11c2ljQnJhaW56IEFsYnVtIElkJzogJ211c2ljYnJhaW56X2FsYnVtaWQnLFxuICAgICdUWFhYOk11c2ljQnJhaW56IEFydGlzdCBJZCc6ICdtdXNpY2JyYWluel9hcnRpc3RpZCcsXG4gICAgJ1RYWFg6TXVzaWNCcmFpbnogQWxidW0gQXJ0aXN0IElkJzogJ211c2ljYnJhaW56X2FsYnVtYXJ0aXN0aWQnLFxuICAgICdUWFhYOk11c2ljQnJhaW56IFJlbGVhc2UgR3JvdXAgSWQnOiAnbXVzaWNicmFpbnpfcmVsZWFzZWdyb3VwaWQnLFxuICAgICdUWFhYOk11c2ljQnJhaW56IFdvcmsgSWQnOiAnbXVzaWNicmFpbnpfd29ya2lkJyxcbiAgICAnVFhYWDpNdXNpY0JyYWlueiBUUk0gSWQnOiAnbXVzaWNicmFpbnpfdHJtaWQnLFxuICAgICdUWFhYOk11c2ljQnJhaW56IERpc2MgSWQnOiAnbXVzaWNicmFpbnpfZGlzY2lkJyxcbiAgICAnVFhYWDpBQ09VU1RJRF9JRCc6ICdhY291c3RpZF9pZCcsXG4gICAgJ1RYWFg6QWNvdXN0aWQgSWQnOiAnYWNvdXN0aWRfaWQnLFxuICAgICdUWFhYOkFjb3VzdGlkIEZpbmdlcnByaW50JzogJ2Fjb3VzdGlkX2ZpbmdlcnByaW50JyxcbiAgICAnVFhYWDpNdXNpY0lQIFBVSUQnOiAnbXVzaWNpcF9wdWlkJyxcbiAgICAnVFhYWDpNdXNpY01hZ2ljIEZpbmdlcnByaW50JzogJ211c2ljaXBfZmluZ2VycHJpbnQnLFxuICAgIFdPQVI6ICd3ZWJzaXRlJyxcbiAgICAvLyBpZDN2Mi40XG4gICAgLy8gVG9EbzogSW4gc2FtZSBzZXF1ZW5jZSBhcyBkZWZpbmVkIGF0IGh0dHA6Ly9pZDMub3JnL2lkM3YyLjQuMC1mcmFtZXNcbiAgICBURFJDOiAnZGF0ZScsXG4gICAgVFlFUjogJ3llYXInLFxuICAgIFRET1I6ICdvcmlnaW5hbGRhdGUnLFxuICAgIC8vICdUTUNMOmluc3RydW1lbnQnOiAncGVyZm9ybWVyOmluc3RydW1lbnQnLFxuICAgICdUSVBMOmFycmFuZ2VyJzogJ2FycmFuZ2VyJyxcbiAgICAnVElQTDplbmdpbmVlcic6ICdlbmdpbmVlcicsXG4gICAgJ1RJUEw6cHJvZHVjZXInOiAncHJvZHVjZXInLFxuICAgICdUSVBMOkRKLW1peCc6ICdkam1peGVyJyxcbiAgICAnVElQTDptaXgnOiAnbWl4ZXInLFxuICAgIFRNT086ICdtb29kJyxcbiAgICAvLyBhZGRpdGlvbmFsIG1hcHBpbmdzOlxuICAgIFNZTFQ6ICdseXJpY3MnLFxuICAgIFRTU1Q6ICdkaXNjc3VidGl0bGUnLFxuICAgIFRLRVk6ICdrZXknLFxuICAgIENPTU06ICdjb21tZW50JyxcbiAgICBUT1BFOiAnb3JpZ2luYWxhcnRpc3QnLFxuICAgIC8vIFdpbmRvd3MgTWVkaWEgUGxheWVyXG4gICAgJ1BSSVY6QXZlcmFnZUxldmVsJzogJ2F2ZXJhZ2VMZXZlbCcsXG4gICAgJ1BSSVY6UGVha0xldmVsJzogJ3BlYWtMZXZlbCcsXG4gICAgLy8gRGlzY29nc1xuICAgICdUWFhYOkRJU0NPR1NfQVJUSVNUX0lEJzogJ2Rpc2NvZ3NfYXJ0aXN0X2lkJyxcbiAgICAnVFhYWDpESVNDT0dTX0FSVElTVFMnOiAnYXJ0aXN0cycsXG4gICAgJ1RYWFg6RElTQ09HU19BUlRJU1RfTkFNRSc6ICdhcnRpc3RzJyxcbiAgICAnVFhYWDpESVNDT0dTX0FMQlVNX0FSVElTVFMnOiAnYWxidW1hcnRpc3QnLFxuICAgICdUWFhYOkRJU0NPR1NfQ0FUQUxPRyc6ICdjYXRhbG9nbnVtYmVyJyxcbiAgICAnVFhYWDpESVNDT0dTX0NPVU5UUlknOiAncmVsZWFzZWNvdW50cnknLFxuICAgICdUWFhYOkRJU0NPR1NfREFURSc6ICdvcmlnaW5hbGRhdGUnLFxuICAgICdUWFhYOkRJU0NPR1NfTEFCRUwnOiAnbGFiZWwnLFxuICAgICdUWFhYOkRJU0NPR1NfTEFCRUxfSUQnOiAnZGlzY29nc19sYWJlbF9pZCcsXG4gICAgJ1RYWFg6RElTQ09HU19NQVNURVJfUkVMRUFTRV9JRCc6ICdkaXNjb2dzX21hc3Rlcl9yZWxlYXNlX2lkJyxcbiAgICAnVFhYWDpESVNDT0dTX1JBVElORyc6ICdkaXNjb2dzX3JhdGluZycsXG4gICAgJ1RYWFg6RElTQ09HU19SRUxFQVNFRCc6ICdkYXRlJyxcbiAgICAnVFhYWDpESVNDT0dTX1JFTEVBU0VfSUQnOiAnZGlzY29nc19yZWxlYXNlX2lkJyxcbiAgICAnVFhYWDpESVNDT0dTX1ZPVEVTJzogJ2Rpc2NvZ3Nfdm90ZXMnLFxuICAgICdUWFhYOkNBVEFMT0dJRCc6ICdjYXRhbG9nbnVtYmVyJyxcbiAgICAnVFhYWDpTVFlMRSc6ICdnZW5yZScsXG4gICAgJ1RYWFg6UkVQTEFZR0FJTl9UUkFDS19QRUFLJzogJ3JlcGxheWdhaW5fdHJhY2tfcGVhaycsXG4gICAgJ1RYWFg6UkVQTEFZR0FJTl9UUkFDS19HQUlOJzogJ3JlcGxheWdhaW5fdHJhY2tfZ2FpbicsXG4gICAgJ1RYWFg6UkVQTEFZR0FJTl9BTEJVTV9QRUFLJzogJ3JlcGxheWdhaW5fYWxidW1fcGVhaycsXG4gICAgJ1RYWFg6UkVQTEFZR0FJTl9BTEJVTV9HQUlOJzogJ3JlcGxheWdhaW5fYWxidW1fZ2FpbicsXG4gICAgJ1RYWFg6TVAzR0FJTl9NSU5NQVgnOiAncmVwbGF5Z2Fpbl90cmFja19taW5tYXgnLFxuICAgICdUWFhYOk1QM0dBSU5fQUxCVU1fTUlOTUFYJzogJ3JlcGxheWdhaW5fYWxidW1fbWlubWF4JyxcbiAgICAnVFhYWDpNUDNHQUlOX1VORE8nOiAncmVwbGF5Z2Fpbl91bmRvJyxcbiAgICBNVk5NOiAnbW92ZW1lbnQnLFxuICAgIE1WSU46ICdtb3ZlbWVudEluZGV4JyxcbiAgICBQQ1NUOiAncG9kY2FzdCcsXG4gICAgVENBVDogJ2NhdGVnb3J5JyxcbiAgICBUREVTOiAnZGVzY3JpcHRpb24nLFxuICAgIFREUkw6ICdkYXRlJyxcbiAgICBUR0lEOiAncG9kY2FzdElkJyxcbiAgICBUS1dEOiAna2V5d29yZHMnLFxuICAgIFdGRUQ6ICdwb2RjYXN0dXJsJ1xufTtcbmNsYXNzIElEM3YyNFRhZ01hcHBlciBleHRlbmRzIENhc2VJbnNlbnNpdGl2ZVRhZ01hcF8xLkNhc2VJbnNlbnNpdGl2ZVRhZ01hcCB7XG4gICAgc3RhdGljIHRvUmF0aW5nKHBvcG0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZTogcG9wbS5lbWFpbCxcbiAgICAgICAgICAgIHJhdGluZzogcG9wbS5yYXRpbmcgPiAwID8gKHBvcG0ucmF0aW5nIC0gMSkgLyAyNTQgKiBHZW5lcmljVGFnTWFwcGVyXzEuQ29tbW9uVGFnTWFwcGVyLm1heFJhdGluZ1Njb3JlIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihbJ0lEM3YyLjMnLCAnSUQzdjIuNCddLCBpZDN2MjRUYWdNYXApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcG9zdCBtYXBwaW5nIGV4Y2VwdGlvbnMgLyBjb3JyZWN0aW9uXG4gICAgICogQHBhcmFtIHRhZyB0byBwb3N0IG1hcFxuICAgICAqIEBwYXJhbSB3YXJuaW5ncyBXaWwgYmUgdXNlZCB0byByZWdpc3RlciAoY29sbGVjdCkgd2FybmluZ3NcbiAgICAgKiBAcmV0dXJuIENvbW1vbiB2YWx1ZSBlLmcuIFwiQnVlbmEgVmlzdGEgU29jaWFsIENsdWJcIlxuICAgICAqL1xuICAgIHBvc3RNYXAodGFnLCB3YXJuaW5ncykge1xuICAgICAgICBzd2l0Y2ggKHRhZy5pZCkge1xuICAgICAgICAgICAgY2FzZSAnVUZJRCc6IC8vIGRlY29kZSBNdXNpY0JyYWlueiBSZWNvcmRpbmcgSWRcbiAgICAgICAgICAgICAgICBpZiAodGFnLnZhbHVlLm93bmVyX2lkZW50aWZpZXIgPT09ICdodHRwOi8vbXVzaWNicmFpbnoub3JnJykge1xuICAgICAgICAgICAgICAgICAgICB0YWcuaWQgKz0gJzonICsgdGFnLnZhbHVlLm93bmVyX2lkZW50aWZpZXI7XG4gICAgICAgICAgICAgICAgICAgIHRhZy52YWx1ZSA9IHV0aWwuZGVjb2RlU3RyaW5nKHRhZy52YWx1ZS5pZGVudGlmaWVyLCAnbGF0aW4xJyk7IC8vIGxhdGluMSA9PSBpc28tODg1OS0xXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUFJJVic6XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcudmFsdWUub3duZXJfaWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWNvZGUgV2luZG93cyBNZWRpYSBQbGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQXZlcmFnZUxldmVsJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUGVha1ZhbHVlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZy5pZCArPSAnOicgKyB0YWcudmFsdWUub3duZXJfaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZy52YWx1ZSA9IHRhZy52YWx1ZS5kYXRhLmxlbmd0aCA9PT0gNCA/IHRhZy52YWx1ZS5kYXRhLnJlYWRVSW50MzJMRSgwKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3MuYWRkV2FybmluZyhgRmFpbGVkIHRvIHBhcnNlIFBSSVY6UGVha1ZhbHVlYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLmFkZFdhcm5pbmcoYFVua25vd24gUFJJViBvd25lci1pZGVudGlmaWVyOiAke3RhZy52YWx1ZS5vd25lcl9pZGVudGlmaWVyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0NPTU0nOlxuICAgICAgICAgICAgICAgIHRhZy52YWx1ZSA9IHRhZy52YWx1ZSA/IHRhZy52YWx1ZS50ZXh0IDogbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BPUE0nOlxuICAgICAgICAgICAgICAgIHRhZy52YWx1ZSA9IElEM3YyNFRhZ01hcHBlci50b1JhdGluZyh0YWcudmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSUQzdjI0VGFnTWFwcGVyID0gSUQzdjI0VGFnTWFwcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SUQzdjI0VGFnTWFwcGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v24TagMapper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js":
/*!**************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ID3v2Parser = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst util = __webpack_require__(/*! ../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\nconst FrameParser_1 = __webpack_require__(/*! ./FrameParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/FrameParser.js\");\nconst ID3v2Token_1 = __webpack_require__(/*! ./ID3v2Token */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v2Token.js\");\nclass ID3v2Parser {\n    static removeUnsyncBytes(buffer) {\n        let readI = 0;\n        let writeI = 0;\n        while (readI < buffer.length - 1) {\n            if (readI !== writeI) {\n                buffer[writeI] = buffer[readI];\n            }\n            readI += (buffer[readI] === 0xFF && buffer[readI + 1] === 0) ? 2 : 1;\n            writeI++;\n        }\n        if (readI < buffer.length) {\n            buffer[writeI++] = buffer[readI];\n        }\n        return buffer.slice(0, writeI);\n    }\n    static getFrameHeaderLength(majorVer) {\n        switch (majorVer) {\n            case 2:\n                return 6;\n            case 3:\n            case 4:\n                return 10;\n            default:\n                throw new Error('header versionIndex is incorrect');\n        }\n    }\n    static readFrameFlags(b) {\n        return {\n            status: {\n                tag_alter_preservation: util.getBit(b, 0, 6),\n                file_alter_preservation: util.getBit(b, 0, 5),\n                read_only: util.getBit(b, 0, 4)\n            },\n            format: {\n                grouping_identity: util.getBit(b, 1, 7),\n                compression: util.getBit(b, 1, 3),\n                encryption: util.getBit(b, 1, 2),\n                unsynchronisation: util.getBit(b, 1, 1),\n                data_length_indicator: util.getBit(b, 1, 0)\n            }\n        };\n    }\n    static readFrameData(uint8Array, frameHeader, majorVer, includeCovers, warningCollector) {\n        const frameParser = new FrameParser_1.FrameParser(majorVer, warningCollector);\n        switch (majorVer) {\n            case 2:\n                return frameParser.readData(uint8Array, frameHeader.id, includeCovers);\n            case 3:\n            case 4:\n                if (frameHeader.flags.format.unsynchronisation) {\n                    uint8Array = ID3v2Parser.removeUnsyncBytes(uint8Array);\n                }\n                if (frameHeader.flags.format.data_length_indicator) {\n                    uint8Array = uint8Array.slice(4, uint8Array.length);\n                }\n                return frameParser.readData(uint8Array, frameHeader.id, includeCovers);\n            default:\n                throw new Error('Unexpected majorVer: ' + majorVer);\n        }\n    }\n    /**\n     * Create a combined tag key, of tag & description\n     * @param tag e.g.: COM\n     * @param description e.g. iTunPGAP\n     * @returns string e.g. COM:iTunPGAP\n     */\n    static makeDescriptionTagName(tag, description) {\n        return tag + (description ? ':' + description : '');\n    }\n    async parse(metadata, tokenizer, options) {\n        this.tokenizer = tokenizer;\n        this.metadata = metadata;\n        this.options = options;\n        const id3Header = await this.tokenizer.readToken(ID3v2Token_1.ID3v2Header);\n        if (id3Header.fileIdentifier !== 'ID3') {\n            throw new Error('expected ID3-header file-identifier \\'ID3\\' was not found');\n        }\n        this.id3Header = id3Header;\n        this.headerType = ('ID3v2.' + id3Header.version.major);\n        return id3Header.flags.isExtendedHeader ? this.parseExtendedHeader() : this.parseId3Data(id3Header.size);\n    }\n    async parseExtendedHeader() {\n        const extendedHeader = await this.tokenizer.readToken(ID3v2Token_1.ExtendedHeader);\n        const dataRemaining = extendedHeader.size - ID3v2Token_1.ExtendedHeader.len;\n        return dataRemaining > 0 ? this.parseExtendedHeaderData(dataRemaining, extendedHeader.size) : this.parseId3Data(this.id3Header.size - extendedHeader.size);\n    }\n    async parseExtendedHeaderData(dataRemaining, extendedHeaderSize) {\n        await this.tokenizer.ignore(dataRemaining);\n        return this.parseId3Data(this.id3Header.size - extendedHeaderSize);\n    }\n    async parseId3Data(dataLen) {\n        const uint8Array = await this.tokenizer.readToken(new Token.Uint8ArrayType(dataLen));\n        for (const tag of this.parseMetadata(uint8Array)) {\n            if (tag.id === 'TXXX') {\n                if (tag.value) {\n                    for (const text of tag.value.text) {\n                        this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, tag.value.description), text);\n                    }\n                }\n            }\n            else if (tag.id === 'COM') {\n                for (const value of tag.value) {\n                    this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, value.description), value.text);\n                }\n            }\n            else if (tag.id === 'COMM') {\n                for (const value of tag.value) {\n                    this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, value.description), value);\n                }\n            }\n            else if (Array.isArray(tag.value)) {\n                for (const value of tag.value) {\n                    this.addTag(tag.id, value);\n                }\n            }\n            else {\n                this.addTag(tag.id, tag.value);\n            }\n        }\n    }\n    addTag(id, value) {\n        this.metadata.addTag(this.headerType, id, value);\n    }\n    parseMetadata(data) {\n        let offset = 0;\n        const tags = [];\n        while (true) {\n            if (offset === data.length)\n                break;\n            const frameHeaderLength = ID3v2Parser.getFrameHeaderLength(this.id3Header.version.major);\n            if (offset + frameHeaderLength > data.length) {\n                this.metadata.addWarning('Illegal ID3v2 tag length');\n                break;\n            }\n            const frameHeaderBytes = data.slice(offset, offset += frameHeaderLength);\n            const frameHeader = this.readFrameHeader(frameHeaderBytes, this.id3Header.version.major);\n            const frameDataBytes = data.slice(offset, offset += frameHeader.length);\n            const values = ID3v2Parser.readFrameData(frameDataBytes, frameHeader, this.id3Header.version.major, !this.options.skipCovers, this.metadata);\n            if (values) {\n                tags.push({ id: frameHeader.id, value: values });\n            }\n        }\n        return tags;\n    }\n    readFrameHeader(uint8Array, majorVer) {\n        let header;\n        switch (majorVer) {\n            case 2:\n                header = {\n                    id: Buffer.from(uint8Array.slice(0, 3)).toString('ascii'),\n                    length: Token.UINT24_BE.get(uint8Array, 3)\n                };\n                if (!header.id.match(/[A-Z0-9]{3}/g)) {\n                    this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);\n                }\n                break;\n            case 3:\n            case 4:\n                header = {\n                    id: Buffer.from(uint8Array.slice(0, 4)).toString('ascii'),\n                    length: (majorVer === 4 ? ID3v2Token_1.UINT32SYNCSAFE : Token.UINT32_BE).get(uint8Array, 4),\n                    flags: ID3v2Parser.readFrameFlags(uint8Array.slice(8, 10))\n                };\n                if (!header.id.match(/[A-Z0-9]{4}/g)) {\n                    this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);\n                }\n                break;\n            default:\n                throw new Error('Unexpected majorVer: ' + majorVer);\n        }\n        return header;\n    }\n}\nexports.ID3v2Parser = ID3v2Parser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvaWQzdjIvSUQzdjJQYXJzZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixjQUFjLG1CQUFPLENBQUMsZ0ZBQWE7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLDRGQUFnQjtBQUNyQyxzQkFBc0IsbUJBQU8sQ0FBQyxpR0FBZTtBQUM3QyxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUNBQW1DO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRTtBQUNqRCw4REFBOEQsOEJBQThCLG1CQUFtQixVQUFVO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRTtBQUNqRCw4REFBOEQsOEJBQThCLG1CQUFtQixVQUFVO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9pZDN2Mi9JRDN2MlBhcnNlci5qcz9kY2U4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JRDN2MlBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuLi9jb21tb24vVXRpbFwiKTtcbmNvbnN0IEZyYW1lUGFyc2VyXzEgPSByZXF1aXJlKFwiLi9GcmFtZVBhcnNlclwiKTtcbmNvbnN0IElEM3YyVG9rZW5fMSA9IHJlcXVpcmUoXCIuL0lEM3YyVG9rZW5cIik7XG5jbGFzcyBJRDN2MlBhcnNlciB7XG4gICAgc3RhdGljIHJlbW92ZVVuc3luY0J5dGVzKGJ1ZmZlcikge1xuICAgICAgICBsZXQgcmVhZEkgPSAwO1xuICAgICAgICBsZXQgd3JpdGVJID0gMDtcbiAgICAgICAgd2hpbGUgKHJlYWRJIDwgYnVmZmVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGlmIChyZWFkSSAhPT0gd3JpdGVJKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW3dyaXRlSV0gPSBidWZmZXJbcmVhZEldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZEkgKz0gKGJ1ZmZlcltyZWFkSV0gPT09IDB4RkYgJiYgYnVmZmVyW3JlYWRJICsgMV0gPT09IDApID8gMiA6IDE7XG4gICAgICAgICAgICB3cml0ZUkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhZEkgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBidWZmZXJbd3JpdGVJKytdID0gYnVmZmVyW3JlYWRJXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIHdyaXRlSSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRGcmFtZUhlYWRlckxlbmd0aChtYWpvclZlcikge1xuICAgICAgICBzd2l0Y2ggKG1ham9yVmVyKSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hlYWRlciB2ZXJzaW9uSW5kZXggaXMgaW5jb3JyZWN0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHJlYWRGcmFtZUZsYWdzKGIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgIHRhZ19hbHRlcl9wcmVzZXJ2YXRpb246IHV0aWwuZ2V0Qml0KGIsIDAsIDYpLFxuICAgICAgICAgICAgICAgIGZpbGVfYWx0ZXJfcHJlc2VydmF0aW9uOiB1dGlsLmdldEJpdChiLCAwLCA1KSxcbiAgICAgICAgICAgICAgICByZWFkX29ubHk6IHV0aWwuZ2V0Qml0KGIsIDAsIDQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgZ3JvdXBpbmdfaWRlbnRpdHk6IHV0aWwuZ2V0Qml0KGIsIDEsIDcpLFxuICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uOiB1dGlsLmdldEJpdChiLCAxLCAzKSxcbiAgICAgICAgICAgICAgICBlbmNyeXB0aW9uOiB1dGlsLmdldEJpdChiLCAxLCAyKSxcbiAgICAgICAgICAgICAgICB1bnN5bmNocm9uaXNhdGlvbjogdXRpbC5nZXRCaXQoYiwgMSwgMSksXG4gICAgICAgICAgICAgICAgZGF0YV9sZW5ndGhfaW5kaWNhdG9yOiB1dGlsLmdldEJpdChiLCAxLCAwKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgcmVhZEZyYW1lRGF0YSh1aW50OEFycmF5LCBmcmFtZUhlYWRlciwgbWFqb3JWZXIsIGluY2x1ZGVDb3ZlcnMsIHdhcm5pbmdDb2xsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgZnJhbWVQYXJzZXIgPSBuZXcgRnJhbWVQYXJzZXJfMS5GcmFtZVBhcnNlcihtYWpvclZlciwgd2FybmluZ0NvbGxlY3Rvcik7XG4gICAgICAgIHN3aXRjaCAobWFqb3JWZXIpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWVQYXJzZXIucmVhZERhdGEodWludDhBcnJheSwgZnJhbWVIZWFkZXIuaWQsIGluY2x1ZGVDb3ZlcnMpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGlmIChmcmFtZUhlYWRlci5mbGFncy5mb3JtYXQudW5zeW5jaHJvbmlzYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdWludDhBcnJheSA9IElEM3YyUGFyc2VyLnJlbW92ZVVuc3luY0J5dGVzKHVpbnQ4QXJyYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZnJhbWVIZWFkZXIuZmxhZ3MuZm9ybWF0LmRhdGFfbGVuZ3RoX2luZGljYXRvcikge1xuICAgICAgICAgICAgICAgICAgICB1aW50OEFycmF5ID0gdWludDhBcnJheS5zbGljZSg0LCB1aW50OEFycmF5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZVBhcnNlci5yZWFkRGF0YSh1aW50OEFycmF5LCBmcmFtZUhlYWRlci5pZCwgaW5jbHVkZUNvdmVycyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBtYWpvclZlcjogJyArIG1ham9yVmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjb21iaW5lZCB0YWcga2V5LCBvZiB0YWcgJiBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSB0YWcgZS5nLjogQ09NXG4gICAgICogQHBhcmFtIGRlc2NyaXB0aW9uIGUuZy4gaVR1blBHQVBcbiAgICAgKiBAcmV0dXJucyBzdHJpbmcgZS5nLiBDT006aVR1blBHQVBcbiAgICAgKi9cbiAgICBzdGF0aWMgbWFrZURlc2NyaXB0aW9uVGFnTmFtZSh0YWcsIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJldHVybiB0YWcgKyAoZGVzY3JpcHRpb24gPyAnOicgKyBkZXNjcmlwdGlvbiA6ICcnKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2UobWV0YWRhdGEsIHRva2VuaXplciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnRva2VuaXplciA9IHRva2VuaXplcjtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBpZDNIZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oSUQzdjJUb2tlbl8xLklEM3YySGVhZGVyKTtcbiAgICAgICAgaWYgKGlkM0hlYWRlci5maWxlSWRlbnRpZmllciAhPT0gJ0lEMycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgSUQzLWhlYWRlciBmaWxlLWlkZW50aWZpZXIgXFwnSUQzXFwnIHdhcyBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkM0hlYWRlciA9IGlkM0hlYWRlcjtcbiAgICAgICAgdGhpcy5oZWFkZXJUeXBlID0gKCdJRDN2Mi4nICsgaWQzSGVhZGVyLnZlcnNpb24ubWFqb3IpO1xuICAgICAgICByZXR1cm4gaWQzSGVhZGVyLmZsYWdzLmlzRXh0ZW5kZWRIZWFkZXIgPyB0aGlzLnBhcnNlRXh0ZW5kZWRIZWFkZXIoKSA6IHRoaXMucGFyc2VJZDNEYXRhKGlkM0hlYWRlci5zaXplKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VFeHRlbmRlZEhlYWRlcigpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5kZWRIZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oSUQzdjJUb2tlbl8xLkV4dGVuZGVkSGVhZGVyKTtcbiAgICAgICAgY29uc3QgZGF0YVJlbWFpbmluZyA9IGV4dGVuZGVkSGVhZGVyLnNpemUgLSBJRDN2MlRva2VuXzEuRXh0ZW5kZWRIZWFkZXIubGVuO1xuICAgICAgICByZXR1cm4gZGF0YVJlbWFpbmluZyA+IDAgPyB0aGlzLnBhcnNlRXh0ZW5kZWRIZWFkZXJEYXRhKGRhdGFSZW1haW5pbmcsIGV4dGVuZGVkSGVhZGVyLnNpemUpIDogdGhpcy5wYXJzZUlkM0RhdGEodGhpcy5pZDNIZWFkZXIuc2l6ZSAtIGV4dGVuZGVkSGVhZGVyLnNpemUpO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZUV4dGVuZGVkSGVhZGVyRGF0YShkYXRhUmVtYWluaW5nLCBleHRlbmRlZEhlYWRlclNpemUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKGRhdGFSZW1haW5pbmcpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUlkM0RhdGEodGhpcy5pZDNIZWFkZXIuc2l6ZSAtIGV4dGVuZGVkSGVhZGVyU2l6ZSk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlSWQzRGF0YShkYXRhTGVuKSB7XG4gICAgICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IFRva2VuLlVpbnQ4QXJyYXlUeXBlKGRhdGFMZW4pKTtcbiAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy5wYXJzZU1ldGFkYXRhKHVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICBpZiAodGFnLmlkID09PSAnVFhYWCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGV4dCBvZiB0YWcudmFsdWUudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUYWcoSUQzdjJQYXJzZXIubWFrZURlc2NyaXB0aW9uVGFnTmFtZSh0YWcuaWQsIHRhZy52YWx1ZS5kZXNjcmlwdGlvbiksIHRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGFnLmlkID09PSAnQ09NJykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGFnLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFnKElEM3YyUGFyc2VyLm1ha2VEZXNjcmlwdGlvblRhZ05hbWUodGFnLmlkLCB2YWx1ZS5kZXNjcmlwdGlvbiksIHZhbHVlLnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRhZy5pZCA9PT0gJ0NPTU0nKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0YWcudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUYWcoSUQzdjJQYXJzZXIubWFrZURlc2NyaXB0aW9uVGFnTmFtZSh0YWcuaWQsIHZhbHVlLmRlc2NyaXB0aW9uKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGFnLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGFnLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFnKHRhZy5pZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFnKHRhZy5pZCwgdGFnLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRUYWcoaWQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuYWRkVGFnKHRoaXMuaGVhZGVyVHlwZSwgaWQsIHZhbHVlKTtcbiAgICB9XG4gICAgcGFyc2VNZXRhZGF0YShkYXRhKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCB0YWdzID0gW107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBkYXRhLmxlbmd0aClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lSGVhZGVyTGVuZ3RoID0gSUQzdjJQYXJzZXIuZ2V0RnJhbWVIZWFkZXJMZW5ndGgodGhpcy5pZDNIZWFkZXIudmVyc2lvbi5tYWpvcik7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICsgZnJhbWVIZWFkZXJMZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuYWRkV2FybmluZygnSWxsZWdhbCBJRDN2MiB0YWcgbGVuZ3RoJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmcmFtZUhlYWRlckJ5dGVzID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArPSBmcmFtZUhlYWRlckxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBmcmFtZUhlYWRlciA9IHRoaXMucmVhZEZyYW1lSGVhZGVyKGZyYW1lSGVhZGVyQnl0ZXMsIHRoaXMuaWQzSGVhZGVyLnZlcnNpb24ubWFqb3IpO1xuICAgICAgICAgICAgY29uc3QgZnJhbWVEYXRhQnl0ZXMgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICs9IGZyYW1lSGVhZGVyLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBJRDN2MlBhcnNlci5yZWFkRnJhbWVEYXRhKGZyYW1lRGF0YUJ5dGVzLCBmcmFtZUhlYWRlciwgdGhpcy5pZDNIZWFkZXIudmVyc2lvbi5tYWpvciwgIXRoaXMub3B0aW9ucy5za2lwQ292ZXJzLCB0aGlzLm1ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB0YWdzLnB1c2goeyBpZDogZnJhbWVIZWFkZXIuaWQsIHZhbHVlOiB2YWx1ZXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ3M7XG4gICAgfVxuICAgIHJlYWRGcmFtZUhlYWRlcih1aW50OEFycmF5LCBtYWpvclZlcikge1xuICAgICAgICBsZXQgaGVhZGVyO1xuICAgICAgICBzd2l0Y2ggKG1ham9yVmVyKSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaGVhZGVyID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogQnVmZmVyLmZyb20odWludDhBcnJheS5zbGljZSgwLCAzKSkudG9TdHJpbmcoJ2FzY2lpJyksXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogVG9rZW4uVUlOVDI0X0JFLmdldCh1aW50OEFycmF5LCAzKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkZXIuaWQubWF0Y2goL1tBLVowLTldezN9L2cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuYWRkV2FybmluZyhgSW52YWxpZCBJRDN2Mi4ke3RoaXMuaWQzSGVhZGVyLnZlcnNpb24ubWFqb3J9IGZyYW1lLWhlYWRlci1JRDogJHtoZWFkZXIuaWR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGhlYWRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IEJ1ZmZlci5mcm9tKHVpbnQ4QXJyYXkuc2xpY2UoMCwgNCkpLnRvU3RyaW5nKCdhc2NpaScpLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IChtYWpvclZlciA9PT0gNCA/IElEM3YyVG9rZW5fMS5VSU5UMzJTWU5DU0FGRSA6IFRva2VuLlVJTlQzMl9CRSkuZ2V0KHVpbnQ4QXJyYXksIDQpLFxuICAgICAgICAgICAgICAgICAgICBmbGFnczogSUQzdjJQYXJzZXIucmVhZEZyYW1lRmxhZ3ModWludDhBcnJheS5zbGljZSg4LCAxMCkpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIWhlYWRlci5pZC5tYXRjaCgvW0EtWjAtOV17NH0vZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRXYXJuaW5nKGBJbnZhbGlkIElEM3YyLiR7dGhpcy5pZDNIZWFkZXIudmVyc2lvbi5tYWpvcn0gZnJhbWUtaGVhZGVyLUlEOiAke2hlYWRlci5pZH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBtYWpvclZlcjogJyArIG1ham9yVmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVyO1xuICAgIH1cbn1cbmV4cG9ydHMuSUQzdjJQYXJzZXIgPSBJRDN2MlBhcnNlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v2Token.js":
/*!*************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v2/ID3v2Token.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextEncodingToken = exports.ExtendedHeader = exports.ID3v2Header = exports.UINT32SYNCSAFE = exports.AttachedPictureType = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst util = __webpack_require__(/*! ../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\n/**\n * The picture type according to the ID3v2 APIC frame\n * Ref: http://id3.org/id3v2.3.0#Attached_picture\n */\nvar AttachedPictureType;\n(function (AttachedPictureType) {\n    AttachedPictureType[AttachedPictureType[\"Other\"] = 0] = \"Other\";\n    AttachedPictureType[AttachedPictureType[\"32x32 pixels 'file icon' (PNG only)\"] = 1] = \"32x32 pixels 'file icon' (PNG only)\";\n    AttachedPictureType[AttachedPictureType[\"Other file icon\"] = 2] = \"Other file icon\";\n    AttachedPictureType[AttachedPictureType[\"Cover (front)\"] = 3] = \"Cover (front)\";\n    AttachedPictureType[AttachedPictureType[\"Cover (back)\"] = 4] = \"Cover (back)\";\n    AttachedPictureType[AttachedPictureType[\"Leaflet page\"] = 5] = \"Leaflet page\";\n    AttachedPictureType[AttachedPictureType[\"Media (e.g. label side of CD)\"] = 6] = \"Media (e.g. label side of CD)\";\n    AttachedPictureType[AttachedPictureType[\"Lead artist/lead performer/soloist\"] = 7] = \"Lead artist/lead performer/soloist\";\n    AttachedPictureType[AttachedPictureType[\"Artist/performer\"] = 8] = \"Artist/performer\";\n    AttachedPictureType[AttachedPictureType[\"Conductor\"] = 9] = \"Conductor\";\n    AttachedPictureType[AttachedPictureType[\"Band/Orchestra\"] = 10] = \"Band/Orchestra\";\n    AttachedPictureType[AttachedPictureType[\"Composer\"] = 11] = \"Composer\";\n    AttachedPictureType[AttachedPictureType[\"Lyricist/text writer\"] = 12] = \"Lyricist/text writer\";\n    AttachedPictureType[AttachedPictureType[\"Recording Location\"] = 13] = \"Recording Location\";\n    AttachedPictureType[AttachedPictureType[\"During recording\"] = 14] = \"During recording\";\n    AttachedPictureType[AttachedPictureType[\"During performance\"] = 15] = \"During performance\";\n    AttachedPictureType[AttachedPictureType[\"Movie/video screen capture\"] = 16] = \"Movie/video screen capture\";\n    AttachedPictureType[AttachedPictureType[\"A bright coloured fish\"] = 17] = \"A bright coloured fish\";\n    AttachedPictureType[AttachedPictureType[\"Illustration\"] = 18] = \"Illustration\";\n    AttachedPictureType[AttachedPictureType[\"Band/artist logotype\"] = 19] = \"Band/artist logotype\";\n    AttachedPictureType[AttachedPictureType[\"Publisher/Studio logotype\"] = 20] = \"Publisher/Studio logotype\";\n})(AttachedPictureType = exports.AttachedPictureType || (exports.AttachedPictureType = {}));\n/**\n * 28 bits (representing up to 256MB) integer, the msb is 0 to avoid 'false syncsignals'.\n * 4 * %0xxxxxxx\n */\nexports.UINT32SYNCSAFE = {\n    get: (buf, off) => {\n        return buf[off + 3] & 0x7f | ((buf[off + 2]) << 7) |\n            ((buf[off + 1]) << 14) | ((buf[off]) << 21);\n    },\n    len: 4\n};\n/**\n * ID3v2 header\n * Ref: http://id3.org/id3v2.3.0#ID3v2_header\n * ToDo\n */\nexports.ID3v2Header = {\n    len: 10,\n    get: (buf, off) => {\n        return {\n            // ID3v2/file identifier   \"ID3\"\n            fileIdentifier: new Token.StringType(3, 'ascii').get(buf, off),\n            // ID3v2 versionIndex\n            version: {\n                major: Token.INT8.get(buf, off + 3),\n                revision: Token.INT8.get(buf, off + 4)\n            },\n            // ID3v2 flags\n            flags: {\n                // Unsynchronisation\n                unsynchronisation: util.getBit(buf, off + 5, 7),\n                // Extended header\n                isExtendedHeader: util.getBit(buf, off + 5, 6),\n                // Experimental indicator\n                expIndicator: util.getBit(buf, off + 5, 5),\n                footer: util.getBit(buf, off + 5, 4)\n            },\n            size: exports.UINT32SYNCSAFE.get(buf, off + 6)\n        };\n    }\n};\nexports.ExtendedHeader = {\n    len: 10,\n    get: (buf, off) => {\n        return {\n            // Extended header size\n            size: Token.UINT32_BE.get(buf, off),\n            // Extended Flags\n            extendedFlags: Token.UINT16_BE.get(buf, off + 4),\n            // Size of padding\n            sizeOfPadding: Token.UINT32_BE.get(buf, off + 6),\n            // CRC data present\n            crcDataPresent: util.getBit(buf, off + 4, 31)\n        };\n    }\n};\nexports.TextEncodingToken = {\n    len: 1,\n    get: (uint8Array, off) => {\n        switch (uint8Array[off]) {\n            case 0x00:\n                return { encoding: 'latin1' }; // binary\n            case 0x01:\n                return { encoding: 'utf16le', bom: true };\n            case 0x02:\n                return { encoding: 'utf16le', bom: false };\n            case 0x03:\n                return { encoding: 'utf8', bom: false };\n            default:\n                return { encoding: 'utf8', bom: false };\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvaWQzdjIvSUQzdjJUb2tlbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRyxzQkFBc0IsR0FBRywyQkFBMkI7QUFDL0gsY0FBYyxtQkFBTyxDQUFDLGdGQUFhO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyw0RkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3REFBd0QsMkJBQTJCLEtBQUs7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvaWQzdjIvSUQzdjJUb2tlbi5qcz8zNTkzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UZXh0RW5jb2RpbmdUb2tlbiA9IGV4cG9ydHMuRXh0ZW5kZWRIZWFkZXIgPSBleHBvcnRzLklEM3YySGVhZGVyID0gZXhwb3J0cy5VSU5UMzJTWU5DU0FGRSA9IGV4cG9ydHMuQXR0YWNoZWRQaWN0dXJlVHlwZSA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuLi9jb21tb24vVXRpbFwiKTtcbi8qKlxuICogVGhlIHBpY3R1cmUgdHlwZSBhY2NvcmRpbmcgdG8gdGhlIElEM3YyIEFQSUMgZnJhbWVcbiAqIFJlZjogaHR0cDovL2lkMy5vcmcvaWQzdjIuMy4wI0F0dGFjaGVkX3BpY3R1cmVcbiAqL1xudmFyIEF0dGFjaGVkUGljdHVyZVR5cGU7XG4oZnVuY3Rpb24gKEF0dGFjaGVkUGljdHVyZVR5cGUpIHtcbiAgICBBdHRhY2hlZFBpY3R1cmVUeXBlW0F0dGFjaGVkUGljdHVyZVR5cGVbXCJPdGhlclwiXSA9IDBdID0gXCJPdGhlclwiO1xuICAgIEF0dGFjaGVkUGljdHVyZVR5cGVbQXR0YWNoZWRQaWN0dXJlVHlwZVtcIjMyeDMyIHBpeGVscyAnZmlsZSBpY29uJyAoUE5HIG9ubHkpXCJdID0gMV0gPSBcIjMyeDMyIHBpeGVscyAnZmlsZSBpY29uJyAoUE5HIG9ubHkpXCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiT3RoZXIgZmlsZSBpY29uXCJdID0gMl0gPSBcIk90aGVyIGZpbGUgaWNvblwiO1xuICAgIEF0dGFjaGVkUGljdHVyZVR5cGVbQXR0YWNoZWRQaWN0dXJlVHlwZVtcIkNvdmVyIChmcm9udClcIl0gPSAzXSA9IFwiQ292ZXIgKGZyb250KVwiO1xuICAgIEF0dGFjaGVkUGljdHVyZVR5cGVbQXR0YWNoZWRQaWN0dXJlVHlwZVtcIkNvdmVyIChiYWNrKVwiXSA9IDRdID0gXCJDb3ZlciAoYmFjaylcIjtcbiAgICBBdHRhY2hlZFBpY3R1cmVUeXBlW0F0dGFjaGVkUGljdHVyZVR5cGVbXCJMZWFmbGV0IHBhZ2VcIl0gPSA1XSA9IFwiTGVhZmxldCBwYWdlXCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiTWVkaWEgKGUuZy4gbGFiZWwgc2lkZSBvZiBDRClcIl0gPSA2XSA9IFwiTWVkaWEgKGUuZy4gbGFiZWwgc2lkZSBvZiBDRClcIjtcbiAgICBBdHRhY2hlZFBpY3R1cmVUeXBlW0F0dGFjaGVkUGljdHVyZVR5cGVbXCJMZWFkIGFydGlzdC9sZWFkIHBlcmZvcm1lci9zb2xvaXN0XCJdID0gN10gPSBcIkxlYWQgYXJ0aXN0L2xlYWQgcGVyZm9ybWVyL3NvbG9pc3RcIjtcbiAgICBBdHRhY2hlZFBpY3R1cmVUeXBlW0F0dGFjaGVkUGljdHVyZVR5cGVbXCJBcnRpc3QvcGVyZm9ybWVyXCJdID0gOF0gPSBcIkFydGlzdC9wZXJmb3JtZXJcIjtcbiAgICBBdHRhY2hlZFBpY3R1cmVUeXBlW0F0dGFjaGVkUGljdHVyZVR5cGVbXCJDb25kdWN0b3JcIl0gPSA5XSA9IFwiQ29uZHVjdG9yXCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiQmFuZC9PcmNoZXN0cmFcIl0gPSAxMF0gPSBcIkJhbmQvT3JjaGVzdHJhXCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiQ29tcG9zZXJcIl0gPSAxMV0gPSBcIkNvbXBvc2VyXCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiTHlyaWNpc3QvdGV4dCB3cml0ZXJcIl0gPSAxMl0gPSBcIkx5cmljaXN0L3RleHQgd3JpdGVyXCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiUmVjb3JkaW5nIExvY2F0aW9uXCJdID0gMTNdID0gXCJSZWNvcmRpbmcgTG9jYXRpb25cIjtcbiAgICBBdHRhY2hlZFBpY3R1cmVUeXBlW0F0dGFjaGVkUGljdHVyZVR5cGVbXCJEdXJpbmcgcmVjb3JkaW5nXCJdID0gMTRdID0gXCJEdXJpbmcgcmVjb3JkaW5nXCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiRHVyaW5nIHBlcmZvcm1hbmNlXCJdID0gMTVdID0gXCJEdXJpbmcgcGVyZm9ybWFuY2VcIjtcbiAgICBBdHRhY2hlZFBpY3R1cmVUeXBlW0F0dGFjaGVkUGljdHVyZVR5cGVbXCJNb3ZpZS92aWRlbyBzY3JlZW4gY2FwdHVyZVwiXSA9IDE2XSA9IFwiTW92aWUvdmlkZW8gc2NyZWVuIGNhcHR1cmVcIjtcbiAgICBBdHRhY2hlZFBpY3R1cmVUeXBlW0F0dGFjaGVkUGljdHVyZVR5cGVbXCJBIGJyaWdodCBjb2xvdXJlZCBmaXNoXCJdID0gMTddID0gXCJBIGJyaWdodCBjb2xvdXJlZCBmaXNoXCI7XG4gICAgQXR0YWNoZWRQaWN0dXJlVHlwZVtBdHRhY2hlZFBpY3R1cmVUeXBlW1wiSWxsdXN0cmF0aW9uXCJdID0gMThdID0gXCJJbGx1c3RyYXRpb25cIjtcbiAgICBBdHRhY2hlZFBpY3R1cmVUeXBlW0F0dGFjaGVkUGljdHVyZVR5cGVbXCJCYW5kL2FydGlzdCBsb2dvdHlwZVwiXSA9IDE5XSA9IFwiQmFuZC9hcnRpc3QgbG9nb3R5cGVcIjtcbiAgICBBdHRhY2hlZFBpY3R1cmVUeXBlW0F0dGFjaGVkUGljdHVyZVR5cGVbXCJQdWJsaXNoZXIvU3R1ZGlvIGxvZ290eXBlXCJdID0gMjBdID0gXCJQdWJsaXNoZXIvU3R1ZGlvIGxvZ290eXBlXCI7XG59KShBdHRhY2hlZFBpY3R1cmVUeXBlID0gZXhwb3J0cy5BdHRhY2hlZFBpY3R1cmVUeXBlIHx8IChleHBvcnRzLkF0dGFjaGVkUGljdHVyZVR5cGUgPSB7fSkpO1xuLyoqXG4gKiAyOCBiaXRzIChyZXByZXNlbnRpbmcgdXAgdG8gMjU2TUIpIGludGVnZXIsIHRoZSBtc2IgaXMgMCB0byBhdm9pZCAnZmFsc2Ugc3luY3NpZ25hbHMnLlxuICogNCAqICUweHh4eHh4eFxuICovXG5leHBvcnRzLlVJTlQzMlNZTkNTQUZFID0ge1xuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiBidWZbb2ZmICsgM10gJiAweDdmIHwgKChidWZbb2ZmICsgMl0pIDw8IDcpIHxcbiAgICAgICAgICAgICgoYnVmW29mZiArIDFdKSA8PCAxNCkgfCAoKGJ1ZltvZmZdKSA8PCAyMSk7XG4gICAgfSxcbiAgICBsZW46IDRcbn07XG4vKipcbiAqIElEM3YyIGhlYWRlclxuICogUmVmOiBodHRwOi8vaWQzLm9yZy9pZDN2Mi4zLjAjSUQzdjJfaGVhZGVyXG4gKiBUb0RvXG4gKi9cbmV4cG9ydHMuSUQzdjJIZWFkZXIgPSB7XG4gICAgbGVuOiAxMCxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gSUQzdjIvZmlsZSBpZGVudGlmaWVyICAgXCJJRDNcIlxuICAgICAgICAgICAgZmlsZUlkZW50aWZpZXI6IG5ldyBUb2tlbi5TdHJpbmdUeXBlKDMsICdhc2NpaScpLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICAvLyBJRDN2MiB2ZXJzaW9uSW5kZXhcbiAgICAgICAgICAgIHZlcnNpb246IHtcbiAgICAgICAgICAgICAgICBtYWpvcjogVG9rZW4uSU5UOC5nZXQoYnVmLCBvZmYgKyAzKSxcbiAgICAgICAgICAgICAgICByZXZpc2lvbjogVG9rZW4uSU5UOC5nZXQoYnVmLCBvZmYgKyA0KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIElEM3YyIGZsYWdzXG4gICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICAgIC8vIFVuc3luY2hyb25pc2F0aW9uXG4gICAgICAgICAgICAgICAgdW5zeW5jaHJvbmlzYXRpb246IHV0aWwuZ2V0Qml0KGJ1Ziwgb2ZmICsgNSwgNyksXG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kZWQgaGVhZGVyXG4gICAgICAgICAgICAgICAgaXNFeHRlbmRlZEhlYWRlcjogdXRpbC5nZXRCaXQoYnVmLCBvZmYgKyA1LCA2KSxcbiAgICAgICAgICAgICAgICAvLyBFeHBlcmltZW50YWwgaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgZXhwSW5kaWNhdG9yOiB1dGlsLmdldEJpdChidWYsIG9mZiArIDUsIDUpLFxuICAgICAgICAgICAgICAgIGZvb3RlcjogdXRpbC5nZXRCaXQoYnVmLCBvZmYgKyA1LCA0KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpemU6IGV4cG9ydHMuVUlOVDMyU1lOQ1NBRkUuZ2V0KGJ1Ziwgb2ZmICsgNilcbiAgICAgICAgfTtcbiAgICB9XG59O1xuZXhwb3J0cy5FeHRlbmRlZEhlYWRlciA9IHtcbiAgICBsZW46IDEwLFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBFeHRlbmRlZCBoZWFkZXIgc2l6ZVxuICAgICAgICAgICAgc2l6ZTogVG9rZW4uVUlOVDMyX0JFLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICAvLyBFeHRlbmRlZCBGbGFnc1xuICAgICAgICAgICAgZXh0ZW5kZWRGbGFnczogVG9rZW4uVUlOVDE2X0JFLmdldChidWYsIG9mZiArIDQpLFxuICAgICAgICAgICAgLy8gU2l6ZSBvZiBwYWRkaW5nXG4gICAgICAgICAgICBzaXplT2ZQYWRkaW5nOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgNiksXG4gICAgICAgICAgICAvLyBDUkMgZGF0YSBwcmVzZW50XG4gICAgICAgICAgICBjcmNEYXRhUHJlc2VudDogdXRpbC5nZXRCaXQoYnVmLCBvZmYgKyA0LCAzMSlcbiAgICAgICAgfTtcbiAgICB9XG59O1xuZXhwb3J0cy5UZXh0RW5jb2RpbmdUb2tlbiA9IHtcbiAgICBsZW46IDEsXG4gICAgZ2V0OiAodWludDhBcnJheSwgb2ZmKSA9PiB7XG4gICAgICAgIHN3aXRjaCAodWludDhBcnJheVtvZmZdKSB7XG4gICAgICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZW5jb2Rpbmc6ICdsYXRpbjEnIH07IC8vIGJpbmFyeVxuICAgICAgICAgICAgY2FzZSAweDAxOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IGVuY29kaW5nOiAndXRmMTZsZScsIGJvbTogdHJ1ZSB9O1xuICAgICAgICAgICAgY2FzZSAweDAyOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IGVuY29kaW5nOiAndXRmMTZsZScsIGJvbTogZmFsc2UgfTtcbiAgICAgICAgICAgIGNhc2UgMHgwMzpcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlbmNvZGluZzogJ3V0ZjgnLCBib206IGZhbHNlIH07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB7IGVuY29kaW5nOiAndXRmOCcsIGJvbTogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v2Token.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/iff/index.js":
/*!******************************************************!*\
  !*** ./node_modules/music-metadata/lib/iff/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Header = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/FourCC.js\");\n/**\n * Common AIFF chunk header\n */\nexports.Header = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            // Chunk type ID\n            chunkID: FourCC_1.FourCcToken.get(buf, off),\n            // Chunk size\n            chunkSize: Number(BigInt(Token.UINT32_BE.get(buf, off + 4)))\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvaWZmL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxjQUFjLG1CQUFPLENBQUMsZ0ZBQWE7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsZ0dBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL2lmZi9pbmRleC5qcz8yYWQ0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IZWFkZXIgPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IEZvdXJDQ18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Gb3VyQ0NcIik7XG4vKipcbiAqIENvbW1vbiBBSUZGIGNodW5rIGhlYWRlclxuICovXG5leHBvcnRzLkhlYWRlciA9IHtcbiAgICBsZW46IDgsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIENodW5rIHR5cGUgSURcbiAgICAgICAgICAgIGNodW5rSUQ6IEZvdXJDQ18xLkZvdXJDY1Rva2VuLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICAvLyBDaHVuayBzaXplXG4gICAgICAgICAgICBjaHVua1NpemU6IE51bWJlcihCaWdJbnQoVG9rZW4uVUlOVDMyX0JFLmdldChidWYsIG9mZiArIDQpKSlcbiAgICAgICAgfTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/iff/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/lyrics3/Lyrics3.js":
/*!************************************************************!*\
  !*** ./node_modules/music-metadata/lib/lyrics3/Lyrics3.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getLyricsHeaderLength = exports.endTag2 = void 0;\nexports.endTag2 = 'LYRICS200';\nasync function getLyricsHeaderLength(reader) {\n    if (reader.fileSize >= 143) {\n        const buf = Buffer.alloc(15);\n        await reader.randomRead(buf, 0, buf.length, reader.fileSize - 143);\n        const txt = buf.toString('binary');\n        const tag = txt.substr(6);\n        if (tag === exports.endTag2) {\n            return parseInt(txt.substr(0, 6), 10) + 15;\n        }\n    }\n    return 0;\n}\nexports.getLyricsHeaderLength = getLyricsHeaderLength;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbHlyaWNzMy9MeXJpY3MzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxlQUFlO0FBQy9DLGVBQWU7QUFDZjtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbHlyaWNzMy9MeXJpY3MzLmpzP2VmNDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEx5cmljc0hlYWRlckxlbmd0aCA9IGV4cG9ydHMuZW5kVGFnMiA9IHZvaWQgMDtcbmV4cG9ydHMuZW5kVGFnMiA9ICdMWVJJQ1MyMDAnO1xuYXN5bmMgZnVuY3Rpb24gZ2V0THlyaWNzSGVhZGVyTGVuZ3RoKHJlYWRlcikge1xuICAgIGlmIChyZWFkZXIuZmlsZVNpemUgPj0gMTQzKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYygxNSk7XG4gICAgICAgIGF3YWl0IHJlYWRlci5yYW5kb21SZWFkKGJ1ZiwgMCwgYnVmLmxlbmd0aCwgcmVhZGVyLmZpbGVTaXplIC0gMTQzKTtcbiAgICAgICAgY29uc3QgdHh0ID0gYnVmLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgICAgY29uc3QgdGFnID0gdHh0LnN1YnN0cig2KTtcbiAgICAgICAgaWYgKHRhZyA9PT0gZXhwb3J0cy5lbmRUYWcyKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodHh0LnN1YnN0cigwLCA2KSwgMTApICsgMTU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5leHBvcnRzLmdldEx5cmljc0hlYWRlckxlbmd0aCA9IGdldEx5cmljc0hlYWRlckxlbmd0aDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/lyrics3/Lyrics3.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/matroska/MatroskaDtd.js":
/*!*****************************************************************!*\
  !*** ./node_modules/music-metadata/lib/matroska/MatroskaDtd.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.elements = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"(app-pages-browser)/./node_modules/music-metadata/lib/matroska/types.js\");\n/**\n * Elements of document type description\n * Derived from https://github.com/tungol/EBML/blob/master/doctypes/matroska.dtd\n * Extended with:\n * - https://www.matroska.org/technical/specs/index.html\n */\nexports.elements = {\n    0x1a45dfa3: {\n        name: 'ebml',\n        container: {\n            0x4286: { name: 'ebmlVersion', value: types_1.DataType.uint },\n            0x42f7: { name: 'ebmlReadVersion', value: types_1.DataType.uint },\n            0x42f2: { name: 'ebmlMaxIDWidth', value: types_1.DataType.uint },\n            0x42f3: { name: 'ebmlMaxSizeWidth', value: types_1.DataType.uint },\n            0x4282: { name: 'docType', value: types_1.DataType.string },\n            0x4287: { name: 'docTypeVersion', value: types_1.DataType.uint },\n            0x4285: { name: 'docTypeReadVersion', value: types_1.DataType.uint } // 5.1.7\n        }\n    },\n    // Matroska segments\n    0x18538067: {\n        name: 'segment',\n        container: {\n            // Meta Seek Information\n            0x114d9b74: {\n                name: 'seekHead',\n                container: {\n                    0x4dbb: {\n                        name: 'seek',\n                        container: {\n                            0x53ab: { name: 'seekId', value: types_1.DataType.binary },\n                            0x53ac: { name: 'seekPosition', value: types_1.DataType.uint }\n                        }\n                    }\n                }\n            },\n            // Segment Information\n            0x1549a966: {\n                name: 'info',\n                container: {\n                    0x73a4: { name: 'uid', value: types_1.DataType.uid },\n                    0x7384: { name: 'filename', value: types_1.DataType.string },\n                    0x3cb923: { name: 'prevUID', value: types_1.DataType.uid },\n                    0x3c83ab: { name: 'prevFilename', value: types_1.DataType.string },\n                    0x3eb923: { name: 'nextUID', value: types_1.DataType.uid },\n                    0x3e83bb: { name: 'nextFilename', value: types_1.DataType.string },\n                    0x2ad7b1: { name: 'timecodeScale', value: types_1.DataType.uint },\n                    0x4489: { name: 'duration', value: types_1.DataType.float },\n                    0x4461: { name: 'dateUTC', value: types_1.DataType.uint },\n                    0x7ba9: { name: 'title', value: types_1.DataType.string },\n                    0x4d80: { name: 'muxingApp', value: types_1.DataType.string },\n                    0x5741: { name: 'writingApp', value: types_1.DataType.string }\n                }\n            },\n            // Cluster\n            0x1f43b675: {\n                name: 'cluster',\n                multiple: true,\n                container: {\n                    0xe7: { name: 'timecode', value: types_1.DataType.uid },\n                    0xa3: { name: 'unknown', value: types_1.DataType.binary },\n                    0xa7: { name: 'position', value: types_1.DataType.uid },\n                    0xab: { name: 'prevSize', value: types_1.DataType.uid }\n                }\n            },\n            // Track\n            0x1654ae6b: {\n                name: 'tracks',\n                container: {\n                    0xae: {\n                        name: 'entries',\n                        multiple: true,\n                        container: {\n                            0xd7: { name: 'trackNumber', value: types_1.DataType.uint },\n                            0x73c5: { name: 'uid', value: types_1.DataType.uid },\n                            0x83: { name: 'trackType', value: types_1.DataType.uint },\n                            0xb9: { name: 'flagEnabled', value: types_1.DataType.bool },\n                            0x88: { name: 'flagDefault', value: types_1.DataType.bool },\n                            0x55aa: { name: 'flagForced', value: types_1.DataType.bool },\n                            0x9c: { name: 'flagLacing', value: types_1.DataType.bool },\n                            0x6de7: { name: 'minCache', value: types_1.DataType.uint },\n                            0x6de8: { name: 'maxCache', value: types_1.DataType.uint },\n                            0x23e383: { name: 'defaultDuration', value: types_1.DataType.uint },\n                            0x23314f: { name: 'timecodeScale', value: types_1.DataType.float },\n                            0x536e: { name: 'name', value: types_1.DataType.string },\n                            0x22b59c: { name: 'language', value: types_1.DataType.string },\n                            0x86: { name: 'codecID', value: types_1.DataType.string },\n                            0x63a2: { name: 'codecPrivate', value: types_1.DataType.binary },\n                            0x258688: { name: 'codecName', value: types_1.DataType.string },\n                            0x3a9697: { name: 'codecSettings', value: types_1.DataType.string },\n                            0x3b4040: { name: 'codecInfoUrl', value: types_1.DataType.string },\n                            0x26b240: { name: 'codecDownloadUrl', value: types_1.DataType.string },\n                            0xaa: { name: 'codecDecodeAll', value: types_1.DataType.bool },\n                            0x6fab: { name: 'trackOverlay', value: types_1.DataType.uint },\n                            // Video\n                            0xe0: {\n                                name: 'video',\n                                container: {\n                                    0x9a: { name: 'flagInterlaced', value: types_1.DataType.bool },\n                                    0x53b8: { name: 'stereoMode', value: types_1.DataType.uint },\n                                    0xb0: { name: 'pixelWidth', value: types_1.DataType.uint },\n                                    0xba: { name: 'pixelHeight', value: types_1.DataType.uint },\n                                    0x54b0: { name: 'displayWidth', value: types_1.DataType.uint },\n                                    0x54ba: { name: 'displayHeight', value: types_1.DataType.uint },\n                                    0x54b3: { name: 'aspectRatioType', value: types_1.DataType.uint },\n                                    0x2eb524: { name: 'colourSpace', value: types_1.DataType.uint },\n                                    0x2fb523: { name: 'gammaValue', value: types_1.DataType.float }\n                                }\n                            },\n                            // Audio\n                            0xe1: {\n                                name: 'audio',\n                                container: {\n                                    0xb5: { name: 'samplingFrequency', value: types_1.DataType.float },\n                                    0x78b5: { name: 'outputSamplingFrequency', value: types_1.DataType.float },\n                                    0x9f: { name: 'channels', value: types_1.DataType.uint },\n                                    0x94: { name: 'channels', value: types_1.DataType.uint },\n                                    0x7d7b: { name: 'channelPositions', value: types_1.DataType.binary },\n                                    0x6264: { name: 'bitDepth', value: types_1.DataType.uint }\n                                }\n                            },\n                            // Content Encoding\n                            0x6d80: {\n                                name: 'contentEncodings',\n                                container: {\n                                    0x6240: {\n                                        name: 'contentEncoding',\n                                        container: {\n                                            0x5031: { name: 'order', value: types_1.DataType.uint },\n                                            0x5032: { name: 'scope', value: types_1.DataType.bool },\n                                            0x5033: { name: 'type', value: types_1.DataType.uint },\n                                            0x5034: {\n                                                name: 'contentEncoding',\n                                                container: {\n                                                    0x4254: { name: 'contentCompAlgo', value: types_1.DataType.uint },\n                                                    0x4255: { name: 'contentCompSettings', value: types_1.DataType.binary }\n                                                }\n                                            },\n                                            0x5035: {\n                                                name: 'contentEncoding',\n                                                container: {\n                                                    0x47e1: { name: 'contentEncAlgo', value: types_1.DataType.uint },\n                                                    0x47e2: { name: 'contentEncKeyID', value: types_1.DataType.binary },\n                                                    0x47e3: { name: 'contentSignature ', value: types_1.DataType.binary },\n                                                    0x47e4: { name: 'ContentSigKeyID  ', value: types_1.DataType.binary },\n                                                    0x47e5: { name: 'contentSigAlgo ', value: types_1.DataType.uint },\n                                                    0x47e6: { name: 'contentSigHashAlgo ', value: types_1.DataType.uint }\n                                                }\n                                            },\n                                            0x6264: { name: 'bitDepth', value: types_1.DataType.uint }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            // Cueing Data\n            0x1c53bb6b: {\n                name: 'cues',\n                container: {\n                    0xbb: {\n                        name: 'cuePoint',\n                        container: {\n                            0xb3: { name: 'cueTime', value: types_1.DataType.uid },\n                            0xb7: {\n                                name: 'positions',\n                                container: {\n                                    0xf7: { name: 'track', value: types_1.DataType.uint },\n                                    0xf1: { name: 'clusterPosition', value: types_1.DataType.uint },\n                                    0x5378: { name: 'blockNumber', value: types_1.DataType.uint },\n                                    0xea: { name: 'codecState', value: types_1.DataType.uint },\n                                    0xdb: {\n                                        name: 'reference', container: {\n                                            0x96: { name: 'time', value: types_1.DataType.uint },\n                                            0x97: { name: 'cluster', value: types_1.DataType.uint },\n                                            0x535f: { name: 'number', value: types_1.DataType.uint },\n                                            0xeb: { name: 'codecState', value: types_1.DataType.uint }\n                                        }\n                                    },\n                                    0xf0: { name: 'relativePosition', value: types_1.DataType.uint } // extended\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            // Attachment\n            0x1941a469: {\n                name: 'attachments',\n                container: {\n                    0x61a7: {\n                        name: 'attachedFiles',\n                        multiple: true,\n                        container: {\n                            0x467e: { name: 'description', value: types_1.DataType.string },\n                            0x466e: { name: 'name', value: types_1.DataType.string },\n                            0x4660: { name: 'mimeType', value: types_1.DataType.string },\n                            0x465c: { name: 'data', value: types_1.DataType.binary },\n                            0x46ae: { name: 'uid', value: types_1.DataType.uid }\n                        }\n                    }\n                }\n            },\n            // Chapters\n            0x1043a770: {\n                name: 'chapters',\n                container: {\n                    0x45b9: {\n                        name: 'editionEntry',\n                        container: {\n                            0xb6: {\n                                name: 'chapterAtom',\n                                container: {\n                                    0x73c4: { name: 'uid', value: types_1.DataType.uid },\n                                    0x91: { name: 'timeStart', value: types_1.DataType.uint },\n                                    0x92: { name: 'timeEnd', value: types_1.DataType.uid },\n                                    0x98: { name: 'hidden', value: types_1.DataType.bool },\n                                    0x4598: { name: 'enabled', value: types_1.DataType.uid },\n                                    0x8f: { name: 'track', container: {\n                                            0x89: { name: 'trackNumber', value: types_1.DataType.uid },\n                                            0x80: {\n                                                name: 'display', container: {\n                                                    0x85: { name: 'string', value: types_1.DataType.string },\n                                                    0x437c: { name: 'language ', value: types_1.DataType.string },\n                                                    0x437e: { name: 'country ', value: types_1.DataType.string }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            // Tagging\n            0x1254c367: {\n                name: 'tags',\n                container: {\n                    0x7373: {\n                        name: 'tag',\n                        multiple: true,\n                        container: {\n                            0x63c0: {\n                                name: 'target',\n                                container: {\n                                    0x63c5: { name: 'tagTrackUID', value: types_1.DataType.uid },\n                                    0x63c4: { name: 'tagChapterUID', value: types_1.DataType.uint },\n                                    0x63c6: { name: 'tagAttachmentUID', value: types_1.DataType.uid },\n                                    0x63ca: { name: 'targetType', value: types_1.DataType.string },\n                                    0x68ca: { name: 'targetTypeValue', value: types_1.DataType.uint },\n                                    0x63c9: { name: 'tagEditionUID', value: types_1.DataType.uid } // extended\n                                }\n                            },\n                            0x67c8: {\n                                name: 'simpleTags',\n                                multiple: true,\n                                container: {\n                                    0x45a3: { name: 'name', value: types_1.DataType.string },\n                                    0x4487: { name: 'string', value: types_1.DataType.string },\n                                    0x4485: { name: 'binary', value: types_1.DataType.binary },\n                                    0x447a: { name: 'language', value: types_1.DataType.string },\n                                    0x447b: { name: 'languageIETF', value: types_1.DataType.string },\n                                    0x4484: { name: 'default', value: types_1.DataType.bool } // extended\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbWF0cm9za2EvTWF0cm9za2FEdGQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCLGdCQUFnQixtQkFBTyxDQUFDLHdGQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbURBQW1EO0FBQ3pFLHNCQUFzQix1REFBdUQ7QUFDN0Usc0JBQXNCLHNEQUFzRDtBQUM1RSxzQkFBc0Isd0RBQXdEO0FBQzlFLHNCQUFzQixpREFBaUQ7QUFDdkUsc0JBQXNCLHNEQUFzRDtBQUM1RSxzQkFBc0IsMkRBQTJEO0FBQ2pGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0RBQWdEO0FBQ3RGLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMENBQTBDO0FBQ3hFLDhCQUE4QixrREFBa0Q7QUFDaEYsZ0NBQWdDLDhDQUE4QztBQUM5RSxnQ0FBZ0Msc0RBQXNEO0FBQ3RGLGdDQUFnQyw4Q0FBOEM7QUFDOUUsZ0NBQWdDLHNEQUFzRDtBQUN0RixnQ0FBZ0MscURBQXFEO0FBQ3JGLDhCQUE4QixpREFBaUQ7QUFDL0UsOEJBQThCLCtDQUErQztBQUM3RSw4QkFBOEIsK0NBQStDO0FBQzdFLDhCQUE4QixtREFBbUQ7QUFDakYsOEJBQThCO0FBQzlCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQStDO0FBQzNFLDRCQUE0QixpREFBaUQ7QUFDN0UsNEJBQTRCLCtDQUErQztBQUMzRSw0QkFBNEI7QUFDNUI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtREFBbUQ7QUFDdkYsc0NBQXNDLDBDQUEwQztBQUNoRixvQ0FBb0MsaURBQWlEO0FBQ3JGLG9DQUFvQyxtREFBbUQ7QUFDdkYsb0NBQW9DLG1EQUFtRDtBQUN2RixzQ0FBc0Msa0RBQWtEO0FBQ3hGLG9DQUFvQyxrREFBa0Q7QUFDdEYsc0NBQXNDLGdEQUFnRDtBQUN0RixzQ0FBc0MsZ0RBQWdEO0FBQ3RGLHdDQUF3Qyx1REFBdUQ7QUFDL0Ysd0NBQXdDLHNEQUFzRDtBQUM5RixzQ0FBc0MsOENBQThDO0FBQ3BGLHdDQUF3QyxrREFBa0Q7QUFDMUYsb0NBQW9DLGlEQUFpRDtBQUNyRixzQ0FBc0Msc0RBQXNEO0FBQzVGLHdDQUF3QyxtREFBbUQ7QUFDM0Ysd0NBQXdDLHVEQUF1RDtBQUMvRix3Q0FBd0Msc0RBQXNEO0FBQzlGLHdDQUF3QywwREFBMEQ7QUFDbEcsb0NBQW9DLHNEQUFzRDtBQUMxRixzQ0FBc0Msb0RBQW9EO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNEQUFzRDtBQUNsRyw4Q0FBOEMsa0RBQWtEO0FBQ2hHLDRDQUE0QyxrREFBa0Q7QUFDOUYsNENBQTRDLG1EQUFtRDtBQUMvRiw4Q0FBOEMsb0RBQW9EO0FBQ2xHLDhDQUE4QyxxREFBcUQ7QUFDbkcsOENBQThDLHVEQUF1RDtBQUNyRyxnREFBZ0QsbURBQW1EO0FBQ25HLGdEQUFnRDtBQUNoRDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywwREFBMEQ7QUFDdEcsOENBQThDLGdFQUFnRTtBQUM5Ryw0Q0FBNEMsZ0RBQWdEO0FBQzVGLDRDQUE0QyxnREFBZ0Q7QUFDNUYsOENBQThDLDBEQUEwRDtBQUN4Ryw4Q0FBOEM7QUFDOUM7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsNkNBQTZDO0FBQ25HLHNEQUFzRCw2Q0FBNkM7QUFDbkcsc0RBQXNELDRDQUE0QztBQUNsRztBQUNBO0FBQ0E7QUFDQSw4REFBOEQsdURBQXVEO0FBQ3JILDhEQUE4RDtBQUM5RDtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSw4REFBOEQsc0RBQXNEO0FBQ3BILDhEQUE4RCx5REFBeUQ7QUFDdkgsOERBQThELDJEQUEyRDtBQUN6SCw4REFBOEQsMkRBQTJEO0FBQ3pILDhEQUE4RCx1REFBdUQ7QUFDckgsOERBQThEO0FBQzlEO0FBQ0EsNkNBQTZDO0FBQzdDLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4Q0FBOEM7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDZDQUE2QztBQUN6Riw0Q0FBNEMsdURBQXVEO0FBQ25HLDhDQUE4QyxtREFBbUQ7QUFDakcsNENBQTRDLGtEQUFrRDtBQUM5RjtBQUNBO0FBQ0Esb0RBQW9ELDRDQUE0QztBQUNoRyxvREFBb0QsK0NBQStDO0FBQ25HLHNEQUFzRCw4Q0FBOEM7QUFDcEcsb0RBQW9EO0FBQ3BEO0FBQ0EscUNBQXFDO0FBQ3JDLDRDQUE0Qyx5REFBeUQ7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFEQUFxRDtBQUMzRixzQ0FBc0MsOENBQThDO0FBQ3BGLHNDQUFzQyxrREFBa0Q7QUFDeEYsc0NBQXNDLDhDQUE4QztBQUNwRixzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDBDQUEwQztBQUN4Riw0Q0FBNEMsaURBQWlEO0FBQzdGLDRDQUE0Qyw4Q0FBOEM7QUFDMUYsNENBQTRDLDhDQUE4QztBQUMxRiw4Q0FBOEMsOENBQThDO0FBQzVGLDRDQUE0QztBQUM1QyxvREFBb0Qsa0RBQWtEO0FBQ3RHO0FBQ0E7QUFDQSw0REFBNEQsZ0RBQWdEO0FBQzVHLDhEQUE4RCxtREFBbUQ7QUFDakgsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtEQUFrRDtBQUNoRyw4Q0FBOEMscURBQXFEO0FBQ25HLDhDQUE4Qyx1REFBdUQ7QUFDckcsOENBQThDLG9EQUFvRDtBQUNsRyw4Q0FBOEMsdURBQXVEO0FBQ3JHLDhDQUE4QyxxREFBcUQ7QUFDbkc7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsOENBQThDO0FBQzVGLDhDQUE4QyxnREFBZ0Q7QUFDOUYsOENBQThDLGdEQUFnRDtBQUM5Riw4Q0FBOEMsa0RBQWtEO0FBQ2hHLDhDQUE4QyxzREFBc0Q7QUFDcEcsOENBQThDLGdEQUFnRDtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9tYXRyb3NrYS9NYXRyb3NrYUR0ZC5qcz8wNzk5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbGVtZW50cyA9IHZvaWQgMDtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbi8qKlxuICogRWxlbWVudHMgb2YgZG9jdW1lbnQgdHlwZSBkZXNjcmlwdGlvblxuICogRGVyaXZlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90dW5nb2wvRUJNTC9ibG9iL21hc3Rlci9kb2N0eXBlcy9tYXRyb3NrYS5kdGRcbiAqIEV4dGVuZGVkIHdpdGg6XG4gKiAtIGh0dHBzOi8vd3d3Lm1hdHJvc2thLm9yZy90ZWNobmljYWwvc3BlY3MvaW5kZXguaHRtbFxuICovXG5leHBvcnRzLmVsZW1lbnRzID0ge1xuICAgIDB4MWE0NWRmYTM6IHtcbiAgICAgICAgbmFtZTogJ2VibWwnLFxuICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgIDB4NDI4NjogeyBuYW1lOiAnZWJtbFZlcnNpb24nLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAweDQyZjc6IHsgbmFtZTogJ2VibWxSZWFkVmVyc2lvbicsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgIDB4NDJmMjogeyBuYW1lOiAnZWJtbE1heElEV2lkdGgnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAweDQyZjM6IHsgbmFtZTogJ2VibWxNYXhTaXplV2lkdGgnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAweDQyODI6IHsgbmFtZTogJ2RvY1R5cGUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcgfSxcbiAgICAgICAgICAgIDB4NDI4NzogeyBuYW1lOiAnZG9jVHlwZVZlcnNpb24nLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAweDQyODU6IHsgbmFtZTogJ2RvY1R5cGVSZWFkVmVyc2lvbicsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSAvLyA1LjEuN1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBNYXRyb3NrYSBzZWdtZW50c1xuICAgIDB4MTg1MzgwNjc6IHtcbiAgICAgICAgbmFtZTogJ3NlZ21lbnQnLFxuICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgIC8vIE1ldGEgU2VlayBJbmZvcm1hdGlvblxuICAgICAgICAgICAgMHgxMTRkOWI3NDoge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzZWVrSGVhZCcsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgIDB4NGRiYjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3NlZWsnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg1M2FiOiB7IG5hbWU6ICdzZWVrSWQnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5iaW5hcnkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDUzYWM6IHsgbmFtZTogJ3NlZWtQb3NpdGlvbicsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIFNlZ21lbnQgSW5mb3JtYXRpb25cbiAgICAgICAgICAgIDB4MTU0OWE5NjY6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnaW5mbycsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgIDB4NzNhNDogeyBuYW1lOiAndWlkJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWlkIH0sXG4gICAgICAgICAgICAgICAgICAgIDB4NzM4NDogeyBuYW1lOiAnZmlsZW5hbWUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcgfSxcbiAgICAgICAgICAgICAgICAgICAgMHgzY2I5MjM6IHsgbmFtZTogJ3ByZXZVSUQnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aWQgfSxcbiAgICAgICAgICAgICAgICAgICAgMHgzYzgzYWI6IHsgbmFtZTogJ3ByZXZGaWxlbmFtZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnN0cmluZyB9LFxuICAgICAgICAgICAgICAgICAgICAweDNlYjkyMzogeyBuYW1lOiAnbmV4dFVJRCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpZCB9LFxuICAgICAgICAgICAgICAgICAgICAweDNlODNiYjogeyBuYW1lOiAnbmV4dEZpbGVuYW1lJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgIDB4MmFkN2IxOiB7IG5hbWU6ICd0aW1lY29kZVNjYWxlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAweDQ0ODk6IHsgbmFtZTogJ2R1cmF0aW9uJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuZmxvYXQgfSxcbiAgICAgICAgICAgICAgICAgICAgMHg0NDYxOiB7IG5hbWU6ICdkYXRlVVRDJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAweDdiYTk6IHsgbmFtZTogJ3RpdGxlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgIDB4NGQ4MDogeyBuYW1lOiAnbXV4aW5nQXBwJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgIDB4NTc0MTogeyBuYW1lOiAnd3JpdGluZ0FwcCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnN0cmluZyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIENsdXN0ZXJcbiAgICAgICAgICAgIDB4MWY0M2I2NzU6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2x1c3RlcicsXG4gICAgICAgICAgICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgIDB4ZTc6IHsgbmFtZTogJ3RpbWVjb2RlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWlkIH0sXG4gICAgICAgICAgICAgICAgICAgIDB4YTM6IHsgbmFtZTogJ3Vua25vd24nLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5iaW5hcnkgfSxcbiAgICAgICAgICAgICAgICAgICAgMHhhNzogeyBuYW1lOiAncG9zaXRpb24nLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aWQgfSxcbiAgICAgICAgICAgICAgICAgICAgMHhhYjogeyBuYW1lOiAncHJldlNpemUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aWQgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBUcmFja1xuICAgICAgICAgICAgMHgxNjU0YWU2Yjoge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0cmFja3MnLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAweGFlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZW50cmllcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZDc6IHsgbmFtZTogJ3RyYWNrTnVtYmVyJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NzNjNTogeyBuYW1lOiAndWlkJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWlkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MzogeyBuYW1lOiAndHJhY2tUeXBlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4Yjk6IHsgbmFtZTogJ2ZsYWdFbmFibGVkJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuYm9vbCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODg6IHsgbmFtZTogJ2ZsYWdEZWZhdWx0JywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuYm9vbCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NTVhYTogeyBuYW1lOiAnZmxhZ0ZvcmNlZCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLmJvb2wgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDljOiB7IG5hbWU6ICdmbGFnTGFjaW5nJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuYm9vbCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NmRlNzogeyBuYW1lOiAnbWluQ2FjaGUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg2ZGU4OiB7IG5hbWU6ICdtYXhDYWNoZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDIzZTM4MzogeyBuYW1lOiAnZGVmYXVsdER1cmF0aW9uJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MjMzMTRmOiB7IG5hbWU6ICd0aW1lY29kZVNjYWxlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuZmxvYXQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDUzNmU6IHsgbmFtZTogJ25hbWUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDIyYjU5YzogeyBuYW1lOiAnbGFuZ3VhZ2UnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDg2OiB7IG5hbWU6ICdjb2RlY0lEJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg2M2EyOiB7IG5hbWU6ICdjb2RlY1ByaXZhdGUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5iaW5hcnkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDI1ODY4ODogeyBuYW1lOiAnY29kZWNOYW1lJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgzYTk2OTc6IHsgbmFtZTogJ2NvZGVjU2V0dGluZ3MnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDNiNDA0MDogeyBuYW1lOiAnY29kZWNJbmZvVXJsJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgyNmIyNDA6IHsgbmFtZTogJ2NvZGVjRG93bmxvYWRVcmwnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweGFhOiB7IG5hbWU6ICdjb2RlY0RlY29kZUFsbCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLmJvb2wgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDZmYWI6IHsgbmFtZTogJ3RyYWNrT3ZlcmxheScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWaWRlb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZTA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3ZpZGVvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDlhOiB7IG5hbWU6ICdmbGFnSW50ZXJsYWNlZCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLmJvb2wgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NTNiODogeyBuYW1lOiAnc3RlcmVvTW9kZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4YjA6IHsgbmFtZTogJ3BpeGVsV2lkdGgnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweGJhOiB7IG5hbWU6ICdwaXhlbEhlaWdodCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NTRiMDogeyBuYW1lOiAnZGlzcGxheVdpZHRoJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg1NGJhOiB7IG5hbWU6ICdkaXNwbGF5SGVpZ2h0JywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg1NGIzOiB7IG5hbWU6ICdhc3BlY3RSYXRpb1R5cGUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDJlYjUyNDogeyBuYW1lOiAnY29sb3VyU3BhY2UnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDJmYjUyMzogeyBuYW1lOiAnZ2FtbWFWYWx1ZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLmZsb2F0IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXVkaW9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweGUxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhdWRpbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHhiNTogeyBuYW1lOiAnc2FtcGxpbmdGcmVxdWVuY3knLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5mbG9hdCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg3OGI1OiB7IG5hbWU6ICdvdXRwdXRTYW1wbGluZ0ZyZXF1ZW5jeScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLmZsb2F0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDlmOiB7IG5hbWU6ICdjaGFubmVscycsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4OTQ6IHsgbmFtZTogJ2NoYW5uZWxzJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg3ZDdiOiB7IG5hbWU6ICdjaGFubmVsUG9zaXRpb25zJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuYmluYXJ5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDYyNjQ6IHsgbmFtZTogJ2JpdERlcHRoJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRlbnQgRW5jb2RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDZkODA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NvbnRlbnRFbmNvZGluZ3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NjI0MDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjb250ZW50RW5jb2RpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDUwMzE6IHsgbmFtZTogJ29yZGVyJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDUwMzI6IHsgbmFtZTogJ3Njb3BlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuYm9vbCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDUwMzM6IHsgbmFtZTogJ3R5cGUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NTAzNDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2NvbnRlbnRFbmNvZGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDQyNTQ6IHsgbmFtZTogJ2NvbnRlbnRDb21wQWxnbycsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDQyNTU6IHsgbmFtZTogJ2NvbnRlbnRDb21wU2V0dGluZ3MnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5iaW5hcnkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDUwMzU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjb250ZW50RW5jb2RpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0N2UxOiB7IG5hbWU6ICdjb250ZW50RW5jQWxnbycsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDQ3ZTI6IHsgbmFtZTogJ2NvbnRlbnRFbmNLZXlJRCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLmJpbmFyeSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NDdlMzogeyBuYW1lOiAnY29udGVudFNpZ25hdHVyZSAnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5iaW5hcnkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDQ3ZTQ6IHsgbmFtZTogJ0NvbnRlbnRTaWdLZXlJRCAgJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuYmluYXJ5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0N2U1OiB7IG5hbWU6ICdjb250ZW50U2lnQWxnbyAnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0N2U2OiB7IG5hbWU6ICdjb250ZW50U2lnSGFzaEFsZ28gJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NjI2NDogeyBuYW1lOiAnYml0RGVwdGgnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gQ3VlaW5nIERhdGFcbiAgICAgICAgICAgIDB4MWM1M2JiNmI6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnY3VlcycsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgIDB4YmI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjdWVQb2ludCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweGIzOiB7IG5hbWU6ICdjdWVUaW1lJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWlkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHhiNzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncG9zaXRpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweGY3OiB7IG5hbWU6ICd0cmFjaycsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZjE6IHsgbmFtZTogJ2NsdXN0ZXJQb3NpdGlvbicsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NTM3ODogeyBuYW1lOiAnYmxvY2tOdW1iZXInLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweGVhOiB7IG5hbWU6ICdjb2RlY1N0YXRlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHhkYjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdyZWZlcmVuY2UnLCBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg5NjogeyBuYW1lOiAndGltZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg5NzogeyBuYW1lOiAnY2x1c3RlcicsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg1MzVmOiB7IG5hbWU6ICdudW1iZXInLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZWI6IHsgbmFtZTogJ2NvZGVjU3RhdGUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHhmMDogeyBuYW1lOiAncmVsYXRpdmVQb3NpdGlvbicsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpbnQgfSAvLyBleHRlbmRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIEF0dGFjaG1lbnRcbiAgICAgICAgICAgIDB4MTk0MWE0Njk6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnYXR0YWNobWVudHMnLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAweDYxYTc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhdHRhY2hlZEZpbGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0NjdlOiB7IG5hbWU6ICdkZXNjcmlwdGlvbicsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnN0cmluZyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NDY2ZTogeyBuYW1lOiAnbmFtZScsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnN0cmluZyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NDY2MDogeyBuYW1lOiAnbWltZVR5cGUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDQ2NWM6IHsgbmFtZTogJ2RhdGEnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5iaW5hcnkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDQ2YWU6IHsgbmFtZTogJ3VpZCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpZCB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gQ2hhcHRlcnNcbiAgICAgICAgICAgIDB4MTA0M2E3NzA6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnY2hhcHRlcnMnLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAweDQ1Yjk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdlZGl0aW9uRW50cnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHhiNjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnY2hhcHRlckF0b20nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NzNjNDogeyBuYW1lOiAndWlkJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWlkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDkxOiB7IG5hbWU6ICd0aW1lU3RhcnQnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aW50IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDkyOiB7IG5hbWU6ICd0aW1lRW5kJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWlkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDk4OiB7IG5hbWU6ICdoaWRkZW4nLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5ib29sIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDQ1OTg6IHsgbmFtZTogJ2VuYWJsZWQnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS51aWQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4OGY6IHsgbmFtZTogJ3RyYWNrJywgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODk6IHsgbmFtZTogJ3RyYWNrTnVtYmVyJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWlkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdkaXNwbGF5JywgY29udGFpbmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4NTogeyBuYW1lOiAnc3RyaW5nJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0MzdjOiB7IG5hbWU6ICdsYW5ndWFnZSAnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDQzN2U6IHsgbmFtZTogJ2NvdW50cnkgJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBUYWdnaW5nXG4gICAgICAgICAgICAweDEyNTRjMzY3OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3RhZ3MnLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAweDczNzM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICd0YWcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDYzYzA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3RhcmdldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg2M2M1OiB7IG5hbWU6ICd0YWdUcmFja1VJRCcsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnVpZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg2M2M0OiB7IG5hbWU6ICd0YWdDaGFwdGVyVUlEJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg2M2M2OiB7IG5hbWU6ICd0YWdBdHRhY2htZW50VUlEJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWlkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDYzY2E6IHsgbmFtZTogJ3RhcmdldFR5cGUnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NjhjYTogeyBuYW1lOiAndGFyZ2V0VHlwZVZhbHVlJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWludCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg2M2M5OiB7IG5hbWU6ICd0YWdFZGl0aW9uVUlEJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUudWlkIH0gLy8gZXh0ZW5kZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg2N2M4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzaW1wbGVUYWdzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0NWEzOiB7IG5hbWU6ICduYW1lJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDQ0ODc6IHsgbmFtZTogJ3N0cmluZycsIHZhbHVlOiB0eXBlc18xLkRhdGFUeXBlLnN0cmluZyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg0NDg1OiB7IG5hbWU6ICdiaW5hcnknLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5iaW5hcnkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NDQ3YTogeyBuYW1lOiAnbGFuZ3VhZ2UnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4NDQ3YjogeyBuYW1lOiAnbGFuZ3VhZ2VJRVRGJywgdmFsdWU6IHR5cGVzXzEuRGF0YVR5cGUuc3RyaW5nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDQ0ODQ6IHsgbmFtZTogJ2RlZmF1bHQnLCB2YWx1ZTogdHlwZXNfMS5EYXRhVHlwZS5ib29sIH0gLy8gZXh0ZW5kZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/matroska/MatroskaDtd.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/matroska/MatroskaParser.js":
/*!********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/matroska/MatroskaParser.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MatroskaParser = void 0;\nconst token_types_1 = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(app-pages-browser)/./node_modules/music-metadata/lib/matroska/types.js\");\nconst matroskaDtd = __webpack_require__(/*! ./MatroskaDtd */ \"(app-pages-browser)/./node_modules/music-metadata/lib/matroska/MatroskaDtd.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:matroska');\n/**\n * Extensible Binary Meta Language (EBML) parser\n * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language\n * http://matroska.sourceforge.net/technical/specs/rfc/index.html\n *\n * WEBM VP8 AUDIO FILE\n */\nclass MatroskaParser extends BasicParser_1.BasicParser {\n    constructor() {\n        super();\n        this.padding = 0;\n        this.parserMap = new Map();\n        this.ebmlMaxIDLength = 4;\n        this.ebmlMaxSizeLength = 8;\n        this.parserMap.set(types_1.DataType.uint, e => this.readUint(e));\n        this.parserMap.set(types_1.DataType.string, e => this.readString(e));\n        this.parserMap.set(types_1.DataType.binary, e => this.readBuffer(e));\n        this.parserMap.set(types_1.DataType.uid, async (e) => await this.readUint(e) === 1);\n        this.parserMap.set(types_1.DataType.bool, e => this.readFlag(e));\n        this.parserMap.set(types_1.DataType.float, e => this.readFloat(e));\n    }\n    /**\n     * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\n     * @param {INativeMetadataCollector} metadata Output\n     * @param {ITokenizer} tokenizer Input\n     * @param {IOptions} options Parsing options\n     */\n    init(metadata, tokenizer, options) {\n        super.init(metadata, tokenizer, options);\n        return this;\n    }\n    async parse() {\n        const matroska = await this.parseContainer(matroskaDtd.elements, this.tokenizer.fileInfo.size, []);\n        this.metadata.setFormat('container', `EBML/${matroska.ebml.docType}`);\n        if (matroska.segment) {\n            const info = matroska.segment.info;\n            if (info) {\n                const timecodeScale = info.timecodeScale ? info.timecodeScale : 1000000;\n                if (typeof info.duration === 'number') {\n                    const duration = info.duration * timecodeScale / 1000000000;\n                    this.addTag('segment:title', info.title);\n                    this.metadata.setFormat('duration', duration);\n                }\n            }\n            const audioTracks = matroska.segment.tracks;\n            if (audioTracks && audioTracks.entries) {\n                audioTracks.entries.forEach(entry => {\n                    const stream = {\n                        codecName: entry.codecID.replace('A_', '').replace('V_', ''),\n                        codecSettings: entry.codecSettings,\n                        flagDefault: entry.flagDefault,\n                        flagLacing: entry.flagLacing,\n                        flagEnabled: entry.flagEnabled,\n                        language: entry.language,\n                        name: entry.name,\n                        type: entry.trackType,\n                        audio: entry.audio,\n                        video: entry.video\n                    };\n                    this.metadata.addStreamInfo(stream);\n                });\n                const audioTrack = audioTracks.entries\n                    .filter(entry => {\n                    return entry.trackType === types_1.TrackType.audio.valueOf();\n                })\n                    .reduce((acc, cur) => {\n                    if (!acc) {\n                        return cur;\n                    }\n                    if (!acc.flagDefault && cur.flagDefault) {\n                        return cur;\n                    }\n                    if (cur.trackNumber && cur.trackNumber < acc.trackNumber) {\n                        return cur;\n                    }\n                    return acc;\n                }, null);\n                if (audioTrack) {\n                    this.metadata.setFormat('codec', audioTrack.codecID.replace('A_', ''));\n                    this.metadata.setFormat('sampleRate', audioTrack.audio.samplingFrequency);\n                    this.metadata.setFormat('numberOfChannels', audioTrack.audio.channels);\n                }\n                if (matroska.segment.tags) {\n                    matroska.segment.tags.tag.forEach(tag => {\n                        const target = tag.target;\n                        const targetType = (target === null || target === void 0 ? void 0 : target.targetTypeValue) ? types_1.TargetType[target.targetTypeValue] : ((target === null || target === void 0 ? void 0 : target.targetType) ? target.targetType : 'track');\n                        tag.simpleTags.forEach(simpleTag => {\n                            const value = simpleTag.string ? simpleTag.string : simpleTag.binary;\n                            this.addTag(`${targetType}:${simpleTag.name}`, value);\n                        });\n                    });\n                }\n                if (matroska.segment.attachments) {\n                    matroska.segment.attachments.attachedFiles\n                        .filter(file => file.mimeType.startsWith('image/'))\n                        .map(file => {\n                        return {\n                            data: file.data,\n                            format: file.mimeType,\n                            description: file.description,\n                            name: file.name\n                        };\n                    }).forEach(picture => {\n                        this.addTag('picture', picture);\n                    });\n                }\n            }\n        }\n    }\n    async parseContainer(container, posDone, path) {\n        const tree = {};\n        while (this.tokenizer.position < posDone) {\n            let element;\n            try {\n                element = await this.readElement();\n            }\n            catch (error) {\n                if (error.message === 'End-Of-Stream') {\n                    break;\n                }\n                throw error;\n            }\n            const type = container[element.id];\n            if (type) {\n                debug(`Element: name=${type.name}, container=${!!type.container}`);\n                if (type.container) {\n                    const res = await this.parseContainer(type.container, element.len >= 0 ? this.tokenizer.position + element.len : -1, path.concat([type.name]));\n                    if (type.multiple) {\n                        if (!tree[type.name]) {\n                            tree[type.name] = [];\n                        }\n                        tree[type.name].push(res);\n                    }\n                    else {\n                        tree[type.name] = res;\n                    }\n                }\n                else {\n                    tree[type.name] = await this.parserMap.get(type.value)(element);\n                }\n            }\n            else {\n                switch (element.id) {\n                    case 0xec: // void\n                        this.padding += element.len;\n                        await this.tokenizer.ignore(element.len);\n                        break;\n                    default:\n                        debug(`parseEbml: path=${path.join('/')}, unknown element: id=${element.id.toString(16)}`);\n                        this.padding += element.len;\n                        await this.tokenizer.ignore(element.len);\n                }\n            }\n        }\n        return tree;\n    }\n    async readVintData(maxLength) {\n        const msb = await this.tokenizer.peekNumber(token_types_1.UINT8);\n        let mask = 0x80;\n        let oc = 1;\n        // Calculate VINT_WIDTH\n        while ((msb & mask) === 0) {\n            if (oc > maxLength) {\n                throw new Error('VINT value exceeding maximum size');\n            }\n            ++oc;\n            mask >>= 1;\n        }\n        const id = Buffer.alloc(oc);\n        await this.tokenizer.readBuffer(id);\n        return id;\n    }\n    async readElement() {\n        const id = await this.readVintData(this.ebmlMaxIDLength);\n        const lenField = await this.readVintData(this.ebmlMaxSizeLength);\n        lenField[0] ^= 0x80 >> (lenField.length - 1);\n        const nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer\n        return {\n            id: id.readUIntBE(0, id.length),\n            len: lenField.readUIntBE(lenField.length - nrLen, nrLen)\n        };\n    }\n    isMaxValue(vintData) {\n        if (vintData.length === this.ebmlMaxSizeLength) {\n            for (let n = 1; n < this.ebmlMaxSizeLength; ++n) {\n                if (vintData[n] !== 0xff)\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    async readFloat(e) {\n        switch (e.len) {\n            case 0:\n                return 0.0;\n            case 4:\n                return this.tokenizer.readNumber(token_types_1.Float32_BE);\n            case 8:\n                return this.tokenizer.readNumber(token_types_1.Float64_BE);\n            case 10:\n                return this.tokenizer.readNumber(token_types_1.Float64_BE);\n            default:\n                throw new Error(`Invalid IEEE-754 float length: ${e.len}`);\n        }\n    }\n    async readFlag(e) {\n        return (await this.readUint(e)) === 1;\n    }\n    async readUint(e) {\n        const buf = await this.readBuffer(e);\n        const nrLen = Math.min(6, e.len); // JavaScript can max read 6 bytes integer\n        return buf.readUIntBE(e.len - nrLen, nrLen);\n    }\n    async readString(e) {\n        const rawString = await this.tokenizer.readToken(new token_types_1.StringType(e.len, 'utf-8'));\n        return rawString.replace(/\\00.*$/g, '');\n    }\n    async readBuffer(e) {\n        const buf = Buffer.alloc(e.len);\n        await this.tokenizer.readBuffer(buf);\n        return buf;\n    }\n    addTag(tagId, value) {\n        this.metadata.addTag('matroska', tagId, value);\n    }\n}\nexports.MatroskaParser = MatroskaParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbWF0cm9za2EvTWF0cm9za2FQYXJzZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0QixzQkFBc0IsbUJBQU8sQ0FBQyxnRkFBYTtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBTztBQUMvQixzQkFBc0IsbUJBQU8sQ0FBQywwR0FBdUI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsd0ZBQVM7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMsb0dBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxZQUFZO0FBQzNCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxzQkFBc0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVcsR0FBRyxlQUFlO0FBQ3hFLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxVQUFVLGNBQWMsaUJBQWlCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZUFBZSx3QkFBd0Isd0JBQXdCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9tYXRyb3NrYS9NYXRyb3NrYVBhcnNlci5qcz81MmQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYXRyb3NrYVBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IHRva2VuX3R5cGVzXzEgPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgQmFzaWNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vQmFzaWNQYXJzZXJcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCBtYXRyb3NrYUR0ZCA9IHJlcXVpcmUoXCIuL01hdHJvc2thRHRkXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbXVzaWMtbWV0YWRhdGE6cGFyc2VyOm1hdHJvc2thJyk7XG4vKipcbiAqIEV4dGVuc2libGUgQmluYXJ5IE1ldGEgTGFuZ3VhZ2UgKEVCTUwpIHBhcnNlclxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXh0ZW5zaWJsZV9CaW5hcnlfTWV0YV9MYW5ndWFnZVxuICogaHR0cDovL21hdHJvc2thLnNvdXJjZWZvcmdlLm5ldC90ZWNobmljYWwvc3BlY3MvcmZjL2luZGV4Lmh0bWxcbiAqXG4gKiBXRUJNIFZQOCBBVURJTyBGSUxFXG4gKi9cbmNsYXNzIE1hdHJvc2thUGFyc2VyIGV4dGVuZHMgQmFzaWNQYXJzZXJfMS5CYXNpY1BhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGFkZGluZyA9IDA7XG4gICAgICAgIHRoaXMucGFyc2VyTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmVibWxNYXhJRExlbmd0aCA9IDQ7XG4gICAgICAgIHRoaXMuZWJtbE1heFNpemVMZW5ndGggPSA4O1xuICAgICAgICB0aGlzLnBhcnNlck1hcC5zZXQodHlwZXNfMS5EYXRhVHlwZS51aW50LCBlID0+IHRoaXMucmVhZFVpbnQoZSkpO1xuICAgICAgICB0aGlzLnBhcnNlck1hcC5zZXQodHlwZXNfMS5EYXRhVHlwZS5zdHJpbmcsIGUgPT4gdGhpcy5yZWFkU3RyaW5nKGUpKTtcbiAgICAgICAgdGhpcy5wYXJzZXJNYXAuc2V0KHR5cGVzXzEuRGF0YVR5cGUuYmluYXJ5LCBlID0+IHRoaXMucmVhZEJ1ZmZlcihlKSk7XG4gICAgICAgIHRoaXMucGFyc2VyTWFwLnNldCh0eXBlc18xLkRhdGFUeXBlLnVpZCwgYXN5bmMgKGUpID0+IGF3YWl0IHRoaXMucmVhZFVpbnQoZSkgPT09IDEpO1xuICAgICAgICB0aGlzLnBhcnNlck1hcC5zZXQodHlwZXNfMS5EYXRhVHlwZS5ib29sLCBlID0+IHRoaXMucmVhZEZsYWcoZSkpO1xuICAgICAgICB0aGlzLnBhcnNlck1hcC5zZXQodHlwZXNfMS5EYXRhVHlwZS5mbG9hdCwgZSA9PiB0aGlzLnJlYWRGbG9hdChlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgcGFyc2VyIHdpdGggb3V0cHV0IChtZXRhZGF0YSksIGlucHV0ICh0b2tlbml6ZXIpICYgcGFyc2luZyBvcHRpb25zIChvcHRpb25zKS5cbiAgICAgKiBAcGFyYW0ge0lOYXRpdmVNZXRhZGF0YUNvbGxlY3Rvcn0gbWV0YWRhdGEgT3V0cHV0XG4gICAgICogQHBhcmFtIHtJVG9rZW5pemVyfSB0b2tlbml6ZXIgSW5wdXRcbiAgICAgKiBAcGFyYW0ge0lPcHRpb25zfSBvcHRpb25zIFBhcnNpbmcgb3B0aW9uc1xuICAgICAqL1xuICAgIGluaXQobWV0YWRhdGEsIHRva2VuaXplciwgb3B0aW9ucykge1xuICAgICAgICBzdXBlci5pbml0KG1ldGFkYXRhLCB0b2tlbml6ZXIsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXN5bmMgcGFyc2UoKSB7XG4gICAgICAgIGNvbnN0IG1hdHJvc2thID0gYXdhaXQgdGhpcy5wYXJzZUNvbnRhaW5lcihtYXRyb3NrYUR0ZC5lbGVtZW50cywgdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSwgW10pO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29udGFpbmVyJywgYEVCTUwvJHttYXRyb3NrYS5lYm1sLmRvY1R5cGV9YCk7XG4gICAgICAgIGlmIChtYXRyb3NrYS5zZWdtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gbWF0cm9za2Euc2VnbWVudC5pbmZvO1xuICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lY29kZVNjYWxlID0gaW5mby50aW1lY29kZVNjYWxlID8gaW5mby50aW1lY29kZVNjYWxlIDogMTAwMDAwMDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluZm8uZHVyYXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gaW5mby5kdXJhdGlvbiAqIHRpbWVjb2RlU2NhbGUgLyAxMDAwMDAwMDAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZygnc2VnbWVudDp0aXRsZScsIGluZm8udGl0bGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnZHVyYXRpb24nLCBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXVkaW9UcmFja3MgPSBtYXRyb3NrYS5zZWdtZW50LnRyYWNrcztcbiAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrcyAmJiBhdWRpb1RyYWNrcy5lbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgYXVkaW9UcmFja3MuZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZWNOYW1lOiBlbnRyeS5jb2RlY0lELnJlcGxhY2UoJ0FfJywgJycpLnJlcGxhY2UoJ1ZfJywgJycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZWNTZXR0aW5nczogZW50cnkuY29kZWNTZXR0aW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdEZWZhdWx0OiBlbnRyeS5mbGFnRGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdMYWNpbmc6IGVudHJ5LmZsYWdMYWNpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnRW5hYmxlZDogZW50cnkuZmxhZ0VuYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZTogZW50cnkubGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBlbnRyeS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZW50cnkudHJhY2tUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW86IGVudHJ5LmF1ZGlvLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW86IGVudHJ5LnZpZGVvXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuYWRkU3RyZWFtSW5mbyhzdHJlYW0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSBhdWRpb1RyYWNrcy5lbnRyaWVzXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZW50cnkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkudHJhY2tUeXBlID09PSB0eXBlc18xLlRyYWNrVHlwZS5hdWRpby52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCBjdXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhY2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhY2MuZmxhZ0RlZmF1bHQgJiYgY3VyLmZsYWdEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIudHJhY2tOdW1iZXIgJiYgY3VyLnRyYWNrTnVtYmVyIDwgYWNjLnRyYWNrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgfSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKGF1ZGlvVHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvZGVjJywgYXVkaW9UcmFjay5jb2RlY0lELnJlcGxhY2UoJ0FfJywgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ3NhbXBsZVJhdGUnLCBhdWRpb1RyYWNrLmF1ZGlvLnNhbXBsaW5nRnJlcXVlbmN5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ251bWJlck9mQ2hhbm5lbHMnLCBhdWRpb1RyYWNrLmF1ZGlvLmNoYW5uZWxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdHJvc2thLnNlZ21lbnQudGFncykge1xuICAgICAgICAgICAgICAgICAgICBtYXRyb3NrYS5zZWdtZW50LnRhZ3MudGFnLmZvckVhY2godGFnID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRhZy50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRUeXBlID0gKHRhcmdldCA9PT0gbnVsbCB8fCB0YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldC50YXJnZXRUeXBlVmFsdWUpID8gdHlwZXNfMS5UYXJnZXRUeXBlW3RhcmdldC50YXJnZXRUeXBlVmFsdWVdIDogKCh0YXJnZXQgPT09IG51bGwgfHwgdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXQudGFyZ2V0VHlwZSkgPyB0YXJnZXQudGFyZ2V0VHlwZSA6ICd0cmFjaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnLnNpbXBsZVRhZ3MuZm9yRWFjaChzaW1wbGVUYWcgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gc2ltcGxlVGFnLnN0cmluZyA/IHNpbXBsZVRhZy5zdHJpbmcgOiBzaW1wbGVUYWcuYmluYXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFnKGAke3RhcmdldFR5cGV9OiR7c2ltcGxlVGFnLm5hbWV9YCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF0cm9za2Euc2VnbWVudC5hdHRhY2htZW50cykge1xuICAgICAgICAgICAgICAgICAgICBtYXRyb3NrYS5zZWdtZW50LmF0dGFjaG1lbnRzLmF0dGFjaGVkRmlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZmlsZSA9PiBmaWxlLm1pbWVUeXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmaWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZmlsZS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogZmlsZS5taW1lVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZmlsZS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmaWxlLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pLmZvckVhY2gocGljdHVyZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZygncGljdHVyZScsIHBpY3R1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcGFyc2VDb250YWluZXIoY29udGFpbmVyLCBwb3NEb25lLCBwYXRoKSB7XG4gICAgICAgIGNvbnN0IHRyZWUgPSB7fTtcbiAgICAgICAgd2hpbGUgKHRoaXMudG9rZW5pemVyLnBvc2l0aW9uIDwgcG9zRG9uZSkge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBhd2FpdCB0aGlzLnJlYWRFbGVtZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gJ0VuZC1PZi1TdHJlYW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBjb250YWluZXJbZWxlbWVudC5pZF07XG4gICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKGBFbGVtZW50OiBuYW1lPSR7dHlwZS5uYW1lfSwgY29udGFpbmVyPSR7ISF0eXBlLmNvbnRhaW5lcn1gKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5wYXJzZUNvbnRhaW5lcih0eXBlLmNvbnRhaW5lciwgZWxlbWVudC5sZW4gPj0gMCA/IHRoaXMudG9rZW5pemVyLnBvc2l0aW9uICsgZWxlbWVudC5sZW4gOiAtMSwgcGF0aC5jb25jYXQoW3R5cGUubmFtZV0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJlZVt0eXBlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZVt0eXBlLm5hbWVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlW3R5cGUubmFtZV0ucHVzaChyZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZVt0eXBlLm5hbWVdID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmVlW3R5cGUubmFtZV0gPSBhd2FpdCB0aGlzLnBhcnNlck1hcC5nZXQodHlwZS52YWx1ZSkoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChlbGVtZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHhlYzogLy8gdm9pZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWRkaW5nICs9IGVsZW1lbnQubGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKGVsZW1lbnQubGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoYHBhcnNlRWJtbDogcGF0aD0ke3BhdGguam9pbignLycpfSwgdW5rbm93biBlbGVtZW50OiBpZD0ke2VsZW1lbnQuaWQudG9TdHJpbmcoMTYpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWRkaW5nICs9IGVsZW1lbnQubGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKGVsZW1lbnQubGVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRWaW50RGF0YShtYXhMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbXNiID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucGVla051bWJlcih0b2tlbl90eXBlc18xLlVJTlQ4KTtcbiAgICAgICAgbGV0IG1hc2sgPSAweDgwO1xuICAgICAgICBsZXQgb2MgPSAxO1xuICAgICAgICAvLyBDYWxjdWxhdGUgVklOVF9XSURUSFxuICAgICAgICB3aGlsZSAoKG1zYiAmIG1hc2spID09PSAwKSB7XG4gICAgICAgICAgICBpZiAob2MgPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZJTlQgdmFsdWUgZXhjZWVkaW5nIG1heGltdW0gc2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytvYztcbiAgICAgICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWQgPSBCdWZmZXIuYWxsb2Mob2MpO1xuICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkQnVmZmVyKGlkKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBhc3luYyByZWFkRWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgaWQgPSBhd2FpdCB0aGlzLnJlYWRWaW50RGF0YSh0aGlzLmVibWxNYXhJRExlbmd0aCk7XG4gICAgICAgIGNvbnN0IGxlbkZpZWxkID0gYXdhaXQgdGhpcy5yZWFkVmludERhdGEodGhpcy5lYm1sTWF4U2l6ZUxlbmd0aCk7XG4gICAgICAgIGxlbkZpZWxkWzBdIF49IDB4ODAgPj4gKGxlbkZpZWxkLmxlbmd0aCAtIDEpO1xuICAgICAgICBjb25zdCBuckxlbiA9IE1hdGgubWluKDYsIGxlbkZpZWxkLmxlbmd0aCk7IC8vIEphdmFTY3JpcHQgY2FuIG1heCByZWFkIDYgYnl0ZXMgaW50ZWdlclxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGlkLnJlYWRVSW50QkUoMCwgaWQubGVuZ3RoKSxcbiAgICAgICAgICAgIGxlbjogbGVuRmllbGQucmVhZFVJbnRCRShsZW5GaWVsZC5sZW5ndGggLSBuckxlbiwgbnJMZW4pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlzTWF4VmFsdWUodmludERhdGEpIHtcbiAgICAgICAgaWYgKHZpbnREYXRhLmxlbmd0aCA9PT0gdGhpcy5lYm1sTWF4U2l6ZUxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgbiA9IDE7IG4gPCB0aGlzLmVibWxNYXhTaXplTGVuZ3RoOyArK24pIHtcbiAgICAgICAgICAgICAgICBpZiAodmludERhdGFbbl0gIT09IDB4ZmYpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZEZsb2F0KGUpIHtcbiAgICAgICAgc3dpdGNoIChlLmxlbikge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5pemVyLnJlYWROdW1iZXIodG9rZW5fdHlwZXNfMS5GbG9hdDMyX0JFKTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbml6ZXIucmVhZE51bWJlcih0b2tlbl90eXBlc18xLkZsb2F0NjRfQkUpO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbml6ZXIucmVhZE51bWJlcih0b2tlbl90eXBlc18xLkZsb2F0NjRfQkUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSUVFRS03NTQgZmxvYXQgbGVuZ3RoOiAke2UubGVufWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlYWRGbGFnKGUpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLnJlYWRVaW50KGUpKSA9PT0gMTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFVpbnQoZSkge1xuICAgICAgICBjb25zdCBidWYgPSBhd2FpdCB0aGlzLnJlYWRCdWZmZXIoZSk7XG4gICAgICAgIGNvbnN0IG5yTGVuID0gTWF0aC5taW4oNiwgZS5sZW4pOyAvLyBKYXZhU2NyaXB0IGNhbiBtYXggcmVhZCA2IGJ5dGVzIGludGVnZXJcbiAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludEJFKGUubGVuIC0gbnJMZW4sIG5yTGVuKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFN0cmluZyhlKSB7XG4gICAgICAgIGNvbnN0IHJhd1N0cmluZyA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgdG9rZW5fdHlwZXNfMS5TdHJpbmdUeXBlKGUubGVuLCAndXRmLTgnKSk7XG4gICAgICAgIHJldHVybiByYXdTdHJpbmcucmVwbGFjZSgvXFwwMC4qJC9nLCAnJyk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRCdWZmZXIoZSkge1xuICAgICAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoZS5sZW4pO1xuICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkQnVmZmVyKGJ1Zik7XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIGFkZFRhZyh0YWdJZCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRUYWcoJ21hdHJvc2thJywgdGFnSWQsIHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLk1hdHJvc2thUGFyc2VyID0gTWF0cm9za2FQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/matroska/MatroskaParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/matroska/MatroskaTagMapper.js":
/*!***********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/matroska/MatroskaTagMapper.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MatroskaTagMapper = void 0;\nconst CaseInsensitiveTagMap_1 = __webpack_require__(/*! ../common/CaseInsensitiveTagMap */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js\");\n/**\n * EBML Tag map\n */\nconst ebmlTagMap = {\n    'segment:title': 'title',\n    'album:ARTIST': 'albumartist',\n    'album:ARTISTSORT': 'albumartistsort',\n    'album:TITLE': 'album',\n    'album:DATE_RECORDED': 'originaldate',\n    'album:PART_NUMBER': 'disk',\n    'album:TOTAL_PARTS': 'totaltracks',\n    'track:ARTIST': 'artist',\n    'track:ARTISTSORT': 'artistsort',\n    'track:TITLE': 'title',\n    'track:PART_NUMBER': 'track',\n    'track:MUSICBRAINZ_TRACKID': 'musicbrainz_recordingid',\n    'track:MUSICBRAINZ_ALBUMID': 'musicbrainz_albumid',\n    'track:MUSICBRAINZ_ARTISTID': 'musicbrainz_artistid',\n    'track:PUBLISHER': 'label',\n    'track:GENRE': 'genre',\n    'track:ENCODER': 'encodedby',\n    'track:ENCODER_OPTIONS': 'encodersettings',\n    'edition:TOTAL_PARTS': 'totaldiscs',\n    picture: 'picture'\n};\nclass MatroskaTagMapper extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {\n    constructor() {\n        super(['matroska'], ebmlTagMap);\n    }\n}\nexports.MatroskaTagMapper = MatroskaTagMapper;\n//# sourceMappingURL=MatroskaTagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbWF0cm9za2EvTWF0cm9za2FUYWdNYXBwZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLGdDQUFnQyxtQkFBTyxDQUFDLDhIQUFpQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9tYXRyb3NrYS9NYXRyb3NrYVRhZ01hcHBlci5qcz82ZmM4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYXRyb3NrYVRhZ01hcHBlciA9IHZvaWQgMDtcbmNvbnN0IENhc2VJbnNlbnNpdGl2ZVRhZ01hcF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9DYXNlSW5zZW5zaXRpdmVUYWdNYXBcIik7XG4vKipcbiAqIEVCTUwgVGFnIG1hcFxuICovXG5jb25zdCBlYm1sVGFnTWFwID0ge1xuICAgICdzZWdtZW50OnRpdGxlJzogJ3RpdGxlJyxcbiAgICAnYWxidW06QVJUSVNUJzogJ2FsYnVtYXJ0aXN0JyxcbiAgICAnYWxidW06QVJUSVNUU09SVCc6ICdhbGJ1bWFydGlzdHNvcnQnLFxuICAgICdhbGJ1bTpUSVRMRSc6ICdhbGJ1bScsXG4gICAgJ2FsYnVtOkRBVEVfUkVDT1JERUQnOiAnb3JpZ2luYWxkYXRlJyxcbiAgICAnYWxidW06UEFSVF9OVU1CRVInOiAnZGlzaycsXG4gICAgJ2FsYnVtOlRPVEFMX1BBUlRTJzogJ3RvdGFsdHJhY2tzJyxcbiAgICAndHJhY2s6QVJUSVNUJzogJ2FydGlzdCcsXG4gICAgJ3RyYWNrOkFSVElTVFNPUlQnOiAnYXJ0aXN0c29ydCcsXG4gICAgJ3RyYWNrOlRJVExFJzogJ3RpdGxlJyxcbiAgICAndHJhY2s6UEFSVF9OVU1CRVInOiAndHJhY2snLFxuICAgICd0cmFjazpNVVNJQ0JSQUlOWl9UUkFDS0lEJzogJ211c2ljYnJhaW56X3JlY29yZGluZ2lkJyxcbiAgICAndHJhY2s6TVVTSUNCUkFJTlpfQUxCVU1JRCc6ICdtdXNpY2JyYWluel9hbGJ1bWlkJyxcbiAgICAndHJhY2s6TVVTSUNCUkFJTlpfQVJUSVNUSUQnOiAnbXVzaWNicmFpbnpfYXJ0aXN0aWQnLFxuICAgICd0cmFjazpQVUJMSVNIRVInOiAnbGFiZWwnLFxuICAgICd0cmFjazpHRU5SRSc6ICdnZW5yZScsXG4gICAgJ3RyYWNrOkVOQ09ERVInOiAnZW5jb2RlZGJ5JyxcbiAgICAndHJhY2s6RU5DT0RFUl9PUFRJT05TJzogJ2VuY29kZXJzZXR0aW5ncycsXG4gICAgJ2VkaXRpb246VE9UQUxfUEFSVFMnOiAndG90YWxkaXNjcycsXG4gICAgcGljdHVyZTogJ3BpY3R1cmUnXG59O1xuY2xhc3MgTWF0cm9za2FUYWdNYXBwZXIgZXh0ZW5kcyBDYXNlSW5zZW5zaXRpdmVUYWdNYXBfMS5DYXNlSW5zZW5zaXRpdmVUYWdNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihbJ21hdHJvc2thJ10sIGVibWxUYWdNYXApO1xuICAgIH1cbn1cbmV4cG9ydHMuTWF0cm9za2FUYWdNYXBwZXIgPSBNYXRyb3NrYVRhZ01hcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hdHJvc2thVGFnTWFwcGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/matroska/MatroskaTagMapper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/matroska/types.js":
/*!***********************************************************!*\
  !*** ./node_modules/music-metadata/lib/matroska/types.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TrackType = exports.TargetType = exports.DataType = void 0;\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"string\"] = 0] = \"string\";\n    DataType[DataType[\"uint\"] = 1] = \"uint\";\n    DataType[DataType[\"uid\"] = 2] = \"uid\";\n    DataType[DataType[\"bool\"] = 3] = \"bool\";\n    DataType[DataType[\"binary\"] = 4] = \"binary\";\n    DataType[DataType[\"float\"] = 5] = \"float\";\n})(DataType = exports.DataType || (exports.DataType = {}));\nvar TargetType;\n(function (TargetType) {\n    TargetType[TargetType[\"shot\"] = 10] = \"shot\";\n    TargetType[TargetType[\"scene\"] = 20] = \"scene\";\n    TargetType[TargetType[\"track\"] = 30] = \"track\";\n    TargetType[TargetType[\"part\"] = 40] = \"part\";\n    TargetType[TargetType[\"album\"] = 50] = \"album\";\n    TargetType[TargetType[\"edition\"] = 60] = \"edition\";\n    TargetType[TargetType[\"collection\"] = 70] = \"collection\";\n})(TargetType = exports.TargetType || (exports.TargetType = {}));\nvar TrackType;\n(function (TrackType) {\n    TrackType[TrackType[\"video\"] = 1] = \"video\";\n    TrackType[TrackType[\"audio\"] = 2] = \"audio\";\n    TrackType[TrackType[\"complex\"] = 3] = \"complex\";\n    TrackType[TrackType[\"logo\"] = 4] = \"logo\";\n    TrackType[TrackType[\"subtitle\"] = 17] = \"subtitle\";\n    TrackType[TrackType[\"button\"] = 18] = \"button\";\n    TrackType[TrackType[\"control\"] = 32] = \"control\";\n})(TrackType = exports.TrackType || (exports.TrackType = {}));\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbWF0cm9za2EvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQyxnQkFBZ0IsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQyxrQkFBa0IsS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQyxpQkFBaUIsS0FBSztBQUMzRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL21hdHJvc2thL3R5cGVzLmpzPzg4ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYWNrVHlwZSA9IGV4cG9ydHMuVGFyZ2V0VHlwZSA9IGV4cG9ydHMuRGF0YVR5cGUgPSB2b2lkIDA7XG52YXIgRGF0YVR5cGU7XG4oZnVuY3Rpb24gKERhdGFUeXBlKSB7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJzdHJpbmdcIl0gPSAwXSA9IFwic3RyaW5nXCI7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJ1aW50XCJdID0gMV0gPSBcInVpbnRcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcInVpZFwiXSA9IDJdID0gXCJ1aWRcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcImJvb2xcIl0gPSAzXSA9IFwiYm9vbFwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiYmluYXJ5XCJdID0gNF0gPSBcImJpbmFyeVwiO1xuICAgIERhdGFUeXBlW0RhdGFUeXBlW1wiZmxvYXRcIl0gPSA1XSA9IFwiZmxvYXRcIjtcbn0pKERhdGFUeXBlID0gZXhwb3J0cy5EYXRhVHlwZSB8fCAoZXhwb3J0cy5EYXRhVHlwZSA9IHt9KSk7XG52YXIgVGFyZ2V0VHlwZTtcbihmdW5jdGlvbiAoVGFyZ2V0VHlwZSkge1xuICAgIFRhcmdldFR5cGVbVGFyZ2V0VHlwZVtcInNob3RcIl0gPSAxMF0gPSBcInNob3RcIjtcbiAgICBUYXJnZXRUeXBlW1RhcmdldFR5cGVbXCJzY2VuZVwiXSA9IDIwXSA9IFwic2NlbmVcIjtcbiAgICBUYXJnZXRUeXBlW1RhcmdldFR5cGVbXCJ0cmFja1wiXSA9IDMwXSA9IFwidHJhY2tcIjtcbiAgICBUYXJnZXRUeXBlW1RhcmdldFR5cGVbXCJwYXJ0XCJdID0gNDBdID0gXCJwYXJ0XCI7XG4gICAgVGFyZ2V0VHlwZVtUYXJnZXRUeXBlW1wiYWxidW1cIl0gPSA1MF0gPSBcImFsYnVtXCI7XG4gICAgVGFyZ2V0VHlwZVtUYXJnZXRUeXBlW1wiZWRpdGlvblwiXSA9IDYwXSA9IFwiZWRpdGlvblwiO1xuICAgIFRhcmdldFR5cGVbVGFyZ2V0VHlwZVtcImNvbGxlY3Rpb25cIl0gPSA3MF0gPSBcImNvbGxlY3Rpb25cIjtcbn0pKFRhcmdldFR5cGUgPSBleHBvcnRzLlRhcmdldFR5cGUgfHwgKGV4cG9ydHMuVGFyZ2V0VHlwZSA9IHt9KSk7XG52YXIgVHJhY2tUeXBlO1xuKGZ1bmN0aW9uIChUcmFja1R5cGUpIHtcbiAgICBUcmFja1R5cGVbVHJhY2tUeXBlW1widmlkZW9cIl0gPSAxXSA9IFwidmlkZW9cIjtcbiAgICBUcmFja1R5cGVbVHJhY2tUeXBlW1wiYXVkaW9cIl0gPSAyXSA9IFwiYXVkaW9cIjtcbiAgICBUcmFja1R5cGVbVHJhY2tUeXBlW1wiY29tcGxleFwiXSA9IDNdID0gXCJjb21wbGV4XCI7XG4gICAgVHJhY2tUeXBlW1RyYWNrVHlwZVtcImxvZ29cIl0gPSA0XSA9IFwibG9nb1wiO1xuICAgIFRyYWNrVHlwZVtUcmFja1R5cGVbXCJzdWJ0aXRsZVwiXSA9IDE3XSA9IFwic3VidGl0bGVcIjtcbiAgICBUcmFja1R5cGVbVHJhY2tUeXBlW1wiYnV0dG9uXCJdID0gMThdID0gXCJidXR0b25cIjtcbiAgICBUcmFja1R5cGVbVHJhY2tUeXBlW1wiY29udHJvbFwiXSA9IDMyXSA9IFwiY29udHJvbFwiO1xufSkoVHJhY2tUeXBlID0gZXhwb3J0cy5UcmFja1R5cGUgfHwgKGV4cG9ydHMuVHJhY2tUeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/matroska/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/mp4/Atom.js":
/*!*****************************************************!*\
  !*** ./node_modules/music-metadata/lib/mp4/Atom.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Atom = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst AtomToken = __webpack_require__(/*! ./AtomToken */ \"(app-pages-browser)/./node_modules/music-metadata/lib/mp4/AtomToken.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:MP4:Atom');\nclass Atom {\n    static async readAtom(tokenizer, dataHandler, parent, remaining) {\n        // Parse atom header\n        const offset = tokenizer.position;\n        // debug(`Reading next token on offset=${offset}...`); //  buf.toString('ascii')\n        const header = await tokenizer.readToken(AtomToken.Header);\n        const extended = header.length === BigInt(1);\n        if (extended) {\n            header.length = await tokenizer.readToken(AtomToken.ExtendedSize);\n        }\n        const atomBean = new Atom(header, header.length === BigInt(1), parent);\n        const payloadLength = atomBean.getPayloadLength(remaining);\n        debug(`parse atom name=${atomBean.atomPath}, extended=${atomBean.extended}, offset=${offset}, len=${atomBean.header.length}`); //  buf.toString('ascii')\n        await atomBean.readData(tokenizer, dataHandler, payloadLength);\n        return atomBean;\n    }\n    constructor(header, extended, parent) {\n        this.header = header;\n        this.extended = extended;\n        this.parent = parent;\n        this.children = [];\n        this.atomPath = (this.parent ? this.parent.atomPath + '.' : '') + this.header.name;\n    }\n    getHeaderLength() {\n        return this.extended ? 16 : 8;\n    }\n    getPayloadLength(remaining) {\n        return (this.header.length === BigInt(0) ? remaining : Number(this.header.length)) - this.getHeaderLength();\n    }\n    async readAtoms(tokenizer, dataHandler, size) {\n        while (size > 0) {\n            const atomBean = await Atom.readAtom(tokenizer, dataHandler, this, size);\n            this.children.push(atomBean);\n            size -= atomBean.header.length === BigInt(0) ? size : Number(atomBean.header.length);\n        }\n    }\n    async readData(tokenizer, dataHandler, remaining) {\n        switch (this.header.name) {\n            // \"Container\" atoms, contains nested atoms\n            case 'moov': // The Movie Atom: contains other atoms\n            case 'udta': // User defined atom\n            case 'trak':\n            case 'mdia': // Media atom\n            case 'minf': // Media Information Atom\n            case 'stbl': // The Sample Table Atom\n            case '<id>':\n            case 'ilst':\n            case 'tref':\n                return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining));\n            case 'meta': // Metadata Atom, ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n                // meta has 4 bytes of padding, ignore\n                const peekHeader = await tokenizer.peekToken(AtomToken.Header);\n                const paddingLength = peekHeader.name === 'hdlr' ? 0 : 4;\n                await tokenizer.ignore(paddingLength);\n                return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining) - paddingLength);\n            case 'mdhd': // Media header atom\n            case 'mvhd': // 'movie' => 'mvhd': movie header atom; child of Movie Atom\n            case 'tkhd':\n            case 'stsz':\n            case 'mdat':\n            default:\n                return dataHandler(this, remaining);\n        }\n    }\n}\nexports.Atom = Atom;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXA0L0F0b20uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFPO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLDJGQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTyxPQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQixhQUFhLGtCQUFrQixXQUFXLE9BQU8sUUFBUSx1QkFBdUIsSUFBSTtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL21wNC9BdG9tLmpzPzhmMDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkF0b20gPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgQXRvbVRva2VuID0gcmVxdWlyZShcIi4vQXRvbVRva2VuXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbXVzaWMtbWV0YWRhdGE6cGFyc2VyOk1QNDpBdG9tJyk7XG5jbGFzcyBBdG9tIHtcbiAgICBzdGF0aWMgYXN5bmMgcmVhZEF0b20odG9rZW5pemVyLCBkYXRhSGFuZGxlciwgcGFyZW50LCByZW1haW5pbmcpIHtcbiAgICAgICAgLy8gUGFyc2UgYXRvbSBoZWFkZXJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdG9rZW5pemVyLnBvc2l0aW9uO1xuICAgICAgICAvLyBkZWJ1ZyhgUmVhZGluZyBuZXh0IHRva2VuIG9uIG9mZnNldD0ke29mZnNldH0uLi5gKTsgLy8gIGJ1Zi50b1N0cmluZygnYXNjaWknKVxuICAgICAgICBjb25zdCBoZWFkZXIgPSBhd2FpdCB0b2tlbml6ZXIucmVhZFRva2VuKEF0b21Ub2tlbi5IZWFkZXIpO1xuICAgICAgICBjb25zdCBleHRlbmRlZCA9IGhlYWRlci5sZW5ndGggPT09IEJpZ0ludCgxKTtcbiAgICAgICAgaWYgKGV4dGVuZGVkKSB7XG4gICAgICAgICAgICBoZWFkZXIubGVuZ3RoID0gYXdhaXQgdG9rZW5pemVyLnJlYWRUb2tlbihBdG9tVG9rZW4uRXh0ZW5kZWRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdG9tQmVhbiA9IG5ldyBBdG9tKGhlYWRlciwgaGVhZGVyLmxlbmd0aCA9PT0gQmlnSW50KDEpLCBwYXJlbnQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkTGVuZ3RoID0gYXRvbUJlYW4uZ2V0UGF5bG9hZExlbmd0aChyZW1haW5pbmcpO1xuICAgICAgICBkZWJ1ZyhgcGFyc2UgYXRvbSBuYW1lPSR7YXRvbUJlYW4uYXRvbVBhdGh9LCBleHRlbmRlZD0ke2F0b21CZWFuLmV4dGVuZGVkfSwgb2Zmc2V0PSR7b2Zmc2V0fSwgbGVuPSR7YXRvbUJlYW4uaGVhZGVyLmxlbmd0aH1gKTsgLy8gIGJ1Zi50b1N0cmluZygnYXNjaWknKVxuICAgICAgICBhd2FpdCBhdG9tQmVhbi5yZWFkRGF0YSh0b2tlbml6ZXIsIGRhdGFIYW5kbGVyLCBwYXlsb2FkTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGF0b21CZWFuO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihoZWFkZXIsIGV4dGVuZGVkLCBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5oZWFkZXIgPSBoZWFkZXI7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWQgPSBleHRlbmRlZDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5hdG9tUGF0aCA9ICh0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmF0b21QYXRoICsgJy4nIDogJycpICsgdGhpcy5oZWFkZXIubmFtZTtcbiAgICB9XG4gICAgZ2V0SGVhZGVyTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlbmRlZCA/IDE2IDogODtcbiAgICB9XG4gICAgZ2V0UGF5bG9hZExlbmd0aChyZW1haW5pbmcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmhlYWRlci5sZW5ndGggPT09IEJpZ0ludCgwKSA/IHJlbWFpbmluZyA6IE51bWJlcih0aGlzLmhlYWRlci5sZW5ndGgpKSAtIHRoaXMuZ2V0SGVhZGVyTGVuZ3RoKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRBdG9tcyh0b2tlbml6ZXIsIGRhdGFIYW5kbGVyLCBzaXplKSB7XG4gICAgICAgIHdoaWxlIChzaXplID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYXRvbUJlYW4gPSBhd2FpdCBBdG9tLnJlYWRBdG9tKHRva2VuaXplciwgZGF0YUhhbmRsZXIsIHRoaXMsIHNpemUpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGF0b21CZWFuKTtcbiAgICAgICAgICAgIHNpemUgLT0gYXRvbUJlYW4uaGVhZGVyLmxlbmd0aCA9PT0gQmlnSW50KDApID8gc2l6ZSA6IE51bWJlcihhdG9tQmVhbi5oZWFkZXIubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZWFkRGF0YSh0b2tlbml6ZXIsIGRhdGFIYW5kbGVyLCByZW1haW5pbmcpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmhlYWRlci5uYW1lKSB7XG4gICAgICAgICAgICAvLyBcIkNvbnRhaW5lclwiIGF0b21zLCBjb250YWlucyBuZXN0ZWQgYXRvbXNcbiAgICAgICAgICAgIGNhc2UgJ21vb3YnOiAvLyBUaGUgTW92aWUgQXRvbTogY29udGFpbnMgb3RoZXIgYXRvbXNcbiAgICAgICAgICAgIGNhc2UgJ3VkdGEnOiAvLyBVc2VyIGRlZmluZWQgYXRvbVxuICAgICAgICAgICAgY2FzZSAndHJhayc6XG4gICAgICAgICAgICBjYXNlICdtZGlhJzogLy8gTWVkaWEgYXRvbVxuICAgICAgICAgICAgY2FzZSAnbWluZic6IC8vIE1lZGlhIEluZm9ybWF0aW9uIEF0b21cbiAgICAgICAgICAgIGNhc2UgJ3N0YmwnOiAvLyBUaGUgU2FtcGxlIFRhYmxlIEF0b21cbiAgICAgICAgICAgIGNhc2UgJzxpZD4nOlxuICAgICAgICAgICAgY2FzZSAnaWxzdCc6XG4gICAgICAgICAgICBjYXNlICd0cmVmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkQXRvbXModG9rZW5pemVyLCBkYXRhSGFuZGxlciwgdGhpcy5nZXRQYXlsb2FkTGVuZ3RoKHJlbWFpbmluZykpO1xuICAgICAgICAgICAgY2FzZSAnbWV0YSc6IC8vIE1ldGFkYXRhIEF0b20sIHJlZjogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvY29udGVudC9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL01ldGFkYXRhL01ldGFkYXRhLmh0bWwjLy9hcHBsZV9yZWYvZG9jL3VpZC9UUDQwMDAwOTM5LUNIMS1TVzhcbiAgICAgICAgICAgICAgICAvLyBtZXRhIGhhcyA0IGJ5dGVzIG9mIHBhZGRpbmcsIGlnbm9yZVxuICAgICAgICAgICAgICAgIGNvbnN0IHBlZWtIZWFkZXIgPSBhd2FpdCB0b2tlbml6ZXIucGVla1Rva2VuKEF0b21Ub2tlbi5IZWFkZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdMZW5ndGggPSBwZWVrSGVhZGVyLm5hbWUgPT09ICdoZGxyJyA/IDAgOiA0O1xuICAgICAgICAgICAgICAgIGF3YWl0IHRva2VuaXplci5pZ25vcmUocGFkZGluZ0xlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEF0b21zKHRva2VuaXplciwgZGF0YUhhbmRsZXIsIHRoaXMuZ2V0UGF5bG9hZExlbmd0aChyZW1haW5pbmcpIC0gcGFkZGluZ0xlbmd0aCk7XG4gICAgICAgICAgICBjYXNlICdtZGhkJzogLy8gTWVkaWEgaGVhZGVyIGF0b21cbiAgICAgICAgICAgIGNhc2UgJ212aGQnOiAvLyAnbW92aWUnID0+ICdtdmhkJzogbW92aWUgaGVhZGVyIGF0b207IGNoaWxkIG9mIE1vdmllIEF0b21cbiAgICAgICAgICAgIGNhc2UgJ3RraGQnOlxuICAgICAgICAgICAgY2FzZSAnc3Rzeic6XG4gICAgICAgICAgICBjYXNlICdtZGF0JzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFIYW5kbGVyKHRoaXMsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkF0b20gPSBBdG9tO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/mp4/Atom.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/mp4/AtomToken.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/mp4/AtomToken.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChapterText = exports.StcoAtom = exports.StszAtom = exports.StscAtom = exports.SampleToChunkToken = exports.SttsAtom = exports.TimeToSampleToken = exports.SoundSampleDescriptionV0 = exports.SoundSampleDescriptionVersion = exports.StsdAtom = exports.TrackHeaderAtom = exports.NameAtom = exports.DataAtom = exports.MvhdAtom = exports.MdhdAtom = exports.FixedLengthAtom = exports.mhdr = exports.tkhd = exports.ftyp = exports.ExtendedSize = exports.Header = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/FourCC.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:MP4:atom');\nexports.Header = {\n    len: 8,\n    get: (buf, off) => {\n        const length = Token.UINT32_BE.get(buf, off);\n        if (length < 0)\n            throw new Error('Invalid atom header length');\n        return {\n            length: BigInt(length),\n            name: new Token.StringType(4, 'binary').get(buf, off + 4)\n        };\n    },\n    put: (buf, off, hdr) => {\n        Token.UINT32_BE.put(buf, off, Number(hdr.length));\n        return FourCC_1.FourCcToken.put(buf, off + 4, hdr.name);\n    }\n};\n/**\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap1/qtff1.html#//apple_ref/doc/uid/TP40000939-CH203-38190\n */\nexports.ExtendedSize = Token.UINT64_BE;\nexports.ftyp = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            type: new Token.StringType(4, 'ascii').get(buf, off)\n        };\n    }\n};\nexports.tkhd = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            type: new Token.StringType(4, 'ascii').get(buf, off)\n        };\n    }\n};\n/**\n * Token: Movie Header Atom\n */\nexports.mhdr = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            nextItemID: Token.UINT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Base class for 'fixed' length atoms.\n * In some cases these atoms are longer then the sum of the described fields.\n * Issue: https://github.com/Borewit/music-metadata/issues/120\n */\nclass FixedLengthAtom {\n    /**\n     *\n     * @param {number} len Length as specified in the size field\n     * @param {number} expLen Total length of sum of specified fields in the standard\n     */\n    constructor(len, expLen, atomId) {\n        this.len = len;\n        if (len < expLen) {\n            throw new Error(`Atom ${atomId} expected to be ${expLen}, but specifies ${len} bytes long.`);\n        }\n        else if (len > expLen) {\n            debug(`Warning: atom ${atomId} expected to be ${expLen}, but was actually ${len} bytes long.`);\n        }\n    }\n}\nexports.FixedLengthAtom = FixedLengthAtom;\n/**\n * Timestamp stored in seconds since Mac Epoch (1 January 1904)\n */\nconst SecondsSinceMacEpoch = {\n    len: 4,\n    get: (buf, off) => {\n        const secondsSinceUnixEpoch = Token.UINT32_BE.get(buf, off) - 2082844800;\n        return new Date(secondsSinceUnixEpoch * 1000);\n    }\n};\n/**\n * Token: Media Header Atom\n * Ref:\n * - https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW34\n * - https://wiki.multimedia.cx/index.php/QuickTime_container#mdhd\n */\nclass MdhdAtom extends FixedLengthAtom {\n    constructor(len) {\n        super(len, 24, 'mdhd');\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off + 0),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),\n            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),\n            timeScale: Token.UINT32_BE.get(buf, off + 12),\n            duration: Token.UINT32_BE.get(buf, off + 16),\n            language: Token.UINT16_BE.get(buf, off + 20),\n            quality: Token.UINT16_BE.get(buf, off + 22)\n        };\n    }\n}\nexports.MdhdAtom = MdhdAtom;\n/**\n * Token: Movie Header Atom\n */\nclass MvhdAtom extends FixedLengthAtom {\n    constructor(len) {\n        super(len, 100, 'mvhd');\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),\n            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),\n            timeScale: Token.UINT32_BE.get(buf, off + 12),\n            duration: Token.UINT32_BE.get(buf, off + 16),\n            preferredRate: Token.UINT32_BE.get(buf, off + 20),\n            preferredVolume: Token.UINT16_BE.get(buf, off + 24),\n            // ignore reserver: 10 bytes\n            // ignore matrix structure: 36 bytes\n            previewTime: Token.UINT32_BE.get(buf, off + 72),\n            previewDuration: Token.UINT32_BE.get(buf, off + 76),\n            posterTime: Token.UINT32_BE.get(buf, off + 80),\n            selectionTime: Token.UINT32_BE.get(buf, off + 84),\n            selectionDuration: Token.UINT32_BE.get(buf, off + 88),\n            currentTime: Token.UINT32_BE.get(buf, off + 92),\n            nextTrackID: Token.UINT32_BE.get(buf, off + 96)\n        };\n    }\n}\nexports.MvhdAtom = MvhdAtom;\n/**\n * Data Atom Structure\n */\nclass DataAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            type: {\n                set: Token.UINT8.get(buf, off + 0),\n                type: Token.UINT24_BE.get(buf, off + 1)\n            },\n            locale: Token.UINT24_BE.get(buf, off + 4),\n            value: Buffer.from(new Token.Uint8ArrayType(this.len - 8).get(buf, off + 8))\n        };\n    }\n}\nexports.DataAtom = DataAtom;\n/**\n * Data Atom Structure\n * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW31\n */\nclass NameAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            name: new Token.StringType(this.len - 4, 'utf-8').get(buf, off + 4)\n        };\n    }\n}\nexports.NameAtom = NameAtom;\n/**\n * Track Header Atoms structure\n * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25550\n */\nclass TrackHeaderAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),\n            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),\n            trackId: Token.UINT32_BE.get(buf, off + 12),\n            // reserved 4 bytes\n            duration: Token.UINT32_BE.get(buf, off + 20),\n            layer: Token.UINT16_BE.get(buf, off + 24),\n            alternateGroup: Token.UINT16_BE.get(buf, off + 26),\n            volume: Token.UINT16_BE.get(buf, off + 28) // ToDo: fixed point\n            // ToDo: add remaining fields\n        };\n    }\n}\nexports.TrackHeaderAtom = TrackHeaderAtom;\n/**\n * Atom: Sample Description Atom ('stsd')\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691\n */\nconst stsdHeader = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            version: Token.UINT8.get(buf, off),\n            flags: Token.UINT24_BE.get(buf, off + 1),\n            numberOfEntries: Token.UINT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Atom: Sample Description Atom ('stsd')\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691\n */\nclass SampleDescriptionTable {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        return {\n            dataFormat: FourCC_1.FourCcToken.get(buf, off),\n            dataReferenceIndex: Token.UINT16_BE.get(buf, off + 10),\n            description: new Token.Uint8ArrayType(this.len - 12).get(buf, off + 12)\n        };\n    }\n}\n/**\n * Atom: Sample-description Atom ('stsd')\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691\n */\nclass StsdAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const header = stsdHeader.get(buf, off);\n        off += stsdHeader.len;\n        const table = [];\n        for (let n = 0; n < header.numberOfEntries; ++n) {\n            const size = Token.UINT32_BE.get(buf, off); // Sample description size\n            off += Token.UINT32_BE.len;\n            table.push(new SampleDescriptionTable(size).get(buf, off));\n            off += size;\n        }\n        return {\n            header,\n            table\n        };\n    }\n}\nexports.StsdAtom = StsdAtom;\n/**\n * Common Sound Sample Description (version & revision)\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-57317\n */\nexports.SoundSampleDescriptionVersion = {\n    len: 8,\n    get(buf, off) {\n        return {\n            version: Token.INT16_BE.get(buf, off),\n            revision: Token.INT16_BE.get(buf, off + 2),\n            vendor: Token.INT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Sound Sample Description (Version 0)\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-130736\n */\nexports.SoundSampleDescriptionV0 = {\n    len: 12,\n    get(buf, off) {\n        return {\n            numAudioChannels: Token.INT16_BE.get(buf, off + 0),\n            sampleSize: Token.INT16_BE.get(buf, off + 2),\n            compressionId: Token.INT16_BE.get(buf, off + 4),\n            packetSize: Token.INT16_BE.get(buf, off + 6),\n            sampleRate: Token.UINT16_BE.get(buf, off + 8) + Token.UINT16_BE.get(buf, off + 10) / 10000\n        };\n    }\n};\nclass SimpleTableAtom {\n    constructor(len, token) {\n        this.len = len;\n        this.token = token;\n    }\n    get(buf, off) {\n        const nrOfEntries = Token.INT32_BE.get(buf, off + 4);\n        return {\n            version: Token.INT8.get(buf, off + 0),\n            flags: Token.INT24_BE.get(buf, off + 1),\n            numberOfEntries: nrOfEntries,\n            entries: readTokenTable(buf, this.token, off + 8, this.len - 8, nrOfEntries)\n        };\n    }\n}\nexports.TimeToSampleToken = {\n    len: 8,\n    get(buf, off) {\n        return {\n            count: Token.INT32_BE.get(buf, off + 0),\n            duration: Token.INT32_BE.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Time-to-sample('stts') atom.\n * Store duration information for a media’s samples.\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25696\n */\nclass SttsAtom extends SimpleTableAtom {\n    constructor(len) {\n        super(len, exports.TimeToSampleToken);\n        this.len = len;\n    }\n}\nexports.SttsAtom = SttsAtom;\nexports.SampleToChunkToken = {\n    len: 12,\n    get(buf, off) {\n        return {\n            firstChunk: Token.INT32_BE.get(buf, off),\n            samplesPerChunk: Token.INT32_BE.get(buf, off + 4),\n            sampleDescriptionId: Token.INT32_BE.get(buf, off + 8)\n        };\n    }\n};\n/**\n * Sample-to-Chunk ('stsc') atom interface\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25706\n */\nclass StscAtom extends SimpleTableAtom {\n    constructor(len) {\n        super(len, exports.SampleToChunkToken);\n        this.len = len;\n    }\n}\nexports.StscAtom = StscAtom;\n/**\n * Sample-size ('stsz') atom\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25710\n */\nclass StszAtom {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const nrOfEntries = Token.INT32_BE.get(buf, off + 8);\n        return {\n            version: Token.INT8.get(buf, off),\n            flags: Token.INT24_BE.get(buf, off + 1),\n            sampleSize: Token.INT32_BE.get(buf, off + 4),\n            numberOfEntries: nrOfEntries,\n            entries: readTokenTable(buf, Token.INT32_BE, off + 12, this.len - 12, nrOfEntries)\n        };\n    }\n}\nexports.StszAtom = StszAtom;\n/**\n * Chunk offset atom, 'stco'\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25715\n */\nclass StcoAtom extends SimpleTableAtom {\n    constructor(len) {\n        super(len, Token.INT32_BE);\n        this.len = len;\n    }\n}\nexports.StcoAtom = StcoAtom;\n/**\n * Token used to decode text-track from 'mdat' atom (raw data stream)\n */\nclass ChapterText {\n    constructor(len) {\n        this.len = len;\n    }\n    get(buf, off) {\n        const titleLen = Token.INT16_BE.get(buf, off + 0);\n        const str = new Token.StringType(titleLen, 'utf-8');\n        return str.get(buf, off + 2);\n    }\n}\nexports.ChapterText = ChapterText;\nfunction readTokenTable(buf, token, off, remainingLen, numberOfEntries) {\n    debug(`remainingLen=${remainingLen}, numberOfEntries=${numberOfEntries} * token-len=${token.len}`);\n    if (remainingLen === 0)\n        return [];\n    if (remainingLen !== numberOfEntries * token.len)\n        throw new Error('mismatch number-of-entries with remaining atom-length');\n    const entries = [];\n    // parse offset-table\n    for (let n = 0; n < numberOfEntries; ++n) {\n        entries.push(token.get(buf, off));\n        off += token.len;\n    }\n    return entries;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXA0L0F0b21Ub2tlbi5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsMEJBQTBCLEdBQUcsZ0JBQWdCLEdBQUcseUJBQXlCLEdBQUcsZ0NBQWdDLEdBQUcscUNBQXFDLEdBQUcsZ0JBQWdCLEdBQUcsdUJBQXVCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsdUJBQXVCLEdBQUcsWUFBWSxHQUFHLFlBQVksR0FBRyxZQUFZLEdBQUcsb0JBQW9CLEdBQUcsY0FBYztBQUMzYyxjQUFjLG1CQUFPLENBQUMsZ0ZBQWE7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQU87QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsZ0dBQWtCO0FBQzNDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRLGlCQUFpQixPQUFPLGtCQUFrQixLQUFLO0FBQzNGO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUSxpQkFBaUIsT0FBTyxxQkFBcUIsS0FBSztBQUM3RjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRCx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSwwQkFBMEIsYUFBYSxvQkFBb0IsaUJBQWlCLGNBQWMsVUFBVTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9tcDQvQXRvbVRva2VuLmpzPzhiYWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoYXB0ZXJUZXh0ID0gZXhwb3J0cy5TdGNvQXRvbSA9IGV4cG9ydHMuU3RzekF0b20gPSBleHBvcnRzLlN0c2NBdG9tID0gZXhwb3J0cy5TYW1wbGVUb0NodW5rVG9rZW4gPSBleHBvcnRzLlN0dHNBdG9tID0gZXhwb3J0cy5UaW1lVG9TYW1wbGVUb2tlbiA9IGV4cG9ydHMuU291bmRTYW1wbGVEZXNjcmlwdGlvblYwID0gZXhwb3J0cy5Tb3VuZFNhbXBsZURlc2NyaXB0aW9uVmVyc2lvbiA9IGV4cG9ydHMuU3RzZEF0b20gPSBleHBvcnRzLlRyYWNrSGVhZGVyQXRvbSA9IGV4cG9ydHMuTmFtZUF0b20gPSBleHBvcnRzLkRhdGFBdG9tID0gZXhwb3J0cy5NdmhkQXRvbSA9IGV4cG9ydHMuTWRoZEF0b20gPSBleHBvcnRzLkZpeGVkTGVuZ3RoQXRvbSA9IGV4cG9ydHMubWhkciA9IGV4cG9ydHMudGtoZCA9IGV4cG9ydHMuZnR5cCA9IGV4cG9ydHMuRXh0ZW5kZWRTaXplID0gZXhwb3J0cy5IZWFkZXIgPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBGb3VyQ0NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vRm91ckNDXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbXVzaWMtbWV0YWRhdGE6cGFyc2VyOk1QNDphdG9tJyk7XG5leHBvcnRzLkhlYWRlciA9IHtcbiAgICBsZW46IDgsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gVG9rZW4uVUlOVDMyX0JFLmdldChidWYsIG9mZik7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGF0b20gaGVhZGVyIGxlbmd0aCcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVuZ3RoOiBCaWdJbnQobGVuZ3RoKSxcbiAgICAgICAgICAgIG5hbWU6IG5ldyBUb2tlbi5TdHJpbmdUeXBlKDQsICdiaW5hcnknKS5nZXQoYnVmLCBvZmYgKyA0KVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcHV0OiAoYnVmLCBvZmYsIGhkcikgPT4ge1xuICAgICAgICBUb2tlbi5VSU5UMzJfQkUucHV0KGJ1Ziwgb2ZmLCBOdW1iZXIoaGRyLmxlbmd0aCkpO1xuICAgICAgICByZXR1cm4gRm91ckNDXzEuRm91ckNjVG9rZW4ucHV0KGJ1Ziwgb2ZmICsgNCwgaGRyLm5hbWUpO1xuICAgIH1cbn07XG4vKipcbiAqIFJlZjogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL1FURkZDaGFwMS9xdGZmMS5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDIwMy0zODE5MFxuICovXG5leHBvcnRzLkV4dGVuZGVkU2l6ZSA9IFRva2VuLlVJTlQ2NF9CRTtcbmV4cG9ydHMuZnR5cCA9IHtcbiAgICBsZW46IDQsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IG5ldyBUb2tlbi5TdHJpbmdUeXBlKDQsICdhc2NpaScpLmdldChidWYsIG9mZilcbiAgICAgICAgfTtcbiAgICB9XG59O1xuZXhwb3J0cy50a2hkID0ge1xuICAgIGxlbjogNCxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogbmV3IFRva2VuLlN0cmluZ1R5cGUoNCwgJ2FzY2lpJykuZ2V0KGJ1Ziwgb2ZmKVxuICAgICAgICB9O1xuICAgIH1cbn07XG4vKipcbiAqIFRva2VuOiBNb3ZpZSBIZWFkZXIgQXRvbVxuICovXG5leHBvcnRzLm1oZHIgPSB7XG4gICAgbGVuOiA4LFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiBUb2tlbi5VSU5UOC5nZXQoYnVmLCBvZmYpLFxuICAgICAgICAgICAgZmxhZ3M6IFRva2VuLlVJTlQyNF9CRS5nZXQoYnVmLCBvZmYgKyAxKSxcbiAgICAgICAgICAgIG5leHRJdGVtSUQ6IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyA0KVxuICAgICAgICB9O1xuICAgIH1cbn07XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yICdmaXhlZCcgbGVuZ3RoIGF0b21zLlxuICogSW4gc29tZSBjYXNlcyB0aGVzZSBhdG9tcyBhcmUgbG9uZ2VyIHRoZW4gdGhlIHN1bSBvZiB0aGUgZGVzY3JpYmVkIGZpZWxkcy5cbiAqIElzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vQm9yZXdpdC9tdXNpYy1tZXRhZGF0YS9pc3N1ZXMvMTIwXG4gKi9cbmNsYXNzIEZpeGVkTGVuZ3RoQXRvbSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuIExlbmd0aCBhcyBzcGVjaWZpZWQgaW4gdGhlIHNpemUgZmllbGRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwTGVuIFRvdGFsIGxlbmd0aCBvZiBzdW0gb2Ygc3BlY2lmaWVkIGZpZWxkcyBpbiB0aGUgc3RhbmRhcmRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihsZW4sIGV4cExlbiwgYXRvbUlkKSB7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgICAgICBpZiAobGVuIDwgZXhwTGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0b20gJHthdG9tSWR9IGV4cGVjdGVkIHRvIGJlICR7ZXhwTGVufSwgYnV0IHNwZWNpZmllcyAke2xlbn0gYnl0ZXMgbG9uZy5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPiBleHBMZW4pIHtcbiAgICAgICAgICAgIGRlYnVnKGBXYXJuaW5nOiBhdG9tICR7YXRvbUlkfSBleHBlY3RlZCB0byBiZSAke2V4cExlbn0sIGJ1dCB3YXMgYWN0dWFsbHkgJHtsZW59IGJ5dGVzIGxvbmcuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkZpeGVkTGVuZ3RoQXRvbSA9IEZpeGVkTGVuZ3RoQXRvbTtcbi8qKlxuICogVGltZXN0YW1wIHN0b3JlZCBpbiBzZWNvbmRzIHNpbmNlIE1hYyBFcG9jaCAoMSBKYW51YXJ5IDE5MDQpXG4gKi9cbmNvbnN0IFNlY29uZHNTaW5jZU1hY0Vwb2NoID0ge1xuICAgIGxlbjogNCxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICBjb25zdCBzZWNvbmRzU2luY2VVbml4RXBvY2ggPSBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmKSAtIDIwODI4NDQ4MDA7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShzZWNvbmRzU2luY2VVbml4RXBvY2ggKiAxMDAwKTtcbiAgICB9XG59O1xuLyoqXG4gKiBUb2tlbjogTWVkaWEgSGVhZGVyIEF0b21cbiAqIFJlZjpcbiAqIC0gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL1FURkZDaGFwMi9xdGZmMi5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDIwNC1TVzM0XG4gKiAtIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocC9RdWlja1RpbWVfY29udGFpbmVyI21kaGRcbiAqL1xuY2xhc3MgTWRoZEF0b20gZXh0ZW5kcyBGaXhlZExlbmd0aEF0b20ge1xuICAgIGNvbnN0cnVjdG9yKGxlbikge1xuICAgICAgICBzdXBlcihsZW4sIDI0LCAnbWRoZCcpO1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB9XG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiBUb2tlbi5VSU5UOC5nZXQoYnVmLCBvZmYgKyAwKSxcbiAgICAgICAgICAgIGZsYWdzOiBUb2tlbi5VSU5UMjRfQkUuZ2V0KGJ1Ziwgb2ZmICsgMSksXG4gICAgICAgICAgICBjcmVhdGlvblRpbWU6IFNlY29uZHNTaW5jZU1hY0Vwb2NoLmdldChidWYsIG9mZiArIDQpLFxuICAgICAgICAgICAgbW9kaWZpY2F0aW9uVGltZTogU2Vjb25kc1NpbmNlTWFjRXBvY2guZ2V0KGJ1Ziwgb2ZmICsgOCksXG4gICAgICAgICAgICB0aW1lU2NhbGU6IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyAxMiksXG4gICAgICAgICAgICBkdXJhdGlvbjogVG9rZW4uVUlOVDMyX0JFLmdldChidWYsIG9mZiArIDE2KSxcbiAgICAgICAgICAgIGxhbmd1YWdlOiBUb2tlbi5VSU5UMTZfQkUuZ2V0KGJ1Ziwgb2ZmICsgMjApLFxuICAgICAgICAgICAgcXVhbGl0eTogVG9rZW4uVUlOVDE2X0JFLmdldChidWYsIG9mZiArIDIyKVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTWRoZEF0b20gPSBNZGhkQXRvbTtcbi8qKlxuICogVG9rZW46IE1vdmllIEhlYWRlciBBdG9tXG4gKi9cbmNsYXNzIE12aGRBdG9tIGV4dGVuZHMgRml4ZWRMZW5ndGhBdG9tIHtcbiAgICBjb25zdHJ1Y3RvcihsZW4pIHtcbiAgICAgICAgc3VwZXIobGVuLCAxMDAsICdtdmhkJyk7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IFRva2VuLlVJTlQ4LmdldChidWYsIG9mZiksXG4gICAgICAgICAgICBmbGFnczogVG9rZW4uVUlOVDI0X0JFLmdldChidWYsIG9mZiArIDEpLFxuICAgICAgICAgICAgY3JlYXRpb25UaW1lOiBTZWNvbmRzU2luY2VNYWNFcG9jaC5nZXQoYnVmLCBvZmYgKyA0KSxcbiAgICAgICAgICAgIG1vZGlmaWNhdGlvblRpbWU6IFNlY29uZHNTaW5jZU1hY0Vwb2NoLmdldChidWYsIG9mZiArIDgpLFxuICAgICAgICAgICAgdGltZVNjYWxlOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgMTIpLFxuICAgICAgICAgICAgZHVyYXRpb246IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyAxNiksXG4gICAgICAgICAgICBwcmVmZXJyZWRSYXRlOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgMjApLFxuICAgICAgICAgICAgcHJlZmVycmVkVm9sdW1lOiBUb2tlbi5VSU5UMTZfQkUuZ2V0KGJ1Ziwgb2ZmICsgMjQpLFxuICAgICAgICAgICAgLy8gaWdub3JlIHJlc2VydmVyOiAxMCBieXRlc1xuICAgICAgICAgICAgLy8gaWdub3JlIG1hdHJpeCBzdHJ1Y3R1cmU6IDM2IGJ5dGVzXG4gICAgICAgICAgICBwcmV2aWV3VGltZTogVG9rZW4uVUlOVDMyX0JFLmdldChidWYsIG9mZiArIDcyKSxcbiAgICAgICAgICAgIHByZXZpZXdEdXJhdGlvbjogVG9rZW4uVUlOVDMyX0JFLmdldChidWYsIG9mZiArIDc2KSxcbiAgICAgICAgICAgIHBvc3RlclRpbWU6IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyA4MCksXG4gICAgICAgICAgICBzZWxlY3Rpb25UaW1lOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgODQpLFxuICAgICAgICAgICAgc2VsZWN0aW9uRHVyYXRpb246IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyA4OCksXG4gICAgICAgICAgICBjdXJyZW50VGltZTogVG9rZW4uVUlOVDMyX0JFLmdldChidWYsIG9mZiArIDkyKSxcbiAgICAgICAgICAgIG5leHRUcmFja0lEOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgOTYpXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5NdmhkQXRvbSA9IE12aGRBdG9tO1xuLyoqXG4gKiBEYXRhIEF0b20gU3RydWN0dXJlXG4gKi9cbmNsYXNzIERhdGFBdG9tIHtcbiAgICBjb25zdHJ1Y3RvcihsZW4pIHtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgIHNldDogVG9rZW4uVUlOVDguZ2V0KGJ1Ziwgb2ZmICsgMCksXG4gICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uVUlOVDI0X0JFLmdldChidWYsIG9mZiArIDEpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbG9jYWxlOiBUb2tlbi5VSU5UMjRfQkUuZ2V0KGJ1Ziwgb2ZmICsgNCksXG4gICAgICAgICAgICB2YWx1ZTogQnVmZmVyLmZyb20obmV3IFRva2VuLlVpbnQ4QXJyYXlUeXBlKHRoaXMubGVuIC0gOCkuZ2V0KGJ1Ziwgb2ZmICsgOCkpXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5EYXRhQXRvbSA9IERhdGFBdG9tO1xuLyoqXG4gKiBEYXRhIEF0b20gU3RydWN0dXJlXG4gKiBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2NvbnRlbnQvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9NZXRhZGF0YS9NZXRhZGF0YS5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDEtU1czMVxuICovXG5jbGFzcyBOYW1lQXRvbSB7XG4gICAgY29uc3RydWN0b3IobGVuKSB7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IFRva2VuLlVJTlQ4LmdldChidWYsIG9mZiksXG4gICAgICAgICAgICBmbGFnczogVG9rZW4uVUlOVDI0X0JFLmdldChidWYsIG9mZiArIDEpLFxuICAgICAgICAgICAgbmFtZTogbmV3IFRva2VuLlN0cmluZ1R5cGUodGhpcy5sZW4gLSA0LCAndXRmLTgnKS5nZXQoYnVmLCBvZmYgKyA0KVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTmFtZUF0b20gPSBOYW1lQXRvbTtcbi8qKlxuICogVHJhY2sgSGVhZGVyIEF0b21zIHN0cnVjdHVyZVxuICogUmVmOiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9jb250ZW50L2RvY3VtZW50YXRpb24vUXVpY2tUaW1lL1FURkYvUVRGRkNoYXAyL3F0ZmYyLmh0bWwjLy9hcHBsZV9yZWYvZG9jL3VpZC9UUDQwMDAwOTM5LUNIMjA0LTI1NTUwXG4gKi9cbmNsYXNzIFRyYWNrSGVhZGVyQXRvbSB7XG4gICAgY29uc3RydWN0b3IobGVuKSB7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IFRva2VuLlVJTlQ4LmdldChidWYsIG9mZiksXG4gICAgICAgICAgICBmbGFnczogVG9rZW4uVUlOVDI0X0JFLmdldChidWYsIG9mZiArIDEpLFxuICAgICAgICAgICAgY3JlYXRpb25UaW1lOiBTZWNvbmRzU2luY2VNYWNFcG9jaC5nZXQoYnVmLCBvZmYgKyA0KSxcbiAgICAgICAgICAgIG1vZGlmaWNhdGlvblRpbWU6IFNlY29uZHNTaW5jZU1hY0Vwb2NoLmdldChidWYsIG9mZiArIDgpLFxuICAgICAgICAgICAgdHJhY2tJZDogVG9rZW4uVUlOVDMyX0JFLmdldChidWYsIG9mZiArIDEyKSxcbiAgICAgICAgICAgIC8vIHJlc2VydmVkIDQgYnl0ZXNcbiAgICAgICAgICAgIGR1cmF0aW9uOiBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgMjApLFxuICAgICAgICAgICAgbGF5ZXI6IFRva2VuLlVJTlQxNl9CRS5nZXQoYnVmLCBvZmYgKyAyNCksXG4gICAgICAgICAgICBhbHRlcm5hdGVHcm91cDogVG9rZW4uVUlOVDE2X0JFLmdldChidWYsIG9mZiArIDI2KSxcbiAgICAgICAgICAgIHZvbHVtZTogVG9rZW4uVUlOVDE2X0JFLmdldChidWYsIG9mZiArIDI4KSAvLyBUb0RvOiBmaXhlZCBwb2ludFxuICAgICAgICAgICAgLy8gVG9EbzogYWRkIHJlbWFpbmluZyBmaWVsZHNcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlRyYWNrSGVhZGVyQXRvbSA9IFRyYWNrSGVhZGVyQXRvbTtcbi8qKlxuICogQXRvbTogU2FtcGxlIERlc2NyaXB0aW9uIEF0b20gKCdzdHNkJylcbiAqIFJlZjogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL1FURkZDaGFwMi9xdGZmMi5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDIwNC0yNTY5MVxuICovXG5jb25zdCBzdHNkSGVhZGVyID0ge1xuICAgIGxlbjogOCxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogVG9rZW4uVUlOVDguZ2V0KGJ1Ziwgb2ZmKSxcbiAgICAgICAgICAgIGZsYWdzOiBUb2tlbi5VSU5UMjRfQkUuZ2V0KGJ1Ziwgb2ZmICsgMSksXG4gICAgICAgICAgICBudW1iZXJPZkVudHJpZXM6IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyA0KVxuICAgICAgICB9O1xuICAgIH1cbn07XG4vKipcbiAqIEF0b206IFNhbXBsZSBEZXNjcmlwdGlvbiBBdG9tICgnc3RzZCcpXG4gKiBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2FyY2hpdmUvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9RVEZGQ2hhcDIvcXRmZjIuaHRtbCMvL2FwcGxlX3JlZi9kb2MvdWlkL1RQNDAwMDA5MzktQ0gyMDQtMjU2OTFcbiAqL1xuY2xhc3MgU2FtcGxlRGVzY3JpcHRpb25UYWJsZSB7XG4gICAgY29uc3RydWN0b3IobGVuKSB7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGFGb3JtYXQ6IEZvdXJDQ18xLkZvdXJDY1Rva2VuLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICBkYXRhUmVmZXJlbmNlSW5kZXg6IFRva2VuLlVJTlQxNl9CRS5nZXQoYnVmLCBvZmYgKyAxMCksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogbmV3IFRva2VuLlVpbnQ4QXJyYXlUeXBlKHRoaXMubGVuIC0gMTIpLmdldChidWYsIG9mZiArIDEyKVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogQXRvbTogU2FtcGxlLWRlc2NyaXB0aW9uIEF0b20gKCdzdHNkJylcbiAqIFJlZjogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL1FURkZDaGFwMi9xdGZmMi5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDIwNC0yNTY5MVxuICovXG5jbGFzcyBTdHNkQXRvbSB7XG4gICAgY29uc3RydWN0b3IobGVuKSB7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gc3RzZEhlYWRlci5nZXQoYnVmLCBvZmYpO1xuICAgICAgICBvZmYgKz0gc3RzZEhlYWRlci5sZW47XG4gICAgICAgIGNvbnN0IHRhYmxlID0gW107XG4gICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgaGVhZGVyLm51bWJlck9mRW50cmllczsgKytuKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gVG9rZW4uVUlOVDMyX0JFLmdldChidWYsIG9mZik7IC8vIFNhbXBsZSBkZXNjcmlwdGlvbiBzaXplXG4gICAgICAgICAgICBvZmYgKz0gVG9rZW4uVUlOVDMyX0JFLmxlbjtcbiAgICAgICAgICAgIHRhYmxlLnB1c2gobmV3IFNhbXBsZURlc2NyaXB0aW9uVGFibGUoc2l6ZSkuZ2V0KGJ1Ziwgb2ZmKSk7XG4gICAgICAgICAgICBvZmYgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgdGFibGVcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlN0c2RBdG9tID0gU3RzZEF0b207XG4vKipcbiAqIENvbW1vbiBTb3VuZCBTYW1wbGUgRGVzY3JpcHRpb24gKHZlcnNpb24gJiByZXZpc2lvbilcbiAqIFJlZjogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL1FURkZDaGFwMy9xdGZmMy5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDIwNS01NzMxN1xuICovXG5leHBvcnRzLlNvdW5kU2FtcGxlRGVzY3JpcHRpb25WZXJzaW9uID0ge1xuICAgIGxlbjogOCxcbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IFRva2VuLklOVDE2X0JFLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICByZXZpc2lvbjogVG9rZW4uSU5UMTZfQkUuZ2V0KGJ1Ziwgb2ZmICsgMiksXG4gICAgICAgICAgICB2ZW5kb3I6IFRva2VuLklOVDMyX0JFLmdldChidWYsIG9mZiArIDQpXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogU291bmQgU2FtcGxlIERlc2NyaXB0aW9uIChWZXJzaW9uIDApXG4gKiBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2FyY2hpdmUvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9RVEZGQ2hhcDMvcXRmZjMuaHRtbCMvL2FwcGxlX3JlZi9kb2MvdWlkL1RQNDAwMDA5MzktQ0gyMDUtMTMwNzM2XG4gKi9cbmV4cG9ydHMuU291bmRTYW1wbGVEZXNjcmlwdGlvblYwID0ge1xuICAgIGxlbjogMTIsXG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBudW1BdWRpb0NoYW5uZWxzOiBUb2tlbi5JTlQxNl9CRS5nZXQoYnVmLCBvZmYgKyAwKSxcbiAgICAgICAgICAgIHNhbXBsZVNpemU6IFRva2VuLklOVDE2X0JFLmdldChidWYsIG9mZiArIDIpLFxuICAgICAgICAgICAgY29tcHJlc3Npb25JZDogVG9rZW4uSU5UMTZfQkUuZ2V0KGJ1Ziwgb2ZmICsgNCksXG4gICAgICAgICAgICBwYWNrZXRTaXplOiBUb2tlbi5JTlQxNl9CRS5nZXQoYnVmLCBvZmYgKyA2KSxcbiAgICAgICAgICAgIHNhbXBsZVJhdGU6IFRva2VuLlVJTlQxNl9CRS5nZXQoYnVmLCBvZmYgKyA4KSArIFRva2VuLlVJTlQxNl9CRS5nZXQoYnVmLCBvZmYgKyAxMCkgLyAxMDAwMFxuICAgICAgICB9O1xuICAgIH1cbn07XG5jbGFzcyBTaW1wbGVUYWJsZUF0b20ge1xuICAgIGNvbnN0cnVjdG9yKGxlbiwgdG9rZW4pIHtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB9XG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIGNvbnN0IG5yT2ZFbnRyaWVzID0gVG9rZW4uSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgNCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiBUb2tlbi5JTlQ4LmdldChidWYsIG9mZiArIDApLFxuICAgICAgICAgICAgZmxhZ3M6IFRva2VuLklOVDI0X0JFLmdldChidWYsIG9mZiArIDEpLFxuICAgICAgICAgICAgbnVtYmVyT2ZFbnRyaWVzOiBuck9mRW50cmllcyxcbiAgICAgICAgICAgIGVudHJpZXM6IHJlYWRUb2tlblRhYmxlKGJ1ZiwgdGhpcy50b2tlbiwgb2ZmICsgOCwgdGhpcy5sZW4gLSA4LCBuck9mRW50cmllcylcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlRpbWVUb1NhbXBsZVRva2VuID0ge1xuICAgIGxlbjogOCxcbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvdW50OiBUb2tlbi5JTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyAwKSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBUb2tlbi5JTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyA0KVxuICAgICAgICB9O1xuICAgIH1cbn07XG4vKipcbiAqIFRpbWUtdG8tc2FtcGxlKCdzdHRzJykgYXRvbS5cbiAqIFN0b3JlIGR1cmF0aW9uIGluZm9ybWF0aW9uIGZvciBhIG1lZGlh4oCZcyBzYW1wbGVzLlxuICogUmVmOiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9hcmNoaXZlL2RvY3VtZW50YXRpb24vUXVpY2tUaW1lL1FURkYvUVRGRkNoYXAyL3F0ZmYyLmh0bWwjLy9hcHBsZV9yZWYvZG9jL3VpZC9UUDQwMDAwOTM5LUNIMjA0LTI1Njk2XG4gKi9cbmNsYXNzIFN0dHNBdG9tIGV4dGVuZHMgU2ltcGxlVGFibGVBdG9tIHtcbiAgICBjb25zdHJ1Y3RvcihsZW4pIHtcbiAgICAgICAgc3VwZXIobGVuLCBleHBvcnRzLlRpbWVUb1NhbXBsZVRva2VuKTtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgfVxufVxuZXhwb3J0cy5TdHRzQXRvbSA9IFN0dHNBdG9tO1xuZXhwb3J0cy5TYW1wbGVUb0NodW5rVG9rZW4gPSB7XG4gICAgbGVuOiAxMixcbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZpcnN0Q2h1bms6IFRva2VuLklOVDMyX0JFLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICBzYW1wbGVzUGVyQ2h1bms6IFRva2VuLklOVDMyX0JFLmdldChidWYsIG9mZiArIDQpLFxuICAgICAgICAgICAgc2FtcGxlRGVzY3JpcHRpb25JZDogVG9rZW4uSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgOClcbiAgICAgICAgfTtcbiAgICB9XG59O1xuLyoqXG4gKiBTYW1wbGUtdG8tQ2h1bmsgKCdzdHNjJykgYXRvbSBpbnRlcmZhY2VcbiAqIFJlZjogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL1FURkZDaGFwMi9xdGZmMi5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDIwNC0yNTcwNlxuICovXG5jbGFzcyBTdHNjQXRvbSBleHRlbmRzIFNpbXBsZVRhYmxlQXRvbSB7XG4gICAgY29uc3RydWN0b3IobGVuKSB7XG4gICAgICAgIHN1cGVyKGxlbiwgZXhwb3J0cy5TYW1wbGVUb0NodW5rVG9rZW4pO1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB9XG59XG5leHBvcnRzLlN0c2NBdG9tID0gU3RzY0F0b207XG4vKipcbiAqIFNhbXBsZS1zaXplICgnc3RzeicpIGF0b21cbiAqIFJlZjogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL1FURkZDaGFwMi9xdGZmMi5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDIwNC0yNTcxMFxuICovXG5jbGFzcyBTdHN6QXRvbSB7XG4gICAgY29uc3RydWN0b3IobGVuKSB7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgY29uc3QgbnJPZkVudHJpZXMgPSBUb2tlbi5JTlQzMl9CRS5nZXQoYnVmLCBvZmYgKyA4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IFRva2VuLklOVDguZ2V0KGJ1Ziwgb2ZmKSxcbiAgICAgICAgICAgIGZsYWdzOiBUb2tlbi5JTlQyNF9CRS5nZXQoYnVmLCBvZmYgKyAxKSxcbiAgICAgICAgICAgIHNhbXBsZVNpemU6IFRva2VuLklOVDMyX0JFLmdldChidWYsIG9mZiArIDQpLFxuICAgICAgICAgICAgbnVtYmVyT2ZFbnRyaWVzOiBuck9mRW50cmllcyxcbiAgICAgICAgICAgIGVudHJpZXM6IHJlYWRUb2tlblRhYmxlKGJ1ZiwgVG9rZW4uSU5UMzJfQkUsIG9mZiArIDEyLCB0aGlzLmxlbiAtIDEyLCBuck9mRW50cmllcylcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlN0c3pBdG9tID0gU3RzekF0b207XG4vKipcbiAqIENodW5rIG9mZnNldCBhdG9tLCAnc3RjbydcbiAqIFJlZjogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL1FURkZDaGFwMi9xdGZmMi5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDIwNC0yNTcxNVxuICovXG5jbGFzcyBTdGNvQXRvbSBleHRlbmRzIFNpbXBsZVRhYmxlQXRvbSB7XG4gICAgY29uc3RydWN0b3IobGVuKSB7XG4gICAgICAgIHN1cGVyKGxlbiwgVG9rZW4uSU5UMzJfQkUpO1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB9XG59XG5leHBvcnRzLlN0Y29BdG9tID0gU3Rjb0F0b207XG4vKipcbiAqIFRva2VuIHVzZWQgdG8gZGVjb2RlIHRleHQtdHJhY2sgZnJvbSAnbWRhdCcgYXRvbSAocmF3IGRhdGEgc3RyZWFtKVxuICovXG5jbGFzcyBDaGFwdGVyVGV4dCB7XG4gICAgY29uc3RydWN0b3IobGVuKSB7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgY29uc3QgdGl0bGVMZW4gPSBUb2tlbi5JTlQxNl9CRS5nZXQoYnVmLCBvZmYgKyAwKTtcbiAgICAgICAgY29uc3Qgc3RyID0gbmV3IFRva2VuLlN0cmluZ1R5cGUodGl0bGVMZW4sICd1dGYtOCcpO1xuICAgICAgICByZXR1cm4gc3RyLmdldChidWYsIG9mZiArIDIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhcHRlclRleHQgPSBDaGFwdGVyVGV4dDtcbmZ1bmN0aW9uIHJlYWRUb2tlblRhYmxlKGJ1ZiwgdG9rZW4sIG9mZiwgcmVtYWluaW5nTGVuLCBudW1iZXJPZkVudHJpZXMpIHtcbiAgICBkZWJ1ZyhgcmVtYWluaW5nTGVuPSR7cmVtYWluaW5nTGVufSwgbnVtYmVyT2ZFbnRyaWVzPSR7bnVtYmVyT2ZFbnRyaWVzfSAqIHRva2VuLWxlbj0ke3Rva2VuLmxlbn1gKTtcbiAgICBpZiAocmVtYWluaW5nTGVuID09PSAwKVxuICAgICAgICByZXR1cm4gW107XG4gICAgaWYgKHJlbWFpbmluZ0xlbiAhPT0gbnVtYmVyT2ZFbnRyaWVzICogdG9rZW4ubGVuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc21hdGNoIG51bWJlci1vZi1lbnRyaWVzIHdpdGggcmVtYWluaW5nIGF0b20tbGVuZ3RoJyk7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIC8vIHBhcnNlIG9mZnNldC10YWJsZVxuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgbnVtYmVyT2ZFbnRyaWVzOyArK24pIHtcbiAgICAgICAgZW50cmllcy5wdXNoKHRva2VuLmdldChidWYsIG9mZikpO1xuICAgICAgICBvZmYgKz0gdG9rZW4ubGVuO1xuICAgIH1cbiAgICByZXR1cm4gZW50cmllcztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/mp4/AtomToken.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/mp4/MP4Parser.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/mp4/MP4Parser.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MP4Parser = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst ID3v1Parser_1 = __webpack_require__(/*! ../id3v1/ID3v1Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js\");\nconst type_1 = __webpack_require__(/*! ../type */ \"(app-pages-browser)/./node_modules/music-metadata/lib/type.js\");\nconst Atom_1 = __webpack_require__(/*! ./Atom */ \"(app-pages-browser)/./node_modules/music-metadata/lib/mp4/Atom.js\");\nconst AtomToken = __webpack_require__(/*! ./AtomToken */ \"(app-pages-browser)/./node_modules/music-metadata/lib/mp4/AtomToken.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:MP4');\nconst tagFormat = 'iTunes';\nconst encoderDict = {\n    raw: {\n        lossy: false,\n        format: 'raw'\n    },\n    MAC3: {\n        lossy: true,\n        format: 'MACE 3:1'\n    },\n    MAC6: {\n        lossy: true,\n        format: 'MACE 6:1'\n    },\n    ima4: {\n        lossy: true,\n        format: 'IMA 4:1'\n    },\n    ulaw: {\n        lossy: true,\n        format: 'uLaw 2:1'\n    },\n    alaw: {\n        lossy: true,\n        format: 'uLaw 2:1'\n    },\n    Qclp: {\n        lossy: true,\n        format: 'QUALCOMM PureVoice'\n    },\n    '.mp3': {\n        lossy: true,\n        format: 'MPEG-1 layer 3'\n    },\n    alac: {\n        lossy: false,\n        format: 'ALAC'\n    },\n    'ac-3': {\n        lossy: true,\n        format: 'AC-3'\n    },\n    mp4a: {\n        lossy: true,\n        format: 'MPEG-4/AAC'\n    },\n    mp4s: {\n        lossy: true,\n        format: 'MP4S'\n    },\n    // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\n    c608: {\n        lossy: true,\n        format: 'CEA-608'\n    },\n    c708: {\n        lossy: true,\n        format: 'CEA-708'\n    }\n};\nfunction distinct(value, index, self) {\n    return self.indexOf(value) === index;\n}\n/*\n * Parser for the MP4 (MPEG-4 Part 14) container format\n * Standard: ISO/IEC 14496-14\n * supporting:\n * - QuickTime container\n * - MP4 File Format\n * - 3GPP file format\n * - 3GPP2 file format\n *\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\n * Support for Apple iTunes tags as found in a M4A/M4V files.\n * Ref:\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\n */\nclass MP4Parser extends BasicParser_1.BasicParser {\n    constructor() {\n        super(...arguments);\n        this.atomParsers = {\n            /**\n             * Parse movie header (mvhd) atom\n             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\n             */\n            mvhd: async (len) => {\n                const mvhd = await this.tokenizer.readToken(new AtomToken.MvhdAtom(len));\n                this.metadata.setFormat('creationTime', mvhd.creationTime);\n                this.metadata.setFormat('modificationTime', mvhd.modificationTime);\n            },\n            /**\n             * Parse media header (mdhd) atom\n             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615\n             */\n            mdhd: async (len) => {\n                const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(len));\n                // this.parse_mxhd(mdhd_data, this.currentTrack);\n                const td = this.getTrackDescription();\n                td.creationTime = mdhd_data.creationTime;\n                td.modificationTime = mdhd_data.modificationTime;\n                td.timeScale = mdhd_data.timeScale;\n                td.duration = mdhd_data.duration;\n            },\n            chap: async (len) => {\n                const td = this.getTrackDescription();\n                const trackIds = [];\n                while (len >= Token.UINT32_BE.len) {\n                    trackIds.push(await this.tokenizer.readNumber(Token.UINT32_BE));\n                    len -= Token.UINT32_BE.len;\n                }\n                td.chapterList = trackIds;\n            },\n            tkhd: async (len) => {\n                const track = (await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(len)));\n                this.tracks.push(track);\n            },\n            /**\n             * Parse mdat atom.\n             * Will scan for chapters\n             */\n            mdat: async (len) => {\n                this.audioLengthInBytes = len;\n                this.calculateBitRate();\n                if (this.options.includeChapters) {\n                    const trackWithChapters = this.tracks.filter(track => track.chapterList);\n                    if (trackWithChapters.length === 1) {\n                        const chapterTrackIds = trackWithChapters[0].chapterList;\n                        const chapterTracks = this.tracks.filter(track => chapterTrackIds.indexOf(track.trackId) !== -1);\n                        if (chapterTracks.length === 1) {\n                            return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);\n                        }\n                    }\n                }\n                await this.tokenizer.ignore(len);\n            },\n            ftyp: async (len) => {\n                const types = [];\n                while (len > 0) {\n                    const ftype = await this.tokenizer.readToken(AtomToken.ftyp);\n                    len -= AtomToken.ftyp.len;\n                    const value = ftype.type.replace(/\\W/g, '');\n                    if (value.length > 0) {\n                        types.push(value); // unshift for backward compatibility\n                    }\n                }\n                debug(`ftyp: ${types.join('/')}`);\n                const x = types.filter(distinct).join('/');\n                this.metadata.setFormat('container', x);\n            },\n            /**\n             * Parse sample description atom\n             */\n            stsd: async (len) => {\n                const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));\n                const trackDescription = this.getTrackDescription();\n                trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n            },\n            /**\n             * sample-to-Chunk Atoms\n             */\n            stsc: async (len) => {\n                const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(len));\n                this.getTrackDescription().sampleToChunkTable = stsc.entries;\n            },\n            /**\n             * time-to-sample table\n             */\n            stts: async (len) => {\n                const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(len));\n                this.getTrackDescription().timeToSampleTable = stts.entries;\n            },\n            /**\n             * Parse sample-sizes atom ('stsz')\n             */\n            stsz: async (len) => {\n                const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));\n                const td = this.getTrackDescription();\n                td.sampleSize = stsz.sampleSize;\n                td.sampleSizeTable = stsz.entries;\n            },\n            /**\n             * Parse chunk-offset atom ('stco')\n             */\n            stco: async (len) => {\n                const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(len));\n                this.getTrackDescription().chunkOffsetTable = stco.entries; // remember chunk offsets\n            },\n            date: async (len) => {\n                const date = await this.tokenizer.readToken(new Token.StringType(len, 'utf-8'));\n                this.addTag('date', date);\n            }\n        };\n    }\n    static read_BE_Integer(array, signed) {\n        const integerType = (signed ? 'INT' : 'UINT') + array.length * 8 + (array.length > 1 ? '_BE' : '');\n        const token = Token[integerType];\n        if (!token) {\n            throw new Error('Token for integer type not found: \"' + integerType + '\"');\n        }\n        return Number(token.get(array, 0));\n    }\n    async parse() {\n        this.tracks = [];\n        let remainingFileSize = this.tokenizer.fileInfo.size;\n        while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {\n            try {\n                const token = await this.tokenizer.peekToken(AtomToken.Header);\n                if (token.name === '\\0\\0\\0\\0') {\n                    const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;\n                    debug(errMsg);\n                    this.addWarning(errMsg);\n                    break;\n                }\n            }\n            catch (error) {\n                const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;\n                debug(errMsg);\n                this.addWarning(errMsg);\n                break;\n            }\n            const rootAtom = await Atom_1.Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);\n            remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);\n        }\n        // Post process metadata\n        const formatList = [];\n        this.tracks.forEach(track => {\n            const trackFormats = [];\n            track.soundSampleDescription.forEach(ssd => {\n                const streamInfo = {};\n                const encoderInfo = encoderDict[ssd.dataFormat];\n                if (encoderInfo) {\n                    trackFormats.push(encoderInfo.format);\n                    streamInfo.codecName = encoderInfo.format;\n                }\n                else {\n                    streamInfo.codecName = `<${ssd.dataFormat}>`;\n                }\n                if (ssd.description) {\n                    const { description } = ssd;\n                    if (description.sampleRate > 0) {\n                        streamInfo.type = type_1.TrackType.audio;\n                        streamInfo.audio = {\n                            samplingFrequency: description.sampleRate,\n                            bitDepth: description.sampleSize,\n                            channels: description.numAudioChannels\n                        };\n                    }\n                }\n                this.metadata.addStreamInfo(streamInfo);\n            });\n            if (trackFormats.length >= 1) {\n                formatList.push(trackFormats.join('/'));\n            }\n        });\n        if (formatList.length > 0) {\n            this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\n        }\n        const audioTracks = this.tracks.filter(track => {\n            return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;\n        });\n        if (audioTracks.length >= 1) {\n            const audioTrack = audioTracks[0];\n            if (audioTrack.timeScale > 0) {\n                const duration = audioTrack.duration / audioTrack.timeScale; // calculate duration in seconds\n                this.metadata.setFormat('duration', duration);\n            }\n            const ssd = audioTrack.soundSampleDescription[0];\n            if (ssd.description) {\n                this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\n                this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\n                this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\n                if (audioTrack.timeScale === 0 && audioTrack.timeToSampleTable.length > 0) {\n                    const totalSampleSize = audioTrack.timeToSampleTable\n                        .map(ttstEntry => ttstEntry.count * ttstEntry.duration)\n                        .reduce((total, sampleSize) => total + sampleSize);\n                    const duration = totalSampleSize / ssd.description.sampleRate;\n                    this.metadata.setFormat('duration', duration);\n                }\n            }\n            const encoderInfo = encoderDict[ssd.dataFormat];\n            if (encoderInfo) {\n                this.metadata.setFormat('lossless', !encoderInfo.lossy);\n            }\n            this.calculateBitRate();\n        }\n    }\n    async handleAtom(atom, remaining) {\n        if (atom.parent) {\n            switch (atom.parent.header.name) {\n                case 'ilst':\n                case '<id>':\n                    return this.parseMetadataItemData(atom);\n            }\n        }\n        // const payloadLength = atom.getPayloadLength(remaining);\n        if (this.atomParsers[atom.header.name]) {\n            return this.atomParsers[atom.header.name](remaining);\n        }\n        else {\n            debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);\n            await this.tokenizer.ignore(remaining);\n        }\n    }\n    getTrackDescription() {\n        return this.tracks[this.tracks.length - 1];\n    }\n    calculateBitRate() {\n        if (this.audioLengthInBytes && this.metadata.format.duration) {\n            this.metadata.setFormat('bitrate', 8 * this.audioLengthInBytes / this.metadata.format.duration);\n        }\n    }\n    addTag(id, value) {\n        this.metadata.addTag(tagFormat, id, value);\n    }\n    addWarning(message) {\n        debug('Warning: ' + message);\n        this.metadata.addWarning(message);\n    }\n    /**\n     * Parse data of Meta-item-list-atom (item of 'ilst' atom)\n     * @param metaAtom\n     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n     */\n    parseMetadataItemData(metaAtom) {\n        let tagKey = metaAtom.header.name;\n        return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {\n            const payLoadLength = child.getPayloadLength(remaining);\n            switch (child.header.name) {\n                case 'data': // value atom\n                    return this.parseValueAtom(tagKey, child);\n                case 'name': // name atom (optional)\n                case 'mean':\n                case 'rate':\n                    const name = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\n                    tagKey += ':' + name.name;\n                    break;\n                default:\n                    const dataAtom = await this.tokenizer.readToken(new Token.BufferType(payLoadLength));\n                    this.addWarning('Unsupported meta-item: ' + tagKey + '[' + child.header.name + '] => value=' + dataAtom.toString('hex') + ' ascii=' + dataAtom.toString('ascii'));\n            }\n        }, metaAtom.getPayloadLength(0));\n    }\n    async parseValueAtom(tagKey, metaAtom) {\n        const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(Number(metaAtom.header.length) - AtomToken.Header.len));\n        if (dataAtom.type.set !== 0) {\n            throw new Error('Unsupported type-set != 0: ' + dataAtom.type.set);\n        }\n        // Use well-known-type table\n        // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\n        switch (dataAtom.type.type) {\n            case 0: // reserved: Reserved for use where no type needs to be indicated\n                switch (tagKey) {\n                    case 'trkn':\n                    case 'disk':\n                        const num = Token.UINT8.get(dataAtom.value, 3);\n                        const of = Token.UINT8.get(dataAtom.value, 5);\n                        // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\n                        this.addTag(tagKey, num + '/' + of);\n                        break;\n                    case 'gnre':\n                        const genreInt = Token.UINT8.get(dataAtom.value, 1);\n                        const genreStr = ID3v1Parser_1.Genres[genreInt - 1];\n                        // console.log(\"  %s[data] = %s\", tagKey, genreStr);\n                        this.addTag(tagKey, genreStr);\n                        break;\n                    case 'rate':\n                        const rate = dataAtom.value.toString('ascii');\n                        this.addTag(tagKey, rate);\n                        break;\n                    default:\n                        debug('unknown proprietary value type for: ' + metaAtom.atomPath);\n                }\n                break;\n            case 1: // UTF-8: Without any count or NULL terminator\n            case 18: // Unknown: Found in m4b in combination with a '©gen' tag\n                this.addTag(tagKey, dataAtom.value.toString('utf-8'));\n                break;\n            case 13: // JPEG\n                if (this.options.skipCovers)\n                    break;\n                this.addTag(tagKey, {\n                    format: 'image/jpeg',\n                    data: Buffer.from(dataAtom.value)\n                });\n                break;\n            case 14: // PNG\n                if (this.options.skipCovers)\n                    break;\n                this.addTag(tagKey, {\n                    format: 'image/png',\n                    data: Buffer.from(dataAtom.value)\n                });\n                break;\n            case 21: // BE Signed Integer\n                this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, true));\n                break;\n            case 22: // BE Unsigned Integer\n                this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, false));\n                break;\n            case 65: // An 8-bit signed integer\n                this.addTag(tagKey, dataAtom.value.readInt8(0));\n                break;\n            case 66: // A big-endian 16-bit signed integer\n                this.addTag(tagKey, dataAtom.value.readInt16BE(0));\n                break;\n            case 67: // A big-endian 32-bit signed integer\n                this.addTag(tagKey, dataAtom.value.readInt32BE(0));\n                break;\n            default:\n                this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);\n        }\n    }\n    /**\n     * @param sampleDescription\n     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\n     */\n    parseSoundSampleDescription(sampleDescription) {\n        const ssd = {\n            dataFormat: sampleDescription.dataFormat,\n            dataReferenceIndex: sampleDescription.dataReferenceIndex\n        };\n        let offset = 0;\n        const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\n        offset += AtomToken.SoundSampleDescriptionVersion.len;\n        if (version.version === 0 || version.version === 1) {\n            // Sound Sample Description (Version 0)\n            ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\n        }\n        else {\n            debug(`Warning: sound-sample-description ${version} not implemented`);\n        }\n        return ssd;\n    }\n    async parseChapterTrack(chapterTrack, track, len) {\n        if (!chapterTrack.sampleSize) {\n            if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)\n                throw new Error('Expected equal chunk-offset-table & sample-size-table length.');\n        }\n        const chapters = [];\n        for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {\n            const chunkOffset = chapterTrack.chunkOffsetTable[i];\n            const nextChunkLen = chunkOffset - this.tokenizer.position;\n            const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\n            len -= nextChunkLen + sampleSize;\n            if (len < 0)\n                throw new Error('Chapter chunk exceeding token length');\n            await this.tokenizer.ignore(nextChunkLen);\n            const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\n            debug(`Chapter ${i + 1}: ${title}`);\n            const chapter = {\n                title,\n                sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\n            };\n            debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${this.tracks[0].duration}`);\n            chapters.push(chapter);\n        }\n        this.metadata.setFormat('chapters', chapters);\n        await this.tokenizer.ignore(len);\n    }\n    findSampleOffset(track, chapterOffset) {\n        let totalDuration = 0;\n        track.timeToSampleTable.forEach(e => {\n            totalDuration += e.count * e.duration;\n        });\n        debug(`Total duration=${totalDuration}`);\n        let chunkIndex = 0;\n        while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\n            ++chunkIndex;\n        }\n        return this.getChunkDuration(chunkIndex + 1, track);\n    }\n    getChunkDuration(chunkId, track) {\n        let ttsi = 0;\n        let ttsc = track.timeToSampleTable[ttsi].count;\n        let ttsd = track.timeToSampleTable[ttsi].duration;\n        let curChunkId = 1;\n        let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n        let totalDuration = 0;\n        while (curChunkId < chunkId) {\n            const nrOfSamples = Math.min(ttsc, samplesPerChunk);\n            totalDuration += nrOfSamples * ttsd;\n            ttsc -= nrOfSamples;\n            samplesPerChunk -= nrOfSamples;\n            if (samplesPerChunk === 0) {\n                ++curChunkId;\n                samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n            }\n            else {\n                ++ttsi;\n                ttsc = track.timeToSampleTable[ttsi].count;\n                ttsd = track.timeToSampleTable[ttsi].duration;\n            }\n        }\n        return totalDuration;\n    }\n    getSamplesPerChunk(chunkId, stcTable) {\n        for (let i = 0; i < stcTable.length - 1; ++i) {\n            if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\n                return stcTable[i].samplesPerChunk;\n            }\n        }\n        return stcTable[stcTable.length - 1].samplesPerChunk;\n    }\n}\nexports.MP4Parser = MP4Parser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXA0L01QNFBhcnNlci5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFPO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyxnRkFBYTtBQUNuQyxzQkFBc0IsbUJBQU8sQ0FBQywwR0FBdUI7QUFDckQsc0JBQXNCLG1CQUFPLENBQUMsd0dBQXNCO0FBQ3BELGVBQWUsbUJBQU8sQ0FBQyw4RUFBUztBQUNoQyxlQUFlLG1CQUFPLENBQUMsaUZBQVE7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsMkZBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx3QkFBd0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHdCQUF3QixJQUFJLGNBQWM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYyxnQkFBZ0IsVUFBVTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU8sNkNBQTZDLG1CQUFtQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBcUQ7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNLElBQUksTUFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjLFdBQVcscUJBQXFCLEdBQUcsd0JBQXdCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9tcDQvTVA0UGFyc2VyLmpzPzRlZDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1QNFBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IEJhc2ljUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0Jhc2ljUGFyc2VyXCIpO1xuY29uc3QgSUQzdjFQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9pZDN2MS9JRDN2MVBhcnNlclwiKTtcbmNvbnN0IHR5cGVfMSA9IHJlcXVpcmUoXCIuLi90eXBlXCIpO1xuY29uc3QgQXRvbV8xID0gcmVxdWlyZShcIi4vQXRvbVwiKTtcbmNvbnN0IEF0b21Ub2tlbiA9IHJlcXVpcmUoXCIuL0F0b21Ub2tlblwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjpNUDQnKTtcbmNvbnN0IHRhZ0Zvcm1hdCA9ICdpVHVuZXMnO1xuY29uc3QgZW5jb2RlckRpY3QgPSB7XG4gICAgcmF3OiB7XG4gICAgICAgIGxvc3N5OiBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiAncmF3J1xuICAgIH0sXG4gICAgTUFDMzoge1xuICAgICAgICBsb3NzeTogdHJ1ZSxcbiAgICAgICAgZm9ybWF0OiAnTUFDRSAzOjEnXG4gICAgfSxcbiAgICBNQUM2OiB7XG4gICAgICAgIGxvc3N5OiB0cnVlLFxuICAgICAgICBmb3JtYXQ6ICdNQUNFIDY6MSdcbiAgICB9LFxuICAgIGltYTQ6IHtcbiAgICAgICAgbG9zc3k6IHRydWUsXG4gICAgICAgIGZvcm1hdDogJ0lNQSA0OjEnXG4gICAgfSxcbiAgICB1bGF3OiB7XG4gICAgICAgIGxvc3N5OiB0cnVlLFxuICAgICAgICBmb3JtYXQ6ICd1TGF3IDI6MSdcbiAgICB9LFxuICAgIGFsYXc6IHtcbiAgICAgICAgbG9zc3k6IHRydWUsXG4gICAgICAgIGZvcm1hdDogJ3VMYXcgMjoxJ1xuICAgIH0sXG4gICAgUWNscDoge1xuICAgICAgICBsb3NzeTogdHJ1ZSxcbiAgICAgICAgZm9ybWF0OiAnUVVBTENPTU0gUHVyZVZvaWNlJ1xuICAgIH0sXG4gICAgJy5tcDMnOiB7XG4gICAgICAgIGxvc3N5OiB0cnVlLFxuICAgICAgICBmb3JtYXQ6ICdNUEVHLTEgbGF5ZXIgMydcbiAgICB9LFxuICAgIGFsYWM6IHtcbiAgICAgICAgbG9zc3k6IGZhbHNlLFxuICAgICAgICBmb3JtYXQ6ICdBTEFDJ1xuICAgIH0sXG4gICAgJ2FjLTMnOiB7XG4gICAgICAgIGxvc3N5OiB0cnVlLFxuICAgICAgICBmb3JtYXQ6ICdBQy0zJ1xuICAgIH0sXG4gICAgbXA0YToge1xuICAgICAgICBsb3NzeTogdHJ1ZSxcbiAgICAgICAgZm9ybWF0OiAnTVBFRy00L0FBQydcbiAgICB9LFxuICAgIG1wNHM6IHtcbiAgICAgICAgbG9zc3k6IHRydWUsXG4gICAgICAgIGZvcm1hdDogJ01QNFMnXG4gICAgfSxcbiAgICAvLyBDbG9zZWQgQ2FwdGlvbmluZyBNZWRpYSwgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL1FURkZDaGFwMy9xdGZmMy5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDIwNS1TVzg3XG4gICAgYzYwODoge1xuICAgICAgICBsb3NzeTogdHJ1ZSxcbiAgICAgICAgZm9ybWF0OiAnQ0VBLTYwOCdcbiAgICB9LFxuICAgIGM3MDg6IHtcbiAgICAgICAgbG9zc3k6IHRydWUsXG4gICAgICAgIGZvcm1hdDogJ0NFQS03MDgnXG4gICAgfVxufTtcbmZ1bmN0aW9uIGRpc3RpbmN0KHZhbHVlLCBpbmRleCwgc2VsZikge1xuICAgIHJldHVybiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleDtcbn1cbi8qXG4gKiBQYXJzZXIgZm9yIHRoZSBNUDQgKE1QRUctNCBQYXJ0IDE0KSBjb250YWluZXIgZm9ybWF0XG4gKiBTdGFuZGFyZDogSVNPL0lFQyAxNDQ5Ni0xNFxuICogc3VwcG9ydGluZzpcbiAqIC0gUXVpY2tUaW1lIGNvbnRhaW5lclxuICogLSBNUDQgRmlsZSBGb3JtYXRcbiAqIC0gM0dQUCBmaWxlIGZvcm1hdFxuICogLSAzR1BQMiBmaWxlIGZvcm1hdFxuICpcbiAqIE1QRUctNCBBdWRpbyAvIFBhcnQgMyAoLm00YSkmIE1QRUcgNCBWaWRlbyAobTR2LCBtcDQpIGV4dGVuc2lvbi5cbiAqIFN1cHBvcnQgZm9yIEFwcGxlIGlUdW5lcyB0YWdzIGFzIGZvdW5kIGluIGEgTTRBL000ViBmaWxlcy5cbiAqIFJlZjpcbiAqICAgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX2Jhc2VfbWVkaWFfZmlsZV9mb3JtYXRcbiAqICAgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL01ldGFkYXRhL01ldGFkYXRhLmh0bWxcbiAqICAgaHR0cDovL2F0b21pY3BhcnNsZXkuc291cmNlZm9yZ2UubmV0L21wZWctNGZpbGVzLmh0bWxcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL3Nlcmdpb21iMi9saWJtcDR2Mi93aWtpL2lUdW5lc01ldGFkYXRhXG4gKiAgIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocC9RdWlja1RpbWVfY29udGFpbmVyXG4gKi9cbmNsYXNzIE1QNFBhcnNlciBleHRlbmRzIEJhc2ljUGFyc2VyXzEuQmFzaWNQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmF0b21QYXJzZXJzID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQYXJzZSBtb3ZpZSBoZWFkZXIgKG12aGQpIGF0b21cbiAgICAgICAgICAgICAqIFJlZjogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL1FURkZDaGFwMi9xdGZmMi5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDIwNC01NjMxM1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtdmhkOiBhc3luYyAobGVuKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXZoZCA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgQXRvbVRva2VuLk12aGRBdG9tKGxlbikpO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjcmVhdGlvblRpbWUnLCBtdmhkLmNyZWF0aW9uVGltZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ21vZGlmaWNhdGlvblRpbWUnLCBtdmhkLm1vZGlmaWNhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGFyc2UgbWVkaWEgaGVhZGVyIChtZGhkKSBhdG9tXG4gICAgICAgICAgICAgKiBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2FyY2hpdmUvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9RVEZGQ2hhcDIvcXRmZjIuaHRtbCMvL2FwcGxlX3JlZi9kb2MvdWlkL1RQNDAwMDA5MzktQ0gyMDQtMjU2MTVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWRoZDogYXN5bmMgKGxlbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1kaGRfZGF0YSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgQXRvbVRva2VuLk1kaGRBdG9tKGxlbikpO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMucGFyc2VfbXhoZChtZGhkX2RhdGEsIHRoaXMuY3VycmVudFRyYWNrKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZCA9IHRoaXMuZ2V0VHJhY2tEZXNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIHRkLmNyZWF0aW9uVGltZSA9IG1kaGRfZGF0YS5jcmVhdGlvblRpbWU7XG4gICAgICAgICAgICAgICAgdGQubW9kaWZpY2F0aW9uVGltZSA9IG1kaGRfZGF0YS5tb2RpZmljYXRpb25UaW1lO1xuICAgICAgICAgICAgICAgIHRkLnRpbWVTY2FsZSA9IG1kaGRfZGF0YS50aW1lU2NhbGU7XG4gICAgICAgICAgICAgICAgdGQuZHVyYXRpb24gPSBtZGhkX2RhdGEuZHVyYXRpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hhcDogYXN5bmMgKGxlbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRkID0gdGhpcy5nZXRUcmFja0Rlc2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tJZHMgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobGVuID49IFRva2VuLlVJTlQzMl9CRS5sZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tJZHMucHVzaChhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkTnVtYmVyKFRva2VuLlVJTlQzMl9CRSkpO1xuICAgICAgICAgICAgICAgICAgICBsZW4gLT0gVG9rZW4uVUlOVDMyX0JFLmxlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGQuY2hhcHRlckxpc3QgPSB0cmFja0lkcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0a2hkOiBhc3luYyAobGVuKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2sgPSAoYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBBdG9tVG9rZW4uVHJhY2tIZWFkZXJBdG9tKGxlbikpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrcy5wdXNoKHRyYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhcnNlIG1kYXQgYXRvbS5cbiAgICAgICAgICAgICAqIFdpbGwgc2NhbiBmb3IgY2hhcHRlcnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWRhdDogYXN5bmMgKGxlbikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9MZW5ndGhJbkJ5dGVzID0gbGVuO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQml0UmF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5jbHVkZUNoYXB0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrV2l0aENoYXB0ZXJzID0gdGhpcy50cmFja3MuZmlsdGVyKHRyYWNrID0+IHRyYWNrLmNoYXB0ZXJMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrV2l0aENoYXB0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhcHRlclRyYWNrSWRzID0gdHJhY2tXaXRoQ2hhcHRlcnNbMF0uY2hhcHRlckxpc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFwdGVyVHJhY2tzID0gdGhpcy50cmFja3MuZmlsdGVyKHRyYWNrID0+IGNoYXB0ZXJUcmFja0lkcy5pbmRleE9mKHRyYWNrLnRyYWNrSWQpICE9PSAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcHRlclRyYWNrcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNoYXB0ZXJUcmFjayhjaGFwdGVyVHJhY2tzWzBdLCB0cmFja1dpdGhDaGFwdGVyc1swXSwgbGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUobGVuKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdHlwOiBhc3luYyAobGVuKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmdHlwZSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihBdG9tVG9rZW4uZnR5cCk7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBBdG9tVG9rZW4uZnR5cC5sZW47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZnR5cGUudHlwZS5yZXBsYWNlKC9cXFcvZywgJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMucHVzaCh2YWx1ZSk7IC8vIHVuc2hpZnQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWJ1ZyhgZnR5cDogJHt0eXBlcy5qb2luKCcvJyl9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHR5cGVzLmZpbHRlcihkaXN0aW5jdCkuam9pbignLycpO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb250YWluZXInLCB4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhcnNlIHNhbXBsZSBkZXNjcmlwdGlvbiBhdG9tXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN0c2Q6IGFzeW5jIChsZW4pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHNkID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBBdG9tVG9rZW4uU3RzZEF0b20obGVuKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tEZXNjcmlwdGlvbiA9IHRoaXMuZ2V0VHJhY2tEZXNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIHRyYWNrRGVzY3JpcHRpb24uc291bmRTYW1wbGVEZXNjcmlwdGlvbiA9IHN0c2QudGFibGUubWFwKGRmRW50cnkgPT4gdGhpcy5wYXJzZVNvdW5kU2FtcGxlRGVzY3JpcHRpb24oZGZFbnRyeSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogc2FtcGxlLXRvLUNodW5rIEF0b21zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN0c2M6IGFzeW5jIChsZW4pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHNjID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBBdG9tVG9rZW4uU3RzY0F0b20obGVuKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRUcmFja0Rlc2NyaXB0aW9uKCkuc2FtcGxlVG9DaHVua1RhYmxlID0gc3RzYy5lbnRyaWVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogdGltZS10by1zYW1wbGUgdGFibGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3R0czogYXN5bmMgKGxlbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0dHMgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEF0b21Ub2tlbi5TdHRzQXRvbShsZW4pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFRyYWNrRGVzY3JpcHRpb24oKS50aW1lVG9TYW1wbGVUYWJsZSA9IHN0dHMuZW50cmllcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhcnNlIHNhbXBsZS1zaXplcyBhdG9tICgnc3RzeicpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN0c3o6IGFzeW5jIChsZW4pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHN6ID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBBdG9tVG9rZW4uU3RzekF0b20obGVuKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGQgPSB0aGlzLmdldFRyYWNrRGVzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICB0ZC5zYW1wbGVTaXplID0gc3Rzei5zYW1wbGVTaXplO1xuICAgICAgICAgICAgICAgIHRkLnNhbXBsZVNpemVUYWJsZSA9IHN0c3ouZW50cmllcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhcnNlIGNodW5rLW9mZnNldCBhdG9tICgnc3RjbycpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN0Y286IGFzeW5jIChsZW4pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGNvID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBBdG9tVG9rZW4uU3Rjb0F0b20obGVuKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRUcmFja0Rlc2NyaXB0aW9uKCkuY2h1bmtPZmZzZXRUYWJsZSA9IHN0Y28uZW50cmllczsgLy8gcmVtZW1iZXIgY2h1bmsgb2Zmc2V0c1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGU6IGFzeW5jIChsZW4pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBUb2tlbi5TdHJpbmdUeXBlKGxlbiwgJ3V0Zi04JykpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFnKCdkYXRlJywgZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyByZWFkX0JFX0ludGVnZXIoYXJyYXksIHNpZ25lZCkge1xuICAgICAgICBjb25zdCBpbnRlZ2VyVHlwZSA9IChzaWduZWQgPyAnSU5UJyA6ICdVSU5UJykgKyBhcnJheS5sZW5ndGggKiA4ICsgKGFycmF5Lmxlbmd0aCA+IDEgPyAnX0JFJyA6ICcnKTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBUb2tlbltpbnRlZ2VyVHlwZV07XG4gICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9rZW4gZm9yIGludGVnZXIgdHlwZSBub3QgZm91bmQ6IFwiJyArIGludGVnZXJUeXBlICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlcih0b2tlbi5nZXQoYXJyYXksIDApKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2UoKSB7XG4gICAgICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgICAgIGxldCByZW1haW5pbmdGaWxlU2l6ZSA9IHRoaXMudG9rZW5pemVyLmZpbGVJbmZvLnNpemU7XG4gICAgICAgIHdoaWxlICghdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSB8fCByZW1haW5pbmdGaWxlU2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLnRva2VuaXplci5wZWVrVG9rZW4oQXRvbVRva2VuLkhlYWRlcik7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLm5hbWUgPT09ICdcXDBcXDBcXDBcXDAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9IGBFcnJvciBhdCBvZmZzZXQ9JHt0aGlzLnRva2VuaXplci5wb3NpdGlvbn06IGJveC5pZD0wYDtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRXYXJuaW5nKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9IGBFcnJvciBhdCBvZmZzZXQ9JHt0aGlzLnRva2VuaXplci5wb3NpdGlvbn06ICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIGRlYnVnKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRXYXJuaW5nKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb290QXRvbSA9IGF3YWl0IEF0b21fMS5BdG9tLnJlYWRBdG9tKHRoaXMudG9rZW5pemVyLCAoYXRvbSwgcmVtYWluaW5nKSA9PiB0aGlzLmhhbmRsZUF0b20oYXRvbSwgcmVtYWluaW5nKSwgbnVsbCwgcmVtYWluaW5nRmlsZVNpemUpO1xuICAgICAgICAgICAgcmVtYWluaW5nRmlsZVNpemUgLT0gcm9vdEF0b20uaGVhZGVyLmxlbmd0aCA9PT0gQmlnSW50KDApID8gcmVtYWluaW5nRmlsZVNpemUgOiBOdW1iZXIocm9vdEF0b20uaGVhZGVyLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9zdCBwcm9jZXNzIG1ldGFkYXRhXG4gICAgICAgIGNvbnN0IGZvcm1hdExpc3QgPSBbXTtcbiAgICAgICAgdGhpcy50cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFja0Zvcm1hdHMgPSBbXTtcbiAgICAgICAgICAgIHRyYWNrLnNvdW5kU2FtcGxlRGVzY3JpcHRpb24uZm9yRWFjaChzc2QgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbUluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVySW5mbyA9IGVuY29kZXJEaWN0W3NzZC5kYXRhRm9ybWF0XTtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RlckluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tGb3JtYXRzLnB1c2goZW5jb2RlckluZm8uZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtSW5mby5jb2RlY05hbWUgPSBlbmNvZGVySW5mby5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW1JbmZvLmNvZGVjTmFtZSA9IGA8JHtzc2QuZGF0YUZvcm1hdH0+YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNzZC5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRlc2NyaXB0aW9uIH0gPSBzc2Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbi5zYW1wbGVSYXRlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtSW5mby50eXBlID0gdHlwZV8xLlRyYWNrVHlwZS5hdWRpbztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbUluZm8uYXVkaW8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxpbmdGcmVxdWVuY3k6IGRlc2NyaXB0aW9uLnNhbXBsZVJhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0RGVwdGg6IGRlc2NyaXB0aW9uLnNhbXBsZVNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHM6IGRlc2NyaXB0aW9uLm51bUF1ZGlvQ2hhbm5lbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRTdHJlYW1JbmZvKHN0cmVhbUluZm8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHJhY2tGb3JtYXRzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0TGlzdC5wdXNoKHRyYWNrRm9ybWF0cy5qb2luKCcvJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZvcm1hdExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvZGVjJywgZm9ybWF0TGlzdC5maWx0ZXIoZGlzdGluY3QpLmpvaW4oJysnKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXVkaW9UcmFja3MgPSB0aGlzLnRyYWNrcy5maWx0ZXIodHJhY2sgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNrLnNvdW5kU2FtcGxlRGVzY3JpcHRpb24ubGVuZ3RoID49IDEgJiYgdHJhY2suc291bmRTYW1wbGVEZXNjcmlwdGlvblswXS5kZXNjcmlwdGlvbiAmJiB0cmFjay5zb3VuZFNhbXBsZURlc2NyaXB0aW9uWzBdLmRlc2NyaXB0aW9uLm51bUF1ZGlvQ2hhbm5lbHMgPiAwO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBhdWRpb1RyYWNrID0gYXVkaW9UcmFja3NbMF07XG4gICAgICAgICAgICBpZiAoYXVkaW9UcmFjay50aW1lU2NhbGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBhdWRpb1RyYWNrLmR1cmF0aW9uIC8gYXVkaW9UcmFjay50aW1lU2NhbGU7IC8vIGNhbGN1bGF0ZSBkdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2R1cmF0aW9uJywgZHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3NkID0gYXVkaW9UcmFjay5zb3VuZFNhbXBsZURlc2NyaXB0aW9uWzBdO1xuICAgICAgICAgICAgaWYgKHNzZC5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdzYW1wbGVSYXRlJywgc3NkLmRlc2NyaXB0aW9uLnNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdiaXRzUGVyU2FtcGxlJywgc3NkLmRlc2NyaXB0aW9uLnNhbXBsZVNpemUpO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZkNoYW5uZWxzJywgc3NkLmRlc2NyaXB0aW9uLm51bUF1ZGlvQ2hhbm5lbHMpO1xuICAgICAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrLnRpbWVTY2FsZSA9PT0gMCAmJiBhdWRpb1RyYWNrLnRpbWVUb1NhbXBsZVRhYmxlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWxTYW1wbGVTaXplID0gYXVkaW9UcmFjay50aW1lVG9TYW1wbGVUYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCh0dHN0RW50cnkgPT4gdHRzdEVudHJ5LmNvdW50ICogdHRzdEVudHJ5LmR1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlZHVjZSgodG90YWwsIHNhbXBsZVNpemUpID0+IHRvdGFsICsgc2FtcGxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdG90YWxTYW1wbGVTaXplIC8gc3NkLmRlc2NyaXB0aW9uLnNhbXBsZVJhdGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdkdXJhdGlvbicsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVySW5mbyA9IGVuY29kZXJEaWN0W3NzZC5kYXRhRm9ybWF0XTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVySW5mbykge1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdsb3NzbGVzcycsICFlbmNvZGVySW5mby5sb3NzeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUJpdFJhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBdG9tKGF0b20sIHJlbWFpbmluZykge1xuICAgICAgICBpZiAoYXRvbS5wYXJlbnQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXRvbS5wYXJlbnQuaGVhZGVyLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpbHN0JzpcbiAgICAgICAgICAgICAgICBjYXNlICc8aWQ+JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VNZXRhZGF0YUl0ZW1EYXRhKGF0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnN0IHBheWxvYWRMZW5ndGggPSBhdG9tLmdldFBheWxvYWRMZW5ndGgocmVtYWluaW5nKTtcbiAgICAgICAgaWYgKHRoaXMuYXRvbVBhcnNlcnNbYXRvbS5oZWFkZXIubmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0b21QYXJzZXJzW2F0b20uaGVhZGVyLm5hbWVdKHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhgTm8gcGFyc2VyIGZvciBhdG9tIHBhdGg9JHthdG9tLmF0b21QYXRofSwgcGF5bG9hZC1sZW49JHtyZW1haW5pbmd9LCBpZ25vcmluZyBhdG9tYCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUocmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUcmFja0Rlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFja3NbdGhpcy50cmFja3MubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGNhbGN1bGF0ZUJpdFJhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmF1ZGlvTGVuZ3RoSW5CeXRlcyAmJiB0aGlzLm1ldGFkYXRhLmZvcm1hdC5kdXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCA4ICogdGhpcy5hdWRpb0xlbmd0aEluQnl0ZXMgLyB0aGlzLm1ldGFkYXRhLmZvcm1hdC5kdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVGFnKGlkLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFRhZyh0YWdGb3JtYXQsIGlkLCB2YWx1ZSk7XG4gICAgfVxuICAgIGFkZFdhcm5pbmcobWVzc2FnZSkge1xuICAgICAgICBkZWJ1ZygnV2FybmluZzogJyArIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFdhcm5pbmcobWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGRhdGEgb2YgTWV0YS1pdGVtLWxpc3QtYXRvbSAoaXRlbSBvZiAnaWxzdCcgYXRvbSlcbiAgICAgKiBAcGFyYW0gbWV0YUF0b21cbiAgICAgKiBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2NvbnRlbnQvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9NZXRhZGF0YS9NZXRhZGF0YS5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDEtU1c4XG4gICAgICovXG4gICAgcGFyc2VNZXRhZGF0YUl0ZW1EYXRhKG1ldGFBdG9tKSB7XG4gICAgICAgIGxldCB0YWdLZXkgPSBtZXRhQXRvbS5oZWFkZXIubmFtZTtcbiAgICAgICAgcmV0dXJuIG1ldGFBdG9tLnJlYWRBdG9tcyh0aGlzLnRva2VuaXplciwgYXN5bmMgKGNoaWxkLCByZW1haW5pbmcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheUxvYWRMZW5ndGggPSBjaGlsZC5nZXRQYXlsb2FkTGVuZ3RoKHJlbWFpbmluZyk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoaWxkLmhlYWRlci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF0YSc6IC8vIHZhbHVlIGF0b21cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYWx1ZUF0b20odGFnS2V5LCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgY2FzZSAnbmFtZSc6IC8vIG5hbWUgYXRvbSAob3B0aW9uYWwpXG4gICAgICAgICAgICAgICAgY2FzZSAnbWVhbic6XG4gICAgICAgICAgICAgICAgY2FzZSAncmF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEF0b21Ub2tlbi5OYW1lQXRvbShwYXlMb2FkTGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRhZ0tleSArPSAnOicgKyBuYW1lLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFBdG9tID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBUb2tlbi5CdWZmZXJUeXBlKHBheUxvYWRMZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRXYXJuaW5nKCdVbnN1cHBvcnRlZCBtZXRhLWl0ZW06ICcgKyB0YWdLZXkgKyAnWycgKyBjaGlsZC5oZWFkZXIubmFtZSArICddID0+IHZhbHVlPScgKyBkYXRhQXRvbS50b1N0cmluZygnaGV4JykgKyAnIGFzY2lpPScgKyBkYXRhQXRvbS50b1N0cmluZygnYXNjaWknKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG1ldGFBdG9tLmdldFBheWxvYWRMZW5ndGgoMCkpO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZVZhbHVlQXRvbSh0YWdLZXksIG1ldGFBdG9tKSB7XG4gICAgICAgIGNvbnN0IGRhdGFBdG9tID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBBdG9tVG9rZW4uRGF0YUF0b20oTnVtYmVyKG1ldGFBdG9tLmhlYWRlci5sZW5ndGgpIC0gQXRvbVRva2VuLkhlYWRlci5sZW4pKTtcbiAgICAgICAgaWYgKGRhdGFBdG9tLnR5cGUuc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGUtc2V0ICE9IDA6ICcgKyBkYXRhQXRvbS50eXBlLnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIHdlbGwta25vd24tdHlwZSB0YWJsZVxuICAgICAgICAvLyBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L2NvbnRlbnQvZG9jdW1lbnRhdGlvbi9RdWlja1RpbWUvUVRGRi9NZXRhZGF0YS9NZXRhZGF0YS5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDEtU1czNVxuICAgICAgICBzd2l0Y2ggKGRhdGFBdG9tLnR5cGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwOiAvLyByZXNlcnZlZDogUmVzZXJ2ZWQgZm9yIHVzZSB3aGVyZSBubyB0eXBlIG5lZWRzIHRvIGJlIGluZGljYXRlZFxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Rya24nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkaXNrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bSA9IFRva2VuLlVJTlQ4LmdldChkYXRhQXRvbS52YWx1ZSwgMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvZiA9IFRva2VuLlVJTlQ4LmdldChkYXRhQXRvbS52YWx1ZSwgNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIiAgJXNbZGF0YV0gPSAlcy8lc1wiLCB0YWdLZXksIG51bSwgb2YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUYWcodGFnS2V5LCBudW0gKyAnLycgKyBvZik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ25yZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW5yZUludCA9IFRva2VuLlVJTlQ4LmdldChkYXRhQXRvbS52YWx1ZSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW5yZVN0ciA9IElEM3YxUGFyc2VyXzEuR2VucmVzW2dlbnJlSW50IC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIiAgJXNbZGF0YV0gPSAlc1wiLCB0YWdLZXksIGdlbnJlU3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFnKHRhZ0tleSwgZ2VucmVTdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF0ZSA9IGRhdGFBdG9tLnZhbHVlLnRvU3RyaW5nKCdhc2NpaScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUYWcodGFnS2V5LCByYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoJ3Vua25vd24gcHJvcHJpZXRhcnkgdmFsdWUgdHlwZSBmb3I6ICcgKyBtZXRhQXRvbS5hdG9tUGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOiAvLyBVVEYtODogV2l0aG91dCBhbnkgY291bnQgb3IgTlVMTCB0ZXJtaW5hdG9yXG4gICAgICAgICAgICBjYXNlIDE4OiAvLyBVbmtub3duOiBGb3VuZCBpbiBtNGIgaW4gY29tYmluYXRpb24gd2l0aCBhICfCqWdlbicgdGFnXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUYWcodGFnS2V5LCBkYXRhQXRvbS52YWx1ZS50b1N0cmluZygndXRmLTgnKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEzOiAvLyBKUEVHXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5za2lwQ292ZXJzKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZyh0YWdLZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnaW1hZ2UvanBlZycsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IEJ1ZmZlci5mcm9tKGRhdGFBdG9tLnZhbHVlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNDogLy8gUE5HXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5za2lwQ292ZXJzKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRhZyh0YWdLZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiAnaW1hZ2UvcG5nJyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogQnVmZmVyLmZyb20oZGF0YUF0b20udmFsdWUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIxOiAvLyBCRSBTaWduZWQgSW50ZWdlclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFnKHRhZ0tleSwgTVA0UGFyc2VyLnJlYWRfQkVfSW50ZWdlcihkYXRhQXRvbS52YWx1ZSwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyMjogLy8gQkUgVW5zaWduZWQgSW50ZWdlclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFnKHRhZ0tleSwgTVA0UGFyc2VyLnJlYWRfQkVfSW50ZWdlcihkYXRhQXRvbS52YWx1ZSwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjU6IC8vIEFuIDgtYml0IHNpZ25lZCBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUYWcodGFnS2V5LCBkYXRhQXRvbS52YWx1ZS5yZWFkSW50OCgwKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY2OiAvLyBBIGJpZy1lbmRpYW4gMTYtYml0IHNpZ25lZCBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUYWcodGFnS2V5LCBkYXRhQXRvbS52YWx1ZS5yZWFkSW50MTZCRSgwKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY3OiAvLyBBIGJpZy1lbmRpYW4gMzItYml0IHNpZ25lZCBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUYWcodGFnS2V5LCBkYXRhQXRvbS52YWx1ZS5yZWFkSW50MzJCRSgwKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuYWRkV2FybmluZyhgYXRvbSBrZXk9JHt0YWdLZXl9LCBoYXMgdW5rbm93biB3ZWxsLWtub3duLXR5cGUgKGRhdGEtdHlwZSk6ICR7ZGF0YUF0b20udHlwZS50eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzYW1wbGVEZXNjcmlwdGlvblxuICAgICAqIFJlZjogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL1F1aWNrVGltZS9RVEZGL1FURkZDaGFwMy9xdGZmMy5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFA0MDAwMDkzOS1DSDIwNS0xMjg5MTZcbiAgICAgKi9cbiAgICBwYXJzZVNvdW5kU2FtcGxlRGVzY3JpcHRpb24oc2FtcGxlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3Qgc3NkID0ge1xuICAgICAgICAgICAgZGF0YUZvcm1hdDogc2FtcGxlRGVzY3JpcHRpb24uZGF0YUZvcm1hdCxcbiAgICAgICAgICAgIGRhdGFSZWZlcmVuY2VJbmRleDogc2FtcGxlRGVzY3JpcHRpb24uZGF0YVJlZmVyZW5jZUluZGV4XG4gICAgICAgIH07XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gQXRvbVRva2VuLlNvdW5kU2FtcGxlRGVzY3JpcHRpb25WZXJzaW9uLmdldChzYW1wbGVEZXNjcmlwdGlvbi5kZXNjcmlwdGlvbiwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IEF0b21Ub2tlbi5Tb3VuZFNhbXBsZURlc2NyaXB0aW9uVmVyc2lvbi5sZW47XG4gICAgICAgIGlmICh2ZXJzaW9uLnZlcnNpb24gPT09IDAgfHwgdmVyc2lvbi52ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgICAvLyBTb3VuZCBTYW1wbGUgRGVzY3JpcHRpb24gKFZlcnNpb24gMClcbiAgICAgICAgICAgIHNzZC5kZXNjcmlwdGlvbiA9IEF0b21Ub2tlbi5Tb3VuZFNhbXBsZURlc2NyaXB0aW9uVjAuZ2V0KHNhbXBsZURlc2NyaXB0aW9uLmRlc2NyaXB0aW9uLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoYFdhcm5pbmc6IHNvdW5kLXNhbXBsZS1kZXNjcmlwdGlvbiAke3ZlcnNpb259IG5vdCBpbXBsZW1lbnRlZGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzc2Q7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQ2hhcHRlclRyYWNrKGNoYXB0ZXJUcmFjaywgdHJhY2ssIGxlbikge1xuICAgICAgICBpZiAoIWNoYXB0ZXJUcmFjay5zYW1wbGVTaXplKSB7XG4gICAgICAgICAgICBpZiAoY2hhcHRlclRyYWNrLmNodW5rT2Zmc2V0VGFibGUubGVuZ3RoICE9PSBjaGFwdGVyVHJhY2suc2FtcGxlU2l6ZVRhYmxlLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGVxdWFsIGNodW5rLW9mZnNldC10YWJsZSAmIHNhbXBsZS1zaXplLXRhYmxlIGxlbmd0aC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFwdGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXB0ZXJUcmFjay5jaHVua09mZnNldFRhYmxlLmxlbmd0aCAmJiBsZW4gPiAwOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rT2Zmc2V0ID0gY2hhcHRlclRyYWNrLmNodW5rT2Zmc2V0VGFibGVbaV07XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2h1bmtMZW4gPSBjaHVua09mZnNldCAtIHRoaXMudG9rZW5pemVyLnBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlU2l6ZSA9IGNoYXB0ZXJUcmFjay5zYW1wbGVTaXplID4gMCA/IGNoYXB0ZXJUcmFjay5zYW1wbGVTaXplIDogY2hhcHRlclRyYWNrLnNhbXBsZVNpemVUYWJsZVtpXTtcbiAgICAgICAgICAgIGxlbiAtPSBuZXh0Q2h1bmtMZW4gKyBzYW1wbGVTaXplO1xuICAgICAgICAgICAgaWYgKGxlbiA8IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFwdGVyIGNodW5rIGV4Y2VlZGluZyB0b2tlbiBsZW5ndGgnKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShuZXh0Q2h1bmtMZW4pO1xuICAgICAgICAgICAgY29uc3QgdGl0bGUgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IEF0b21Ub2tlbi5DaGFwdGVyVGV4dChzYW1wbGVTaXplKSk7XG4gICAgICAgICAgICBkZWJ1ZyhgQ2hhcHRlciAke2kgKyAxfTogJHt0aXRsZX1gKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYXB0ZXIgPSB7XG4gICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgc2FtcGxlT2Zmc2V0OiB0aGlzLmZpbmRTYW1wbGVPZmZzZXQodHJhY2ssIHRoaXMudG9rZW5pemVyLnBvc2l0aW9uKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlYnVnKGBDaGFwdGVyIHRpdGxlPSR7Y2hhcHRlci50aXRsZX0sIG9mZnNldD0ke2NoYXB0ZXIuc2FtcGxlT2Zmc2V0fS8ke3RoaXMudHJhY2tzWzBdLmR1cmF0aW9ufWApO1xuICAgICAgICAgICAgY2hhcHRlcnMucHVzaChjaGFwdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY2hhcHRlcnMnLCBjaGFwdGVycyk7XG4gICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShsZW4pO1xuICAgIH1cbiAgICBmaW5kU2FtcGxlT2Zmc2V0KHRyYWNrLCBjaGFwdGVyT2Zmc2V0KSB7XG4gICAgICAgIGxldCB0b3RhbER1cmF0aW9uID0gMDtcbiAgICAgICAgdHJhY2sudGltZVRvU2FtcGxlVGFibGUuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICAgIHRvdGFsRHVyYXRpb24gKz0gZS5jb3VudCAqIGUuZHVyYXRpb247XG4gICAgICAgIH0pO1xuICAgICAgICBkZWJ1ZyhgVG90YWwgZHVyYXRpb249JHt0b3RhbER1cmF0aW9ufWApO1xuICAgICAgICBsZXQgY2h1bmtJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChjaHVua0luZGV4IDwgdHJhY2suY2h1bmtPZmZzZXRUYWJsZS5sZW5ndGggJiYgdHJhY2suY2h1bmtPZmZzZXRUYWJsZVtjaHVua0luZGV4XSA8IGNoYXB0ZXJPZmZzZXQpIHtcbiAgICAgICAgICAgICsrY2h1bmtJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDaHVua0R1cmF0aW9uKGNodW5rSW5kZXggKyAxLCB0cmFjayk7XG4gICAgfVxuICAgIGdldENodW5rRHVyYXRpb24oY2h1bmtJZCwgdHJhY2spIHtcbiAgICAgICAgbGV0IHR0c2kgPSAwO1xuICAgICAgICBsZXQgdHRzYyA9IHRyYWNrLnRpbWVUb1NhbXBsZVRhYmxlW3R0c2ldLmNvdW50O1xuICAgICAgICBsZXQgdHRzZCA9IHRyYWNrLnRpbWVUb1NhbXBsZVRhYmxlW3R0c2ldLmR1cmF0aW9uO1xuICAgICAgICBsZXQgY3VyQ2h1bmtJZCA9IDE7XG4gICAgICAgIGxldCBzYW1wbGVzUGVyQ2h1bmsgPSB0aGlzLmdldFNhbXBsZXNQZXJDaHVuayhjdXJDaHVua0lkLCB0cmFjay5zYW1wbGVUb0NodW5rVGFibGUpO1xuICAgICAgICBsZXQgdG90YWxEdXJhdGlvbiA9IDA7XG4gICAgICAgIHdoaWxlIChjdXJDaHVua0lkIDwgY2h1bmtJZCkge1xuICAgICAgICAgICAgY29uc3QgbnJPZlNhbXBsZXMgPSBNYXRoLm1pbih0dHNjLCBzYW1wbGVzUGVyQ2h1bmspO1xuICAgICAgICAgICAgdG90YWxEdXJhdGlvbiArPSBuck9mU2FtcGxlcyAqIHR0c2Q7XG4gICAgICAgICAgICB0dHNjIC09IG5yT2ZTYW1wbGVzO1xuICAgICAgICAgICAgc2FtcGxlc1BlckNodW5rIC09IG5yT2ZTYW1wbGVzO1xuICAgICAgICAgICAgaWYgKHNhbXBsZXNQZXJDaHVuayA9PT0gMCkge1xuICAgICAgICAgICAgICAgICsrY3VyQ2h1bmtJZDtcbiAgICAgICAgICAgICAgICBzYW1wbGVzUGVyQ2h1bmsgPSB0aGlzLmdldFNhbXBsZXNQZXJDaHVuayhjdXJDaHVua0lkLCB0cmFjay5zYW1wbGVUb0NodW5rVGFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKyt0dHNpO1xuICAgICAgICAgICAgICAgIHR0c2MgPSB0cmFjay50aW1lVG9TYW1wbGVUYWJsZVt0dHNpXS5jb3VudDtcbiAgICAgICAgICAgICAgICB0dHNkID0gdHJhY2sudGltZVRvU2FtcGxlVGFibGVbdHRzaV0uZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsRHVyYXRpb247XG4gICAgfVxuICAgIGdldFNhbXBsZXNQZXJDaHVuayhjaHVua0lkLCBzdGNUYWJsZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0Y1RhYmxlLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgaWYgKGNodW5rSWQgPj0gc3RjVGFibGVbaV0uZmlyc3RDaHVuayAmJiBjaHVua0lkIDwgc3RjVGFibGVbaSArIDFdLmZpcnN0Q2h1bmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RjVGFibGVbaV0uc2FtcGxlc1BlckNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGNUYWJsZVtzdGNUYWJsZS5sZW5ndGggLSAxXS5zYW1wbGVzUGVyQ2h1bms7XG4gICAgfVxufVxuZXhwb3J0cy5NUDRQYXJzZXIgPSBNUDRQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/mp4/MP4Parser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/mp4/MP4TagMapper.js":
/*!*************************************************************!*\
  !*** ./node_modules/music-metadata/lib/mp4/MP4TagMapper.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MP4TagMapper = exports.tagType = void 0;\nconst CaseInsensitiveTagMap_1 = __webpack_require__(/*! ../common/CaseInsensitiveTagMap */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/CaseInsensitiveTagMap.js\");\n/**\n * Ref: https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\n */\nconst mp4TagMap = {\n    '©nam': 'title',\n    '©ART': 'artist',\n    aART: 'albumartist',\n    /**\n     * ToDo: Album artist seems to be stored here while Picard documentation says: aART\n     */\n    '----:com.apple.iTunes:Band': 'albumartist',\n    '©alb': 'album',\n    '©day': 'date',\n    '©cmt': 'comment',\n    '©com': 'comment',\n    trkn: 'track',\n    disk: 'disk',\n    '©gen': 'genre',\n    covr: 'picture',\n    '©wrt': 'composer',\n    '©lyr': 'lyrics',\n    soal: 'albumsort',\n    sonm: 'titlesort',\n    soar: 'artistsort',\n    soaa: 'albumartistsort',\n    soco: 'composersort',\n    '----:com.apple.iTunes:LYRICIST': 'lyricist',\n    '----:com.apple.iTunes:CONDUCTOR': 'conductor',\n    '----:com.apple.iTunes:REMIXER': 'remixer',\n    '----:com.apple.iTunes:ENGINEER': 'engineer',\n    '----:com.apple.iTunes:PRODUCER': 'producer',\n    '----:com.apple.iTunes:DJMIXER': 'djmixer',\n    '----:com.apple.iTunes:MIXER': 'mixer',\n    '----:com.apple.iTunes:LABEL': 'label',\n    '©grp': 'grouping',\n    '----:com.apple.iTunes:SUBTITLE': 'subtitle',\n    '----:com.apple.iTunes:DISCSUBTITLE': 'discsubtitle',\n    cpil: 'compilation',\n    tmpo: 'bpm',\n    '----:com.apple.iTunes:MOOD': 'mood',\n    '----:com.apple.iTunes:MEDIA': 'media',\n    '----:com.apple.iTunes:CATALOGNUMBER': 'catalognumber',\n    tvsh: 'tvShow',\n    tvsn: 'tvSeason',\n    tves: 'tvEpisode',\n    sosn: 'tvShowSort',\n    tven: 'tvEpisodeId',\n    tvnn: 'tvNetwork',\n    pcst: 'podcast',\n    purl: 'podcasturl',\n    '----:com.apple.iTunes:MusicBrainz Album Status': 'releasestatus',\n    '----:com.apple.iTunes:MusicBrainz Album Type': 'releasetype',\n    '----:com.apple.iTunes:MusicBrainz Album Release Country': 'releasecountry',\n    '----:com.apple.iTunes:SCRIPT': 'script',\n    '----:com.apple.iTunes:LANGUAGE': 'language',\n    cprt: 'copyright',\n    '©cpy': 'copyright',\n    '----:com.apple.iTunes:LICENSE': 'license',\n    '©too': 'encodedby',\n    pgap: 'gapless',\n    '----:com.apple.iTunes:BARCODE': 'barcode',\n    '----:com.apple.iTunes:ISRC': 'isrc',\n    '----:com.apple.iTunes:ASIN': 'asin',\n    '----:com.apple.iTunes:NOTES': 'comment',\n    '----:com.apple.iTunes:MusicBrainz Track Id': 'musicbrainz_recordingid',\n    '----:com.apple.iTunes:MusicBrainz Release Track Id': 'musicbrainz_trackid',\n    '----:com.apple.iTunes:MusicBrainz Album Id': 'musicbrainz_albumid',\n    '----:com.apple.iTunes:MusicBrainz Artist Id': 'musicbrainz_artistid',\n    '----:com.apple.iTunes:MusicBrainz Album Artist Id': 'musicbrainz_albumartistid',\n    '----:com.apple.iTunes:MusicBrainz Release Group Id': 'musicbrainz_releasegroupid',\n    '----:com.apple.iTunes:MusicBrainz Work Id': 'musicbrainz_workid',\n    '----:com.apple.iTunes:MusicBrainz TRM Id': 'musicbrainz_trmid',\n    '----:com.apple.iTunes:MusicBrainz Disc Id': 'musicbrainz_discid',\n    '----:com.apple.iTunes:Acoustid Id': 'acoustid_id',\n    '----:com.apple.iTunes:Acoustid Fingerprint': 'acoustid_fingerprint',\n    '----:com.apple.iTunes:MusicIP PUID': 'musicip_puid',\n    '----:com.apple.iTunes:fingerprint': 'musicip_fingerprint',\n    '----:com.apple.iTunes:replaygain_track_gain': 'replaygain_track_gain',\n    '----:com.apple.iTunes:replaygain_track_peak': 'replaygain_track_peak',\n    '----:com.apple.iTunes:replaygain_album_gain': 'replaygain_album_gain',\n    '----:com.apple.iTunes:replaygain_album_peak': 'replaygain_album_peak',\n    '----:com.apple.iTunes:replaygain_track_minmax': 'replaygain_track_minmax',\n    '----:com.apple.iTunes:replaygain_album_minmax': 'replaygain_album_minmax',\n    '----:com.apple.iTunes:replaygain_undo': 'replaygain_undo',\n    // Additional mappings:\n    gnre: 'genre',\n    '----:com.apple.iTunes:ALBUMARTISTSORT': 'albumartistsort',\n    '----:com.apple.iTunes:ARTISTS': 'artists',\n    '----:com.apple.iTunes:ORIGINALDATE': 'originaldate',\n    '----:com.apple.iTunes:ORIGINALYEAR': 'originalyear',\n    // '----:com.apple.iTunes:PERFORMER': 'performer'\n    desc: 'description',\n    ldes: 'longDescription',\n    '©mvn': 'movement',\n    '©mvi': 'movementIndex',\n    '©mvc': 'movementTotal',\n    '©wrk': 'work',\n    catg: 'category',\n    egid: 'podcastId',\n    hdvd: 'hdVideo',\n    keyw: 'keywords',\n    shwm: 'showMovement',\n    stik: 'stik',\n    rate: 'rating'\n};\nexports.tagType = 'iTunes';\nclass MP4TagMapper extends CaseInsensitiveTagMap_1.CaseInsensitiveTagMap {\n    constructor() {\n        super([exports.tagType], mp4TagMap);\n    }\n    postMap(tag, warnings) {\n        switch (tag.id) {\n            case 'rate':\n                tag.value = {\n                    source: undefined,\n                    rating: parseFloat(tag.value) / 100\n                };\n                break;\n        }\n    }\n}\nexports.MP4TagMapper = MP4TagMapper;\n//# sourceMappingURL=MP4TagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXA0L01QNFRhZ01hcHBlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxlQUFlO0FBQ3RDLGdDQUFnQyxtQkFBTyxDQUFDLDhIQUFpQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXA0L01QNFRhZ01hcHBlci5qcz9mNDJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NUDRUYWdNYXBwZXIgPSBleHBvcnRzLnRhZ1R5cGUgPSB2b2lkIDA7XG5jb25zdCBDYXNlSW5zZW5zaXRpdmVUYWdNYXBfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vQ2FzZUluc2Vuc2l0aXZlVGFnTWFwXCIpO1xuLyoqXG4gKiBSZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9zZXJnaW9tYjIvbGlibXA0djIvd2lraS9pVHVuZXNNZXRhZGF0YVxuICovXG5jb25zdCBtcDRUYWdNYXAgPSB7XG4gICAgJ8KpbmFtJzogJ3RpdGxlJyxcbiAgICAnwqlBUlQnOiAnYXJ0aXN0JyxcbiAgICBhQVJUOiAnYWxidW1hcnRpc3QnLFxuICAgIC8qKlxuICAgICAqIFRvRG86IEFsYnVtIGFydGlzdCBzZWVtcyB0byBiZSBzdG9yZWQgaGVyZSB3aGlsZSBQaWNhcmQgZG9jdW1lbnRhdGlvbiBzYXlzOiBhQVJUXG4gICAgICovXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpCYW5kJzogJ2FsYnVtYXJ0aXN0JyxcbiAgICAnwqlhbGInOiAnYWxidW0nLFxuICAgICfCqWRheSc6ICdkYXRlJyxcbiAgICAnwqljbXQnOiAnY29tbWVudCcsXG4gICAgJ8KpY29tJzogJ2NvbW1lbnQnLFxuICAgIHRya246ICd0cmFjaycsXG4gICAgZGlzazogJ2Rpc2snLFxuICAgICfCqWdlbic6ICdnZW5yZScsXG4gICAgY292cjogJ3BpY3R1cmUnLFxuICAgICfCqXdydCc6ICdjb21wb3NlcicsXG4gICAgJ8KpbHlyJzogJ2x5cmljcycsXG4gICAgc29hbDogJ2FsYnVtc29ydCcsXG4gICAgc29ubTogJ3RpdGxlc29ydCcsXG4gICAgc29hcjogJ2FydGlzdHNvcnQnLFxuICAgIHNvYWE6ICdhbGJ1bWFydGlzdHNvcnQnLFxuICAgIHNvY286ICdjb21wb3NlcnNvcnQnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6TFlSSUNJU1QnOiAnbHlyaWNpc3QnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6Q09ORFVDVE9SJzogJ2NvbmR1Y3RvcicsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpSRU1JWEVSJzogJ3JlbWl4ZXInLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6RU5HSU5FRVInOiAnZW5naW5lZXInLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6UFJPRFVDRVInOiAncHJvZHVjZXInLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6REpNSVhFUic6ICdkam1peGVyJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk1JWEVSJzogJ21peGVyJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOkxBQkVMJzogJ2xhYmVsJyxcbiAgICAnwqlncnAnOiAnZ3JvdXBpbmcnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6U1VCVElUTEUnOiAnc3VidGl0bGUnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6RElTQ1NVQlRJVExFJzogJ2Rpc2NzdWJ0aXRsZScsXG4gICAgY3BpbDogJ2NvbXBpbGF0aW9uJyxcbiAgICB0bXBvOiAnYnBtJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk1PT0QnOiAnbW9vZCcsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpNRURJQSc6ICdtZWRpYScsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpDQVRBTE9HTlVNQkVSJzogJ2NhdGFsb2dudW1iZXInLFxuICAgIHR2c2g6ICd0dlNob3cnLFxuICAgIHR2c246ICd0dlNlYXNvbicsXG4gICAgdHZlczogJ3R2RXBpc29kZScsXG4gICAgc29zbjogJ3R2U2hvd1NvcnQnLFxuICAgIHR2ZW46ICd0dkVwaXNvZGVJZCcsXG4gICAgdHZubjogJ3R2TmV0d29yaycsXG4gICAgcGNzdDogJ3BvZGNhc3QnLFxuICAgIHB1cmw6ICdwb2RjYXN0dXJsJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk11c2ljQnJhaW56IEFsYnVtIFN0YXR1cyc6ICdyZWxlYXNlc3RhdHVzJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk11c2ljQnJhaW56IEFsYnVtIFR5cGUnOiAncmVsZWFzZXR5cGUnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6TXVzaWNCcmFpbnogQWxidW0gUmVsZWFzZSBDb3VudHJ5JzogJ3JlbGVhc2Vjb3VudHJ5JyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOlNDUklQVCc6ICdzY3JpcHQnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6TEFOR1VBR0UnOiAnbGFuZ3VhZ2UnLFxuICAgIGNwcnQ6ICdjb3B5cmlnaHQnLFxuICAgICfCqWNweSc6ICdjb3B5cmlnaHQnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6TElDRU5TRSc6ICdsaWNlbnNlJyxcbiAgICAnwql0b28nOiAnZW5jb2RlZGJ5JyxcbiAgICBwZ2FwOiAnZ2FwbGVzcycsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpCQVJDT0RFJzogJ2JhcmNvZGUnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6SVNSQyc6ICdpc3JjJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOkFTSU4nOiAnYXNpbicsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpOT1RFUyc6ICdjb21tZW50JyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk11c2ljQnJhaW56IFRyYWNrIElkJzogJ211c2ljYnJhaW56X3JlY29yZGluZ2lkJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk11c2ljQnJhaW56IFJlbGVhc2UgVHJhY2sgSWQnOiAnbXVzaWNicmFpbnpfdHJhY2tpZCcsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpNdXNpY0JyYWlueiBBbGJ1bSBJZCc6ICdtdXNpY2JyYWluel9hbGJ1bWlkJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk11c2ljQnJhaW56IEFydGlzdCBJZCc6ICdtdXNpY2JyYWluel9hcnRpc3RpZCcsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpNdXNpY0JyYWlueiBBbGJ1bSBBcnRpc3QgSWQnOiAnbXVzaWNicmFpbnpfYWxidW1hcnRpc3RpZCcsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpNdXNpY0JyYWlueiBSZWxlYXNlIEdyb3VwIElkJzogJ211c2ljYnJhaW56X3JlbGVhc2Vncm91cGlkJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk11c2ljQnJhaW56IFdvcmsgSWQnOiAnbXVzaWNicmFpbnpfd29ya2lkJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk11c2ljQnJhaW56IFRSTSBJZCc6ICdtdXNpY2JyYWluel90cm1pZCcsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpNdXNpY0JyYWlueiBEaXNjIElkJzogJ211c2ljYnJhaW56X2Rpc2NpZCcsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpBY291c3RpZCBJZCc6ICdhY291c3RpZF9pZCcsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpBY291c3RpZCBGaW5nZXJwcmludCc6ICdhY291c3RpZF9maW5nZXJwcmludCcsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpNdXNpY0lQIFBVSUQnOiAnbXVzaWNpcF9wdWlkJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOmZpbmdlcnByaW50JzogJ211c2ljaXBfZmluZ2VycHJpbnQnLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6cmVwbGF5Z2Fpbl90cmFja19nYWluJzogJ3JlcGxheWdhaW5fdHJhY2tfZ2FpbicsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpyZXBsYXlnYWluX3RyYWNrX3BlYWsnOiAncmVwbGF5Z2Fpbl90cmFja19wZWFrJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOnJlcGxheWdhaW5fYWxidW1fZ2Fpbic6ICdyZXBsYXlnYWluX2FsYnVtX2dhaW4nLFxuICAgICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6cmVwbGF5Z2Fpbl9hbGJ1bV9wZWFrJzogJ3JlcGxheWdhaW5fYWxidW1fcGVhaycsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpyZXBsYXlnYWluX3RyYWNrX21pbm1heCc6ICdyZXBsYXlnYWluX3RyYWNrX21pbm1heCcsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpyZXBsYXlnYWluX2FsYnVtX21pbm1heCc6ICdyZXBsYXlnYWluX2FsYnVtX21pbm1heCcsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpyZXBsYXlnYWluX3VuZG8nOiAncmVwbGF5Z2Fpbl91bmRvJyxcbiAgICAvLyBBZGRpdGlvbmFsIG1hcHBpbmdzOlxuICAgIGducmU6ICdnZW5yZScsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpBTEJVTUFSVElTVFNPUlQnOiAnYWxidW1hcnRpc3Rzb3J0JyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOkFSVElTVFMnOiAnYXJ0aXN0cycsXG4gICAgJy0tLS06Y29tLmFwcGxlLmlUdW5lczpPUklHSU5BTERBVEUnOiAnb3JpZ2luYWxkYXRlJyxcbiAgICAnLS0tLTpjb20uYXBwbGUuaVR1bmVzOk9SSUdJTkFMWUVBUic6ICdvcmlnaW5hbHllYXInLFxuICAgIC8vICctLS0tOmNvbS5hcHBsZS5pVHVuZXM6UEVSRk9STUVSJzogJ3BlcmZvcm1lcidcbiAgICBkZXNjOiAnZGVzY3JpcHRpb24nLFxuICAgIGxkZXM6ICdsb25nRGVzY3JpcHRpb24nLFxuICAgICfCqW12bic6ICdtb3ZlbWVudCcsXG4gICAgJ8KpbXZpJzogJ21vdmVtZW50SW5kZXgnLFxuICAgICfCqW12Yyc6ICdtb3ZlbWVudFRvdGFsJyxcbiAgICAnwql3cmsnOiAnd29yaycsXG4gICAgY2F0ZzogJ2NhdGVnb3J5JyxcbiAgICBlZ2lkOiAncG9kY2FzdElkJyxcbiAgICBoZHZkOiAnaGRWaWRlbycsXG4gICAga2V5dzogJ2tleXdvcmRzJyxcbiAgICBzaHdtOiAnc2hvd01vdmVtZW50JyxcbiAgICBzdGlrOiAnc3RpaycsXG4gICAgcmF0ZTogJ3JhdGluZydcbn07XG5leHBvcnRzLnRhZ1R5cGUgPSAnaVR1bmVzJztcbmNsYXNzIE1QNFRhZ01hcHBlciBleHRlbmRzIENhc2VJbnNlbnNpdGl2ZVRhZ01hcF8xLkNhc2VJbnNlbnNpdGl2ZVRhZ01hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFtleHBvcnRzLnRhZ1R5cGVdLCBtcDRUYWdNYXApO1xuICAgIH1cbiAgICBwb3N0TWFwKHRhZywgd2FybmluZ3MpIHtcbiAgICAgICAgc3dpdGNoICh0YWcuaWQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JhdGUnOlxuICAgICAgICAgICAgICAgIHRhZy52YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHJhdGluZzogcGFyc2VGbG9hdCh0YWcudmFsdWUpIC8gMTAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTVA0VGFnTWFwcGVyID0gTVA0VGFnTWFwcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TVA0VGFnTWFwcGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/mp4/MP4TagMapper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/mpeg/ExtendedLameHeader.js":
/*!********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/mpeg/ExtendedLameHeader.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/**\n * Extended Lame Header\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExtendedLameHeader = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst common = __webpack_require__(/*! ../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\nconst ReplayGainDataFormat_1 = __webpack_require__(/*! ./ReplayGainDataFormat */ \"(app-pages-browser)/./node_modules/music-metadata/lib/mpeg/ReplayGainDataFormat.js\");\n/**\n * Info Tag\n * @link http://gabriel.mp3-tech.org/mp3infotag.html\n * @link https://github.com/quodlibet/mutagen/blob/abd58ee58772224334a18817c3fb31103572f70e/mutagen/mp3/_util.py#L112\n */\nexports.ExtendedLameHeader = {\n    len: 27,\n    get: (buf, off) => {\n        const track_peak = Token.UINT32_BE.get(buf, off + 2);\n        return {\n            revision: common.getBitAllignedNumber(buf, off, 0, 4),\n            vbr_method: common.getBitAllignedNumber(buf, off, 4, 4),\n            lowpass_filter: 100 * Token.UINT8.get(buf, off + 1),\n            track_peak: track_peak === 0 ? undefined : track_peak / Math.pow(2, 23),\n            track_gain: ReplayGainDataFormat_1.ReplayGain.get(buf, 6),\n            album_gain: ReplayGainDataFormat_1.ReplayGain.get(buf, 8),\n            music_length: Token.UINT32_BE.get(buf, off + 20),\n            music_crc: Token.UINT8.get(buf, off + 24),\n            header_crc: Token.UINT16_BE.get(buf, off + 24)\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXBlZy9FeHRlbmRlZExhbWVIZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxnRkFBYTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsNEZBQWdCO0FBQ3ZDLCtCQUErQixtQkFBTyxDQUFDLGtIQUF3QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXBlZy9FeHRlbmRlZExhbWVIZWFkZXIuanM/MDdhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogRXh0ZW5kZWQgTGFtZSBIZWFkZXJcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FeHRlbmRlZExhbWVIZWFkZXIgPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoXCIuLi9jb21tb24vVXRpbFwiKTtcbmNvbnN0IFJlcGxheUdhaW5EYXRhRm9ybWF0XzEgPSByZXF1aXJlKFwiLi9SZXBsYXlHYWluRGF0YUZvcm1hdFwiKTtcbi8qKlxuICogSW5mbyBUYWdcbiAqIEBsaW5rIGh0dHA6Ly9nYWJyaWVsLm1wMy10ZWNoLm9yZy9tcDNpbmZvdGFnLmh0bWxcbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9xdW9kbGliZXQvbXV0YWdlbi9ibG9iL2FiZDU4ZWU1ODc3MjIyNDMzNGExODgxN2MzZmIzMTEwMzU3MmY3MGUvbXV0YWdlbi9tcDMvX3V0aWwucHkjTDExMlxuICovXG5leHBvcnRzLkV4dGVuZGVkTGFtZUhlYWRlciA9IHtcbiAgICBsZW46IDI3LFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYWNrX3BlYWsgPSBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1Ziwgb2ZmICsgMik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXZpc2lvbjogY29tbW9uLmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmLCAwLCA0KSxcbiAgICAgICAgICAgIHZicl9tZXRob2Q6IGNvbW1vbi5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiwgNCwgNCksXG4gICAgICAgICAgICBsb3dwYXNzX2ZpbHRlcjogMTAwICogVG9rZW4uVUlOVDguZ2V0KGJ1Ziwgb2ZmICsgMSksXG4gICAgICAgICAgICB0cmFja19wZWFrOiB0cmFja19wZWFrID09PSAwID8gdW5kZWZpbmVkIDogdHJhY2tfcGVhayAvIE1hdGgucG93KDIsIDIzKSxcbiAgICAgICAgICAgIHRyYWNrX2dhaW46IFJlcGxheUdhaW5EYXRhRm9ybWF0XzEuUmVwbGF5R2Fpbi5nZXQoYnVmLCA2KSxcbiAgICAgICAgICAgIGFsYnVtX2dhaW46IFJlcGxheUdhaW5EYXRhRm9ybWF0XzEuUmVwbGF5R2Fpbi5nZXQoYnVmLCA4KSxcbiAgICAgICAgICAgIG11c2ljX2xlbmd0aDogVG9rZW4uVUlOVDMyX0JFLmdldChidWYsIG9mZiArIDIwKSxcbiAgICAgICAgICAgIG11c2ljX2NyYzogVG9rZW4uVUlOVDguZ2V0KGJ1Ziwgb2ZmICsgMjQpLFxuICAgICAgICAgICAgaGVhZGVyX2NyYzogVG9rZW4uVUlOVDE2X0JFLmdldChidWYsIG9mZiArIDI0KVxuICAgICAgICB9O1xuICAgIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/mpeg/ExtendedLameHeader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/mpeg/MpegParser.js":
/*!************************************************************!*\
  !*** ./node_modules/music-metadata/lib/mpeg/MpegParser.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MpegParser = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst core_1 = __webpack_require__(/*! strtok3/lib/core */ \"(app-pages-browser)/./node_modules/strtok3/lib/core.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst common = __webpack_require__(/*! ../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\nconst AbstractID3Parser_1 = __webpack_require__(/*! ../id3v2/AbstractID3Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js\");\nconst XingTag_1 = __webpack_require__(/*! ./XingTag */ \"(app-pages-browser)/./node_modules/music-metadata/lib/mpeg/XingTag.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:mpeg');\n/**\n * Cache buffer size used for searching synchronization preabmle\n */\nconst maxPeekLen = 1024;\n/**\n * MPEG-4 Audio definitions\n * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio\n */\nconst MPEG4 = {\n    /**\n     * Audio Object Types\n     */\n    AudioObjectTypes: [\n        'AAC Main',\n        'AAC LC',\n        'AAC SSR',\n        'AAC LTP' // Long Term Prediction\n    ],\n    /**\n     * Sampling Frequencies\n     * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies\n     */\n    SamplingFrequencies: [\n        96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, undefined, undefined, -1\n    ]\n    /**\n     * Channel Configurations\n     */\n};\nconst MPEG4_ChannelConfigurations = [\n    undefined,\n    ['front-center'],\n    ['front-left', 'front-right'],\n    ['front-center', 'front-left', 'front-right'],\n    ['front-center', 'front-left', 'front-right', 'back-center'],\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'],\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'],\n    ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']\n];\n/**\n * MPEG Audio Layer I/II/III frame header\n * Ref: https://www.mp3-tech.org/programmer/frame_header.html\n * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM\n * Ref: https://wiki.multimedia.cx/index.php/ADTS\n */\nclass MpegFrameHeader {\n    constructor(buf, off) {\n        // B(20,19): MPEG Audio versionIndex ID\n        this.versionIndex = common.getBitAllignedNumber(buf, off + 1, 3, 2);\n        // C(18,17): Layer description\n        this.layer = MpegFrameHeader.LayerDescription[common.getBitAllignedNumber(buf, off + 1, 5, 2)];\n        if (this.versionIndex > 1 && this.layer === 0) {\n            this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)\n        }\n        else {\n            this.parseMpegHeader(buf, off); // Conventional MPEG header\n        }\n        // D(16): Protection bit (if true 16-bit CRC follows header)\n        this.isProtectedByCRC = !common.isBitSet(buf, off + 1, 7);\n    }\n    calcDuration(numFrames) {\n        return numFrames * this.calcSamplesPerFrame() / this.samplingRate;\n    }\n    calcSamplesPerFrame() {\n        return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];\n    }\n    calculateSideInfoLength() {\n        if (this.layer !== 3)\n            return 2;\n        if (this.channelModeIndex === 3) {\n            // mono\n            if (this.version === 1) {\n                return 17;\n            }\n            else if (this.version === 2 || this.version === 2.5) {\n                return 9;\n            }\n        }\n        else {\n            if (this.version === 1) {\n                return 32;\n            }\n            else if (this.version === 2 || this.version === 2.5) {\n                return 17;\n            }\n        }\n    }\n    calcSlotSize() {\n        return [null, 4, 1, 1][this.layer];\n    }\n    parseMpegHeader(buf, off) {\n        this.container = 'MPEG';\n        // E(15,12): Bitrate index\n        this.bitrateIndex = common.getBitAllignedNumber(buf, off + 2, 0, 4);\n        // F(11,10): Sampling rate frequency index\n        this.sampRateFreqIndex = common.getBitAllignedNumber(buf, off + 2, 4, 2);\n        // G(9): Padding bit\n        this.padding = common.isBitSet(buf, off + 2, 6);\n        // H(8): Private bit\n        this.privateBit = common.isBitSet(buf, off + 2, 7);\n        // I(7,6): Channel Mode\n        this.channelModeIndex = common.getBitAllignedNumber(buf, off + 3, 0, 2);\n        // J(5,4): Mode extension (Only used in Joint stereo)\n        this.modeExtension = common.getBitAllignedNumber(buf, off + 3, 2, 2);\n        // K(3): Copyright\n        this.isCopyrighted = common.isBitSet(buf, off + 3, 4);\n        // L(2): Original\n        this.isOriginalMedia = common.isBitSet(buf, off + 3, 5);\n        // M(3): The original bit indicates, if it is set, that the frame is located on its original media.\n        this.emphasis = common.getBitAllignedNumber(buf, off + 3, 7, 2);\n        this.version = MpegFrameHeader.VersionID[this.versionIndex];\n        this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];\n        this.codec = `MPEG ${this.version} Layer ${this.layer}`;\n        // Calculate bitrate\n        const bitrateInKbps = this.calcBitrate();\n        if (!bitrateInKbps) {\n            throw new Error('Cannot determine bit-rate');\n        }\n        this.bitrate = bitrateInKbps * 1000;\n        // Calculate sampling rate\n        this.samplingRate = this.calcSamplingRate();\n        if (this.samplingRate == null) {\n            throw new Error('Cannot determine sampling-rate');\n        }\n    }\n    parseAdtsHeader(buf, off) {\n        debug(`layer=0 => ADTS`);\n        this.version = this.versionIndex === 2 ? 4 : 2;\n        this.container = 'ADTS/MPEG-' + this.version;\n        const profileIndex = common.getBitAllignedNumber(buf, off + 2, 0, 2);\n        this.codec = 'AAC';\n        this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];\n        debug(`MPEG-4 audio-codec=${this.codec}`);\n        const samplingFrequencyIndex = common.getBitAllignedNumber(buf, off + 2, 2, 4);\n        this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];\n        debug(`sampling-rate=${this.samplingRate}`);\n        const channelIndex = common.getBitAllignedNumber(buf, off + 2, 7, 3);\n        this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];\n        debug(`channel-config=${this.mp4ChannelConfig.join('+')}`);\n        this.frameLength = common.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;\n    }\n    calcBitrate() {\n        if (this.bitrateIndex === 0x00 || // free\n            this.bitrateIndex === 0x0F) { // reserved\n            return;\n        }\n        const codecIndex = `${Math.floor(this.version)}${this.layer}`;\n        return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];\n    }\n    calcSamplingRate() {\n        if (this.sampRateFreqIndex === 0x03)\n            return null; // 'reserved'\n        return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];\n    }\n}\nMpegFrameHeader.SyncByte1 = 0xFF;\nMpegFrameHeader.SyncByte2 = 0xE0;\nMpegFrameHeader.VersionID = [2.5, null, 2, 1];\nMpegFrameHeader.LayerDescription = [0, 3, 2, 1];\nMpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];\nMpegFrameHeader.bitrate_index = {\n    0x01: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },\n    0x02: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },\n    0x03: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },\n    0x04: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },\n    0x05: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },\n    0x06: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },\n    0x07: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },\n    0x08: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },\n    0x09: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },\n    0x0A: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },\n    0x0B: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },\n    0x0C: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },\n    0x0D: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },\n    0x0E: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }\n};\nMpegFrameHeader.sampling_rate_freq_index = {\n    1: { 0x00: 44100, 0x01: 48000, 0x02: 32000 },\n    2: { 0x00: 22050, 0x01: 24000, 0x02: 16000 },\n    2.5: { 0x00: 11025, 0x01: 12000, 0x02: 8000 }\n};\nMpegFrameHeader.samplesInFrameTable = [\n    /* Layer   I    II   III */\n    [0, 384, 1152, 1152],\n    [0, 384, 1152, 576] // MPEG-2(.5\n];\n/**\n * MPEG Audio Layer I/II/III\n */\nconst FrameHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return new MpegFrameHeader(buf, off);\n    }\n};\nfunction getVbrCodecProfile(vbrScale) {\n    return 'V' + Math.floor((100 - vbrScale) / 10);\n}\nclass MpegParser extends AbstractID3Parser_1.AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.frameCount = 0;\n        this.syncFrameCount = -1;\n        this.countSkipFrameData = 0;\n        this.totalDataLength = 0;\n        this.bitrates = [];\n        this.calculateEofDuration = false;\n        this.buf_frame_header = Buffer.alloc(4);\n        this.syncPeek = {\n            buf: Buffer.alloc(maxPeekLen),\n            len: 0\n        };\n    }\n    /**\n     * Called after ID3 headers have been parsed\n     */\n    async postId3v2Parse() {\n        this.metadata.setFormat('lossless', false);\n        try {\n            let quit = false;\n            while (!quit) {\n                await this.sync();\n                quit = await this.parseCommonMpegHeader();\n            }\n        }\n        catch (err) {\n            if (err instanceof core_1.EndOfStreamError) {\n                debug(`End-of-stream`);\n                if (this.calculateEofDuration) {\n                    const numberOfSamples = this.frameCount * this.samplesPerFrame;\n                    this.metadata.setFormat('numberOfSamples', numberOfSamples);\n                    const duration = numberOfSamples / this.metadata.format.sampleRate;\n                    debug(`Calculate duration at EOF: ${duration} sec.`, duration);\n                    this.metadata.setFormat('duration', duration);\n                }\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    /**\n     * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length\n     */\n    finalize() {\n        const format = this.metadata.format;\n        const hasID3v1 = this.metadata.native.hasOwnProperty('ID3v1');\n        if (format.duration && this.tokenizer.fileInfo.size) {\n            const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n            if (format.codecProfile && format.codecProfile[0] === 'V') {\n                this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);\n            }\n        }\n        else if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {\n            const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n            const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;\n            this.metadata.setFormat('numberOfSamples', numberOfSamples);\n            const duration = numberOfSamples / format.sampleRate;\n            debug(\"Calculate CBR duration based on file size: %s\", duration);\n            this.metadata.setFormat('duration', duration);\n        }\n    }\n    async sync() {\n        let gotFirstSync = false;\n        while (true) {\n            let bo = 0;\n            this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: true });\n            if (this.syncPeek.len <= 163) {\n                throw new core_1.EndOfStreamError();\n            }\n            while (true) {\n                if (gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0) {\n                    this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;\n                    this.buf_frame_header[1] = this.syncPeek.buf[bo];\n                    await this.tokenizer.ignore(bo);\n                    debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);\n                    if (this.syncFrameCount === this.frameCount) {\n                        debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);\n                        this.frameCount = 0;\n                        this.frame_size = 0;\n                    }\n                    this.syncFrameCount = this.frameCount;\n                    return; // sync\n                }\n                else {\n                    gotFirstSync = false;\n                    bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);\n                    if (bo === -1) {\n                        if (this.syncPeek.len < this.syncPeek.buf.length) {\n                            throw new core_1.EndOfStreamError();\n                        }\n                        await this.tokenizer.ignore(this.syncPeek.len);\n                        break; // continue with next buffer\n                    }\n                    else {\n                        ++bo;\n                        gotFirstSync = true;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Combined ADTS & MPEG (MP2 & MP3) header handling\n     * @return {Promise<boolean>} true if parser should quit\n     */\n    async parseCommonMpegHeader() {\n        if (this.frameCount === 0) {\n            this.mpegOffset = this.tokenizer.position - 1;\n        }\n        await this.tokenizer.peekBuffer(this.buf_frame_header, { offset: 1, length: 3 });\n        let header;\n        try {\n            header = FrameHeader.get(this.buf_frame_header, 0);\n        }\n        catch (err) {\n            await this.tokenizer.ignore(1);\n            this.metadata.addWarning('Parse error: ' + err.message);\n            return false; // sync\n        }\n        await this.tokenizer.ignore(3);\n        this.metadata.setFormat('container', header.container);\n        this.metadata.setFormat('codec', header.codec);\n        this.metadata.setFormat('lossless', false);\n        this.metadata.setFormat('sampleRate', header.samplingRate);\n        this.frameCount++;\n        return header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);\n    }\n    /**\n     * @return {Promise<boolean>} true if parser should quit\n     */\n    async parseAudioFrameHeader(header) {\n        this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);\n        this.metadata.setFormat('bitrate', header.bitrate);\n        if (this.frameCount < 20 * 10000) {\n            debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);\n        }\n        const slot_size = header.calcSlotSize();\n        if (slot_size === null) {\n            throw new Error('invalid slot_size');\n        }\n        const samples_per_frame = header.calcSamplesPerFrame();\n        debug(`samples_per_frame=${samples_per_frame}`);\n        const bps = samples_per_frame / 8.0;\n        const fsize = (bps * header.bitrate / header.samplingRate) +\n            ((header.padding) ? slot_size : 0);\n        this.frame_size = Math.floor(fsize);\n        this.audioFrameHeader = header;\n        this.bitrates.push(header.bitrate);\n        // xtra header only exists in first frame\n        if (this.frameCount === 1) {\n            this.offset = FrameHeader.len;\n            await this.skipSideInformation();\n            return false;\n        }\n        if (this.frameCount === 3) {\n            // the stream is CBR if the first 3 frame bitrates are the same\n            if (this.areAllSame(this.bitrates)) {\n                // Actual calculation will be done in finalize\n                this.samplesPerFrame = samples_per_frame;\n                this.metadata.setFormat('codecProfile', 'CBR');\n                if (this.tokenizer.fileInfo.size)\n                    return true; // Will calculate duration based on the file size\n            }\n            else if (this.metadata.format.duration) {\n                return true; // We already got the duration, stop processing MPEG stream any further\n            }\n            if (!this.options.duration) {\n                return true; // Enforce duration not enabled, stop processing entire stream\n            }\n        }\n        // once we know the file is VBR attach listener to end of\n        // stream so we can do the duration calculation when we\n        // have counted all the frames\n        if (this.options.duration && this.frameCount === 4) {\n            this.samplesPerFrame = samples_per_frame;\n            this.calculateEofDuration = true;\n        }\n        this.offset = 4;\n        if (header.isProtectedByCRC) {\n            await this.parseCrc();\n            return false;\n        }\n        else {\n            await this.skipSideInformation();\n            return false;\n        }\n    }\n    async parseAdts(header) {\n        const buf = Buffer.alloc(3);\n        await this.tokenizer.readBuffer(buf);\n        header.frameLength += common.getBitAllignedNumber(buf, 0, 0, 11);\n        this.totalDataLength += header.frameLength;\n        this.samplesPerFrame = 1024;\n        const framesPerSec = header.samplingRate / this.samplesPerFrame;\n        const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;\n        const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;\n        this.metadata.setFormat('bitrate', bitrate);\n        debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);\n        await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);\n        // Consume remaining header and frame data\n        if (this.frameCount === 3) {\n            this.metadata.setFormat('codecProfile', header.codecProfile);\n            if (header.mp4ChannelConfig) {\n                this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);\n            }\n            if (this.options.duration) {\n                this.calculateEofDuration = true;\n            }\n            else {\n                return true; // Stop parsing after the third frame\n            }\n        }\n        return false;\n    }\n    async parseCrc() {\n        this.crc = await this.tokenizer.readNumber(Token.INT16_BE);\n        this.offset += 2;\n        return this.skipSideInformation();\n    }\n    async skipSideInformation() {\n        const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();\n        // side information\n        await this.tokenizer.readToken(new Token.Uint8ArrayType(sideinfo_length));\n        this.offset += sideinfo_length;\n        await this.readXtraInfoHeader();\n        return;\n    }\n    async readXtraInfoHeader() {\n        const headerTag = await this.tokenizer.readToken(XingTag_1.InfoTagHeaderTag);\n        this.offset += XingTag_1.InfoTagHeaderTag.len; // 12\n        switch (headerTag) {\n            case 'Info':\n                this.metadata.setFormat('codecProfile', 'CBR');\n                return this.readXingInfoHeader();\n            case 'Xing':\n                const infoTag = await this.readXingInfoHeader();\n                const codecProfile = getVbrCodecProfile(infoTag.vbrScale);\n                this.metadata.setFormat('codecProfile', codecProfile);\n                return null;\n            case 'Xtra':\n                // ToDo: ???\n                break;\n            case 'LAME':\n                const version = await this.tokenizer.readToken(XingTag_1.LameEncoderVersion);\n                if (this.frame_size >= this.offset + XingTag_1.LameEncoderVersion.len) {\n                    this.offset += XingTag_1.LameEncoderVersion.len;\n                    this.metadata.setFormat('tool', 'LAME ' + version);\n                    await this.skipFrameData(this.frame_size - this.offset);\n                    return null;\n                }\n                else {\n                    this.metadata.addWarning('Corrupt LAME header');\n                    break;\n                }\n            // ToDo: ???\n        }\n        // ToDo: promise duration???\n        const frameDataLeft = this.frame_size - this.offset;\n        if (frameDataLeft < 0) {\n            this.metadata.addWarning('Frame ' + this.frameCount + 'corrupt: negative frameDataLeft');\n        }\n        else {\n            await this.skipFrameData(frameDataLeft);\n        }\n        return null;\n    }\n    /**\n     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n     * @returns {Promise<string>}\n     */\n    async readXingInfoHeader() {\n        const offset = this.tokenizer.position;\n        const infoTag = await (0, XingTag_1.readXingHeader)(this.tokenizer);\n        this.offset += this.tokenizer.position - offset;\n        if (infoTag.lame) {\n            this.metadata.setFormat('tool', 'LAME ' + common.stripNulls(infoTag.lame.version));\n            if (infoTag.lame.extended) {\n                // this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain);\n                this.metadata.setFormat('trackPeakLevel', infoTag.lame.extended.track_peak);\n                if (infoTag.lame.extended.track_gain) {\n                    this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain.adjustment);\n                }\n                if (infoTag.lame.extended.album_gain) {\n                    this.metadata.setFormat('albumGain', infoTag.lame.extended.album_gain.adjustment);\n                }\n                this.metadata.setFormat('duration', infoTag.lame.extended.music_length / 1000);\n            }\n        }\n        if (infoTag.streamSize) {\n            const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);\n            this.metadata.setFormat('duration', duration);\n            debug('Get duration from Xing header: %s', this.metadata.format.duration);\n            return infoTag;\n        }\n        // frames field is not present\n        const frameDataLeft = this.frame_size - this.offset;\n        await this.skipFrameData(frameDataLeft);\n        return infoTag;\n    }\n    async skipFrameData(frameDataLeft) {\n        if (frameDataLeft < 0)\n            throw new Error('frame-data-left cannot be negative');\n        await this.tokenizer.ignore(frameDataLeft);\n        this.countSkipFrameData += frameDataLeft;\n    }\n    areAllSame(array) {\n        const first = array[0];\n        return array.every(element => {\n            return element === first;\n        });\n    }\n}\nexports.MpegParser = MpegParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXBlZy9NcGVnUGFyc2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsY0FBYyxtQkFBTyxDQUFDLGdGQUFhO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyxnRkFBa0I7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQU87QUFDL0IsZUFBZSxtQkFBTyxDQUFDLDRGQUFnQjtBQUN2Qyw0QkFBNEIsbUJBQU8sQ0FBQyxvSEFBNEI7QUFDaEUsa0JBQWtCLG1CQUFPLENBQUMsd0ZBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYyxRQUFRLFdBQVc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVztBQUMvQztBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QixFQUFFLFdBQVc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4Q0FBOEM7QUFDMUQsWUFBWSxnREFBZ0Q7QUFDNUQsWUFBWSxnREFBZ0Q7QUFDNUQsWUFBWSxpREFBaUQ7QUFDN0QsWUFBWSxpREFBaUQ7QUFDN0QsWUFBWSxpREFBaUQ7QUFDN0QsWUFBWSxtREFBbUQ7QUFDL0QsWUFBWSxvREFBb0Q7QUFDaEUsWUFBWSxvREFBb0Q7QUFDaEUsWUFBWSxvREFBb0Q7QUFDaEUsWUFBWSxzREFBc0Q7QUFDbEUsWUFBWSxzREFBc0Q7QUFDbEUsWUFBWSxzREFBc0Q7QUFDbEUsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTLHVDQUF1QztBQUNoRCxTQUFTLHVDQUF1QztBQUNoRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxVQUFVO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixxQ0FBcUM7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw0QkFBNEIsZUFBZSxnQkFBZ0I7QUFDdkc7QUFDQSxtRUFBbUUsZ0JBQWdCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHNCQUFzQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCLFNBQVMsb0JBQW9CLGtCQUFrQixRQUFRO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXBlZy9NcGVnUGFyc2VyLmpzP2Q0MTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1wZWdQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCJzdHJ0b2szL2xpYi9jb3JlXCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoXCIuLi9jb21tb24vVXRpbFwiKTtcbmNvbnN0IEFic3RyYWN0SUQzUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vaWQzdjIvQWJzdHJhY3RJRDNQYXJzZXJcIik7XG5jb25zdCBYaW5nVGFnXzEgPSByZXF1aXJlKFwiLi9YaW5nVGFnXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbXVzaWMtbWV0YWRhdGE6cGFyc2VyOm1wZWcnKTtcbi8qKlxuICogQ2FjaGUgYnVmZmVyIHNpemUgdXNlZCBmb3Igc2VhcmNoaW5nIHN5bmNocm9uaXphdGlvbiBwcmVhYm1sZVxuICovXG5jb25zdCBtYXhQZWVrTGVuID0gMTAyNDtcbi8qKlxuICogTVBFRy00IEF1ZGlvIGRlZmluaXRpb25zXG4gKiBSZWY6ICBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHAvTVBFRy00X0F1ZGlvXG4gKi9cbmNvbnN0IE1QRUc0ID0ge1xuICAgIC8qKlxuICAgICAqIEF1ZGlvIE9iamVjdCBUeXBlc1xuICAgICAqL1xuICAgIEF1ZGlvT2JqZWN0VHlwZXM6IFtcbiAgICAgICAgJ0FBQyBNYWluJyxcbiAgICAgICAgJ0FBQyBMQycsXG4gICAgICAgICdBQUMgU1NSJyxcbiAgICAgICAgJ0FBQyBMVFAnIC8vIExvbmcgVGVybSBQcmVkaWN0aW9uXG4gICAgXSxcbiAgICAvKipcbiAgICAgKiBTYW1wbGluZyBGcmVxdWVuY2llc1xuICAgICAqIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocC9NUEVHLTRfQXVkaW8jU2FtcGxpbmdfRnJlcXVlbmNpZXNcbiAgICAgKi9cbiAgICBTYW1wbGluZ0ZyZXF1ZW5jaWVzOiBbXG4gICAgICAgIDk2MDAwLCA4ODIwMCwgNjQwMDAsIDQ4MDAwLCA0NDEwMCwgMzIwMDAsIDI0MDAwLCAyMjA1MCwgMTYwMDAsIDEyMDAwLCAxMTAyNSwgODAwMCwgNzM1MCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIC0xXG4gICAgXVxuICAgIC8qKlxuICAgICAqIENoYW5uZWwgQ29uZmlndXJhdGlvbnNcbiAgICAgKi9cbn07XG5jb25zdCBNUEVHNF9DaGFubmVsQ29uZmlndXJhdGlvbnMgPSBbXG4gICAgdW5kZWZpbmVkLFxuICAgIFsnZnJvbnQtY2VudGVyJ10sXG4gICAgWydmcm9udC1sZWZ0JywgJ2Zyb250LXJpZ2h0J10sXG4gICAgWydmcm9udC1jZW50ZXInLCAnZnJvbnQtbGVmdCcsICdmcm9udC1yaWdodCddLFxuICAgIFsnZnJvbnQtY2VudGVyJywgJ2Zyb250LWxlZnQnLCAnZnJvbnQtcmlnaHQnLCAnYmFjay1jZW50ZXInXSxcbiAgICBbJ2Zyb250LWNlbnRlcicsICdmcm9udC1sZWZ0JywgJ2Zyb250LXJpZ2h0JywgJ2JhY2stbGVmdCcsICdiYWNrLXJpZ2h0J10sXG4gICAgWydmcm9udC1jZW50ZXInLCAnZnJvbnQtbGVmdCcsICdmcm9udC1yaWdodCcsICdiYWNrLWxlZnQnLCAnYmFjay1yaWdodCcsICdMRkUtY2hhbm5lbCddLFxuICAgIFsnZnJvbnQtY2VudGVyJywgJ2Zyb250LWxlZnQnLCAnZnJvbnQtcmlnaHQnLCAnc2lkZS1sZWZ0JywgJ3NpZGUtcmlnaHQnLCAnYmFjay1sZWZ0JywgJ2JhY2stcmlnaHQnLCAnTEZFLWNoYW5uZWwnXVxuXTtcbi8qKlxuICogTVBFRyBBdWRpbyBMYXllciBJL0lJL0lJSSBmcmFtZSBoZWFkZXJcbiAqIFJlZjogaHR0cHM6Ly93d3cubXAzLXRlY2gub3JnL3Byb2dyYW1tZXIvZnJhbWVfaGVhZGVyLmh0bWxcbiAqIEJpdCBsYXlvdXQ6IEFBQUFBQUFBIEFBQUJCQ0NEIEVFRUVGRkdIIElJSkpLTE1NXG4gKiBSZWY6IGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocC9BRFRTXG4gKi9cbmNsYXNzIE1wZWdGcmFtZUhlYWRlciB7XG4gICAgY29uc3RydWN0b3IoYnVmLCBvZmYpIHtcbiAgICAgICAgLy8gQigyMCwxOSk6IE1QRUcgQXVkaW8gdmVyc2lvbkluZGV4IElEXG4gICAgICAgIHRoaXMudmVyc2lvbkluZGV4ID0gY29tbW9uLmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmICsgMSwgMywgMik7XG4gICAgICAgIC8vIEMoMTgsMTcpOiBMYXllciBkZXNjcmlwdGlvblxuICAgICAgICB0aGlzLmxheWVyID0gTXBlZ0ZyYW1lSGVhZGVyLkxheWVyRGVzY3JpcHRpb25bY29tbW9uLmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmICsgMSwgNSwgMildO1xuICAgICAgICBpZiAodGhpcy52ZXJzaW9uSW5kZXggPiAxICYmIHRoaXMubGF5ZXIgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VBZHRzSGVhZGVyKGJ1Ziwgb2ZmKTsgLy8gQXVkaW8gRGF0YSBUcmFuc3BvcnQgU3RyZWFtIChBRFRTKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXJzZU1wZWdIZWFkZXIoYnVmLCBvZmYpOyAvLyBDb252ZW50aW9uYWwgTVBFRyBoZWFkZXJcbiAgICAgICAgfVxuICAgICAgICAvLyBEKDE2KTogUHJvdGVjdGlvbiBiaXQgKGlmIHRydWUgMTYtYml0IENSQyBmb2xsb3dzIGhlYWRlcilcbiAgICAgICAgdGhpcy5pc1Byb3RlY3RlZEJ5Q1JDID0gIWNvbW1vbi5pc0JpdFNldChidWYsIG9mZiArIDEsIDcpO1xuICAgIH1cbiAgICBjYWxjRHVyYXRpb24obnVtRnJhbWVzKSB7XG4gICAgICAgIHJldHVybiBudW1GcmFtZXMgKiB0aGlzLmNhbGNTYW1wbGVzUGVyRnJhbWUoKSAvIHRoaXMuc2FtcGxpbmdSYXRlO1xuICAgIH1cbiAgICBjYWxjU2FtcGxlc1BlckZyYW1lKCkge1xuICAgICAgICByZXR1cm4gTXBlZ0ZyYW1lSGVhZGVyLnNhbXBsZXNJbkZyYW1lVGFibGVbdGhpcy52ZXJzaW9uID09PSAxID8gMCA6IDFdW3RoaXMubGF5ZXJdO1xuICAgIH1cbiAgICBjYWxjdWxhdGVTaWRlSW5mb0xlbmd0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXIgIT09IDMpXG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbE1vZGVJbmRleCA9PT0gMykge1xuICAgICAgICAgICAgLy8gbW9ub1xuICAgICAgICAgICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudmVyc2lvbiA9PT0gMiB8fCB0aGlzLnZlcnNpb24gPT09IDIuNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAzMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudmVyc2lvbiA9PT0gMiB8fCB0aGlzLnZlcnNpb24gPT09IDIuNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxjU2xvdFNpemUoKSB7XG4gICAgICAgIHJldHVybiBbbnVsbCwgNCwgMSwgMV1bdGhpcy5sYXllcl07XG4gICAgfVxuICAgIHBhcnNlTXBlZ0hlYWRlcihidWYsIG9mZikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9ICdNUEVHJztcbiAgICAgICAgLy8gRSgxNSwxMik6IEJpdHJhdGUgaW5kZXhcbiAgICAgICAgdGhpcy5iaXRyYXRlSW5kZXggPSBjb21tb24uZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAyLCAwLCA0KTtcbiAgICAgICAgLy8gRigxMSwxMCk6IFNhbXBsaW5nIHJhdGUgZnJlcXVlbmN5IGluZGV4XG4gICAgICAgIHRoaXMuc2FtcFJhdGVGcmVxSW5kZXggPSBjb21tb24uZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAyLCA0LCAyKTtcbiAgICAgICAgLy8gRyg5KTogUGFkZGluZyBiaXRcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gY29tbW9uLmlzQml0U2V0KGJ1Ziwgb2ZmICsgMiwgNik7XG4gICAgICAgIC8vIEgoOCk6IFByaXZhdGUgYml0XG4gICAgICAgIHRoaXMucHJpdmF0ZUJpdCA9IGNvbW1vbi5pc0JpdFNldChidWYsIG9mZiArIDIsIDcpO1xuICAgICAgICAvLyBJKDcsNik6IENoYW5uZWwgTW9kZVxuICAgICAgICB0aGlzLmNoYW5uZWxNb2RlSW5kZXggPSBjb21tb24uZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAzLCAwLCAyKTtcbiAgICAgICAgLy8gSig1LDQpOiBNb2RlIGV4dGVuc2lvbiAoT25seSB1c2VkIGluIEpvaW50IHN0ZXJlbylcbiAgICAgICAgdGhpcy5tb2RlRXh0ZW5zaW9uID0gY29tbW9uLmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmICsgMywgMiwgMik7XG4gICAgICAgIC8vIEsoMyk6IENvcHlyaWdodFxuICAgICAgICB0aGlzLmlzQ29weXJpZ2h0ZWQgPSBjb21tb24uaXNCaXRTZXQoYnVmLCBvZmYgKyAzLCA0KTtcbiAgICAgICAgLy8gTCgyKTogT3JpZ2luYWxcbiAgICAgICAgdGhpcy5pc09yaWdpbmFsTWVkaWEgPSBjb21tb24uaXNCaXRTZXQoYnVmLCBvZmYgKyAzLCA1KTtcbiAgICAgICAgLy8gTSgzKTogVGhlIG9yaWdpbmFsIGJpdCBpbmRpY2F0ZXMsIGlmIGl0IGlzIHNldCwgdGhhdCB0aGUgZnJhbWUgaXMgbG9jYXRlZCBvbiBpdHMgb3JpZ2luYWwgbWVkaWEuXG4gICAgICAgIHRoaXMuZW1waGFzaXMgPSBjb21tb24uZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAzLCA3LCAyKTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gTXBlZ0ZyYW1lSGVhZGVyLlZlcnNpb25JRFt0aGlzLnZlcnNpb25JbmRleF07XG4gICAgICAgIHRoaXMuY2hhbm5lbE1vZGUgPSBNcGVnRnJhbWVIZWFkZXIuQ2hhbm5lbE1vZGVbdGhpcy5jaGFubmVsTW9kZUluZGV4XTtcbiAgICAgICAgdGhpcy5jb2RlYyA9IGBNUEVHICR7dGhpcy52ZXJzaW9ufSBMYXllciAke3RoaXMubGF5ZXJ9YDtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGJpdHJhdGVcbiAgICAgICAgY29uc3QgYml0cmF0ZUluS2JwcyA9IHRoaXMuY2FsY0JpdHJhdGUoKTtcbiAgICAgICAgaWYgKCFiaXRyYXRlSW5LYnBzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZXRlcm1pbmUgYml0LXJhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJpdHJhdGUgPSBiaXRyYXRlSW5LYnBzICogMTAwMDtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHNhbXBsaW5nIHJhdGVcbiAgICAgICAgdGhpcy5zYW1wbGluZ1JhdGUgPSB0aGlzLmNhbGNTYW1wbGluZ1JhdGUoKTtcbiAgICAgICAgaWYgKHRoaXMuc2FtcGxpbmdSYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRldGVybWluZSBzYW1wbGluZy1yYXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VBZHRzSGVhZGVyKGJ1Ziwgb2ZmKSB7XG4gICAgICAgIGRlYnVnKGBsYXllcj0wID0+IEFEVFNgKTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdGhpcy52ZXJzaW9uSW5kZXggPT09IDIgPyA0IDogMjtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSAnQURUUy9NUEVHLScgKyB0aGlzLnZlcnNpb247XG4gICAgICAgIGNvbnN0IHByb2ZpbGVJbmRleCA9IGNvbW1vbi5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDIsIDAsIDIpO1xuICAgICAgICB0aGlzLmNvZGVjID0gJ0FBQyc7XG4gICAgICAgIHRoaXMuY29kZWNQcm9maWxlID0gTVBFRzQuQXVkaW9PYmplY3RUeXBlc1twcm9maWxlSW5kZXhdO1xuICAgICAgICBkZWJ1ZyhgTVBFRy00IGF1ZGlvLWNvZGVjPSR7dGhpcy5jb2RlY31gKTtcbiAgICAgICAgY29uc3Qgc2FtcGxpbmdGcmVxdWVuY3lJbmRleCA9IGNvbW1vbi5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDIsIDIsIDQpO1xuICAgICAgICB0aGlzLnNhbXBsaW5nUmF0ZSA9IE1QRUc0LlNhbXBsaW5nRnJlcXVlbmNpZXNbc2FtcGxpbmdGcmVxdWVuY3lJbmRleF07XG4gICAgICAgIGRlYnVnKGBzYW1wbGluZy1yYXRlPSR7dGhpcy5zYW1wbGluZ1JhdGV9YCk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxJbmRleCA9IGNvbW1vbi5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDIsIDcsIDMpO1xuICAgICAgICB0aGlzLm1wNENoYW5uZWxDb25maWcgPSBNUEVHNF9DaGFubmVsQ29uZmlndXJhdGlvbnNbY2hhbm5lbEluZGV4XTtcbiAgICAgICAgZGVidWcoYGNoYW5uZWwtY29uZmlnPSR7dGhpcy5tcDRDaGFubmVsQ29uZmlnLmpvaW4oJysnKX1gKTtcbiAgICAgICAgdGhpcy5mcmFtZUxlbmd0aCA9IGNvbW1vbi5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDMsIDYsIDIpIDw8IDExO1xuICAgIH1cbiAgICBjYWxjQml0cmF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYml0cmF0ZUluZGV4ID09PSAweDAwIHx8IC8vIGZyZWVcbiAgICAgICAgICAgIHRoaXMuYml0cmF0ZUluZGV4ID09PSAweDBGKSB7IC8vIHJlc2VydmVkXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZWNJbmRleCA9IGAke01hdGguZmxvb3IodGhpcy52ZXJzaW9uKX0ke3RoaXMubGF5ZXJ9YDtcbiAgICAgICAgcmV0dXJuIE1wZWdGcmFtZUhlYWRlci5iaXRyYXRlX2luZGV4W3RoaXMuYml0cmF0ZUluZGV4XVtjb2RlY0luZGV4XTtcbiAgICB9XG4gICAgY2FsY1NhbXBsaW5nUmF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2FtcFJhdGVGcmVxSW5kZXggPT09IDB4MDMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gJ3Jlc2VydmVkJ1xuICAgICAgICByZXR1cm4gTXBlZ0ZyYW1lSGVhZGVyLnNhbXBsaW5nX3JhdGVfZnJlcV9pbmRleFt0aGlzLnZlcnNpb25dW3RoaXMuc2FtcFJhdGVGcmVxSW5kZXhdO1xuICAgIH1cbn1cbk1wZWdGcmFtZUhlYWRlci5TeW5jQnl0ZTEgPSAweEZGO1xuTXBlZ0ZyYW1lSGVhZGVyLlN5bmNCeXRlMiA9IDB4RTA7XG5NcGVnRnJhbWVIZWFkZXIuVmVyc2lvbklEID0gWzIuNSwgbnVsbCwgMiwgMV07XG5NcGVnRnJhbWVIZWFkZXIuTGF5ZXJEZXNjcmlwdGlvbiA9IFswLCAzLCAyLCAxXTtcbk1wZWdGcmFtZUhlYWRlci5DaGFubmVsTW9kZSA9IFsnc3RlcmVvJywgJ2pvaW50X3N0ZXJlbycsICdkdWFsX2NoYW5uZWwnLCAnbW9ubyddO1xuTXBlZ0ZyYW1lSGVhZGVyLmJpdHJhdGVfaW5kZXggPSB7XG4gICAgMHgwMTogeyAxMTogMzIsIDEyOiAzMiwgMTM6IDMyLCAyMTogMzIsIDIyOiA4LCAyMzogOCB9LFxuICAgIDB4MDI6IHsgMTE6IDY0LCAxMjogNDgsIDEzOiA0MCwgMjE6IDQ4LCAyMjogMTYsIDIzOiAxNiB9LFxuICAgIDB4MDM6IHsgMTE6IDk2LCAxMjogNTYsIDEzOiA0OCwgMjE6IDU2LCAyMjogMjQsIDIzOiAyNCB9LFxuICAgIDB4MDQ6IHsgMTE6IDEyOCwgMTI6IDY0LCAxMzogNTYsIDIxOiA2NCwgMjI6IDMyLCAyMzogMzIgfSxcbiAgICAweDA1OiB7IDExOiAxNjAsIDEyOiA4MCwgMTM6IDY0LCAyMTogODAsIDIyOiA0MCwgMjM6IDQwIH0sXG4gICAgMHgwNjogeyAxMTogMTkyLCAxMjogOTYsIDEzOiA4MCwgMjE6IDk2LCAyMjogNDgsIDIzOiA0OCB9LFxuICAgIDB4MDc6IHsgMTE6IDIyNCwgMTI6IDExMiwgMTM6IDk2LCAyMTogMTEyLCAyMjogNTYsIDIzOiA1NiB9LFxuICAgIDB4MDg6IHsgMTE6IDI1NiwgMTI6IDEyOCwgMTM6IDExMiwgMjE6IDEyOCwgMjI6IDY0LCAyMzogNjQgfSxcbiAgICAweDA5OiB7IDExOiAyODgsIDEyOiAxNjAsIDEzOiAxMjgsIDIxOiAxNDQsIDIyOiA4MCwgMjM6IDgwIH0sXG4gICAgMHgwQTogeyAxMTogMzIwLCAxMjogMTkyLCAxMzogMTYwLCAyMTogMTYwLCAyMjogOTYsIDIzOiA5NiB9LFxuICAgIDB4MEI6IHsgMTE6IDM1MiwgMTI6IDIyNCwgMTM6IDE5MiwgMjE6IDE3NiwgMjI6IDExMiwgMjM6IDExMiB9LFxuICAgIDB4MEM6IHsgMTE6IDM4NCwgMTI6IDI1NiwgMTM6IDIyNCwgMjE6IDE5MiwgMjI6IDEyOCwgMjM6IDEyOCB9LFxuICAgIDB4MEQ6IHsgMTE6IDQxNiwgMTI6IDMyMCwgMTM6IDI1NiwgMjE6IDIyNCwgMjI6IDE0NCwgMjM6IDE0NCB9LFxuICAgIDB4MEU6IHsgMTE6IDQ0OCwgMTI6IDM4NCwgMTM6IDMyMCwgMjE6IDI1NiwgMjI6IDE2MCwgMjM6IDE2MCB9XG59O1xuTXBlZ0ZyYW1lSGVhZGVyLnNhbXBsaW5nX3JhdGVfZnJlcV9pbmRleCA9IHtcbiAgICAxOiB7IDB4MDA6IDQ0MTAwLCAweDAxOiA0ODAwMCwgMHgwMjogMzIwMDAgfSxcbiAgICAyOiB7IDB4MDA6IDIyMDUwLCAweDAxOiAyNDAwMCwgMHgwMjogMTYwMDAgfSxcbiAgICAyLjU6IHsgMHgwMDogMTEwMjUsIDB4MDE6IDEyMDAwLCAweDAyOiA4MDAwIH1cbn07XG5NcGVnRnJhbWVIZWFkZXIuc2FtcGxlc0luRnJhbWVUYWJsZSA9IFtcbiAgICAvKiBMYXllciAgIEkgICAgSUkgICBJSUkgKi9cbiAgICBbMCwgMzg0LCAxMTUyLCAxMTUyXSxcbiAgICBbMCwgMzg0LCAxMTUyLCA1NzZdIC8vIE1QRUctMiguNVxuXTtcbi8qKlxuICogTVBFRyBBdWRpbyBMYXllciBJL0lJL0lJSVxuICovXG5jb25zdCBGcmFtZUhlYWRlciA9IHtcbiAgICBsZW46IDQsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBNcGVnRnJhbWVIZWFkZXIoYnVmLCBvZmYpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBnZXRWYnJDb2RlY1Byb2ZpbGUodmJyU2NhbGUpIHtcbiAgICByZXR1cm4gJ1YnICsgTWF0aC5mbG9vcigoMTAwIC0gdmJyU2NhbGUpIC8gMTApO1xufVxuY2xhc3MgTXBlZ1BhcnNlciBleHRlbmRzIEFic3RyYWN0SUQzUGFyc2VyXzEuQWJzdHJhY3RJRDNQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmZyYW1lQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnN5bmNGcmFtZUNvdW50ID0gLTE7XG4gICAgICAgIHRoaXMuY291bnRTa2lwRnJhbWVEYXRhID0gMDtcbiAgICAgICAgdGhpcy50b3RhbERhdGFMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmJpdHJhdGVzID0gW107XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlRW9mRHVyYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZfZnJhbWVfaGVhZGVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgICB0aGlzLnN5bmNQZWVrID0ge1xuICAgICAgICAgICAgYnVmOiBCdWZmZXIuYWxsb2MobWF4UGVla0xlbiksXG4gICAgICAgICAgICBsZW46IDBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFmdGVyIElEMyBoZWFkZXJzIGhhdmUgYmVlbiBwYXJzZWRcbiAgICAgKi9cbiAgICBhc3luYyBwb3N0SWQzdjJQYXJzZSgpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2xvc3NsZXNzJywgZmFsc2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHF1aXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICghcXVpdCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc3luYygpO1xuICAgICAgICAgICAgICAgIHF1aXQgPSBhd2FpdCB0aGlzLnBhcnNlQ29tbW9uTXBlZ0hlYWRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBjb3JlXzEuRW5kT2ZTdHJlYW1FcnJvcikge1xuICAgICAgICAgICAgICAgIGRlYnVnKGBFbmQtb2Ytc3RyZWFtYCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsY3VsYXRlRW9mRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZTYW1wbGVzID0gdGhpcy5mcmFtZUNvdW50ICogdGhpcy5zYW1wbGVzUGVyRnJhbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZlNhbXBsZXMnLCBudW1iZXJPZlNhbXBsZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IG51bWJlck9mU2FtcGxlcyAvIHRoaXMubWV0YWRhdGEuZm9ybWF0LnNhbXBsZVJhdGU7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKGBDYWxjdWxhdGUgZHVyYXRpb24gYXQgRU9GOiAke2R1cmF0aW9ufSBzZWMuYCwgZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnZHVyYXRpb24nLCBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhZnRlciBmaWxlIGhhcyBiZWVuIGZ1bGx5IHBhcnNlZCwgdGhpcyBhbGxvd3MsIGlmIHByZXNlbnQsIHRvIGV4Y2x1ZGUgdGhlIElEM3YxLjEgaGVhZGVyIGxlbmd0aFxuICAgICAqL1xuICAgIGZpbmFsaXplKCkge1xuICAgICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLm1ldGFkYXRhLmZvcm1hdDtcbiAgICAgICAgY29uc3QgaGFzSUQzdjEgPSB0aGlzLm1ldGFkYXRhLm5hdGl2ZS5oYXNPd25Qcm9wZXJ0eSgnSUQzdjEnKTtcbiAgICAgICAgaWYgKGZvcm1hdC5kdXJhdGlvbiAmJiB0aGlzLnRva2VuaXplci5maWxlSW5mby5zaXplKSB7XG4gICAgICAgICAgICBjb25zdCBtcGVnU2l6ZSA9IHRoaXMudG9rZW5pemVyLmZpbGVJbmZvLnNpemUgLSB0aGlzLm1wZWdPZmZzZXQgLSAoaGFzSUQzdjEgPyAxMjggOiAwKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXQuY29kZWNQcm9maWxlICYmIGZvcm1hdC5jb2RlY1Byb2ZpbGVbMF0gPT09ICdWJykge1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdiaXRyYXRlJywgbXBlZ1NpemUgKiA4IC8gZm9ybWF0LmR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnRva2VuaXplci5maWxlSW5mby5zaXplICYmIGZvcm1hdC5jb2RlY1Byb2ZpbGUgPT09ICdDQlInKSB7XG4gICAgICAgICAgICBjb25zdCBtcGVnU2l6ZSA9IHRoaXMudG9rZW5pemVyLmZpbGVJbmZvLnNpemUgLSB0aGlzLm1wZWdPZmZzZXQgLSAoaGFzSUQzdjEgPyAxMjggOiAwKTtcbiAgICAgICAgICAgIGNvbnN0IG51bWJlck9mU2FtcGxlcyA9IE1hdGgucm91bmQobXBlZ1NpemUgLyB0aGlzLmZyYW1lX3NpemUpICogdGhpcy5zYW1wbGVzUGVyRnJhbWU7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZTYW1wbGVzJywgbnVtYmVyT2ZTYW1wbGVzKTtcbiAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gbnVtYmVyT2ZTYW1wbGVzIC8gZm9ybWF0LnNhbXBsZVJhdGU7XG4gICAgICAgICAgICBkZWJ1ZyhcIkNhbGN1bGF0ZSBDQlIgZHVyYXRpb24gYmFzZWQgb24gZmlsZSBzaXplOiAlc1wiLCBkdXJhdGlvbik7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnZHVyYXRpb24nLCBkdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc3luYygpIHtcbiAgICAgICAgbGV0IGdvdEZpcnN0U3luYyA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGJvID0gMDtcbiAgICAgICAgICAgIHRoaXMuc3luY1BlZWsubGVuID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucGVla0J1ZmZlcih0aGlzLnN5bmNQZWVrLmJ1ZiwgeyBsZW5ndGg6IG1heFBlZWtMZW4sIG1heUJlTGVzczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN5bmNQZWVrLmxlbiA8PSAxNjMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV8xLkVuZE9mU3RyZWFtRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdvdEZpcnN0U3luYyAmJiAodGhpcy5zeW5jUGVlay5idWZbYm9dICYgMHhFMCkgPT09IDB4RTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZfZnJhbWVfaGVhZGVyWzBdID0gTXBlZ0ZyYW1lSGVhZGVyLlN5bmNCeXRlMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZfZnJhbWVfaGVhZGVyWzFdID0gdGhpcy5zeW5jUGVlay5idWZbYm9dO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUoYm8pO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhgU3luYyBhdCBvZmZzZXQ9JHt0aGlzLnRva2VuaXplci5wb3NpdGlvbiAtIDF9LCBmcmFtZUNvdW50PSR7dGhpcy5mcmFtZUNvdW50fWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zeW5jRnJhbWVDb3VudCA9PT0gdGhpcy5mcmFtZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhgUmUtc3luY2VkIE1QRUcgc3RyZWFtLCBmcmFtZUNvdW50PSR7dGhpcy5mcmFtZUNvdW50fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFtZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVfc2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW5jRnJhbWVDb3VudCA9IHRoaXMuZnJhbWVDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBzeW5jXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnb3RGaXJzdFN5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYm8gPSB0aGlzLnN5bmNQZWVrLmJ1Zi5pbmRleE9mKE1wZWdGcmFtZUhlYWRlci5TeW5jQnl0ZTEsIGJvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3luY1BlZWsubGVuIDwgdGhpcy5zeW5jUGVlay5idWYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfMS5FbmRPZlN0cmVhbUVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUodGhpcy5zeW5jUGVlay5sZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGNvbnRpbnVlIHdpdGggbmV4dCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrYm87XG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RGaXJzdFN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbWJpbmVkIEFEVFMgJiBNUEVHIChNUDIgJiBNUDMpIGhlYWRlciBoYW5kbGluZ1xuICAgICAqIEByZXR1cm4ge1Byb21pc2U8Ym9vbGVhbj59IHRydWUgaWYgcGFyc2VyIHNob3VsZCBxdWl0XG4gICAgICovXG4gICAgYXN5bmMgcGFyc2VDb21tb25NcGVnSGVhZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5mcmFtZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm1wZWdPZmZzZXQgPSB0aGlzLnRva2VuaXplci5wb3NpdGlvbiAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIucGVla0J1ZmZlcih0aGlzLmJ1Zl9mcmFtZV9oZWFkZXIsIHsgb2Zmc2V0OiAxLCBsZW5ndGg6IDMgfSk7XG4gICAgICAgIGxldCBoZWFkZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBoZWFkZXIgPSBGcmFtZUhlYWRlci5nZXQodGhpcy5idWZfZnJhbWVfaGVhZGVyLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5pZ25vcmUoMSk7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFdhcm5pbmcoJ1BhcnNlIGVycm9yOiAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBzeW5jXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKDMpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29udGFpbmVyJywgaGVhZGVyLmNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb2RlYycsIGhlYWRlci5jb2RlYyk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdsb3NzbGVzcycsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ3NhbXBsZVJhdGUnLCBoZWFkZXIuc2FtcGxpbmdSYXRlKTtcbiAgICAgICAgdGhpcy5mcmFtZUNvdW50Kys7XG4gICAgICAgIHJldHVybiBoZWFkZXIudmVyc2lvbiA+PSAyICYmIGhlYWRlci5sYXllciA9PT0gMCA/IHRoaXMucGFyc2VBZHRzKGhlYWRlcikgOiB0aGlzLnBhcnNlQXVkaW9GcmFtZUhlYWRlcihoZWFkZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPGJvb2xlYW4+fSB0cnVlIGlmIHBhcnNlciBzaG91bGQgcXVpdFxuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlQXVkaW9GcmFtZUhlYWRlcihoZWFkZXIpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ251bWJlck9mQ2hhbm5lbHMnLCBoZWFkZXIuY2hhbm5lbE1vZGUgPT09ICdtb25vJyA/IDEgOiAyKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCBoZWFkZXIuYml0cmF0ZSk7XG4gICAgICAgIGlmICh0aGlzLmZyYW1lQ291bnQgPCAyMCAqIDEwMDAwKSB7XG4gICAgICAgICAgICBkZWJ1Zygnb2Zmc2V0PSVzIE1QJXMgYml0cmF0ZT0lcyBzYW1wbGUtcmF0ZT0lcycsIHRoaXMudG9rZW5pemVyLnBvc2l0aW9uIC0gNCwgaGVhZGVyLmxheWVyLCBoZWFkZXIuYml0cmF0ZSwgaGVhZGVyLnNhbXBsaW5nUmF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2xvdF9zaXplID0gaGVhZGVyLmNhbGNTbG90U2l6ZSgpO1xuICAgICAgICBpZiAoc2xvdF9zaXplID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2xvdF9zaXplJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2FtcGxlc19wZXJfZnJhbWUgPSBoZWFkZXIuY2FsY1NhbXBsZXNQZXJGcmFtZSgpO1xuICAgICAgICBkZWJ1Zyhgc2FtcGxlc19wZXJfZnJhbWU9JHtzYW1wbGVzX3Blcl9mcmFtZX1gKTtcbiAgICAgICAgY29uc3QgYnBzID0gc2FtcGxlc19wZXJfZnJhbWUgLyA4LjA7XG4gICAgICAgIGNvbnN0IGZzaXplID0gKGJwcyAqIGhlYWRlci5iaXRyYXRlIC8gaGVhZGVyLnNhbXBsaW5nUmF0ZSkgK1xuICAgICAgICAgICAgKChoZWFkZXIucGFkZGluZykgPyBzbG90X3NpemUgOiAwKTtcbiAgICAgICAgdGhpcy5mcmFtZV9zaXplID0gTWF0aC5mbG9vcihmc2l6ZSk7XG4gICAgICAgIHRoaXMuYXVkaW9GcmFtZUhlYWRlciA9IGhlYWRlcjtcbiAgICAgICAgdGhpcy5iaXRyYXRlcy5wdXNoKGhlYWRlci5iaXRyYXRlKTtcbiAgICAgICAgLy8geHRyYSBoZWFkZXIgb25seSBleGlzdHMgaW4gZmlyc3QgZnJhbWVcbiAgICAgICAgaWYgKHRoaXMuZnJhbWVDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBGcmFtZUhlYWRlci5sZW47XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNraXBTaWRlSW5mb3JtYXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mcmFtZUNvdW50ID09PSAzKSB7XG4gICAgICAgICAgICAvLyB0aGUgc3RyZWFtIGlzIENCUiBpZiB0aGUgZmlyc3QgMyBmcmFtZSBiaXRyYXRlcyBhcmUgdGhlIHNhbWVcbiAgICAgICAgICAgIGlmICh0aGlzLmFyZUFsbFNhbWUodGhpcy5iaXRyYXRlcykpIHtcbiAgICAgICAgICAgICAgICAvLyBBY3R1YWwgY2FsY3VsYXRpb24gd2lsbCBiZSBkb25lIGluIGZpbmFsaXplXG4gICAgICAgICAgICAgICAgdGhpcy5zYW1wbGVzUGVyRnJhbWUgPSBzYW1wbGVzX3Blcl9mcmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29kZWNQcm9maWxlJywgJ0NCUicpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRva2VuaXplci5maWxlSW5mby5zaXplKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gV2lsbCBjYWxjdWxhdGUgZHVyYXRpb24gYmFzZWQgb24gdGhlIGZpbGUgc2l6ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tZXRhZGF0YS5mb3JtYXQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gV2UgYWxyZWFkeSBnb3QgdGhlIGR1cmF0aW9uLCBzdG9wIHByb2Nlc3NpbmcgTVBFRyBzdHJlYW0gYW55IGZ1cnRoZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIEVuZm9yY2UgZHVyYXRpb24gbm90IGVuYWJsZWQsIHN0b3AgcHJvY2Vzc2luZyBlbnRpcmUgc3RyZWFtXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25jZSB3ZSBrbm93IHRoZSBmaWxlIGlzIFZCUiBhdHRhY2ggbGlzdGVuZXIgdG8gZW5kIG9mXG4gICAgICAgIC8vIHN0cmVhbSBzbyB3ZSBjYW4gZG8gdGhlIGR1cmF0aW9uIGNhbGN1bGF0aW9uIHdoZW4gd2VcbiAgICAgICAgLy8gaGF2ZSBjb3VudGVkIGFsbCB0aGUgZnJhbWVzXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHVyYXRpb24gJiYgdGhpcy5mcmFtZUNvdW50ID09PSA0KSB7XG4gICAgICAgICAgICB0aGlzLnNhbXBsZXNQZXJGcmFtZSA9IHNhbXBsZXNfcGVyX2ZyYW1lO1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVFb2ZEdXJhdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmZzZXQgPSA0O1xuICAgICAgICBpZiAoaGVhZGVyLmlzUHJvdGVjdGVkQnlDUkMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGFyc2VDcmMoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2tpcFNpZGVJbmZvcm1hdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQWR0cyhoZWFkZXIpIHtcbiAgICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKDMpO1xuICAgICAgICBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkQnVmZmVyKGJ1Zik7XG4gICAgICAgIGhlYWRlci5mcmFtZUxlbmd0aCArPSBjb21tb24uZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCAwLCAwLCAxMSk7XG4gICAgICAgIHRoaXMudG90YWxEYXRhTGVuZ3RoICs9IGhlYWRlci5mcmFtZUxlbmd0aDtcbiAgICAgICAgdGhpcy5zYW1wbGVzUGVyRnJhbWUgPSAxMDI0O1xuICAgICAgICBjb25zdCBmcmFtZXNQZXJTZWMgPSBoZWFkZXIuc2FtcGxpbmdSYXRlIC8gdGhpcy5zYW1wbGVzUGVyRnJhbWU7XG4gICAgICAgIGNvbnN0IGJ5dGVzUGVyRnJhbWUgPSB0aGlzLmZyYW1lQ291bnQgPT09IDAgPyAwIDogdGhpcy50b3RhbERhdGFMZW5ndGggLyB0aGlzLmZyYW1lQ291bnQ7XG4gICAgICAgIGNvbnN0IGJpdHJhdGUgPSA4ICogYnl0ZXNQZXJGcmFtZSAqIGZyYW1lc1BlclNlYyArIDAuNTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCBiaXRyYXRlKTtcbiAgICAgICAgZGVidWcoYGZyYW1lLWNvdW50PSR7dGhpcy5mcmFtZUNvdW50fSwgc2l6ZT0ke2hlYWRlci5mcmFtZUxlbmd0aH0gYnl0ZXMsIGJpdC1yYXRlPSR7Yml0cmF0ZX1gKTtcbiAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKGhlYWRlci5mcmFtZUxlbmd0aCA+IDcgPyBoZWFkZXIuZnJhbWVMZW5ndGggLSA3IDogMSk7XG4gICAgICAgIC8vIENvbnN1bWUgcmVtYWluaW5nIGhlYWRlciBhbmQgZnJhbWUgZGF0YVxuICAgICAgICBpZiAodGhpcy5mcmFtZUNvdW50ID09PSAzKSB7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29kZWNQcm9maWxlJywgaGVhZGVyLmNvZGVjUHJvZmlsZSk7XG4gICAgICAgICAgICBpZiAoaGVhZGVyLm1wNENoYW5uZWxDb25maWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZDaGFubmVscycsIGhlYWRlci5tcDRDaGFubmVsQ29uZmlnLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVFb2ZEdXJhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gU3RvcCBwYXJzaW5nIGFmdGVyIHRoZSB0aGlyZCBmcmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VDcmMoKSB7XG4gICAgICAgIHRoaXMuY3JjID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZE51bWJlcihUb2tlbi5JTlQxNl9CRSk7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgIHJldHVybiB0aGlzLnNraXBTaWRlSW5mb3JtYXRpb24oKTtcbiAgICB9XG4gICAgYXN5bmMgc2tpcFNpZGVJbmZvcm1hdGlvbigpIHtcbiAgICAgICAgY29uc3Qgc2lkZWluZm9fbGVuZ3RoID0gdGhpcy5hdWRpb0ZyYW1lSGVhZGVyLmNhbGN1bGF0ZVNpZGVJbmZvTGVuZ3RoKCk7XG4gICAgICAgIC8vIHNpZGUgaW5mb3JtYXRpb25cbiAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBUb2tlbi5VaW50OEFycmF5VHlwZShzaWRlaW5mb19sZW5ndGgpKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gc2lkZWluZm9fbGVuZ3RoO1xuICAgICAgICBhd2FpdCB0aGlzLnJlYWRYdHJhSW5mb0hlYWRlcigpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFzeW5jIHJlYWRYdHJhSW5mb0hlYWRlcigpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyVGFnID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKFhpbmdUYWdfMS5JbmZvVGFnSGVhZGVyVGFnKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gWGluZ1RhZ18xLkluZm9UYWdIZWFkZXJUYWcubGVuOyAvLyAxMlxuICAgICAgICBzd2l0Y2ggKGhlYWRlclRhZykge1xuICAgICAgICAgICAgY2FzZSAnSW5mbyc6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvZGVjUHJvZmlsZScsICdDQlInKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkWGluZ0luZm9IZWFkZXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ1hpbmcnOlxuICAgICAgICAgICAgICAgIGNvbnN0IGluZm9UYWcgPSBhd2FpdCB0aGlzLnJlYWRYaW5nSW5mb0hlYWRlcigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVjUHJvZmlsZSA9IGdldFZickNvZGVjUHJvZmlsZShpbmZvVGFnLnZiclNjYWxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29kZWNQcm9maWxlJywgY29kZWNQcm9maWxlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgJ1h0cmEnOlxuICAgICAgICAgICAgICAgIC8vIFRvRG86ID8/P1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTEFNRSc6XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihYaW5nVGFnXzEuTGFtZUVuY29kZXJWZXJzaW9uKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mcmFtZV9zaXplID49IHRoaXMub2Zmc2V0ICsgWGluZ1RhZ18xLkxhbWVFbmNvZGVyVmVyc2lvbi5sZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gWGluZ1RhZ18xLkxhbWVFbmNvZGVyVmVyc2lvbi5sZW47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCd0b29sJywgJ0xBTUUgJyArIHZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNraXBGcmFtZURhdGEodGhpcy5mcmFtZV9zaXplIC0gdGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuYWRkV2FybmluZygnQ29ycnVwdCBMQU1FIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUb0RvOiA/Pz9cbiAgICAgICAgfVxuICAgICAgICAvLyBUb0RvOiBwcm9taXNlIGR1cmF0aW9uPz8/XG4gICAgICAgIGNvbnN0IGZyYW1lRGF0YUxlZnQgPSB0aGlzLmZyYW1lX3NpemUgLSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKGZyYW1lRGF0YUxlZnQgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFdhcm5pbmcoJ0ZyYW1lICcgKyB0aGlzLmZyYW1lQ291bnQgKyAnY29ycnVwdDogbmVnYXRpdmUgZnJhbWVEYXRhTGVmdCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5za2lwRnJhbWVEYXRhKGZyYW1lRGF0YUxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWY6IGh0dHA6Ly9nYWJyaWVsLm1wMy10ZWNoLm9yZy9tcDNpbmZvdGFnLmh0bWxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRYaW5nSW5mb0hlYWRlcigpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy50b2tlbml6ZXIucG9zaXRpb247XG4gICAgICAgIGNvbnN0IGluZm9UYWcgPSBhd2FpdCAoMCwgWGluZ1RhZ18xLnJlYWRYaW5nSGVhZGVyKSh0aGlzLnRva2VuaXplcik7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IHRoaXMudG9rZW5pemVyLnBvc2l0aW9uIC0gb2Zmc2V0O1xuICAgICAgICBpZiAoaW5mb1RhZy5sYW1lKSB7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgndG9vbCcsICdMQU1FICcgKyBjb21tb24uc3RyaXBOdWxscyhpbmZvVGFnLmxhbWUudmVyc2lvbikpO1xuICAgICAgICAgICAgaWYgKGluZm9UYWcubGFtZS5leHRlbmRlZCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCd0cmFja0dhaW4nLCBpbmZvVGFnLmxhbWUuZXh0ZW5kZWQudHJhY2tfZ2Fpbik7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ3RyYWNrUGVha0xldmVsJywgaW5mb1RhZy5sYW1lLmV4dGVuZGVkLnRyYWNrX3BlYWspO1xuICAgICAgICAgICAgICAgIGlmIChpbmZvVGFnLmxhbWUuZXh0ZW5kZWQudHJhY2tfZ2Fpbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgndHJhY2tHYWluJywgaW5mb1RhZy5sYW1lLmV4dGVuZGVkLnRyYWNrX2dhaW4uYWRqdXN0bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmZvVGFnLmxhbWUuZXh0ZW5kZWQuYWxidW1fZ2Fpbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYWxidW1HYWluJywgaW5mb1RhZy5sYW1lLmV4dGVuZGVkLmFsYnVtX2dhaW4uYWRqdXN0bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdkdXJhdGlvbicsIGluZm9UYWcubGFtZS5leHRlbmRlZC5tdXNpY19sZW5ndGggLyAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5mb1RhZy5zdHJlYW1TaXplKSB7XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuYXVkaW9GcmFtZUhlYWRlci5jYWxjRHVyYXRpb24oaW5mb1RhZy5udW1GcmFtZXMpO1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2R1cmF0aW9uJywgZHVyYXRpb24pO1xuICAgICAgICAgICAgZGVidWcoJ0dldCBkdXJhdGlvbiBmcm9tIFhpbmcgaGVhZGVyOiAlcycsIHRoaXMubWV0YWRhdGEuZm9ybWF0LmR1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBpbmZvVGFnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZyYW1lcyBmaWVsZCBpcyBub3QgcHJlc2VudFxuICAgICAgICBjb25zdCBmcmFtZURhdGFMZWZ0ID0gdGhpcy5mcmFtZV9zaXplIC0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGF3YWl0IHRoaXMuc2tpcEZyYW1lRGF0YShmcmFtZURhdGFMZWZ0KTtcbiAgICAgICAgcmV0dXJuIGluZm9UYWc7XG4gICAgfVxuICAgIGFzeW5jIHNraXBGcmFtZURhdGEoZnJhbWVEYXRhTGVmdCkge1xuICAgICAgICBpZiAoZnJhbWVEYXRhTGVmdCA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZyYW1lLWRhdGEtbGVmdCBjYW5ub3QgYmUgbmVnYXRpdmUnKTtcbiAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKGZyYW1lRGF0YUxlZnQpO1xuICAgICAgICB0aGlzLmNvdW50U2tpcEZyYW1lRGF0YSArPSBmcmFtZURhdGFMZWZ0O1xuICAgIH1cbiAgICBhcmVBbGxTYW1lKGFycmF5KSB7XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gYXJyYXlbMF07XG4gICAgICAgIHJldHVybiBhcnJheS5ldmVyeShlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50ID09PSBmaXJzdDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5NcGVnUGFyc2VyID0gTXBlZ1BhcnNlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/mpeg/MpegParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/mpeg/ReplayGainDataFormat.js":
/*!**********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/mpeg/ReplayGainDataFormat.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReplayGain = void 0;\nconst common = __webpack_require__(/*! ../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\n/**\n * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format#name-code\n */\nvar NameCode;\n(function (NameCode) {\n    /**\n     * not set\n     */\n    NameCode[NameCode[\"not_set\"] = 0] = \"not_set\";\n    /**\n     * Radio Gain Adjustment\n     */\n    NameCode[NameCode[\"radio\"] = 1] = \"radio\";\n    /**\n     * Audiophile Gain Adjustment\n     */\n    NameCode[NameCode[\"audiophile\"] = 2] = \"audiophile\";\n})(NameCode || (NameCode = {}));\n/**\n * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format#originator-code\n */\nvar ReplayGainOriginator;\n(function (ReplayGainOriginator) {\n    /**\n     * Replay Gain unspecified\n     */\n    ReplayGainOriginator[ReplayGainOriginator[\"unspecified\"] = 0] = \"unspecified\";\n    /**\n     * Replay Gain pre-set by artist/producer/mastering engineer\n     */\n    ReplayGainOriginator[ReplayGainOriginator[\"engineer\"] = 1] = \"engineer\";\n    /**\n     * Replay Gain set by user\n     */\n    ReplayGainOriginator[ReplayGainOriginator[\"user\"] = 2] = \"user\";\n    /**\n     * Replay Gain determined automatically, as described on this site\n     */\n    ReplayGainOriginator[ReplayGainOriginator[\"automatic\"] = 3] = \"automatic\";\n    /**\n     * Set by simple RMS average\n     */\n    ReplayGainOriginator[ReplayGainOriginator[\"rms_average\"] = 4] = \"rms_average\";\n})(ReplayGainOriginator || (ReplayGainOriginator = {}));\n/**\n * Replay Gain Data Format\n *\n * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format\n */\nexports.ReplayGain = {\n    len: 2,\n    get: (buf, off) => {\n        const gain_type = common.getBitAllignedNumber(buf, off, 0, 3);\n        const sign = common.getBitAllignedNumber(buf, off, 6, 1);\n        const gain_adj = common.getBitAllignedNumber(buf, off, 7, 9) / 10.0;\n        if (gain_type > 0) {\n            return {\n                type: common.getBitAllignedNumber(buf, off, 0, 3),\n                origin: common.getBitAllignedNumber(buf, off, 3, 3),\n                adjustment: (sign ? -gain_adj : gain_adj)\n            };\n        }\n        return undefined;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXBlZy9SZXBsYXlHYWluRGF0YUZvcm1hdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsZUFBZSxtQkFBTyxDQUFDLDRGQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL21wZWcvUmVwbGF5R2FpbkRhdGFGb3JtYXQuanM/NDgwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVwbGF5R2FpbiA9IHZvaWQgMDtcbmNvbnN0IGNvbW1vbiA9IHJlcXVpcmUoXCIuLi9jb21tb24vVXRpbFwiKTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL0JvcmV3aXQvbXVzaWMtbWV0YWRhdGEvd2lraS9SZXBsYXktR2Fpbi1EYXRhLUZvcm1hdCNuYW1lLWNvZGVcbiAqL1xudmFyIE5hbWVDb2RlO1xuKGZ1bmN0aW9uIChOYW1lQ29kZSkge1xuICAgIC8qKlxuICAgICAqIG5vdCBzZXRcbiAgICAgKi9cbiAgICBOYW1lQ29kZVtOYW1lQ29kZVtcIm5vdF9zZXRcIl0gPSAwXSA9IFwibm90X3NldFwiO1xuICAgIC8qKlxuICAgICAqIFJhZGlvIEdhaW4gQWRqdXN0bWVudFxuICAgICAqL1xuICAgIE5hbWVDb2RlW05hbWVDb2RlW1wicmFkaW9cIl0gPSAxXSA9IFwicmFkaW9cIjtcbiAgICAvKipcbiAgICAgKiBBdWRpb3BoaWxlIEdhaW4gQWRqdXN0bWVudFxuICAgICAqL1xuICAgIE5hbWVDb2RlW05hbWVDb2RlW1wiYXVkaW9waGlsZVwiXSA9IDJdID0gXCJhdWRpb3BoaWxlXCI7XG59KShOYW1lQ29kZSB8fCAoTmFtZUNvZGUgPSB7fSkpO1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vQm9yZXdpdC9tdXNpYy1tZXRhZGF0YS93aWtpL1JlcGxheS1HYWluLURhdGEtRm9ybWF0I29yaWdpbmF0b3ItY29kZVxuICovXG52YXIgUmVwbGF5R2Fpbk9yaWdpbmF0b3I7XG4oZnVuY3Rpb24gKFJlcGxheUdhaW5PcmlnaW5hdG9yKSB7XG4gICAgLyoqXG4gICAgICogUmVwbGF5IEdhaW4gdW5zcGVjaWZpZWRcbiAgICAgKi9cbiAgICBSZXBsYXlHYWluT3JpZ2luYXRvcltSZXBsYXlHYWluT3JpZ2luYXRvcltcInVuc3BlY2lmaWVkXCJdID0gMF0gPSBcInVuc3BlY2lmaWVkXCI7XG4gICAgLyoqXG4gICAgICogUmVwbGF5IEdhaW4gcHJlLXNldCBieSBhcnRpc3QvcHJvZHVjZXIvbWFzdGVyaW5nIGVuZ2luZWVyXG4gICAgICovXG4gICAgUmVwbGF5R2Fpbk9yaWdpbmF0b3JbUmVwbGF5R2Fpbk9yaWdpbmF0b3JbXCJlbmdpbmVlclwiXSA9IDFdID0gXCJlbmdpbmVlclwiO1xuICAgIC8qKlxuICAgICAqIFJlcGxheSBHYWluIHNldCBieSB1c2VyXG4gICAgICovXG4gICAgUmVwbGF5R2Fpbk9yaWdpbmF0b3JbUmVwbGF5R2Fpbk9yaWdpbmF0b3JbXCJ1c2VyXCJdID0gMl0gPSBcInVzZXJcIjtcbiAgICAvKipcbiAgICAgKiBSZXBsYXkgR2FpbiBkZXRlcm1pbmVkIGF1dG9tYXRpY2FsbHksIGFzIGRlc2NyaWJlZCBvbiB0aGlzIHNpdGVcbiAgICAgKi9cbiAgICBSZXBsYXlHYWluT3JpZ2luYXRvcltSZXBsYXlHYWluT3JpZ2luYXRvcltcImF1dG9tYXRpY1wiXSA9IDNdID0gXCJhdXRvbWF0aWNcIjtcbiAgICAvKipcbiAgICAgKiBTZXQgYnkgc2ltcGxlIFJNUyBhdmVyYWdlXG4gICAgICovXG4gICAgUmVwbGF5R2Fpbk9yaWdpbmF0b3JbUmVwbGF5R2Fpbk9yaWdpbmF0b3JbXCJybXNfYXZlcmFnZVwiXSA9IDRdID0gXCJybXNfYXZlcmFnZVwiO1xufSkoUmVwbGF5R2Fpbk9yaWdpbmF0b3IgfHwgKFJlcGxheUdhaW5PcmlnaW5hdG9yID0ge30pKTtcbi8qKlxuICogUmVwbGF5IEdhaW4gRGF0YSBGb3JtYXRcbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vQm9yZXdpdC9tdXNpYy1tZXRhZGF0YS93aWtpL1JlcGxheS1HYWluLURhdGEtRm9ybWF0XG4gKi9cbmV4cG9ydHMuUmVwbGF5R2FpbiA9IHtcbiAgICBsZW46IDIsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgY29uc3QgZ2Fpbl90eXBlID0gY29tbW9uLmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmLCAwLCAzKTtcbiAgICAgICAgY29uc3Qgc2lnbiA9IGNvbW1vbi5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiwgNiwgMSk7XG4gICAgICAgIGNvbnN0IGdhaW5fYWRqID0gY29tbW9uLmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmLCA3LCA5KSAvIDEwLjA7XG4gICAgICAgIGlmIChnYWluX3R5cGUgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGNvbW1vbi5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiwgMCwgMyksXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBjb21tb24uZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYsIDMsIDMpLFxuICAgICAgICAgICAgICAgIGFkanVzdG1lbnQ6IChzaWduID8gLWdhaW5fYWRqIDogZ2Fpbl9hZGopXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/mpeg/ReplayGainDataFormat.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/mpeg/XingTag.js":
/*!*********************************************************!*\
  !*** ./node_modules/music-metadata/lib/mpeg/XingTag.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.readXingHeader = exports.XingHeaderFlags = exports.LameEncoderVersion = exports.InfoTagHeaderTag = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst util = __webpack_require__(/*! ../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\nconst ExtendedLameHeader_1 = __webpack_require__(/*! ./ExtendedLameHeader */ \"(app-pages-browser)/./node_modules/music-metadata/lib/mpeg/ExtendedLameHeader.js\");\n/**\n * Info Tag: Xing, LAME\n */\nexports.InfoTagHeaderTag = new Token.StringType(4, 'ascii');\n/**\n * LAME TAG value\n * Did not find any official documentation for this\n * Value e.g.: \"3.98.4\"\n */\nexports.LameEncoderVersion = new Token.StringType(6, 'ascii');\n/**\n * Info Tag\n * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n */\nexports.XingHeaderFlags = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            frames: util.isBitSet(buf, off, 31),\n            bytes: util.isBitSet(buf, off, 30),\n            toc: util.isBitSet(buf, off, 29),\n            vbrScale: util.isBitSet(buf, off, 28)\n        };\n    }\n};\n// /**\n//  * XING Header Tag\n//  * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n//  */\nasync function readXingHeader(tokenizer) {\n    const flags = await tokenizer.readToken(exports.XingHeaderFlags);\n    const xingInfoTag = {};\n    if (flags.frames) {\n        xingInfoTag.numFrames = await tokenizer.readToken(Token.UINT32_BE);\n    }\n    if (flags.bytes) {\n        xingInfoTag.streamSize = await tokenizer.readToken(Token.UINT32_BE);\n    }\n    if (flags.toc) {\n        xingInfoTag.toc = Buffer.alloc(100);\n        await tokenizer.readBuffer(xingInfoTag.toc);\n    }\n    if (flags.vbrScale) {\n        xingInfoTag.vbrScale = await tokenizer.readToken(Token.UINT32_BE);\n    }\n    const lameTag = await tokenizer.peekToken(new Token.StringType(4, 'ascii'));\n    if (lameTag === 'LAME') {\n        await tokenizer.ignore(4);\n        xingInfoTag.lame = {\n            version: await tokenizer.readToken(new Token.StringType(5, 'ascii'))\n        };\n        const match = xingInfoTag.lame.version.match(/\\d+.\\d+/g);\n        if (match) {\n            const majorMinorVersion = xingInfoTag.lame.version.match(/\\d+.\\d+/g)[0]; // e.g. 3.97\n            const version = majorMinorVersion.split('.').map(n => parseInt(n, 10));\n            if (version[0] >= 3 && version[1] >= 90) {\n                xingInfoTag.lame.extended = await tokenizer.readToken(ExtendedLameHeader_1.ExtendedLameHeader);\n            }\n        }\n    }\n    return xingInfoTag;\n}\nexports.readXingHeader = readXingHeader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXBlZy9YaW5nVGFnLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyx1QkFBdUIsR0FBRywwQkFBMEIsR0FBRyx3QkFBd0I7QUFDeEcsY0FBYyxtQkFBTyxDQUFDLGdGQUFhO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyw0RkFBZ0I7QUFDckMsNkJBQTZCLG1CQUFPLENBQUMsOEdBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9tcGVnL1hpbmdUYWcuanM/NjI1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVhZFhpbmdIZWFkZXIgPSBleHBvcnRzLlhpbmdIZWFkZXJGbGFncyA9IGV4cG9ydHMuTGFtZUVuY29kZXJWZXJzaW9uID0gZXhwb3J0cy5JbmZvVGFnSGVhZGVyVGFnID0gdm9pZCAwO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcIi4uL2NvbW1vbi9VdGlsXCIpO1xuY29uc3QgRXh0ZW5kZWRMYW1lSGVhZGVyXzEgPSByZXF1aXJlKFwiLi9FeHRlbmRlZExhbWVIZWFkZXJcIik7XG4vKipcbiAqIEluZm8gVGFnOiBYaW5nLCBMQU1FXG4gKi9cbmV4cG9ydHMuSW5mb1RhZ0hlYWRlclRhZyA9IG5ldyBUb2tlbi5TdHJpbmdUeXBlKDQsICdhc2NpaScpO1xuLyoqXG4gKiBMQU1FIFRBRyB2YWx1ZVxuICogRGlkIG5vdCBmaW5kIGFueSBvZmZpY2lhbCBkb2N1bWVudGF0aW9uIGZvciB0aGlzXG4gKiBWYWx1ZSBlLmcuOiBcIjMuOTguNFwiXG4gKi9cbmV4cG9ydHMuTGFtZUVuY29kZXJWZXJzaW9uID0gbmV3IFRva2VuLlN0cmluZ1R5cGUoNiwgJ2FzY2lpJyk7XG4vKipcbiAqIEluZm8gVGFnXG4gKiBSZWY6IGh0dHA6Ly9nYWJyaWVsLm1wMy10ZWNoLm9yZy9tcDNpbmZvdGFnLmh0bWxcbiAqL1xuZXhwb3J0cy5YaW5nSGVhZGVyRmxhZ3MgPSB7XG4gICAgbGVuOiA0LFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcmFtZXM6IHV0aWwuaXNCaXRTZXQoYnVmLCBvZmYsIDMxKSxcbiAgICAgICAgICAgIGJ5dGVzOiB1dGlsLmlzQml0U2V0KGJ1Ziwgb2ZmLCAzMCksXG4gICAgICAgICAgICB0b2M6IHV0aWwuaXNCaXRTZXQoYnVmLCBvZmYsIDI5KSxcbiAgICAgICAgICAgIHZiclNjYWxlOiB1dGlsLmlzQml0U2V0KGJ1Ziwgb2ZmLCAyOClcbiAgICAgICAgfTtcbiAgICB9XG59O1xuLy8gLyoqXG4vLyAgKiBYSU5HIEhlYWRlciBUYWdcbi8vICAqIFJlZjogaHR0cDovL2dhYnJpZWwubXAzLXRlY2gub3JnL21wM2luZm90YWcuaHRtbFxuLy8gICovXG5hc3luYyBmdW5jdGlvbiByZWFkWGluZ0hlYWRlcih0b2tlbml6ZXIpIHtcbiAgICBjb25zdCBmbGFncyA9IGF3YWl0IHRva2VuaXplci5yZWFkVG9rZW4oZXhwb3J0cy5YaW5nSGVhZGVyRmxhZ3MpO1xuICAgIGNvbnN0IHhpbmdJbmZvVGFnID0ge307XG4gICAgaWYgKGZsYWdzLmZyYW1lcykge1xuICAgICAgICB4aW5nSW5mb1RhZy5udW1GcmFtZXMgPSBhd2FpdCB0b2tlbml6ZXIucmVhZFRva2VuKFRva2VuLlVJTlQzMl9CRSk7XG4gICAgfVxuICAgIGlmIChmbGFncy5ieXRlcykge1xuICAgICAgICB4aW5nSW5mb1RhZy5zdHJlYW1TaXplID0gYXdhaXQgdG9rZW5pemVyLnJlYWRUb2tlbihUb2tlbi5VSU5UMzJfQkUpO1xuICAgIH1cbiAgICBpZiAoZmxhZ3MudG9jKSB7XG4gICAgICAgIHhpbmdJbmZvVGFnLnRvYyA9IEJ1ZmZlci5hbGxvYygxMDApO1xuICAgICAgICBhd2FpdCB0b2tlbml6ZXIucmVhZEJ1ZmZlcih4aW5nSW5mb1RhZy50b2MpO1xuICAgIH1cbiAgICBpZiAoZmxhZ3MudmJyU2NhbGUpIHtcbiAgICAgICAgeGluZ0luZm9UYWcudmJyU2NhbGUgPSBhd2FpdCB0b2tlbml6ZXIucmVhZFRva2VuKFRva2VuLlVJTlQzMl9CRSk7XG4gICAgfVxuICAgIGNvbnN0IGxhbWVUYWcgPSBhd2FpdCB0b2tlbml6ZXIucGVla1Rva2VuKG5ldyBUb2tlbi5TdHJpbmdUeXBlKDQsICdhc2NpaScpKTtcbiAgICBpZiAobGFtZVRhZyA9PT0gJ0xBTUUnKSB7XG4gICAgICAgIGF3YWl0IHRva2VuaXplci5pZ25vcmUoNCk7XG4gICAgICAgIHhpbmdJbmZvVGFnLmxhbWUgPSB7XG4gICAgICAgICAgICB2ZXJzaW9uOiBhd2FpdCB0b2tlbml6ZXIucmVhZFRva2VuKG5ldyBUb2tlbi5TdHJpbmdUeXBlKDUsICdhc2NpaScpKVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYXRjaCA9IHhpbmdJbmZvVGFnLmxhbWUudmVyc2lvbi5tYXRjaCgvXFxkKy5cXGQrL2cpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ham9yTWlub3JWZXJzaW9uID0geGluZ0luZm9UYWcubGFtZS52ZXJzaW9uLm1hdGNoKC9cXGQrLlxcZCsvZylbMF07IC8vIGUuZy4gMy45N1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IG1ham9yTWlub3JWZXJzaW9uLnNwbGl0KCcuJykubWFwKG4gPT4gcGFyc2VJbnQobiwgMTApKTtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uWzBdID49IDMgJiYgdmVyc2lvblsxXSA+PSA5MCkge1xuICAgICAgICAgICAgICAgIHhpbmdJbmZvVGFnLmxhbWUuZXh0ZW5kZWQgPSBhd2FpdCB0b2tlbml6ZXIucmVhZFRva2VuKEV4dGVuZGVkTGFtZUhlYWRlcl8xLkV4dGVuZGVkTGFtZUhlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHhpbmdJbmZvVGFnO1xufVxuZXhwb3J0cy5yZWFkWGluZ0hlYWRlciA9IHJlYWRYaW5nSGVhZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/mpeg/XingTag.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/musepack/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/music-metadata/lib/musepack/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst AbstractID3Parser_1 = __webpack_require__(/*! ../id3v2/AbstractID3Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js\");\nconst MpcSv8Parser_1 = __webpack_require__(/*! ./sv8/MpcSv8Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/musepack/sv8/MpcSv8Parser.js\");\nconst MpcSv7Parser_1 = __webpack_require__(/*! ./sv7/MpcSv7Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/musepack/sv7/MpcSv7Parser.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:musepack');\nclass MusepackParser extends AbstractID3Parser_1.AbstractID3Parser {\n    async postId3v2Parse() {\n        const signature = await this.tokenizer.peekToken(new Token.StringType(3, 'binary'));\n        let mpcParser;\n        switch (signature) {\n            case 'MP+': {\n                debug('Musepack stream-version 7');\n                mpcParser = new MpcSv7Parser_1.MpcSv7Parser();\n                break;\n            }\n            case 'MPC': {\n                debug('Musepack stream-version 8');\n                mpcParser = new MpcSv8Parser_1.MpcSv8Parser();\n                break;\n            }\n            default: {\n                throw new Error('Invalid Musepack signature prefix');\n            }\n        }\n        mpcParser.init(this.metadata, this.tokenizer, this.options);\n        return mpcParser.parse();\n    }\n}\nexports[\"default\"] = MusepackParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXVzZXBhY2svaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQU87QUFDL0IsY0FBYyxtQkFBTyxDQUFDLGdGQUFhO0FBQ25DLDRCQUE0QixtQkFBTyxDQUFDLG9IQUE0QjtBQUNoRSx1QkFBdUIsbUJBQU8sQ0FBQyw4R0FBb0I7QUFDbkQsdUJBQXVCLG1CQUFPLENBQUMsOEdBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXVzZXBhY2svaW5kZXguanM/MDc4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IEFic3RyYWN0SUQzUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vaWQzdjIvQWJzdHJhY3RJRDNQYXJzZXJcIik7XG5jb25zdCBNcGNTdjhQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3N2OC9NcGNTdjhQYXJzZXJcIik7XG5jb25zdCBNcGNTdjdQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3N2Ny9NcGNTdjdQYXJzZXJcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6bXVzZXBhY2snKTtcbmNsYXNzIE11c2VwYWNrUGFyc2VyIGV4dGVuZHMgQWJzdHJhY3RJRDNQYXJzZXJfMS5BYnN0cmFjdElEM1BhcnNlciB7XG4gICAgYXN5bmMgcG9zdElkM3YyUGFyc2UoKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnBlZWtUb2tlbihuZXcgVG9rZW4uU3RyaW5nVHlwZSgzLCAnYmluYXJ5JykpO1xuICAgICAgICBsZXQgbXBjUGFyc2VyO1xuICAgICAgICBzd2l0Y2ggKHNpZ25hdHVyZSkge1xuICAgICAgICAgICAgY2FzZSAnTVArJzoge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdNdXNlcGFjayBzdHJlYW0tdmVyc2lvbiA3Jyk7XG4gICAgICAgICAgICAgICAgbXBjUGFyc2VyID0gbmV3IE1wY1N2N1BhcnNlcl8xLk1wY1N2N1BhcnNlcigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnTVBDJzoge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdNdXNlcGFjayBzdHJlYW0tdmVyc2lvbiA4Jyk7XG4gICAgICAgICAgICAgICAgbXBjUGFyc2VyID0gbmV3IE1wY1N2OFBhcnNlcl8xLk1wY1N2OFBhcnNlcigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBNdXNlcGFjayBzaWduYXR1cmUgcHJlZml4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbXBjUGFyc2VyLmluaXQodGhpcy5tZXRhZGF0YSwgdGhpcy50b2tlbml6ZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBtcGNQYXJzZXIucGFyc2UoKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNdXNlcGFja1BhcnNlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/musepack/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/musepack/sv7/BitReader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/music-metadata/lib/musepack/sv7/BitReader.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BitReader = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nclass BitReader {\n    constructor(tokenizer) {\n        this.tokenizer = tokenizer;\n        this.pos = 0;\n        this.dword = undefined;\n    }\n    /**\n     *\n     * @param bits 1..30 bits\n     */\n    async read(bits) {\n        while (this.dword === undefined) {\n            this.dword = await this.tokenizer.readToken(Token.UINT32_LE);\n        }\n        let out = this.dword;\n        this.pos += bits;\n        if (this.pos < 32) {\n            out >>>= (32 - this.pos);\n            return out & ((1 << bits) - 1);\n        }\n        else {\n            this.pos -= 32;\n            if (this.pos === 0) {\n                this.dword = undefined;\n                return out & ((1 << bits) - 1);\n            }\n            else {\n                this.dword = await this.tokenizer.readToken(Token.UINT32_LE);\n                if (this.pos) {\n                    out <<= this.pos;\n                    out |= this.dword >>> (32 - this.pos);\n                }\n                return out & ((1 << bits) - 1);\n            }\n        }\n    }\n    async ignore(bits) {\n        if (this.pos > 0) {\n            const remaining = 32 - this.pos;\n            this.dword = undefined;\n            bits -= remaining;\n            this.pos = 0;\n        }\n        const remainder = bits % 32;\n        const numOfWords = (bits - remainder) / 32;\n        await this.tokenizer.ignore(numOfWords * 4);\n        return this.read(remainder);\n    }\n}\nexports.BitReader = BitReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXVzZXBhY2svc3Y3L0JpdFJlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsY0FBYyxtQkFBTyxDQUFDLGdGQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXVzZXBhY2svc3Y3L0JpdFJlYWRlci5qcz82NzNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaXRSZWFkZXIgPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNsYXNzIEJpdFJlYWRlciB7XG4gICAgY29uc3RydWN0b3IodG9rZW5pemVyKSB7XG4gICAgICAgIHRoaXMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZHdvcmQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGJpdHMgMS4uMzAgYml0c1xuICAgICAqL1xuICAgIGFzeW5jIHJlYWQoYml0cykge1xuICAgICAgICB3aGlsZSAodGhpcy5kd29yZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmR3b3JkID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKFRva2VuLlVJTlQzMl9MRSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dCA9IHRoaXMuZHdvcmQ7XG4gICAgICAgIHRoaXMucG9zICs9IGJpdHM7XG4gICAgICAgIGlmICh0aGlzLnBvcyA8IDMyKSB7XG4gICAgICAgICAgICBvdXQgPj4+PSAoMzIgLSB0aGlzLnBvcyk7XG4gICAgICAgICAgICByZXR1cm4gb3V0ICYgKCgxIDw8IGJpdHMpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvcyAtPSAzMjtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHdvcmQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dCAmICgoMSA8PCBiaXRzKSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kd29yZCA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihUb2tlbi5VSU5UMzJfTEUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcykge1xuICAgICAgICAgICAgICAgICAgICBvdXQgPDw9IHRoaXMucG9zO1xuICAgICAgICAgICAgICAgICAgICBvdXQgfD0gdGhpcy5kd29yZCA+Pj4gKDMyIC0gdGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0ICYgKCgxIDw8IGJpdHMpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaWdub3JlKGJpdHMpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nID0gMzIgLSB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMuZHdvcmQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBiaXRzIC09IHJlbWFpbmluZztcbiAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1haW5kZXIgPSBiaXRzICUgMzI7XG4gICAgICAgIGNvbnN0IG51bU9mV29yZHMgPSAoYml0cyAtIHJlbWFpbmRlcikgLyAzMjtcbiAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKG51bU9mV29yZHMgKiA0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZChyZW1haW5kZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQml0UmVhZGVyID0gQml0UmVhZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/musepack/sv7/BitReader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/musepack/sv7/MpcSv7Parser.js":
/*!**********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/musepack/sv7/MpcSv7Parser.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MpcSv7Parser = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../../common/BasicParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst APEv2Parser_1 = __webpack_require__(/*! ../../apev2/APEv2Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/apev2/APEv2Parser.js\");\nconst BitReader_1 = __webpack_require__(/*! ./BitReader */ \"(app-pages-browser)/./node_modules/music-metadata/lib/musepack/sv7/BitReader.js\");\nconst SV7 = __webpack_require__(/*! ./StreamVersion7 */ \"(app-pages-browser)/./node_modules/music-metadata/lib/musepack/sv7/StreamVersion7.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:musepack');\nclass MpcSv7Parser extends BasicParser_1.BasicParser {\n    constructor() {\n        super(...arguments);\n        this.audioLength = 0;\n    }\n    async parse() {\n        const header = await this.tokenizer.readToken(SV7.Header);\n        if (header.signature !== 'MP+')\n            throw new Error('Unexpected magic number');\n        debug(`stream-version=${header.streamMajorVersion}.${header.streamMinorVersion}`);\n        this.metadata.setFormat('container', 'Musepack, SV7');\n        this.metadata.setFormat('sampleRate', header.sampleFrequency);\n        const numberOfSamples = 1152 * (header.frameCount - 1) + header.lastFrameLength;\n        this.metadata.setFormat('numberOfSamples', numberOfSamples);\n        this.duration = numberOfSamples / header.sampleFrequency;\n        this.metadata.setFormat('duration', this.duration);\n        this.bitreader = new BitReader_1.BitReader(this.tokenizer);\n        this.metadata.setFormat('numberOfChannels', header.midSideStereo || header.intensityStereo ? 2 : 1);\n        const version = await this.bitreader.read(8);\n        this.metadata.setFormat('codec', (version / 100).toFixed(2));\n        await this.skipAudioData(header.frameCount);\n        debug(`End of audio stream, switching to APEv2, offset=${this.tokenizer.position}`);\n        return APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);\n    }\n    async skipAudioData(frameCount) {\n        while (frameCount-- > 0) {\n            const frameLength = await this.bitreader.read(20);\n            this.audioLength += 20 + frameLength;\n            await this.bitreader.ignore(frameLength);\n        }\n        // last frame\n        const lastFrameLength = await this.bitreader.read(11);\n        this.audioLength += lastFrameLength;\n        this.metadata.setFormat('bitrate', this.audioLength / this.duration);\n    }\n}\nexports.MpcSv7Parser = MpcSv7Parser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXVzZXBhY2svc3Y3L01wY1N2N1BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQU87QUFDL0Isc0JBQXNCLG1CQUFPLENBQUMsNkdBQTBCO0FBQ3hELHNCQUFzQixtQkFBTyxDQUFDLDJHQUF5QjtBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQyxvR0FBYTtBQUN6QyxZQUFZLG1CQUFPLENBQUMsOEdBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBCQUEwQixHQUFHLDBCQUEwQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHdCQUF3QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXVzZXBhY2svc3Y3L01wY1N2N1BhcnNlci5qcz9iMjJmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NcGNTdjdQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgQmFzaWNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vQmFzaWNQYXJzZXJcIik7XG5jb25zdCBBUEV2MlBhcnNlcl8xID0gcmVxdWlyZShcIi4uLy4uL2FwZXYyL0FQRXYyUGFyc2VyXCIpO1xuY29uc3QgQml0UmVhZGVyXzEgPSByZXF1aXJlKFwiLi9CaXRSZWFkZXJcIik7XG5jb25zdCBTVjcgPSByZXF1aXJlKFwiLi9TdHJlYW1WZXJzaW9uN1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjptdXNlcGFjaycpO1xuY2xhc3MgTXBjU3Y3UGFyc2VyIGV4dGVuZHMgQmFzaWNQYXJzZXJfMS5CYXNpY1BhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYXVkaW9MZW5ndGggPSAwO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZSgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKFNWNy5IZWFkZXIpO1xuICAgICAgICBpZiAoaGVhZGVyLnNpZ25hdHVyZSAhPT0gJ01QKycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgbWFnaWMgbnVtYmVyJyk7XG4gICAgICAgIGRlYnVnKGBzdHJlYW0tdmVyc2lvbj0ke2hlYWRlci5zdHJlYW1NYWpvclZlcnNpb259LiR7aGVhZGVyLnN0cmVhbU1pbm9yVmVyc2lvbn1gKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvbnRhaW5lcicsICdNdXNlcGFjaywgU1Y3Jyk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdzYW1wbGVSYXRlJywgaGVhZGVyLnNhbXBsZUZyZXF1ZW5jeSk7XG4gICAgICAgIGNvbnN0IG51bWJlck9mU2FtcGxlcyA9IDExNTIgKiAoaGVhZGVyLmZyYW1lQ291bnQgLSAxKSArIGhlYWRlci5sYXN0RnJhbWVMZW5ndGg7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZlNhbXBsZXMnLCBudW1iZXJPZlNhbXBsZXMpO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gbnVtYmVyT2ZTYW1wbGVzIC8gaGVhZGVyLnNhbXBsZUZyZXF1ZW5jeTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2R1cmF0aW9uJywgdGhpcy5kdXJhdGlvbik7XG4gICAgICAgIHRoaXMuYml0cmVhZGVyID0gbmV3IEJpdFJlYWRlcl8xLkJpdFJlYWRlcih0aGlzLnRva2VuaXplcik7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZkNoYW5uZWxzJywgaGVhZGVyLm1pZFNpZGVTdGVyZW8gfHwgaGVhZGVyLmludGVuc2l0eVN0ZXJlbyA/IDIgOiAxKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IHRoaXMuYml0cmVhZGVyLnJlYWQoOCk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb2RlYycsICh2ZXJzaW9uIC8gMTAwKS50b0ZpeGVkKDIpKTtcbiAgICAgICAgYXdhaXQgdGhpcy5za2lwQXVkaW9EYXRhKGhlYWRlci5mcmFtZUNvdW50KTtcbiAgICAgICAgZGVidWcoYEVuZCBvZiBhdWRpbyBzdHJlYW0sIHN3aXRjaGluZyB0byBBUEV2Miwgb2Zmc2V0PSR7dGhpcy50b2tlbml6ZXIucG9zaXRpb259YCk7XG4gICAgICAgIHJldHVybiBBUEV2MlBhcnNlcl8xLkFQRXYyUGFyc2VyLnRyeVBhcnNlQXBlSGVhZGVyKHRoaXMubWV0YWRhdGEsIHRoaXMudG9rZW5pemVyLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBza2lwQXVkaW9EYXRhKGZyYW1lQ291bnQpIHtcbiAgICAgICAgd2hpbGUgKGZyYW1lQ291bnQtLSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lTGVuZ3RoID0gYXdhaXQgdGhpcy5iaXRyZWFkZXIucmVhZCgyMCk7XG4gICAgICAgICAgICB0aGlzLmF1ZGlvTGVuZ3RoICs9IDIwICsgZnJhbWVMZW5ndGg7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmJpdHJlYWRlci5pZ25vcmUoZnJhbWVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxhc3QgZnJhbWVcbiAgICAgICAgY29uc3QgbGFzdEZyYW1lTGVuZ3RoID0gYXdhaXQgdGhpcy5iaXRyZWFkZXIucmVhZCgxMSk7XG4gICAgICAgIHRoaXMuYXVkaW9MZW5ndGggKz0gbGFzdEZyYW1lTGVuZ3RoO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYml0cmF0ZScsIHRoaXMuYXVkaW9MZW5ndGggLyB0aGlzLmR1cmF0aW9uKTtcbiAgICB9XG59XG5leHBvcnRzLk1wY1N2N1BhcnNlciA9IE1wY1N2N1BhcnNlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/musepack/sv7/MpcSv7Parser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/musepack/sv7/StreamVersion7.js":
/*!************************************************************************!*\
  !*** ./node_modules/music-metadata/lib/musepack/sv7/StreamVersion7.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Header = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst util = __webpack_require__(/*! ../../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\n/**\n * BASIC STRUCTURE\n */\nexports.Header = {\n    len: 6 * 4,\n    get: (buf, off) => {\n        const header = {\n            // word 0\n            signature: Buffer.from(buf).toString('latin1', off, off + 3),\n            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\n            streamMinorVersion: util.getBitAllignedNumber(buf, off + 3, 0, 4),\n            streamMajorVersion: util.getBitAllignedNumber(buf, off + 3, 4, 4),\n            // word 1\n            frameCount: Token.UINT32_LE.get(buf, off + 4),\n            // word 2\n            maxLevel: Token.UINT16_LE.get(buf, off + 8),\n            sampleFrequency: [44100, 48000, 37800, 32000][util.getBitAllignedNumber(buf, off + 10, 0, 2)],\n            link: util.getBitAllignedNumber(buf, off + 10, 2, 2),\n            profile: util.getBitAllignedNumber(buf, off + 10, 4, 4),\n            maxBand: util.getBitAllignedNumber(buf, off + 11, 0, 6),\n            intensityStereo: util.isBitSet(buf, off + 11, 6),\n            midSideStereo: util.isBitSet(buf, off + 11, 7),\n            // word 3\n            titlePeak: Token.UINT16_LE.get(buf, off + 12),\n            titleGain: Token.UINT16_LE.get(buf, off + 14),\n            // word 4\n            albumPeak: Token.UINT16_LE.get(buf, off + 16),\n            albumGain: Token.UINT16_LE.get(buf, off + 18),\n            // word\n            lastFrameLength: (Token.UINT32_LE.get(buf, off + 20) >>> 20) & 0x7FF,\n            trueGapless: util.isBitSet(buf, off + 23, 0)\n        };\n        header.lastFrameLength = header.trueGapless ? (Token.UINT32_LE.get(buf, 20) >>> 20) & 0x7FF : 0;\n        return header;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXVzZXBhY2svc3Y3L1N0cmVhbVZlcnNpb243LmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsY0FBYyxtQkFBTyxDQUFDLGdGQUFhO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQywrRkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXVzZXBhY2svc3Y3L1N0cmVhbVZlcnNpb243LmpzPzZmYTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhlYWRlciA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vVXRpbFwiKTtcbi8qKlxuICogQkFTSUMgU1RSVUNUVVJFXG4gKi9cbmV4cG9ydHMuSGVhZGVyID0ge1xuICAgIGxlbjogNiAqIDQsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0ge1xuICAgICAgICAgICAgLy8gd29yZCAwXG4gICAgICAgICAgICBzaWduYXR1cmU6IEJ1ZmZlci5mcm9tKGJ1ZikudG9TdHJpbmcoJ2xhdGluMScsIG9mZiwgb2ZmICsgMyksXG4gICAgICAgICAgICAvLyB2ZXJzaW9uSW5kZXggbnVtYmVyICogMTAwMCAoMy44MSA9IDM4MTApIChyZW1lbWJlciB0aGF0IDQtYnl0ZSBhbGlnbm1lbnQgY2F1c2VzIHRoaXMgdG8gdGFrZSA0LWJ5dGVzKVxuICAgICAgICAgICAgc3RyZWFtTWlub3JWZXJzaW9uOiB1dGlsLmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmICsgMywgMCwgNCksXG4gICAgICAgICAgICBzdHJlYW1NYWpvclZlcnNpb246IHV0aWwuZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAzLCA0LCA0KSxcbiAgICAgICAgICAgIC8vIHdvcmQgMVxuICAgICAgICAgICAgZnJhbWVDb3VudDogVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIG9mZiArIDQpLFxuICAgICAgICAgICAgLy8gd29yZCAyXG4gICAgICAgICAgICBtYXhMZXZlbDogVG9rZW4uVUlOVDE2X0xFLmdldChidWYsIG9mZiArIDgpLFxuICAgICAgICAgICAgc2FtcGxlRnJlcXVlbmN5OiBbNDQxMDAsIDQ4MDAwLCAzNzgwMCwgMzIwMDBdW3V0aWwuZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAxMCwgMCwgMildLFxuICAgICAgICAgICAgbGluazogdXRpbC5nZXRCaXRBbGxpZ25lZE51bWJlcihidWYsIG9mZiArIDEwLCAyLCAyKSxcbiAgICAgICAgICAgIHByb2ZpbGU6IHV0aWwuZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYgKyAxMCwgNCwgNCksXG4gICAgICAgICAgICBtYXhCYW5kOiB1dGlsLmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmICsgMTEsIDAsIDYpLFxuICAgICAgICAgICAgaW50ZW5zaXR5U3RlcmVvOiB1dGlsLmlzQml0U2V0KGJ1Ziwgb2ZmICsgMTEsIDYpLFxuICAgICAgICAgICAgbWlkU2lkZVN0ZXJlbzogdXRpbC5pc0JpdFNldChidWYsIG9mZiArIDExLCA3KSxcbiAgICAgICAgICAgIC8vIHdvcmQgM1xuICAgICAgICAgICAgdGl0bGVQZWFrOiBUb2tlbi5VSU5UMTZfTEUuZ2V0KGJ1Ziwgb2ZmICsgMTIpLFxuICAgICAgICAgICAgdGl0bGVHYWluOiBUb2tlbi5VSU5UMTZfTEUuZ2V0KGJ1Ziwgb2ZmICsgMTQpLFxuICAgICAgICAgICAgLy8gd29yZCA0XG4gICAgICAgICAgICBhbGJ1bVBlYWs6IFRva2VuLlVJTlQxNl9MRS5nZXQoYnVmLCBvZmYgKyAxNiksXG4gICAgICAgICAgICBhbGJ1bUdhaW46IFRva2VuLlVJTlQxNl9MRS5nZXQoYnVmLCBvZmYgKyAxOCksXG4gICAgICAgICAgICAvLyB3b3JkXG4gICAgICAgICAgICBsYXN0RnJhbWVMZW5ndGg6IChUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgMjApID4+PiAyMCkgJiAweDdGRixcbiAgICAgICAgICAgIHRydWVHYXBsZXNzOiB1dGlsLmlzQml0U2V0KGJ1Ziwgb2ZmICsgMjMsIDApXG4gICAgICAgIH07XG4gICAgICAgIGhlYWRlci5sYXN0RnJhbWVMZW5ndGggPSBoZWFkZXIudHJ1ZUdhcGxlc3MgPyAoVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIDIwKSA+Pj4gMjApICYgMHg3RkYgOiAwO1xuICAgICAgICByZXR1cm4gaGVhZGVyO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/musepack/sv7/StreamVersion7.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/musepack/sv8/MpcSv8Parser.js":
/*!**********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/musepack/sv8/MpcSv8Parser.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MpcSv8Parser = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../../common/BasicParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst APEv2Parser_1 = __webpack_require__(/*! ../../apev2/APEv2Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/apev2/APEv2Parser.js\");\nconst FourCC_1 = __webpack_require__(/*! ../../common/FourCC */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/FourCC.js\");\nconst SV8 = __webpack_require__(/*! ./StreamVersion8 */ \"(app-pages-browser)/./node_modules/music-metadata/lib/musepack/sv8/StreamVersion8.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:musepack');\nclass MpcSv8Parser extends BasicParser_1.BasicParser {\n    constructor() {\n        super(...arguments);\n        this.audioLength = 0;\n    }\n    async parse() {\n        const signature = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        if (signature !== 'MPCK')\n            throw new Error('Invalid Magic number');\n        this.metadata.setFormat('container', 'Musepack, SV8');\n        return this.parsePacket();\n    }\n    async parsePacket() {\n        const sv8reader = new SV8.StreamReader(this.tokenizer);\n        do {\n            const header = await sv8reader.readPacketHeader();\n            debug(`packet-header key=${header.key}, payloadLength=${header.payloadLength}`);\n            switch (header.key) {\n                case 'SH': // Stream Header\n                    const sh = await sv8reader.readStreamHeader(header.payloadLength);\n                    this.metadata.setFormat('numberOfSamples', sh.sampleCount);\n                    this.metadata.setFormat('sampleRate', sh.sampleFrequency);\n                    this.metadata.setFormat('duration', sh.sampleCount / sh.sampleFrequency);\n                    this.metadata.setFormat('numberOfChannels', sh.channelCount);\n                    break;\n                case 'AP': // Audio Packet\n                    this.audioLength += header.payloadLength;\n                    await this.tokenizer.ignore(header.payloadLength);\n                    break;\n                case 'RG': // Replaygain\n                case 'EI': // Encoder Info\n                case 'SO': // Seek Table Offset\n                case 'ST': // Seek Table\n                case 'CT': // Chapter-Tag\n                    await this.tokenizer.ignore(header.payloadLength);\n                    break;\n                case 'SE': // Stream End\n                    this.metadata.setFormat('bitrate', this.audioLength * 8 / this.metadata.format.duration);\n                    return APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);\n                default:\n                    throw new Error(`Unexpected header: ${header.key}`);\n            }\n        } while (true);\n    }\n}\nexports.MpcSv8Parser = MpcSv8Parser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXVzZXBhY2svc3Y4L01wY1N2OFBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQU87QUFDL0Isc0JBQXNCLG1CQUFPLENBQUMsNkdBQTBCO0FBQ3hELHNCQUFzQixtQkFBTyxDQUFDLDJHQUF5QjtBQUN2RCxpQkFBaUIsbUJBQU8sQ0FBQyxtR0FBcUI7QUFDOUMsWUFBWSxtQkFBTyxDQUFDLDhHQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVcsa0JBQWtCLHFCQUFxQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVc7QUFDckU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL211c2VwYWNrL3N2OC9NcGNTdjhQYXJzZXIuanM/ZWM4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXBjU3Y4UGFyc2VyID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IEJhc2ljUGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL0Jhc2ljUGFyc2VyXCIpO1xuY29uc3QgQVBFdjJQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcGV2Mi9BUEV2MlBhcnNlclwiKTtcbmNvbnN0IEZvdXJDQ18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9Gb3VyQ0NcIik7XG5jb25zdCBTVjggPSByZXF1aXJlKFwiLi9TdHJlYW1WZXJzaW9uOFwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjptdXNlcGFjaycpO1xuY2xhc3MgTXBjU3Y4UGFyc2VyIGV4dGVuZHMgQmFzaWNQYXJzZXJfMS5CYXNpY1BhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYXVkaW9MZW5ndGggPSAwO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZSgpIHtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKEZvdXJDQ18xLkZvdXJDY1Rva2VuKTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZSAhPT0gJ01QQ0snKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIE1hZ2ljIG51bWJlcicpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29udGFpbmVyJywgJ011c2VwYWNrLCBTVjgnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYWNrZXQoKTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VQYWNrZXQoKSB7XG4gICAgICAgIGNvbnN0IHN2OHJlYWRlciA9IG5ldyBTVjguU3RyZWFtUmVhZGVyKHRoaXMudG9rZW5pemVyKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgc3Y4cmVhZGVyLnJlYWRQYWNrZXRIZWFkZXIoKTtcbiAgICAgICAgICAgIGRlYnVnKGBwYWNrZXQtaGVhZGVyIGtleT0ke2hlYWRlci5rZXl9LCBwYXlsb2FkTGVuZ3RoPSR7aGVhZGVyLnBheWxvYWRMZW5ndGh9YCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGhlYWRlci5rZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdTSCc6IC8vIFN0cmVhbSBIZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2ggPSBhd2FpdCBzdjhyZWFkZXIucmVhZFN0cmVhbUhlYWRlcihoZWFkZXIucGF5bG9hZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZlNhbXBsZXMnLCBzaC5zYW1wbGVDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdzYW1wbGVSYXRlJywgc2guc2FtcGxlRnJlcXVlbmN5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2R1cmF0aW9uJywgc2guc2FtcGxlQ291bnQgLyBzaC5zYW1wbGVGcmVxdWVuY3kpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZDaGFubmVscycsIHNoLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0FQJzogLy8gQXVkaW8gUGFja2V0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9MZW5ndGggKz0gaGVhZGVyLnBheWxvYWRMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShoZWFkZXIucGF5bG9hZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1JHJzogLy8gUmVwbGF5Z2FpblxuICAgICAgICAgICAgICAgIGNhc2UgJ0VJJzogLy8gRW5jb2RlciBJbmZvXG4gICAgICAgICAgICAgICAgY2FzZSAnU08nOiAvLyBTZWVrIFRhYmxlIE9mZnNldFxuICAgICAgICAgICAgICAgIGNhc2UgJ1NUJzogLy8gU2VlayBUYWJsZVxuICAgICAgICAgICAgICAgIGNhc2UgJ0NUJzogLy8gQ2hhcHRlci1UYWdcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKGhlYWRlci5wYXlsb2FkTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnU0UnOiAvLyBTdHJlYW0gRW5kXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdiaXRyYXRlJywgdGhpcy5hdWRpb0xlbmd0aCAqIDggLyB0aGlzLm1ldGFkYXRhLmZvcm1hdC5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBUEV2MlBhcnNlcl8xLkFQRXYyUGFyc2VyLnRyeVBhcnNlQXBlSGVhZGVyKHRoaXMubWV0YWRhdGEsIHRoaXMudG9rZW5pemVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBoZWFkZXI6ICR7aGVhZGVyLmtleX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5NcGNTdjhQYXJzZXIgPSBNcGNTdjhQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/musepack/sv8/MpcSv8Parser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/musepack/sv8/StreamVersion8.js":
/*!************************************************************************!*\
  !*** ./node_modules/music-metadata/lib/musepack/sv8/StreamVersion8.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StreamReader = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst util = __webpack_require__(/*! ../../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:musepack:sv8');\nconst PacketKey = new Token.StringType(2, 'binary');\n/**\n * Stream Header Packet part 1\n * Ref: http://trac.musepack.net/musepack/wiki/SV8Specification#StreamHeaderPacket\n */\nconst SH_part1 = {\n    len: 5,\n    get: (buf, off) => {\n        return {\n            crc: Token.UINT32_LE.get(buf, off),\n            streamVersion: Token.UINT8.get(buf, off + 4)\n        };\n    }\n};\n/**\n * Stream Header Packet part 3\n * Ref: http://trac.musepack.net/musepack/wiki/SV8Specification#StreamHeaderPacket\n */\nconst SH_part3 = {\n    len: 2,\n    get: (buf, off) => {\n        return {\n            sampleFrequency: [44100, 48000, 37800, 32000][util.getBitAllignedNumber(buf, off, 0, 3)],\n            maxUsedBands: util.getBitAllignedNumber(buf, off, 3, 5),\n            channelCount: util.getBitAllignedNumber(buf, off + 1, 0, 4) + 1,\n            msUsed: util.isBitSet(buf, off + 1, 4),\n            audioBlockFrames: util.getBitAllignedNumber(buf, off + 1, 5, 3)\n        };\n    }\n};\nclass StreamReader {\n    constructor(tokenizer) {\n        this.tokenizer = tokenizer;\n    }\n    async readPacketHeader() {\n        const key = await this.tokenizer.readToken(PacketKey);\n        const size = await this.readVariableSizeField();\n        return {\n            key,\n            payloadLength: size.value - 2 - size.len\n        };\n    }\n    async readStreamHeader(size) {\n        const streamHeader = {};\n        debug(`Reading SH at offset=${this.tokenizer.position}`);\n        const part1 = await this.tokenizer.readToken(SH_part1);\n        size -= SH_part1.len;\n        Object.assign(streamHeader, part1);\n        debug(`SH.streamVersion = ${part1.streamVersion}`);\n        const sampleCount = await this.readVariableSizeField();\n        size -= sampleCount.len;\n        streamHeader.sampleCount = sampleCount.value;\n        const bs = await this.readVariableSizeField();\n        size -= bs.len;\n        streamHeader.beginningOfSilence = bs.value;\n        const part3 = await this.tokenizer.readToken(SH_part3);\n        size -= SH_part3.len;\n        Object.assign(streamHeader, part3);\n        // assert.equal(size, 0);\n        await this.tokenizer.ignore(size);\n        return streamHeader;\n    }\n    async readVariableSizeField(len = 1, hb = 0) {\n        let n = await this.tokenizer.readNumber(Token.UINT8);\n        if ((n & 0x80) === 0) {\n            return { len, value: hb + n };\n        }\n        n &= 0x7F;\n        n += hb;\n        return this.readVariableSizeField(len + 1, n << 7);\n    }\n}\nexports.StreamReader = StreamReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXVzZXBhY2svc3Y4L1N0cmVhbVZlcnNpb244LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQixjQUFjLG1CQUFPLENBQUMsZ0ZBQWE7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQU87QUFDL0IsYUFBYSxtQkFBTyxDQUFDLCtGQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0JBQXdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvQkFBb0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvbXVzZXBhY2svc3Y4L1N0cmVhbVZlcnNpb244LmpzPzU4YTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0cmVhbVJlYWRlciA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1V0aWxcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdtdXNpYy1tZXRhZGF0YTpwYXJzZXI6bXVzZXBhY2s6c3Y4Jyk7XG5jb25zdCBQYWNrZXRLZXkgPSBuZXcgVG9rZW4uU3RyaW5nVHlwZSgyLCAnYmluYXJ5Jyk7XG4vKipcbiAqIFN0cmVhbSBIZWFkZXIgUGFja2V0IHBhcnQgMVxuICogUmVmOiBodHRwOi8vdHJhYy5tdXNlcGFjay5uZXQvbXVzZXBhY2svd2lraS9TVjhTcGVjaWZpY2F0aW9uI1N0cmVhbUhlYWRlclBhY2tldFxuICovXG5jb25zdCBTSF9wYXJ0MSA9IHtcbiAgICBsZW46IDUsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyYzogVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICBzdHJlYW1WZXJzaW9uOiBUb2tlbi5VSU5UOC5nZXQoYnVmLCBvZmYgKyA0KVxuICAgICAgICB9O1xuICAgIH1cbn07XG4vKipcbiAqIFN0cmVhbSBIZWFkZXIgUGFja2V0IHBhcnQgM1xuICogUmVmOiBodHRwOi8vdHJhYy5tdXNlcGFjay5uZXQvbXVzZXBhY2svd2lraS9TVjhTcGVjaWZpY2F0aW9uI1N0cmVhbUhlYWRlclBhY2tldFxuICovXG5jb25zdCBTSF9wYXJ0MyA9IHtcbiAgICBsZW46IDIsXG4gICAgZ2V0OiAoYnVmLCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNhbXBsZUZyZXF1ZW5jeTogWzQ0MTAwLCA0ODAwMCwgMzc4MDAsIDMyMDAwXVt1dGlsLmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmLCAwLCAzKV0sXG4gICAgICAgICAgICBtYXhVc2VkQmFuZHM6IHV0aWwuZ2V0Qml0QWxsaWduZWROdW1iZXIoYnVmLCBvZmYsIDMsIDUpLFxuICAgICAgICAgICAgY2hhbm5lbENvdW50OiB1dGlsLmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmICsgMSwgMCwgNCkgKyAxLFxuICAgICAgICAgICAgbXNVc2VkOiB1dGlsLmlzQml0U2V0KGJ1Ziwgb2ZmICsgMSwgNCksXG4gICAgICAgICAgICBhdWRpb0Jsb2NrRnJhbWVzOiB1dGlsLmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1Ziwgb2ZmICsgMSwgNSwgMylcbiAgICAgICAgfTtcbiAgICB9XG59O1xuY2xhc3MgU3RyZWFtUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbml6ZXIpIHtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRQYWNrZXRIZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihQYWNrZXRLZXkpO1xuICAgICAgICBjb25zdCBzaXplID0gYXdhaXQgdGhpcy5yZWFkVmFyaWFibGVTaXplRmllbGQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHBheWxvYWRMZW5ndGg6IHNpemUudmFsdWUgLSAyIC0gc2l6ZS5sZW5cbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFN0cmVhbUhlYWRlcihzaXplKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbUhlYWRlciA9IHt9O1xuICAgICAgICBkZWJ1ZyhgUmVhZGluZyBTSCBhdCBvZmZzZXQ9JHt0aGlzLnRva2VuaXplci5wb3NpdGlvbn1gKTtcbiAgICAgICAgY29uc3QgcGFydDEgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oU0hfcGFydDEpO1xuICAgICAgICBzaXplIC09IFNIX3BhcnQxLmxlbjtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHJlYW1IZWFkZXIsIHBhcnQxKTtcbiAgICAgICAgZGVidWcoYFNILnN0cmVhbVZlcnNpb24gPSAke3BhcnQxLnN0cmVhbVZlcnNpb259YCk7XG4gICAgICAgIGNvbnN0IHNhbXBsZUNvdW50ID0gYXdhaXQgdGhpcy5yZWFkVmFyaWFibGVTaXplRmllbGQoKTtcbiAgICAgICAgc2l6ZSAtPSBzYW1wbGVDb3VudC5sZW47XG4gICAgICAgIHN0cmVhbUhlYWRlci5zYW1wbGVDb3VudCA9IHNhbXBsZUNvdW50LnZhbHVlO1xuICAgICAgICBjb25zdCBicyA9IGF3YWl0IHRoaXMucmVhZFZhcmlhYmxlU2l6ZUZpZWxkKCk7XG4gICAgICAgIHNpemUgLT0gYnMubGVuO1xuICAgICAgICBzdHJlYW1IZWFkZXIuYmVnaW5uaW5nT2ZTaWxlbmNlID0gYnMudmFsdWU7XG4gICAgICAgIGNvbnN0IHBhcnQzID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKFNIX3BhcnQzKTtcbiAgICAgICAgc2l6ZSAtPSBTSF9wYXJ0My5sZW47XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3RyZWFtSGVhZGVyLCBwYXJ0Myk7XG4gICAgICAgIC8vIGFzc2VydC5lcXVhbChzaXplLCAwKTtcbiAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKHNpemUpO1xuICAgICAgICByZXR1cm4gc3RyZWFtSGVhZGVyO1xuICAgIH1cbiAgICBhc3luYyByZWFkVmFyaWFibGVTaXplRmllbGQobGVuID0gMSwgaGIgPSAwKSB7XG4gICAgICAgIGxldCBuID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZE51bWJlcihUb2tlbi5VSU5UOCk7XG4gICAgICAgIGlmICgobiAmIDB4ODApID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBsZW4sIHZhbHVlOiBoYiArIG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuICY9IDB4N0Y7XG4gICAgICAgIG4gKz0gaGI7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRWYXJpYWJsZVNpemVGaWVsZChsZW4gKyAxLCBuIDw8IDcpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyZWFtUmVhZGVyID0gU3RyZWFtUmVhZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/musepack/sv8/StreamVersion8.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/ogg/OggParser.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/OggParser.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OggParser = exports.SegmentTable = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst core_1 = __webpack_require__(/*! strtok3/lib/core */ \"(app-pages-browser)/./node_modules/strtok3/lib/core.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst util = __webpack_require__(/*! ../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/FourCC.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst VorbisParser_1 = __webpack_require__(/*! ./vorbis/VorbisParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js\");\nconst OpusParser_1 = __webpack_require__(/*! ./opus/OpusParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ogg/opus/OpusParser.js\");\nconst SpeexParser_1 = __webpack_require__(/*! ./speex/SpeexParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ogg/speex/SpeexParser.js\");\nconst TheoraParser_1 = __webpack_require__(/*! ./theora/TheoraParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ogg/theora/TheoraParser.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:ogg');\nclass SegmentTable {\n    static sum(buf, off, len) {\n        let s = 0;\n        for (let i = off; i < off + len; ++i) {\n            s += buf[i];\n        }\n        return s;\n    }\n    constructor(header) {\n        this.len = header.page_segments;\n    }\n    get(buf, off) {\n        return {\n            totalPageSize: SegmentTable.sum(buf, off, this.len)\n        };\n    }\n}\nexports.SegmentTable = SegmentTable;\n/**\n * Parser for Ogg logical bitstream framing\n */\nclass OggParser extends BasicParser_1.BasicParser {\n    /**\n     * Parse page\n     * @returns {Promise<void>}\n     */\n    async parse() {\n        debug('pos=%s, parsePage()', this.tokenizer.position);\n        try {\n            let header;\n            do {\n                header = await this.tokenizer.readToken(OggParser.Header);\n                if (header.capturePattern !== 'OggS')\n                    throw new Error('Invalid Ogg capture pattern');\n                this.metadata.setFormat('container', 'Ogg');\n                this.header = header;\n                this.pageNumber = header.pageSequenceNo;\n                debug('page#=%s, Ogg.id=%s', header.pageSequenceNo, header.capturePattern);\n                const segmentTable = await this.tokenizer.readToken(new SegmentTable(header));\n                debug('totalPageSize=%s', segmentTable.totalPageSize);\n                const pageData = await this.tokenizer.readToken(new Token.Uint8ArrayType(segmentTable.totalPageSize));\n                debug('firstPage=%s, lastPage=%s, continued=%s', header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);\n                if (header.headerType.firstPage) {\n                    const id = new Token.StringType(7, 'ascii').get(Buffer.from(pageData), 0);\n                    switch (id) {\n                        case '\\x01vorbis': // Ogg/Vorbis\n                            debug('Set page consumer to Ogg/Vorbis');\n                            this.pageConsumer = new VorbisParser_1.VorbisParser(this.metadata, this.options);\n                            break;\n                        case 'OpusHea': // Ogg/Opus\n                            debug('Set page consumer to Ogg/Opus');\n                            this.pageConsumer = new OpusParser_1.OpusParser(this.metadata, this.options, this.tokenizer);\n                            break;\n                        case 'Speex  ': // Ogg/Speex\n                            debug('Set page consumer to Ogg/Speex');\n                            this.pageConsumer = new SpeexParser_1.SpeexParser(this.metadata, this.options, this.tokenizer);\n                            break;\n                        case 'fishead':\n                        case '\\x00theora': // Ogg/Theora\n                            debug('Set page consumer to Ogg/Theora');\n                            this.pageConsumer = new TheoraParser_1.TheoraParser(this.metadata, this.options, this.tokenizer);\n                            break;\n                        default:\n                            throw new Error('gg audio-codec not recognized (id=' + id + ')');\n                    }\n                }\n                this.pageConsumer.parsePage(header, pageData);\n            } while (!header.headerType.lastPage);\n        }\n        catch (err) {\n            if (err instanceof core_1.EndOfStreamError) {\n                this.metadata.addWarning('Last OGG-page is not marked with last-page flag');\n                debug(`End-of-stream`);\n                this.metadata.addWarning('Last OGG-page is not marked with last-page flag');\n                if (this.header) {\n                    this.pageConsumer.calculateDuration(this.header);\n                }\n            }\n            else if (err.message.startsWith('FourCC')) {\n                if (this.pageNumber > 0) {\n                    // ignore this error: work-around if last OGG-page is not marked with last-page flag\n                    this.metadata.addWarning('Invalid FourCC ID, maybe last OGG-page is not marked with last-page flag');\n                    this.pageConsumer.flush();\n                }\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n}\nOggParser.Header = {\n    len: 27,\n    get: (buf, off) => {\n        return {\n            capturePattern: FourCC_1.FourCcToken.get(buf, off),\n            version: Token.UINT8.get(buf, off + 4),\n            headerType: {\n                continued: util.getBit(buf, off + 5, 0),\n                firstPage: util.getBit(buf, off + 5, 1),\n                lastPage: util.getBit(buf, off + 5, 2)\n            },\n            // packet_flag: buf.readUInt8(off + 5),\n            absoluteGranulePosition: Number(Token.UINT64_LE.get(buf, off + 6)),\n            streamSerialNumber: Token.UINT32_LE.get(buf, off + 14),\n            pageSequenceNo: Token.UINT32_LE.get(buf, off + 18),\n            pageChecksum: Token.UINT32_LE.get(buf, off + 22),\n            page_segments: Token.UINT8.get(buf, off + 26)\n        };\n    }\n};\nexports.OggParser = OggParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL09nZ1BhcnNlci5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsb0JBQW9CO0FBQ3hDLGNBQWMsbUJBQU8sQ0FBQyxnRkFBYTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsZ0ZBQWtCO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFPO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyw0RkFBZ0I7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsZ0dBQWtCO0FBQzNDLHNCQUFzQixtQkFBTyxDQUFDLDBHQUF1QjtBQUNyRCx1QkFBdUIsbUJBQU8sQ0FBQywrR0FBdUI7QUFDdEQscUJBQXFCLG1CQUFPLENBQUMsdUdBQW1CO0FBQ2hELHNCQUFzQixtQkFBTyxDQUFDLDJHQUFxQjtBQUNuRCx1QkFBdUIsbUJBQU8sQ0FBQywrR0FBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLE1BQU07QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL09nZ1BhcnNlci5qcz8yN2Y1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PZ2dQYXJzZXIgPSBleHBvcnRzLlNlZ21lbnRUYWJsZSA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcInN0cnRvazMvbGliL2NvcmVcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuLi9jb21tb24vVXRpbFwiKTtcbmNvbnN0IEZvdXJDQ18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Gb3VyQ0NcIik7XG5jb25zdCBCYXNpY1BhcnNlcl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9CYXNpY1BhcnNlclwiKTtcbmNvbnN0IFZvcmJpc1BhcnNlcl8xID0gcmVxdWlyZShcIi4vdm9yYmlzL1ZvcmJpc1BhcnNlclwiKTtcbmNvbnN0IE9wdXNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL29wdXMvT3B1c1BhcnNlclwiKTtcbmNvbnN0IFNwZWV4UGFyc2VyXzEgPSByZXF1aXJlKFwiLi9zcGVleC9TcGVleFBhcnNlclwiKTtcbmNvbnN0IFRoZW9yYVBhcnNlcl8xID0gcmVxdWlyZShcIi4vdGhlb3JhL1RoZW9yYVBhcnNlclwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjpvZ2cnKTtcbmNsYXNzIFNlZ21lbnRUYWJsZSB7XG4gICAgc3RhdGljIHN1bShidWYsIG9mZiwgbGVuKSB7XG4gICAgICAgIGxldCBzID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZjsgaSA8IG9mZiArIGxlbjsgKytpKSB7XG4gICAgICAgICAgICBzICs9IGJ1ZltpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaGVhZGVyKSB7XG4gICAgICAgIHRoaXMubGVuID0gaGVhZGVyLnBhZ2Vfc2VnbWVudHM7XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG90YWxQYWdlU2l6ZTogU2VnbWVudFRhYmxlLnN1bShidWYsIG9mZiwgdGhpcy5sZW4pXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5TZWdtZW50VGFibGUgPSBTZWdtZW50VGFibGU7XG4vKipcbiAqIFBhcnNlciBmb3IgT2dnIGxvZ2ljYWwgYml0c3RyZWFtIGZyYW1pbmdcbiAqL1xuY2xhc3MgT2dnUGFyc2VyIGV4dGVuZHMgQmFzaWNQYXJzZXJfMS5CYXNpY1BhcnNlciB7XG4gICAgLyoqXG4gICAgICogUGFyc2UgcGFnZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlKCkge1xuICAgICAgICBkZWJ1ZygncG9zPSVzLCBwYXJzZVBhZ2UoKScsIHRoaXMudG9rZW5pemVyLnBvc2l0aW9uKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBoZWFkZXI7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKE9nZ1BhcnNlci5IZWFkZXIpO1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXIuY2FwdHVyZVBhdHRlcm4gIT09ICdPZ2dTJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIE9nZyBjYXB0dXJlIHBhdHRlcm4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29udGFpbmVyJywgJ09nZycpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyID0gaGVhZGVyO1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZU51bWJlciA9IGhlYWRlci5wYWdlU2VxdWVuY2VObztcbiAgICAgICAgICAgICAgICBkZWJ1ZygncGFnZSM9JXMsIE9nZy5pZD0lcycsIGhlYWRlci5wYWdlU2VxdWVuY2VObywgaGVhZGVyLmNhcHR1cmVQYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWdtZW50VGFibGUgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IFNlZ21lbnRUYWJsZShoZWFkZXIpKTtcbiAgICAgICAgICAgICAgICBkZWJ1ZygndG90YWxQYWdlU2l6ZT0lcycsIHNlZ21lbnRUYWJsZS50b3RhbFBhZ2VTaXplKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlRGF0YSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgVG9rZW4uVWludDhBcnJheVR5cGUoc2VnbWVudFRhYmxlLnRvdGFsUGFnZVNpemUpKTtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnZmlyc3RQYWdlPSVzLCBsYXN0UGFnZT0lcywgY29udGludWVkPSVzJywgaGVhZGVyLmhlYWRlclR5cGUuZmlyc3RQYWdlLCBoZWFkZXIuaGVhZGVyVHlwZS5sYXN0UGFnZSwgaGVhZGVyLmhlYWRlclR5cGUuY29udGludWVkKTtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyLmhlYWRlclR5cGUuZmlyc3RQYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gbmV3IFRva2VuLlN0cmluZ1R5cGUoNywgJ2FzY2lpJykuZ2V0KEJ1ZmZlci5mcm9tKHBhZ2VEYXRhKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xceDAxdm9yYmlzJzogLy8gT2dnL1ZvcmJpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKCdTZXQgcGFnZSBjb25zdW1lciB0byBPZ2cvVm9yYmlzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlQ29uc3VtZXIgPSBuZXcgVm9yYmlzUGFyc2VyXzEuVm9yYmlzUGFyc2VyKHRoaXMubWV0YWRhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdPcHVzSGVhJzogLy8gT2dnL09wdXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnU2V0IHBhZ2UgY29uc3VtZXIgdG8gT2dnL09wdXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2VDb25zdW1lciA9IG5ldyBPcHVzUGFyc2VyXzEuT3B1c1BhcnNlcih0aGlzLm1ldGFkYXRhLCB0aGlzLm9wdGlvbnMsIHRoaXMudG9rZW5pemVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1NwZWV4ICAnOiAvLyBPZ2cvU3BlZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnU2V0IHBhZ2UgY29uc3VtZXIgdG8gT2dnL1NwZWV4Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlQ29uc3VtZXIgPSBuZXcgU3BlZXhQYXJzZXJfMS5TcGVleFBhcnNlcih0aGlzLm1ldGFkYXRhLCB0aGlzLm9wdGlvbnMsIHRoaXMudG9rZW5pemVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Zpc2hlYWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFx4MDB0aGVvcmEnOiAvLyBPZ2cvVGhlb3JhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoJ1NldCBwYWdlIGNvbnN1bWVyIHRvIE9nZy9UaGVvcmEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2VDb25zdW1lciA9IG5ldyBUaGVvcmFQYXJzZXJfMS5UaGVvcmFQYXJzZXIodGhpcy5tZXRhZGF0YSwgdGhpcy5vcHRpb25zLCB0aGlzLnRva2VuaXplcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2cgYXVkaW8tY29kZWMgbm90IHJlY29nbml6ZWQgKGlkPScgKyBpZCArICcpJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlQ29uc3VtZXIucGFyc2VQYWdlKGhlYWRlciwgcGFnZURhdGEpO1xuICAgICAgICAgICAgfSB3aGlsZSAoIWhlYWRlci5oZWFkZXJUeXBlLmxhc3RQYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgY29yZV8xLkVuZE9mU3RyZWFtRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFdhcm5pbmcoJ0xhc3QgT0dHLXBhZ2UgaXMgbm90IG1hcmtlZCB3aXRoIGxhc3QtcGFnZSBmbGFnJyk7XG4gICAgICAgICAgICAgICAgZGVidWcoYEVuZC1vZi1zdHJlYW1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFdhcm5pbmcoJ0xhc3QgT0dHLXBhZ2UgaXMgbm90IG1hcmtlZCB3aXRoIGxhc3QtcGFnZSBmbGFnJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFnZUNvbnN1bWVyLmNhbGN1bGF0ZUR1cmF0aW9uKHRoaXMuaGVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlcnIubWVzc2FnZS5zdGFydHNXaXRoKCdGb3VyQ0MnKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhZ2VOdW1iZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB0aGlzIGVycm9yOiB3b3JrLWFyb3VuZCBpZiBsYXN0IE9HRy1wYWdlIGlzIG5vdCBtYXJrZWQgd2l0aCBsYXN0LXBhZ2UgZmxhZ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFdhcm5pbmcoJ0ludmFsaWQgRm91ckNDIElELCBtYXliZSBsYXN0IE9HRy1wYWdlIGlzIG5vdCBtYXJrZWQgd2l0aCBsYXN0LXBhZ2UgZmxhZycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2VDb25zdW1lci5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbk9nZ1BhcnNlci5IZWFkZXIgPSB7XG4gICAgbGVuOiAyNyxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FwdHVyZVBhdHRlcm46IEZvdXJDQ18xLkZvdXJDY1Rva2VuLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICB2ZXJzaW9uOiBUb2tlbi5VSU5UOC5nZXQoYnVmLCBvZmYgKyA0KSxcbiAgICAgICAgICAgIGhlYWRlclR5cGU6IHtcbiAgICAgICAgICAgICAgICBjb250aW51ZWQ6IHV0aWwuZ2V0Qml0KGJ1Ziwgb2ZmICsgNSwgMCksXG4gICAgICAgICAgICAgICAgZmlyc3RQYWdlOiB1dGlsLmdldEJpdChidWYsIG9mZiArIDUsIDEpLFxuICAgICAgICAgICAgICAgIGxhc3RQYWdlOiB1dGlsLmdldEJpdChidWYsIG9mZiArIDUsIDIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gcGFja2V0X2ZsYWc6IGJ1Zi5yZWFkVUludDgob2ZmICsgNSksXG4gICAgICAgICAgICBhYnNvbHV0ZUdyYW51bGVQb3NpdGlvbjogTnVtYmVyKFRva2VuLlVJTlQ2NF9MRS5nZXQoYnVmLCBvZmYgKyA2KSksXG4gICAgICAgICAgICBzdHJlYW1TZXJpYWxOdW1iZXI6IFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAxNCksXG4gICAgICAgICAgICBwYWdlU2VxdWVuY2VObzogVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIG9mZiArIDE4KSxcbiAgICAgICAgICAgIHBhZ2VDaGVja3N1bTogVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIG9mZiArIDIyKSxcbiAgICAgICAgICAgIHBhZ2Vfc2VnbWVudHM6IFRva2VuLlVJTlQ4LmdldChidWYsIG9mZiArIDI2KVxuICAgICAgICB9O1xuICAgIH1cbn07XG5leHBvcnRzLk9nZ1BhcnNlciA9IE9nZ1BhcnNlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/ogg/OggParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/ogg/opus/Opus.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/opus/Opus.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IdHeader = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\n/**\n * Opus ID Header parser\n * Ref: https://wiki.xiph.org/OggOpus#ID_Header\n */\nclass IdHeader {\n    constructor(len) {\n        this.len = len;\n        if (len < 19) {\n            throw new Error(\"ID-header-page 0 should be at least 19 bytes long\");\n        }\n    }\n    get(buf, off) {\n        return {\n            magicSignature: new Token.StringType(8, 'ascii').get(buf, off + 0),\n            version: buf.readUInt8(off + 8),\n            channelCount: buf.readUInt8(off + 9),\n            preSkip: buf.readInt16LE(off + 10),\n            inputSampleRate: buf.readInt32LE(off + 12),\n            outputGain: buf.readInt16LE(off + 16),\n            channelMapping: buf.readUInt8(off + 18)\n        };\n    }\n}\nexports.IdHeader = IdHeader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL29wdXMvT3B1cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsY0FBYyxtQkFBTyxDQUFDLGdGQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9vZ2cvb3B1cy9PcHVzLmpzPzRkM2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklkSGVhZGVyID0gdm9pZCAwO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG4vKipcbiAqIE9wdXMgSUQgSGVhZGVyIHBhcnNlclxuICogUmVmOiBodHRwczovL3dpa2kueGlwaC5vcmcvT2dnT3B1cyNJRF9IZWFkZXJcbiAqL1xuY2xhc3MgSWRIZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGxlbikge1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICAgICAgaWYgKGxlbiA8IDE5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJRC1oZWFkZXItcGFnZSAwIHNob3VsZCBiZSBhdCBsZWFzdCAxOSBieXRlcyBsb25nXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFnaWNTaWduYXR1cmU6IG5ldyBUb2tlbi5TdHJpbmdUeXBlKDgsICdhc2NpaScpLmdldChidWYsIG9mZiArIDApLFxuICAgICAgICAgICAgdmVyc2lvbjogYnVmLnJlYWRVSW50OChvZmYgKyA4KSxcbiAgICAgICAgICAgIGNoYW5uZWxDb3VudDogYnVmLnJlYWRVSW50OChvZmYgKyA5KSxcbiAgICAgICAgICAgIHByZVNraXA6IGJ1Zi5yZWFkSW50MTZMRShvZmYgKyAxMCksXG4gICAgICAgICAgICBpbnB1dFNhbXBsZVJhdGU6IGJ1Zi5yZWFkSW50MzJMRShvZmYgKyAxMiksXG4gICAgICAgICAgICBvdXRwdXRHYWluOiBidWYucmVhZEludDE2TEUob2ZmICsgMTYpLFxuICAgICAgICAgICAgY2hhbm5lbE1hcHBpbmc6IGJ1Zi5yZWFkVUludDgob2ZmICsgMTgpXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5JZEhlYWRlciA9IElkSGVhZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/ogg/opus/Opus.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/ogg/opus/OpusParser.js":
/*!****************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/opus/OpusParser.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OpusParser = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst VorbisParser_1 = __webpack_require__(/*! ../vorbis/VorbisParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js\");\nconst Opus = __webpack_require__(/*! ./Opus */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ogg/opus/Opus.js\");\n/**\n * Opus parser\n * Internet Engineering Task Force (IETF) - RFC 6716\n * Used by OggParser\n */\nclass OpusParser extends VorbisParser_1.VorbisParser {\n    constructor(metadata, options, tokenizer) {\n        super(metadata, options);\n        this.tokenizer = tokenizer;\n        this.lastPos = -1;\n    }\n    /**\n     * Parse first Opus Ogg page\n     * @param {IPageHeader} header\n     * @param {Buffer} pageData\n     */\n    parseFirstPage(header, pageData) {\n        this.metadata.setFormat('codec', 'Opus');\n        // Parse Opus ID Header\n        this.idHeader = new Opus.IdHeader(pageData.length).get(pageData, 0);\n        if (this.idHeader.magicSignature !== \"OpusHead\")\n            throw new Error(\"Illegal ogg/Opus magic-signature\");\n        this.metadata.setFormat('sampleRate', this.idHeader.inputSampleRate);\n        this.metadata.setFormat('numberOfChannels', this.idHeader.channelCount);\n    }\n    parseFullPage(pageData) {\n        const magicSignature = new Token.StringType(8, 'ascii').get(pageData, 0);\n        switch (magicSignature) {\n            case 'OpusTags':\n                this.parseUserCommentList(pageData, 8);\n                this.lastPos = this.tokenizer.position - pageData.length;\n                break;\n            default:\n                break;\n        }\n    }\n    calculateDuration(header) {\n        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            const pos_48bit = header.absoluteGranulePosition - this.idHeader.preSkip;\n            this.metadata.setFormat('numberOfSamples', pos_48bit);\n            this.metadata.setFormat('duration', pos_48bit / 48000);\n            if (this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n                const dataSize = this.tokenizer.fileInfo.size - this.lastPos;\n                this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n            }\n        }\n    }\n}\nexports.OpusParser = OpusParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL29wdXMvT3B1c1BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsY0FBYyxtQkFBTyxDQUFDLGdGQUFhO0FBQ25DLHVCQUF1QixtQkFBTyxDQUFDLGdIQUF3QjtBQUN2RCxhQUFhLG1CQUFPLENBQUMsc0ZBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL29wdXMvT3B1c1BhcnNlci5qcz9kZGQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PcHVzUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBWb3JiaXNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi92b3JiaXMvVm9yYmlzUGFyc2VyXCIpO1xuY29uc3QgT3B1cyA9IHJlcXVpcmUoXCIuL09wdXNcIik7XG4vKipcbiAqIE9wdXMgcGFyc2VyXG4gKiBJbnRlcm5ldCBFbmdpbmVlcmluZyBUYXNrIEZvcmNlIChJRVRGKSAtIFJGQyA2NzE2XG4gKiBVc2VkIGJ5IE9nZ1BhcnNlclxuICovXG5jbGFzcyBPcHVzUGFyc2VyIGV4dGVuZHMgVm9yYmlzUGFyc2VyXzEuVm9yYmlzUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YSwgb3B0aW9ucywgdG9rZW5pemVyKSB7XG4gICAgICAgIHN1cGVyKG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICAgIHRoaXMubGFzdFBvcyA9IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBmaXJzdCBPcHVzIE9nZyBwYWdlXG4gICAgICogQHBhcmFtIHtJUGFnZUhlYWRlcn0gaGVhZGVyXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IHBhZ2VEYXRhXG4gICAgICovXG4gICAgcGFyc2VGaXJzdFBhZ2UoaGVhZGVyLCBwYWdlRGF0YSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29kZWMnLCAnT3B1cycpO1xuICAgICAgICAvLyBQYXJzZSBPcHVzIElEIEhlYWRlclxuICAgICAgICB0aGlzLmlkSGVhZGVyID0gbmV3IE9wdXMuSWRIZWFkZXIocGFnZURhdGEubGVuZ3RoKS5nZXQocGFnZURhdGEsIDApO1xuICAgICAgICBpZiAodGhpcy5pZEhlYWRlci5tYWdpY1NpZ25hdHVyZSAhPT0gXCJPcHVzSGVhZFwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBvZ2cvT3B1cyBtYWdpYy1zaWduYXR1cmVcIik7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdzYW1wbGVSYXRlJywgdGhpcy5pZEhlYWRlci5pbnB1dFNhbXBsZVJhdGUpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZDaGFubmVscycsIHRoaXMuaWRIZWFkZXIuY2hhbm5lbENvdW50KTtcbiAgICB9XG4gICAgcGFyc2VGdWxsUGFnZShwYWdlRGF0YSkge1xuICAgICAgICBjb25zdCBtYWdpY1NpZ25hdHVyZSA9IG5ldyBUb2tlbi5TdHJpbmdUeXBlKDgsICdhc2NpaScpLmdldChwYWdlRGF0YSwgMCk7XG4gICAgICAgIHN3aXRjaCAobWFnaWNTaWduYXR1cmUpIHtcbiAgICAgICAgICAgIGNhc2UgJ09wdXNUYWdzJzpcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVXNlckNvbW1lbnRMaXN0KHBhZ2VEYXRhLCA4KTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RQb3MgPSB0aGlzLnRva2VuaXplci5wb3NpdGlvbiAtIHBhZ2VEYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsY3VsYXRlRHVyYXRpb24oaGVhZGVyKSB7XG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmZvcm1hdC5zYW1wbGVSYXRlICYmIGhlYWRlci5hYnNvbHV0ZUdyYW51bGVQb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgZHVyYXRpb25cbiAgICAgICAgICAgIGNvbnN0IHBvc180OGJpdCA9IGhlYWRlci5hYnNvbHV0ZUdyYW51bGVQb3NpdGlvbiAtIHRoaXMuaWRIZWFkZXIucHJlU2tpcDtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZlNhbXBsZXMnLCBwb3NfNDhiaXQpO1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2R1cmF0aW9uJywgcG9zXzQ4Yml0IC8gNDgwMDApO1xuICAgICAgICAgICAgaWYgKHRoaXMubGFzdFBvcyAhPT0gLTEgJiYgdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSAmJiB0aGlzLm1ldGFkYXRhLmZvcm1hdC5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFTaXplID0gdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSAtIHRoaXMubGFzdFBvcztcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYml0cmF0ZScsIDggKiBkYXRhU2l6ZSAvIHRoaXMubWV0YWRhdGEuZm9ybWF0LmR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuT3B1c1BhcnNlciA9IE9wdXNQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/ogg/opus/OpusParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/ogg/speex/Speex.js":
/*!************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/speex/Speex.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Header = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst util = __webpack_require__(/*! ../../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\n/**\n * Speex Header Packet\n * Ref: https://www.speex.org/docs/manual/speex-manual/node8.html#SECTION00830000000000000000\n */\nexports.Header = {\n    len: 80,\n    get: (buf, off) => {\n        return {\n            speex: new Token.StringType(8, 'ascii').get(buf, off + 0),\n            version: util.trimRightNull(new Token.StringType(20, 'ascii').get(buf, off + 8)),\n            version_id: buf.readInt32LE(off + 28),\n            header_size: buf.readInt32LE(off + 32),\n            rate: buf.readInt32LE(off + 36),\n            mode: buf.readInt32LE(off + 40),\n            mode_bitstream_version: buf.readInt32LE(off + 44),\n            nb_channels: buf.readInt32LE(off + 48),\n            bitrate: buf.readInt32LE(off + 52),\n            frame_size: buf.readInt32LE(off + 56),\n            vbr: buf.readInt32LE(off + 60),\n            frames_per_packet: buf.readInt32LE(off + 64),\n            extra_headers: buf.readInt32LE(off + 68),\n            reserved1: buf.readInt32LE(off + 72),\n            reserved2: buf.readInt32LE(off + 76)\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL3NwZWV4L1NwZWV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxjQUFjLG1CQUFPLENBQUMsZ0ZBQWE7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLCtGQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9vZ2cvc3BlZXgvU3BlZXguanM/ODI3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGVhZGVyID0gdm9pZCAwO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9VdGlsXCIpO1xuLyoqXG4gKiBTcGVleCBIZWFkZXIgUGFja2V0XG4gKiBSZWY6IGh0dHBzOi8vd3d3LnNwZWV4Lm9yZy9kb2NzL21hbnVhbC9zcGVleC1tYW51YWwvbm9kZTguaHRtbCNTRUNUSU9OMDA4MzAwMDAwMDAwMDAwMDAwMDBcbiAqL1xuZXhwb3J0cy5IZWFkZXIgPSB7XG4gICAgbGVuOiA4MCxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BlZXg6IG5ldyBUb2tlbi5TdHJpbmdUeXBlKDgsICdhc2NpaScpLmdldChidWYsIG9mZiArIDApLFxuICAgICAgICAgICAgdmVyc2lvbjogdXRpbC50cmltUmlnaHROdWxsKG5ldyBUb2tlbi5TdHJpbmdUeXBlKDIwLCAnYXNjaWknKS5nZXQoYnVmLCBvZmYgKyA4KSksXG4gICAgICAgICAgICB2ZXJzaW9uX2lkOiBidWYucmVhZEludDMyTEUob2ZmICsgMjgpLFxuICAgICAgICAgICAgaGVhZGVyX3NpemU6IGJ1Zi5yZWFkSW50MzJMRShvZmYgKyAzMiksXG4gICAgICAgICAgICByYXRlOiBidWYucmVhZEludDMyTEUob2ZmICsgMzYpLFxuICAgICAgICAgICAgbW9kZTogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDQwKSxcbiAgICAgICAgICAgIG1vZGVfYml0c3RyZWFtX3ZlcnNpb246IGJ1Zi5yZWFkSW50MzJMRShvZmYgKyA0NCksXG4gICAgICAgICAgICBuYl9jaGFubmVsczogYnVmLnJlYWRJbnQzMkxFKG9mZiArIDQ4KSxcbiAgICAgICAgICAgIGJpdHJhdGU6IGJ1Zi5yZWFkSW50MzJMRShvZmYgKyA1MiksXG4gICAgICAgICAgICBmcmFtZV9zaXplOiBidWYucmVhZEludDMyTEUob2ZmICsgNTYpLFxuICAgICAgICAgICAgdmJyOiBidWYucmVhZEludDMyTEUob2ZmICsgNjApLFxuICAgICAgICAgICAgZnJhbWVzX3Blcl9wYWNrZXQ6IGJ1Zi5yZWFkSW50MzJMRShvZmYgKyA2NCksXG4gICAgICAgICAgICBleHRyYV9oZWFkZXJzOiBidWYucmVhZEludDMyTEUob2ZmICsgNjgpLFxuICAgICAgICAgICAgcmVzZXJ2ZWQxOiBidWYucmVhZEludDMyTEUob2ZmICsgNzIpLFxuICAgICAgICAgICAgcmVzZXJ2ZWQyOiBidWYucmVhZEludDMyTEUob2ZmICsgNzYpXG4gICAgICAgIH07XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/ogg/speex/Speex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/ogg/speex/SpeexParser.js":
/*!******************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/speex/SpeexParser.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SpeexParser = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst VorbisParser_1 = __webpack_require__(/*! ../vorbis/VorbisParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js\");\nconst Speex = __webpack_require__(/*! ./Speex */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ogg/speex/Speex.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:ogg:speex');\n/**\n * Speex, RFC 5574\n * Ref:\n * - https://www.speex.org/docs/manual/speex-manual/\n * - https://tools.ietf.org/html/rfc5574\n */\nclass SpeexParser extends VorbisParser_1.VorbisParser {\n    constructor(metadata, options, tokenizer) {\n        super(metadata, options);\n        this.tokenizer = tokenizer;\n    }\n    /**\n     * Parse first Speex Ogg page\n     * @param {IPageHeader} header\n     * @param {Buffer} pageData\n     */\n    parseFirstPage(header, pageData) {\n        debug('First Ogg/Speex page');\n        const speexHeader = Speex.Header.get(pageData, 0);\n        this.metadata.setFormat('codec', `Speex ${speexHeader.version}`);\n        this.metadata.setFormat('numberOfChannels', speexHeader.nb_channels);\n        this.metadata.setFormat('sampleRate', speexHeader.rate);\n        if (speexHeader.bitrate !== -1) {\n            this.metadata.setFormat('bitrate', speexHeader.bitrate);\n        }\n    }\n}\nexports.SpeexParser = SpeexParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL3NwZWV4L1NwZWV4UGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBTztBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyxnSEFBd0I7QUFDdkQsY0FBYyxtQkFBTyxDQUFDLHlGQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy9zcGVleC9TcGVleFBhcnNlci5qcz8yNTQ3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TcGVleFBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBWb3JiaXNQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi92b3JiaXMvVm9yYmlzUGFyc2VyXCIpO1xuY29uc3QgU3BlZXggPSByZXF1aXJlKFwiLi9TcGVleFwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjpvZ2c6c3BlZXgnKTtcbi8qKlxuICogU3BlZXgsIFJGQyA1NTc0XG4gKiBSZWY6XG4gKiAtIGh0dHBzOi8vd3d3LnNwZWV4Lm9yZy9kb2NzL21hbnVhbC9zcGVleC1tYW51YWwvXG4gKiAtIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1NTc0XG4gKi9cbmNsYXNzIFNwZWV4UGFyc2VyIGV4dGVuZHMgVm9yYmlzUGFyc2VyXzEuVm9yYmlzUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YSwgb3B0aW9ucywgdG9rZW5pemVyKSB7XG4gICAgICAgIHN1cGVyKG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGZpcnN0IFNwZWV4IE9nZyBwYWdlXG4gICAgICogQHBhcmFtIHtJUGFnZUhlYWRlcn0gaGVhZGVyXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IHBhZ2VEYXRhXG4gICAgICovXG4gICAgcGFyc2VGaXJzdFBhZ2UoaGVhZGVyLCBwYWdlRGF0YSkge1xuICAgICAgICBkZWJ1ZygnRmlyc3QgT2dnL1NwZWV4IHBhZ2UnKTtcbiAgICAgICAgY29uc3Qgc3BlZXhIZWFkZXIgPSBTcGVleC5IZWFkZXIuZ2V0KHBhZ2VEYXRhLCAwKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvZGVjJywgYFNwZWV4ICR7c3BlZXhIZWFkZXIudmVyc2lvbn1gKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ251bWJlck9mQ2hhbm5lbHMnLCBzcGVleEhlYWRlci5uYl9jaGFubmVscyk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdzYW1wbGVSYXRlJywgc3BlZXhIZWFkZXIucmF0ZSk7XG4gICAgICAgIGlmIChzcGVleEhlYWRlci5iaXRyYXRlICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCBzcGVleEhlYWRlci5iaXRyYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU3BlZXhQYXJzZXIgPSBTcGVleFBhcnNlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/ogg/speex/SpeexParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/ogg/theora/Theora.js":
/*!**************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/theora/Theora.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IdentificationHeader = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\n/**\n * 6.2 Identification Header\n * Ref: https://theora.org/doc/Theora.pdf: 6.2 Identification Header Decode\n */\nexports.IdentificationHeader = {\n    len: 42,\n    get: (buf, off) => {\n        return {\n            id: new Token.StringType(7, 'ascii').get(buf, off),\n            vmaj: buf.readUInt8(off + 7),\n            vmin: buf.readUInt8(off + 8),\n            vrev: buf.readUInt8(off + 9),\n            vmbw: buf.readUInt16BE(off + 10),\n            vmbh: buf.readUInt16BE(off + 17),\n            nombr: Token.UINT24_BE.get(buf, off + 37),\n            nqual: buf.readUInt8(off + 40)\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL3RoZW9yYS9UaGVvcmEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCO0FBQzVCLGNBQWMsbUJBQU8sQ0FBQyxnRkFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL3RoZW9yYS9UaGVvcmEuanM/YjUzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSWRlbnRpZmljYXRpb25IZWFkZXIgPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbi8qKlxuICogNi4yIElkZW50aWZpY2F0aW9uIEhlYWRlclxuICogUmVmOiBodHRwczovL3RoZW9yYS5vcmcvZG9jL1RoZW9yYS5wZGY6IDYuMiBJZGVudGlmaWNhdGlvbiBIZWFkZXIgRGVjb2RlXG4gKi9cbmV4cG9ydHMuSWRlbnRpZmljYXRpb25IZWFkZXIgPSB7XG4gICAgbGVuOiA0MixcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IG5ldyBUb2tlbi5TdHJpbmdUeXBlKDcsICdhc2NpaScpLmdldChidWYsIG9mZiksXG4gICAgICAgICAgICB2bWFqOiBidWYucmVhZFVJbnQ4KG9mZiArIDcpLFxuICAgICAgICAgICAgdm1pbjogYnVmLnJlYWRVSW50OChvZmYgKyA4KSxcbiAgICAgICAgICAgIHZyZXY6IGJ1Zi5yZWFkVUludDgob2ZmICsgOSksXG4gICAgICAgICAgICB2bWJ3OiBidWYucmVhZFVJbnQxNkJFKG9mZiArIDEwKSxcbiAgICAgICAgICAgIHZtYmg6IGJ1Zi5yZWFkVUludDE2QkUob2ZmICsgMTcpLFxuICAgICAgICAgICAgbm9tYnI6IFRva2VuLlVJTlQyNF9CRS5nZXQoYnVmLCBvZmYgKyAzNyksXG4gICAgICAgICAgICBucXVhbDogYnVmLnJlYWRVSW50OChvZmYgKyA0MClcbiAgICAgICAgfTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/ogg/theora/Theora.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/ogg/theora/TheoraParser.js":
/*!********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/theora/TheoraParser.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TheoraParser = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst Theora_1 = __webpack_require__(/*! ./Theora */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ogg/theora/Theora.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:ogg:theora');\n/**\n * Ref:\n * - https://theora.org/doc/Theora.pdf\n */\nclass TheoraParser {\n    constructor(metadata, options, tokenizer) {\n        this.metadata = metadata;\n        this.tokenizer = tokenizer;\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    parsePage(header, pageData) {\n        if (header.headerType.firstPage) {\n            this.parseFirstPage(header, pageData);\n        }\n    }\n    flush() {\n        debug('flush');\n    }\n    calculateDuration(header) {\n        debug('duration calculation not implemented');\n    }\n    /**\n     * Parse first Theora Ogg page. the initial identification header packet\n     * @param {IPageHeader} header\n     * @param {Buffer} pageData\n     */\n    parseFirstPage(header, pageData) {\n        debug('First Ogg/Theora page');\n        this.metadata.setFormat('codec', 'Theora');\n        const idHeader = Theora_1.IdentificationHeader.get(pageData, 0);\n        this.metadata.setFormat('bitrate', idHeader.nombr);\n    }\n}\nexports.TheoraParser = TheoraParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL3RoZW9yYS9UaGVvcmFQYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFPO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLDRGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL3RoZW9yYS9UaGVvcmFQYXJzZXIuanM/MTdkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGhlb3JhUGFyc2VyID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IFRoZW9yYV8xID0gcmVxdWlyZShcIi4vVGhlb3JhXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbXVzaWMtbWV0YWRhdGE6cGFyc2VyOm9nZzp0aGVvcmEnKTtcbi8qKlxuICogUmVmOlxuICogLSBodHRwczovL3RoZW9yYS5vcmcvZG9jL1RoZW9yYS5wZGZcbiAqL1xuY2xhc3MgVGhlb3JhUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YSwgb3B0aW9ucywgdG9rZW5pemVyKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZvcmJpcyAxIHBhcnNlclxuICAgICAqIEBwYXJhbSBoZWFkZXIgT2dnIFBhZ2UgSGVhZGVyXG4gICAgICogQHBhcmFtIHBhZ2VEYXRhIFBhZ2UgZGF0YVxuICAgICAqL1xuICAgIHBhcnNlUGFnZShoZWFkZXIsIHBhZ2VEYXRhKSB7XG4gICAgICAgIGlmIChoZWFkZXIuaGVhZGVyVHlwZS5maXJzdFBhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VGaXJzdFBhZ2UoaGVhZGVyLCBwYWdlRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2goKSB7XG4gICAgICAgIGRlYnVnKCdmbHVzaCcpO1xuICAgIH1cbiAgICBjYWxjdWxhdGVEdXJhdGlvbihoZWFkZXIpIHtcbiAgICAgICAgZGVidWcoJ2R1cmF0aW9uIGNhbGN1bGF0aW9uIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBmaXJzdCBUaGVvcmEgT2dnIHBhZ2UuIHRoZSBpbml0aWFsIGlkZW50aWZpY2F0aW9uIGhlYWRlciBwYWNrZXRcbiAgICAgKiBAcGFyYW0ge0lQYWdlSGVhZGVyfSBoZWFkZXJcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gcGFnZURhdGFcbiAgICAgKi9cbiAgICBwYXJzZUZpcnN0UGFnZShoZWFkZXIsIHBhZ2VEYXRhKSB7XG4gICAgICAgIGRlYnVnKCdGaXJzdCBPZ2cvVGhlb3JhIHBhZ2UnKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvZGVjJywgJ1RoZW9yYScpO1xuICAgICAgICBjb25zdCBpZEhlYWRlciA9IFRoZW9yYV8xLklkZW50aWZpY2F0aW9uSGVhZGVyLmdldChwYWdlRGF0YSwgMCk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdiaXRyYXRlJywgaWRIZWFkZXIubm9tYnIpO1xuICAgIH1cbn1cbmV4cG9ydHMuVGhlb3JhUGFyc2VyID0gVGhlb3JhUGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/ogg/theora/TheoraParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js":
/*!**************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IdentificationHeader = exports.CommonHeader = exports.VorbisPictureToken = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst ID3v2Token_1 = __webpack_require__(/*! ../../id3v2/ID3v2Token */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v2Token.js\");\n/**\n * Parse the METADATA_BLOCK_PICTURE\n * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE\n * Ref: https://xiph.org/flac/format.html#metadata_block_picture\n * // ToDo: move to ID3 / APIC?\n */\nclass VorbisPictureToken {\n    static fromBase64(base64str) {\n        return this.fromBuffer(Buffer.from(base64str, 'base64'));\n    }\n    static fromBuffer(buffer) {\n        const pic = new VorbisPictureToken(buffer.length);\n        return pic.get(buffer, 0);\n    }\n    constructor(len) {\n        this.len = len;\n    }\n    get(buffer, offset) {\n        const type = ID3v2Token_1.AttachedPictureType[Token.UINT32_BE.get(buffer, offset)];\n        const mimeLen = Token.UINT32_BE.get(buffer, offset += 4);\n        const format = buffer.toString('utf-8', offset += 4, offset + mimeLen);\n        const descLen = Token.UINT32_BE.get(buffer, offset += mimeLen);\n        const description = buffer.toString('utf-8', offset += 4, offset + descLen);\n        const width = Token.UINT32_BE.get(buffer, offset += descLen);\n        const height = Token.UINT32_BE.get(buffer, offset += 4);\n        const colour_depth = Token.UINT32_BE.get(buffer, offset += 4);\n        const indexed_color = Token.UINT32_BE.get(buffer, offset += 4);\n        const picDataLen = Token.UINT32_BE.get(buffer, offset += 4);\n        const data = Buffer.from(buffer.slice(offset += 4, offset + picDataLen));\n        return {\n            type,\n            format,\n            description,\n            width,\n            height,\n            colour_depth,\n            indexed_color,\n            data\n        };\n    }\n}\nexports.VorbisPictureToken = VorbisPictureToken;\n/**\n * Comment header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1\n */\nexports.CommonHeader = {\n    len: 7,\n    get: (buf, off) => {\n        return {\n            packetType: buf.readUInt8(off),\n            vorbis: new Token.StringType(6, 'ascii').get(buf, off + 1)\n        };\n    }\n};\n/**\n * Identification header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2\n */\nexports.IdentificationHeader = {\n    len: 23,\n    get: (uint8Array, off) => {\n        const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset);\n        return {\n            version: dataView.getUint32(off + 0, true),\n            channelMode: dataView.getUint8(off + 4),\n            sampleRate: dataView.getUint32(off + 5, true),\n            bitrateMax: dataView.getUint32(off + 9, true),\n            bitrateNominal: dataView.getUint32(off + 13, true),\n            bitrateMin: dataView.getUint32(off + 17, true)\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL3ZvcmJpcy9Wb3JiaXMuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLG9CQUFvQixHQUFHLDBCQUEwQjtBQUNoRixjQUFjLG1CQUFPLENBQUMsZ0ZBQWE7QUFDbkMscUJBQXFCLG1CQUFPLENBQUMseUdBQXdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9vZ2cvdm9yYmlzL1ZvcmJpcy5qcz81NTk2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JZGVudGlmaWNhdGlvbkhlYWRlciA9IGV4cG9ydHMuQ29tbW9uSGVhZGVyID0gZXhwb3J0cy5Wb3JiaXNQaWN0dXJlVG9rZW4gPSB2b2lkIDA7XG5jb25zdCBUb2tlbiA9IHJlcXVpcmUoXCJ0b2tlbi10eXBlc1wiKTtcbmNvbnN0IElEM3YyVG9rZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9pZDN2Mi9JRDN2MlRva2VuXCIpO1xuLyoqXG4gKiBQYXJzZSB0aGUgTUVUQURBVEFfQkxPQ0tfUElDVFVSRVxuICogUmVmOiBodHRwczovL3dpa2kueGlwaC5vcmcvVm9yYmlzQ29tbWVudCNNRVRBREFUQV9CTE9DS19QSUNUVVJFXG4gKiBSZWY6IGh0dHBzOi8veGlwaC5vcmcvZmxhYy9mb3JtYXQuaHRtbCNtZXRhZGF0YV9ibG9ja19waWN0dXJlXG4gKiAvLyBUb0RvOiBtb3ZlIHRvIElEMyAvIEFQSUM/XG4gKi9cbmNsYXNzIFZvcmJpc1BpY3R1cmVUb2tlbiB7XG4gICAgc3RhdGljIGZyb21CYXNlNjQoYmFzZTY0c3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIoQnVmZmVyLmZyb20oYmFzZTY0c3RyLCAnYmFzZTY0JykpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgY29uc3QgcGljID0gbmV3IFZvcmJpc1BpY3R1cmVUb2tlbihidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHBpYy5nZXQoYnVmZmVyLCAwKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobGVuKSB7XG4gICAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgIH1cbiAgICBnZXQoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IElEM3YyVG9rZW5fMS5BdHRhY2hlZFBpY3R1cmVUeXBlW1Rva2VuLlVJTlQzMl9CRS5nZXQoYnVmZmVyLCBvZmZzZXQpXTtcbiAgICAgICAgY29uc3QgbWltZUxlbiA9IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmZmVyLCBvZmZzZXQgKz0gNCk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGJ1ZmZlci50b1N0cmluZygndXRmLTgnLCBvZmZzZXQgKz0gNCwgb2Zmc2V0ICsgbWltZUxlbik7XG4gICAgICAgIGNvbnN0IGRlc2NMZW4gPSBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1ZmZlciwgb2Zmc2V0ICs9IG1pbWVMZW4pO1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGJ1ZmZlci50b1N0cmluZygndXRmLTgnLCBvZmZzZXQgKz0gNCwgb2Zmc2V0ICsgZGVzY0xlbik7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gVG9rZW4uVUlOVDMyX0JFLmdldChidWZmZXIsIG9mZnNldCArPSBkZXNjTGVuKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gVG9rZW4uVUlOVDMyX0JFLmdldChidWZmZXIsIG9mZnNldCArPSA0KTtcbiAgICAgICAgY29uc3QgY29sb3VyX2RlcHRoID0gVG9rZW4uVUlOVDMyX0JFLmdldChidWZmZXIsIG9mZnNldCArPSA0KTtcbiAgICAgICAgY29uc3QgaW5kZXhlZF9jb2xvciA9IFRva2VuLlVJTlQzMl9CRS5nZXQoYnVmZmVyLCBvZmZzZXQgKz0gNCk7XG4gICAgICAgIGNvbnN0IHBpY0RhdGFMZW4gPSBUb2tlbi5VSU5UMzJfQkUuZ2V0KGJ1ZmZlciwgb2Zmc2V0ICs9IDQpO1xuICAgICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmZyb20oYnVmZmVyLnNsaWNlKG9mZnNldCArPSA0LCBvZmZzZXQgKyBwaWNEYXRhTGVuKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIGNvbG91cl9kZXB0aCxcbiAgICAgICAgICAgIGluZGV4ZWRfY29sb3IsXG4gICAgICAgICAgICBkYXRhXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Wb3JiaXNQaWN0dXJlVG9rZW4gPSBWb3JiaXNQaWN0dXJlVG9rZW47XG4vKipcbiAqIENvbW1lbnQgaGVhZGVyIGRlY29kZXJcbiAqIFJlZjogaHR0cHM6Ly94aXBoLm9yZy92b3JiaXMvZG9jL1ZvcmJpc19JX3NwZWMuaHRtbCN4MS02MjAwMDQuMi4xXG4gKi9cbmV4cG9ydHMuQ29tbW9uSGVhZGVyID0ge1xuICAgIGxlbjogNyxcbiAgICBnZXQ6IChidWYsIG9mZikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFja2V0VHlwZTogYnVmLnJlYWRVSW50OChvZmYpLFxuICAgICAgICAgICAgdm9yYmlzOiBuZXcgVG9rZW4uU3RyaW5nVHlwZSg2LCAnYXNjaWknKS5nZXQoYnVmLCBvZmYgKyAxKVxuICAgICAgICB9O1xuICAgIH1cbn07XG4vKipcbiAqIElkZW50aWZpY2F0aW9uIGhlYWRlciBkZWNvZGVyXG4gKiBSZWY6IGh0dHBzOi8veGlwaC5vcmcvdm9yYmlzL2RvYy9Wb3JiaXNfSV9zcGVjLmh0bWwjeDEtNjMwMDA0LjIuMlxuICovXG5leHBvcnRzLklkZW50aWZpY2F0aW9uSGVhZGVyID0ge1xuICAgIGxlbjogMjMsXG4gICAgZ2V0OiAodWludDhBcnJheSwgb2ZmKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHVpbnQ4QXJyYXkuYnVmZmVyLCB1aW50OEFycmF5LmJ5dGVPZmZzZXQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogZGF0YVZpZXcuZ2V0VWludDMyKG9mZiArIDAsIHRydWUpLFxuICAgICAgICAgICAgY2hhbm5lbE1vZGU6IGRhdGFWaWV3LmdldFVpbnQ4KG9mZiArIDQpLFxuICAgICAgICAgICAgc2FtcGxlUmF0ZTogZGF0YVZpZXcuZ2V0VWludDMyKG9mZiArIDUsIHRydWUpLFxuICAgICAgICAgICAgYml0cmF0ZU1heDogZGF0YVZpZXcuZ2V0VWludDMyKG9mZiArIDksIHRydWUpLFxuICAgICAgICAgICAgYml0cmF0ZU5vbWluYWw6IGRhdGFWaWV3LmdldFVpbnQzMihvZmYgKyAxMywgdHJ1ZSksXG4gICAgICAgICAgICBiaXRyYXRlTWluOiBkYXRhVmlldy5nZXRVaW50MzIob2ZmICsgMTcsIHRydWUpXG4gICAgICAgIH07XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VorbisDecoder = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nclass VorbisDecoder {\n    constructor(data, offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n    readInt32() {\n        const value = Token.UINT32_LE.get(this.data, this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readStringUtf8() {\n        const len = this.readInt32();\n        const value = Buffer.from(this.data).toString('utf-8', this.offset, this.offset + len);\n        this.offset += len;\n        return value;\n    }\n    parseUserComment() {\n        const offset0 = this.offset;\n        const v = this.readStringUtf8();\n        const idx = v.indexOf('=');\n        return {\n            key: v.slice(0, idx).toUpperCase(),\n            value: v.slice(idx + 1),\n            len: this.offset - offset0\n        };\n    }\n}\nexports.VorbisDecoder = VorbisDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL3ZvcmJpcy9Wb3JiaXNEZWNvZGVyLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsY0FBYyxtQkFBTyxDQUFDLGdGQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9vZ2cvdm9yYmlzL1ZvcmJpc0RlY29kZXIuanM/YjAzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVm9yYmlzRGVjb2RlciA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY2xhc3MgVm9yYmlzRGVjb2RlciB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgICByZWFkSW50MzIoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gVG9rZW4uVUlOVDMyX0xFLmdldCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZWFkU3RyaW5nVXRmOCgpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5yZWFkSW50MzIoKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBCdWZmZXIuZnJvbSh0aGlzLmRhdGEpLnRvU3RyaW5nKCd1dGYtOCcsIHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIGxlbik7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBwYXJzZVVzZXJDb21tZW50KCkge1xuICAgICAgICBjb25zdCBvZmZzZXQwID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLnJlYWRTdHJpbmdVdGY4KCk7XG4gICAgICAgIGNvbnN0IGlkeCA9IHYuaW5kZXhPZignPScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiB2LnNsaWNlKDAsIGlkeCkudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgIHZhbHVlOiB2LnNsaWNlKGlkeCArIDEpLFxuICAgICAgICAgICAgbGVuOiB0aGlzLm9mZnNldCAtIG9mZnNldDBcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlZvcmJpc0RlY29kZXIgPSBWb3JiaXNEZWNvZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js":
/*!********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VorbisParser = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst VorbisDecoder_1 = __webpack_require__(/*! ./VorbisDecoder */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js\");\nconst Vorbis_1 = __webpack_require__(/*! ./Vorbis */ \"(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:ogg:vorbis1');\n/**\n * Vorbis 1 Parser.\n * Used by OggParser\n */\nclass VorbisParser {\n    constructor(metadata, options) {\n        this.metadata = metadata;\n        this.options = options;\n        this.pageSegments = [];\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    parsePage(header, pageData) {\n        if (header.headerType.firstPage) {\n            this.parseFirstPage(header, pageData);\n        }\n        else {\n            if (header.headerType.continued) {\n                if (this.pageSegments.length === 0) {\n                    throw new Error(\"Cannot continue on previous page\");\n                }\n                this.pageSegments.push(pageData);\n            }\n            if (header.headerType.lastPage || !header.headerType.continued) {\n                // Flush page segments\n                if (this.pageSegments.length > 0) {\n                    const fullPage = Buffer.concat(this.pageSegments);\n                    this.parseFullPage(fullPage);\n                }\n                // Reset page segments\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n            }\n        }\n        if (header.headerType.lastPage) {\n            this.calculateDuration(header);\n        }\n    }\n    flush() {\n        this.parseFullPage(Buffer.concat(this.pageSegments));\n    }\n    parseUserComment(pageData, offset) {\n        const decoder = new VorbisDecoder_1.VorbisDecoder(pageData, offset);\n        const tag = decoder.parseUserComment();\n        this.addTag(tag.key, tag.value);\n        return tag.len;\n    }\n    addTag(id, value) {\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\n            if (this.options.skipCovers) {\n                debug(`Ignore picture`);\n                return;\n            }\n            value = Vorbis_1.VorbisPictureToken.fromBase64(value);\n            debug(`Push picture: id=${id}, format=${value.format}`);\n        }\n        else {\n            debug(`Push tag: id=${id}, value=${value}`);\n        }\n        this.metadata.addTag('vorbis', id, value);\n    }\n    calculateDuration(header) {\n        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            this.metadata.setFormat('numberOfSamples', header.absoluteGranulePosition);\n            this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n        }\n    }\n    /**\n     * Parse first Ogg/Vorbis page\n     * @param {IPageHeader} header\n     * @param {Buffer} pageData\n     */\n    parseFirstPage(header, pageData) {\n        this.metadata.setFormat('codec', 'Vorbis I');\n        debug(\"Parse first page\");\n        // Parse  Vorbis common header\n        const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\n        if (commonHeader.vorbis !== 'vorbis')\n            throw new Error('Metadata does not look like Vorbis');\n        if (commonHeader.packetType === 1) {\n            const idHeader = Vorbis_1.IdentificationHeader.get(pageData, Vorbis_1.CommonHeader.len);\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n            debug(\"sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s\", idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n        }\n        else\n            throw new Error('First Ogg page should be type 1: the identification header');\n    }\n    parseFullPage(pageData) {\n        // New page\n        const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\n        debug(\"Parse full page: type=%s, byteLength=%s\", commonHeader.packetType, pageData.byteLength);\n        switch (commonHeader.packetType) {\n            case 3: //  type 3: comment header\n                return this.parseUserCommentList(pageData, Vorbis_1.CommonHeader.len);\n            case 1: // type 1: the identification header\n            case 5: // type 5: setup header type\n                break; // ignore\n        }\n    }\n    /**\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n     */\n    parseUserCommentList(pageData, offset) {\n        const strLen = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n        offset += strLen;\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        while (userCommentListLength-- > 0) {\n            offset += this.parseUserComment(pageData, offset);\n        }\n    }\n}\nexports.VorbisParser = VorbisParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL3ZvcmJpcy9Wb3JiaXNQYXJzZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQixjQUFjLG1CQUFPLENBQUMsZ0ZBQWE7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQU87QUFDL0Isd0JBQXdCLG1CQUFPLENBQUMsMEdBQWlCO0FBQ2pELGlCQUFpQixtQkFBTyxDQUFDLDRGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEdBQUcsV0FBVyxhQUFhO0FBQ2pFO0FBQ0E7QUFDQSxrQ0FBa0MsR0FBRyxVQUFVLE1BQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy92b3JiaXMvVm9yYmlzUGFyc2VyLmpzP2E3ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZvcmJpc1BhcnNlciA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IFZvcmJpc0RlY29kZXJfMSA9IHJlcXVpcmUoXCIuL1ZvcmJpc0RlY29kZXJcIik7XG5jb25zdCBWb3JiaXNfMSA9IHJlcXVpcmUoXCIuL1ZvcmJpc1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjpvZ2c6dm9yYmlzMScpO1xuLyoqXG4gKiBWb3JiaXMgMSBQYXJzZXIuXG4gKiBVc2VkIGJ5IE9nZ1BhcnNlclxuICovXG5jbGFzcyBWb3JiaXNQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKG1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5wYWdlU2VnbWVudHMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVm9yYmlzIDEgcGFyc2VyXG4gICAgICogQHBhcmFtIGhlYWRlciBPZ2cgUGFnZSBIZWFkZXJcbiAgICAgKiBAcGFyYW0gcGFnZURhdGEgUGFnZSBkYXRhXG4gICAgICovXG4gICAgcGFyc2VQYWdlKGhlYWRlciwgcGFnZURhdGEpIHtcbiAgICAgICAgaWYgKGhlYWRlci5oZWFkZXJUeXBlLmZpcnN0UGFnZSkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUZpcnN0UGFnZShoZWFkZXIsIHBhZ2VEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXIuaGVhZGVyVHlwZS5jb250aW51ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYWdlU2VnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb250aW51ZSBvbiBwcmV2aW91cyBwYWdlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VTZWdtZW50cy5wdXNoKHBhZ2VEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWFkZXIuaGVhZGVyVHlwZS5sYXN0UGFnZSB8fCAhaGVhZGVyLmhlYWRlclR5cGUuY29udGludWVkKSB7XG4gICAgICAgICAgICAgICAgLy8gRmx1c2ggcGFnZSBzZWdtZW50c1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhZ2VTZWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxQYWdlID0gQnVmZmVyLmNvbmNhdCh0aGlzLnBhZ2VTZWdtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VGdWxsUGFnZShmdWxsUGFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHBhZ2Ugc2VnbWVudHNcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VTZWdtZW50cyA9IGhlYWRlci5oZWFkZXJUeXBlLmxhc3RQYWdlID8gW10gOiBbcGFnZURhdGFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXIuaGVhZGVyVHlwZS5sYXN0UGFnZSkge1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVEdXJhdGlvbihoZWFkZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZsdXNoKCkge1xuICAgICAgICB0aGlzLnBhcnNlRnVsbFBhZ2UoQnVmZmVyLmNvbmNhdCh0aGlzLnBhZ2VTZWdtZW50cykpO1xuICAgIH1cbiAgICBwYXJzZVVzZXJDb21tZW50KHBhZ2VEYXRhLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBWb3JiaXNEZWNvZGVyXzEuVm9yYmlzRGVjb2RlcihwYWdlRGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgdGFnID0gZGVjb2Rlci5wYXJzZVVzZXJDb21tZW50KCk7XG4gICAgICAgIHRoaXMuYWRkVGFnKHRhZy5rZXksIHRhZy52YWx1ZSk7XG4gICAgICAgIHJldHVybiB0YWcubGVuO1xuICAgIH1cbiAgICBhZGRUYWcoaWQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpZCA9PT0gJ01FVEFEQVRBX0JMT0NLX1BJQ1RVUkUnICYmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5za2lwQ292ZXJzKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoYElnbm9yZSBwaWN0dXJlYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBWb3JiaXNfMS5Wb3JiaXNQaWN0dXJlVG9rZW4uZnJvbUJhc2U2NCh2YWx1ZSk7XG4gICAgICAgICAgICBkZWJ1ZyhgUHVzaCBwaWN0dXJlOiBpZD0ke2lkfSwgZm9ybWF0PSR7dmFsdWUuZm9ybWF0fWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoYFB1c2ggdGFnOiBpZD0ke2lkfSwgdmFsdWU9JHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFRhZygndm9yYmlzJywgaWQsIHZhbHVlKTtcbiAgICB9XG4gICAgY2FsY3VsYXRlRHVyYXRpb24oaGVhZGVyKSB7XG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmZvcm1hdC5zYW1wbGVSYXRlICYmIGhlYWRlci5hYnNvbHV0ZUdyYW51bGVQb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgZHVyYXRpb25cbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZlNhbXBsZXMnLCBoZWFkZXIuYWJzb2x1dGVHcmFudWxlUG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2R1cmF0aW9uJywgdGhpcy5tZXRhZGF0YS5mb3JtYXQubnVtYmVyT2ZTYW1wbGVzIC8gdGhpcy5tZXRhZGF0YS5mb3JtYXQuc2FtcGxlUmF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgZmlyc3QgT2dnL1ZvcmJpcyBwYWdlXG4gICAgICogQHBhcmFtIHtJUGFnZUhlYWRlcn0gaGVhZGVyXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IHBhZ2VEYXRhXG4gICAgICovXG4gICAgcGFyc2VGaXJzdFBhZ2UoaGVhZGVyLCBwYWdlRGF0YSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29kZWMnLCAnVm9yYmlzIEknKTtcbiAgICAgICAgZGVidWcoXCJQYXJzZSBmaXJzdCBwYWdlXCIpO1xuICAgICAgICAvLyBQYXJzZSAgVm9yYmlzIGNvbW1vbiBoZWFkZXJcbiAgICAgICAgY29uc3QgY29tbW9uSGVhZGVyID0gVm9yYmlzXzEuQ29tbW9uSGVhZGVyLmdldChwYWdlRGF0YSwgMCk7XG4gICAgICAgIGlmIChjb21tb25IZWFkZXIudm9yYmlzICE9PSAndm9yYmlzJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YWRhdGEgZG9lcyBub3QgbG9vayBsaWtlIFZvcmJpcycpO1xuICAgICAgICBpZiAoY29tbW9uSGVhZGVyLnBhY2tldFR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkSGVhZGVyID0gVm9yYmlzXzEuSWRlbnRpZmljYXRpb25IZWFkZXIuZ2V0KHBhZ2VEYXRhLCBWb3JiaXNfMS5Db21tb25IZWFkZXIubGVuKTtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdzYW1wbGVSYXRlJywgaWRIZWFkZXIuc2FtcGxlUmF0ZSk7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYml0cmF0ZScsIGlkSGVhZGVyLmJpdHJhdGVOb21pbmFsKTtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZkNoYW5uZWxzJywgaWRIZWFkZXIuY2hhbm5lbE1vZGUpO1xuICAgICAgICAgICAgZGVidWcoXCJzYW1wbGUtcmF0ZT0lc1toel0sIGJpdHJhdGU9JXNbYi9zXSwgY2hhbm5lbC1tb2RlPSVzXCIsIGlkSGVhZGVyLnNhbXBsZVJhdGUsIGlkSGVhZGVyLmJpdHJhdGVOb21pbmFsLCBpZEhlYWRlci5jaGFubmVsTW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBPZ2cgcGFnZSBzaG91bGQgYmUgdHlwZSAxOiB0aGUgaWRlbnRpZmljYXRpb24gaGVhZGVyJyk7XG4gICAgfVxuICAgIHBhcnNlRnVsbFBhZ2UocGFnZURhdGEpIHtcbiAgICAgICAgLy8gTmV3IHBhZ2VcbiAgICAgICAgY29uc3QgY29tbW9uSGVhZGVyID0gVm9yYmlzXzEuQ29tbW9uSGVhZGVyLmdldChwYWdlRGF0YSwgMCk7XG4gICAgICAgIGRlYnVnKFwiUGFyc2UgZnVsbCBwYWdlOiB0eXBlPSVzLCBieXRlTGVuZ3RoPSVzXCIsIGNvbW1vbkhlYWRlci5wYWNrZXRUeXBlLCBwYWdlRGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgc3dpdGNoIChjb21tb25IZWFkZXIucGFja2V0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSAzOiAvLyAgdHlwZSAzOiBjb21tZW50IGhlYWRlclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVXNlckNvbW1lbnRMaXN0KHBhZ2VEYXRhLCBWb3JiaXNfMS5Db21tb25IZWFkZXIubGVuKTtcbiAgICAgICAgICAgIGNhc2UgMTogLy8gdHlwZSAxOiB0aGUgaWRlbnRpZmljYXRpb24gaGVhZGVyXG4gICAgICAgICAgICBjYXNlIDU6IC8vIHR5cGUgNTogc2V0dXAgaGVhZGVyIHR5cGVcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gaWdub3JlXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmOiBodHRwczovL3hpcGgub3JnL3ZvcmJpcy9kb2MvVm9yYmlzX0lfc3BlYy5odG1sI3gxLTg0MDAwNS4yXG4gICAgICovXG4gICAgcGFyc2VVc2VyQ29tbWVudExpc3QocGFnZURhdGEsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBzdHJMZW4gPSBUb2tlbi5VSU5UMzJfTEUuZ2V0KHBhZ2VEYXRhLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgLy8gY29uc3QgdmVuZG9yU3RyaW5nID0gbmV3IFRva2VuLlN0cmluZ1R5cGUoc3RyTGVuLCAndXRmLTgnKS5nZXQocGFnZURhdGEsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBzdHJMZW47XG4gICAgICAgIGxldCB1c2VyQ29tbWVudExpc3RMZW5ndGggPSBUb2tlbi5VSU5UMzJfTEUuZ2V0KHBhZ2VEYXRhLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgd2hpbGUgKHVzZXJDb21tZW50TGlzdExlbmd0aC0tID4gMCkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMucGFyc2VVc2VyQ29tbWVudChwYWdlRGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVm9yYmlzUGFyc2VyID0gVm9yYmlzUGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/VorbisTagMapper.js":
/*!***********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/vorbis/VorbisTagMapper.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VorbisTagMapper = void 0;\nconst GenericTagMapper_1 = __webpack_require__(/*! ../../common/GenericTagMapper */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/GenericTagMapper.js\");\n/**\n * Vorbis tag mappings\n *\n * Mapping from native header format to one or possibly more 'common' entries\n * The common entries aim to read the same information from different media files\n * independent of the underlying format\n */\nconst vorbisTagMap = {\n    TITLE: 'title',\n    ARTIST: 'artist',\n    ARTISTS: 'artists',\n    ALBUMARTIST: 'albumartist',\n    'ALBUM ARTIST': 'albumartist',\n    ALBUM: 'album',\n    DATE: 'date',\n    ORIGINALDATE: 'originaldate',\n    ORIGINALYEAR: 'originalyear',\n    COMMENT: 'comment',\n    TRACKNUMBER: 'track',\n    DISCNUMBER: 'disk',\n    GENRE: 'genre',\n    METADATA_BLOCK_PICTURE: 'picture',\n    COMPOSER: 'composer',\n    LYRICS: 'lyrics',\n    ALBUMSORT: 'albumsort',\n    TITLESORT: 'titlesort',\n    WORK: 'work',\n    ARTISTSORT: 'artistsort',\n    ALBUMARTISTSORT: 'albumartistsort',\n    COMPOSERSORT: 'composersort',\n    LYRICIST: 'lyricist',\n    WRITER: 'writer',\n    CONDUCTOR: 'conductor',\n    // 'PERFORMER=artist (instrument)': 'performer:instrument', // ToDo\n    REMIXER: 'remixer',\n    ARRANGER: 'arranger',\n    ENGINEER: 'engineer',\n    PRODUCER: 'producer',\n    DJMIXER: 'djmixer',\n    MIXER: 'mixer',\n    LABEL: 'label',\n    GROUPING: 'grouping',\n    SUBTITLE: 'subtitle',\n    DISCSUBTITLE: 'discsubtitle',\n    TRACKTOTAL: 'totaltracks',\n    DISCTOTAL: 'totaldiscs',\n    COMPILATION: 'compilation',\n    RATING: 'rating',\n    BPM: 'bpm',\n    KEY: 'key',\n    MOOD: 'mood',\n    MEDIA: 'media',\n    CATALOGNUMBER: 'catalognumber',\n    RELEASESTATUS: 'releasestatus',\n    RELEASETYPE: 'releasetype',\n    RELEASECOUNTRY: 'releasecountry',\n    SCRIPT: 'script',\n    LANGUAGE: 'language',\n    COPYRIGHT: 'copyright',\n    LICENSE: 'license',\n    ENCODEDBY: 'encodedby',\n    ENCODERSETTINGS: 'encodersettings',\n    BARCODE: 'barcode',\n    ISRC: 'isrc',\n    ASIN: 'asin',\n    MUSICBRAINZ_TRACKID: 'musicbrainz_recordingid',\n    MUSICBRAINZ_RELEASETRACKID: 'musicbrainz_trackid',\n    MUSICBRAINZ_ALBUMID: 'musicbrainz_albumid',\n    MUSICBRAINZ_ARTISTID: 'musicbrainz_artistid',\n    MUSICBRAINZ_ALBUMARTISTID: 'musicbrainz_albumartistid',\n    MUSICBRAINZ_RELEASEGROUPID: 'musicbrainz_releasegroupid',\n    MUSICBRAINZ_WORKID: 'musicbrainz_workid',\n    MUSICBRAINZ_TRMID: 'musicbrainz_trmid',\n    MUSICBRAINZ_DISCID: 'musicbrainz_discid',\n    ACOUSTID_ID: 'acoustid_id',\n    ACOUSTID_ID_FINGERPRINT: 'acoustid_fingerprint',\n    MUSICIP_PUID: 'musicip_puid',\n    // 'FINGERPRINT=MusicMagic Fingerprint {fingerprint}': 'musicip_fingerprint', // ToDo\n    WEBSITE: 'website',\n    NOTES: 'notes',\n    TOTALTRACKS: 'totaltracks',\n    TOTALDISCS: 'totaldiscs',\n    // Discogs\n    DISCOGS_ARTIST_ID: 'discogs_artist_id',\n    DISCOGS_ARTISTS: 'artists',\n    DISCOGS_ARTIST_NAME: 'artists',\n    DISCOGS_ALBUM_ARTISTS: 'albumartist',\n    DISCOGS_CATALOG: 'catalognumber',\n    DISCOGS_COUNTRY: 'releasecountry',\n    DISCOGS_DATE: 'originaldate',\n    DISCOGS_LABEL: 'label',\n    DISCOGS_LABEL_ID: 'discogs_label_id',\n    DISCOGS_MASTER_RELEASE_ID: 'discogs_master_release_id',\n    DISCOGS_RATING: 'discogs_rating',\n    DISCOGS_RELEASED: 'date',\n    DISCOGS_RELEASE_ID: 'discogs_release_id',\n    DISCOGS_VOTES: 'discogs_votes',\n    CATALOGID: 'catalognumber',\n    STYLE: 'genre',\n    //\n    REPLAYGAIN_TRACK_GAIN: 'replaygain_track_gain',\n    REPLAYGAIN_TRACK_PEAK: 'replaygain_track_peak',\n    REPLAYGAIN_ALBUM_GAIN: 'replaygain_album_gain',\n    REPLAYGAIN_ALBUM_PEAK: 'replaygain_album_peak',\n    // To Sure if these (REPLAYGAIN_MINMAX, REPLAYGAIN_ALBUM_MINMAX & REPLAYGAIN_UNDO) are used for Vorbis:\n    REPLAYGAIN_MINMAX: 'replaygain_track_minmax',\n    REPLAYGAIN_ALBUM_MINMAX: 'replaygain_album_minmax',\n    REPLAYGAIN_UNDO: 'replaygain_undo'\n};\nclass VorbisTagMapper extends GenericTagMapper_1.CommonTagMapper {\n    static toRating(email, rating, maxScore) {\n        return {\n            source: email ? email.toLowerCase() : email,\n            rating: (parseFloat(rating) / maxScore) * GenericTagMapper_1.CommonTagMapper.maxRatingScore\n        };\n    }\n    constructor() {\n        super(['vorbis'], vorbisTagMap);\n    }\n    postMap(tag) {\n        if (tag.id === 'RATING') {\n            // The way Winamp 5.666 assigns rating\n            tag.value = VorbisTagMapper.toRating(undefined, tag.value, 100);\n        }\n        else if (tag.id.indexOf('RATING:') === 0) {\n            const keys = tag.id.split(':');\n            tag.value = VorbisTagMapper.toRating(keys[1], tag.value, 1);\n            tag.id = keys[0];\n        }\n    }\n}\nexports.VorbisTagMapper = VorbisTagMapper;\n//# sourceMappingURL=VorbisTagMapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvb2dnL3ZvcmJpcy9Wb3JiaXNUYWdNYXBwZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLDJCQUEyQixtQkFBTyxDQUFDLHVIQUErQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL29nZy92b3JiaXMvVm9yYmlzVGFnTWFwcGVyLmpzPzg4OTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZvcmJpc1RhZ01hcHBlciA9IHZvaWQgMDtcbmNvbnN0IEdlbmVyaWNUYWdNYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vR2VuZXJpY1RhZ01hcHBlclwiKTtcbi8qKlxuICogVm9yYmlzIHRhZyBtYXBwaW5nc1xuICpcbiAqIE1hcHBpbmcgZnJvbSBuYXRpdmUgaGVhZGVyIGZvcm1hdCB0byBvbmUgb3IgcG9zc2libHkgbW9yZSAnY29tbW9uJyBlbnRyaWVzXG4gKiBUaGUgY29tbW9uIGVudHJpZXMgYWltIHRvIHJlYWQgdGhlIHNhbWUgaW5mb3JtYXRpb24gZnJvbSBkaWZmZXJlbnQgbWVkaWEgZmlsZXNcbiAqIGluZGVwZW5kZW50IG9mIHRoZSB1bmRlcmx5aW5nIGZvcm1hdFxuICovXG5jb25zdCB2b3JiaXNUYWdNYXAgPSB7XG4gICAgVElUTEU6ICd0aXRsZScsXG4gICAgQVJUSVNUOiAnYXJ0aXN0JyxcbiAgICBBUlRJU1RTOiAnYXJ0aXN0cycsXG4gICAgQUxCVU1BUlRJU1Q6ICdhbGJ1bWFydGlzdCcsXG4gICAgJ0FMQlVNIEFSVElTVCc6ICdhbGJ1bWFydGlzdCcsXG4gICAgQUxCVU06ICdhbGJ1bScsXG4gICAgREFURTogJ2RhdGUnLFxuICAgIE9SSUdJTkFMREFURTogJ29yaWdpbmFsZGF0ZScsXG4gICAgT1JJR0lOQUxZRUFSOiAnb3JpZ2luYWx5ZWFyJyxcbiAgICBDT01NRU5UOiAnY29tbWVudCcsXG4gICAgVFJBQ0tOVU1CRVI6ICd0cmFjaycsXG4gICAgRElTQ05VTUJFUjogJ2Rpc2snLFxuICAgIEdFTlJFOiAnZ2VucmUnLFxuICAgIE1FVEFEQVRBX0JMT0NLX1BJQ1RVUkU6ICdwaWN0dXJlJyxcbiAgICBDT01QT1NFUjogJ2NvbXBvc2VyJyxcbiAgICBMWVJJQ1M6ICdseXJpY3MnLFxuICAgIEFMQlVNU09SVDogJ2FsYnVtc29ydCcsXG4gICAgVElUTEVTT1JUOiAndGl0bGVzb3J0JyxcbiAgICBXT1JLOiAnd29yaycsXG4gICAgQVJUSVNUU09SVDogJ2FydGlzdHNvcnQnLFxuICAgIEFMQlVNQVJUSVNUU09SVDogJ2FsYnVtYXJ0aXN0c29ydCcsXG4gICAgQ09NUE9TRVJTT1JUOiAnY29tcG9zZXJzb3J0JyxcbiAgICBMWVJJQ0lTVDogJ2x5cmljaXN0JyxcbiAgICBXUklURVI6ICd3cml0ZXInLFxuICAgIENPTkRVQ1RPUjogJ2NvbmR1Y3RvcicsXG4gICAgLy8gJ1BFUkZPUk1FUj1hcnRpc3TCoChpbnN0cnVtZW50KSc6ICdwZXJmb3JtZXI6aW5zdHJ1bWVudCcsIC8vIFRvRG9cbiAgICBSRU1JWEVSOiAncmVtaXhlcicsXG4gICAgQVJSQU5HRVI6ICdhcnJhbmdlcicsXG4gICAgRU5HSU5FRVI6ICdlbmdpbmVlcicsXG4gICAgUFJPRFVDRVI6ICdwcm9kdWNlcicsXG4gICAgREpNSVhFUjogJ2RqbWl4ZXInLFxuICAgIE1JWEVSOiAnbWl4ZXInLFxuICAgIExBQkVMOiAnbGFiZWwnLFxuICAgIEdST1VQSU5HOiAnZ3JvdXBpbmcnLFxuICAgIFNVQlRJVExFOiAnc3VidGl0bGUnLFxuICAgIERJU0NTVUJUSVRMRTogJ2Rpc2NzdWJ0aXRsZScsXG4gICAgVFJBQ0tUT1RBTDogJ3RvdGFsdHJhY2tzJyxcbiAgICBESVNDVE9UQUw6ICd0b3RhbGRpc2NzJyxcbiAgICBDT01QSUxBVElPTjogJ2NvbXBpbGF0aW9uJyxcbiAgICBSQVRJTkc6ICdyYXRpbmcnLFxuICAgIEJQTTogJ2JwbScsXG4gICAgS0VZOiAna2V5JyxcbiAgICBNT09EOiAnbW9vZCcsXG4gICAgTUVESUE6ICdtZWRpYScsXG4gICAgQ0FUQUxPR05VTUJFUjogJ2NhdGFsb2dudW1iZXInLFxuICAgIFJFTEVBU0VTVEFUVVM6ICdyZWxlYXNlc3RhdHVzJyxcbiAgICBSRUxFQVNFVFlQRTogJ3JlbGVhc2V0eXBlJyxcbiAgICBSRUxFQVNFQ09VTlRSWTogJ3JlbGVhc2Vjb3VudHJ5JyxcbiAgICBTQ1JJUFQ6ICdzY3JpcHQnLFxuICAgIExBTkdVQUdFOiAnbGFuZ3VhZ2UnLFxuICAgIENPUFlSSUdIVDogJ2NvcHlyaWdodCcsXG4gICAgTElDRU5TRTogJ2xpY2Vuc2UnLFxuICAgIEVOQ09ERURCWTogJ2VuY29kZWRieScsXG4gICAgRU5DT0RFUlNFVFRJTkdTOiAnZW5jb2RlcnNldHRpbmdzJyxcbiAgICBCQVJDT0RFOiAnYmFyY29kZScsXG4gICAgSVNSQzogJ2lzcmMnLFxuICAgIEFTSU46ICdhc2luJyxcbiAgICBNVVNJQ0JSQUlOWl9UUkFDS0lEOiAnbXVzaWNicmFpbnpfcmVjb3JkaW5naWQnLFxuICAgIE1VU0lDQlJBSU5aX1JFTEVBU0VUUkFDS0lEOiAnbXVzaWNicmFpbnpfdHJhY2tpZCcsXG4gICAgTVVTSUNCUkFJTlpfQUxCVU1JRDogJ211c2ljYnJhaW56X2FsYnVtaWQnLFxuICAgIE1VU0lDQlJBSU5aX0FSVElTVElEOiAnbXVzaWNicmFpbnpfYXJ0aXN0aWQnLFxuICAgIE1VU0lDQlJBSU5aX0FMQlVNQVJUSVNUSUQ6ICdtdXNpY2JyYWluel9hbGJ1bWFydGlzdGlkJyxcbiAgICBNVVNJQ0JSQUlOWl9SRUxFQVNFR1JPVVBJRDogJ211c2ljYnJhaW56X3JlbGVhc2Vncm91cGlkJyxcbiAgICBNVVNJQ0JSQUlOWl9XT1JLSUQ6ICdtdXNpY2JyYWluel93b3JraWQnLFxuICAgIE1VU0lDQlJBSU5aX1RSTUlEOiAnbXVzaWNicmFpbnpfdHJtaWQnLFxuICAgIE1VU0lDQlJBSU5aX0RJU0NJRDogJ211c2ljYnJhaW56X2Rpc2NpZCcsXG4gICAgQUNPVVNUSURfSUQ6ICdhY291c3RpZF9pZCcsXG4gICAgQUNPVVNUSURfSURfRklOR0VSUFJJTlQ6ICdhY291c3RpZF9maW5nZXJwcmludCcsXG4gICAgTVVTSUNJUF9QVUlEOiAnbXVzaWNpcF9wdWlkJyxcbiAgICAvLyAnRklOR0VSUFJJTlQ9TXVzaWNNYWdpYyBGaW5nZXJwcmludMKge2ZpbmdlcnByaW50fSc6ICdtdXNpY2lwX2ZpbmdlcnByaW50JywgLy8gVG9Eb1xuICAgIFdFQlNJVEU6ICd3ZWJzaXRlJyxcbiAgICBOT1RFUzogJ25vdGVzJyxcbiAgICBUT1RBTFRSQUNLUzogJ3RvdGFsdHJhY2tzJyxcbiAgICBUT1RBTERJU0NTOiAndG90YWxkaXNjcycsXG4gICAgLy8gRGlzY29nc1xuICAgIERJU0NPR1NfQVJUSVNUX0lEOiAnZGlzY29nc19hcnRpc3RfaWQnLFxuICAgIERJU0NPR1NfQVJUSVNUUzogJ2FydGlzdHMnLFxuICAgIERJU0NPR1NfQVJUSVNUX05BTUU6ICdhcnRpc3RzJyxcbiAgICBESVNDT0dTX0FMQlVNX0FSVElTVFM6ICdhbGJ1bWFydGlzdCcsXG4gICAgRElTQ09HU19DQVRBTE9HOiAnY2F0YWxvZ251bWJlcicsXG4gICAgRElTQ09HU19DT1VOVFJZOiAncmVsZWFzZWNvdW50cnknLFxuICAgIERJU0NPR1NfREFURTogJ29yaWdpbmFsZGF0ZScsXG4gICAgRElTQ09HU19MQUJFTDogJ2xhYmVsJyxcbiAgICBESVNDT0dTX0xBQkVMX0lEOiAnZGlzY29nc19sYWJlbF9pZCcsXG4gICAgRElTQ09HU19NQVNURVJfUkVMRUFTRV9JRDogJ2Rpc2NvZ3NfbWFzdGVyX3JlbGVhc2VfaWQnLFxuICAgIERJU0NPR1NfUkFUSU5HOiAnZGlzY29nc19yYXRpbmcnLFxuICAgIERJU0NPR1NfUkVMRUFTRUQ6ICdkYXRlJyxcbiAgICBESVNDT0dTX1JFTEVBU0VfSUQ6ICdkaXNjb2dzX3JlbGVhc2VfaWQnLFxuICAgIERJU0NPR1NfVk9URVM6ICdkaXNjb2dzX3ZvdGVzJyxcbiAgICBDQVRBTE9HSUQ6ICdjYXRhbG9nbnVtYmVyJyxcbiAgICBTVFlMRTogJ2dlbnJlJyxcbiAgICAvL1xuICAgIFJFUExBWUdBSU5fVFJBQ0tfR0FJTjogJ3JlcGxheWdhaW5fdHJhY2tfZ2FpbicsXG4gICAgUkVQTEFZR0FJTl9UUkFDS19QRUFLOiAncmVwbGF5Z2Fpbl90cmFja19wZWFrJyxcbiAgICBSRVBMQVlHQUlOX0FMQlVNX0dBSU46ICdyZXBsYXlnYWluX2FsYnVtX2dhaW4nLFxuICAgIFJFUExBWUdBSU5fQUxCVU1fUEVBSzogJ3JlcGxheWdhaW5fYWxidW1fcGVhaycsXG4gICAgLy8gVG8gU3VyZSBpZiB0aGVzZSAoUkVQTEFZR0FJTl9NSU5NQVgsIFJFUExBWUdBSU5fQUxCVU1fTUlOTUFYICYgUkVQTEFZR0FJTl9VTkRPKSBhcmUgdXNlZCBmb3IgVm9yYmlzOlxuICAgIFJFUExBWUdBSU5fTUlOTUFYOiAncmVwbGF5Z2Fpbl90cmFja19taW5tYXgnLFxuICAgIFJFUExBWUdBSU5fQUxCVU1fTUlOTUFYOiAncmVwbGF5Z2Fpbl9hbGJ1bV9taW5tYXgnLFxuICAgIFJFUExBWUdBSU5fVU5ETzogJ3JlcGxheWdhaW5fdW5kbydcbn07XG5jbGFzcyBWb3JiaXNUYWdNYXBwZXIgZXh0ZW5kcyBHZW5lcmljVGFnTWFwcGVyXzEuQ29tbW9uVGFnTWFwcGVyIHtcbiAgICBzdGF0aWMgdG9SYXRpbmcoZW1haWwsIHJhdGluZywgbWF4U2NvcmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZTogZW1haWwgPyBlbWFpbC50b0xvd2VyQ2FzZSgpIDogZW1haWwsXG4gICAgICAgICAgICByYXRpbmc6IChwYXJzZUZsb2F0KHJhdGluZykgLyBtYXhTY29yZSkgKiBHZW5lcmljVGFnTWFwcGVyXzEuQ29tbW9uVGFnTWFwcGVyLm1heFJhdGluZ1Njb3JlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihbJ3ZvcmJpcyddLCB2b3JiaXNUYWdNYXApO1xuICAgIH1cbiAgICBwb3N0TWFwKHRhZykge1xuICAgICAgICBpZiAodGFnLmlkID09PSAnUkFUSU5HJykge1xuICAgICAgICAgICAgLy8gVGhlIHdheSBXaW5hbXAgNS42NjYgYXNzaWducyByYXRpbmdcbiAgICAgICAgICAgIHRhZy52YWx1ZSA9IFZvcmJpc1RhZ01hcHBlci50b1JhdGluZyh1bmRlZmluZWQsIHRhZy52YWx1ZSwgMTAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YWcuaWQuaW5kZXhPZignUkFUSU5HOicpID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gdGFnLmlkLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICB0YWcudmFsdWUgPSBWb3JiaXNUYWdNYXBwZXIudG9SYXRpbmcoa2V5c1sxXSwgdGFnLnZhbHVlLCAxKTtcbiAgICAgICAgICAgIHRhZy5pZCA9IGtleXNbMF07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlZvcmJpc1RhZ01hcHBlciA9IFZvcmJpc1RhZ01hcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZvcmJpc1RhZ01hcHBlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/ogg/vorbis/VorbisTagMapper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/riff/RiffChunk.js":
/*!***********************************************************!*\
  !*** ./node_modules/music-metadata/lib/riff/RiffChunk.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ListInfoTagValue = exports.Header = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\n/**\n * Common RIFF chunk header\n */\nexports.Header = {\n    len: 8,\n    get: (buf, off) => {\n        return {\n            // Group-ID\n            chunkID: buf.toString('binary', off, off + 4),\n            // Size\n            chunkSize: Token.UINT32_LE.get(buf, 4)\n        };\n    }\n};\n/**\n * Token to parse RIFF-INFO tag value\n */\nclass ListInfoTagValue {\n    constructor(tagHeader) {\n        this.tagHeader = tagHeader;\n        this.len = tagHeader.chunkSize;\n        this.len += this.len & 1; // if it is an odd length, round up to even\n    }\n    get(buf, off) {\n        return new Token.StringType(this.tagHeader.chunkSize, 'ascii').get(buf, off);\n    }\n}\nexports.ListInfoTagValue = ListInfoTagValue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvcmlmZi9SaWZmQ2h1bmsuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsY0FBYztBQUN6QyxjQUFjLG1CQUFPLENBQUMsZ0ZBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL3JpZmYvUmlmZkNodW5rLmpzPzBmZGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpc3RJbmZvVGFnVmFsdWUgPSBleHBvcnRzLkhlYWRlciA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuLyoqXG4gKiBDb21tb24gUklGRiBjaHVuayBoZWFkZXJcbiAqL1xuZXhwb3J0cy5IZWFkZXIgPSB7XG4gICAgbGVuOiA4LFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBHcm91cC1JRFxuICAgICAgICAgICAgY2h1bmtJRDogYnVmLnRvU3RyaW5nKCdiaW5hcnknLCBvZmYsIG9mZiArIDQpLFxuICAgICAgICAgICAgLy8gU2l6ZVxuICAgICAgICAgICAgY2h1bmtTaXplOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1ZiwgNClcbiAgICAgICAgfTtcbiAgICB9XG59O1xuLyoqXG4gKiBUb2tlbiB0byBwYXJzZSBSSUZGLUlORk8gdGFnIHZhbHVlXG4gKi9cbmNsYXNzIExpc3RJbmZvVGFnVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHRhZ0hlYWRlcikge1xuICAgICAgICB0aGlzLnRhZ0hlYWRlciA9IHRhZ0hlYWRlcjtcbiAgICAgICAgdGhpcy5sZW4gPSB0YWdIZWFkZXIuY2h1bmtTaXplO1xuICAgICAgICB0aGlzLmxlbiArPSB0aGlzLmxlbiAmIDE7IC8vIGlmIGl0IGlzIGFuIG9kZCBsZW5ndGgsIHJvdW5kIHVwIHRvIGV2ZW5cbiAgICB9XG4gICAgZ2V0KGJ1Ziwgb2ZmKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW4uU3RyaW5nVHlwZSh0aGlzLnRhZ0hlYWRlci5jaHVua1NpemUsICdhc2NpaScpLmdldChidWYsIG9mZik7XG4gICAgfVxufVxuZXhwb3J0cy5MaXN0SW5mb1RhZ1ZhbHVlID0gTGlzdEluZm9UYWdWYWx1ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/riff/RiffChunk.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/riff/RiffInfoTagMap.js":
/*!****************************************************************!*\
  !*** ./node_modules/music-metadata/lib/riff/RiffInfoTagMap.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RiffInfoTagMapper = exports.riffInfoTagMap = void 0;\nconst GenericTagMapper_1 = __webpack_require__(/*! ../common/GenericTagMapper */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/GenericTagMapper.js\");\n/**\n * RIFF Info Tags; part of the EXIF 2.3\n * Ref: http://owl.phy.queensu.ca/~phil/exiftool/TagNames/RIFF.html#Info\n */\nexports.riffInfoTagMap = {\n    IART: 'artist',\n    ICRD: 'date',\n    INAM: 'title',\n    TITL: 'title',\n    IPRD: 'album',\n    ITRK: 'track',\n    IPRT: 'track',\n    COMM: 'comment',\n    ICMT: 'comment',\n    ICNT: 'releasecountry',\n    GNRE: 'genre',\n    IWRI: 'writer',\n    RATE: 'rating',\n    YEAR: 'year',\n    ISFT: 'encodedby',\n    CODE: 'encodedby',\n    TURL: 'website',\n    IGNR: 'genre',\n    IENG: 'engineer',\n    ITCH: 'technician',\n    IMED: 'media',\n    IRPD: 'album' // Product, where the file was intended for\n};\nclass RiffInfoTagMapper extends GenericTagMapper_1.CommonTagMapper {\n    constructor() {\n        super(['exif'], exports.riffInfoTagMap);\n    }\n}\nexports.RiffInfoTagMapper = RiffInfoTagMapper;\n//# sourceMappingURL=RiffInfoTagMap.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvcmlmZi9SaWZmSW5mb1RhZ01hcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxzQkFBc0I7QUFDbEQsMkJBQTJCLG1CQUFPLENBQUMsb0hBQTRCO0FBQy9EO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi9yaWZmL1JpZmZJbmZvVGFnTWFwLmpzP2Q0YTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJpZmZJbmZvVGFnTWFwcGVyID0gZXhwb3J0cy5yaWZmSW5mb1RhZ01hcCA9IHZvaWQgMDtcbmNvbnN0IEdlbmVyaWNUYWdNYXBwZXJfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vR2VuZXJpY1RhZ01hcHBlclwiKTtcbi8qKlxuICogUklGRiBJbmZvIFRhZ3M7IHBhcnQgb2YgdGhlIEVYSUYgMi4zXG4gKiBSZWY6IGh0dHA6Ly9vd2wucGh5LnF1ZWVuc3UuY2EvfnBoaWwvZXhpZnRvb2wvVGFnTmFtZXMvUklGRi5odG1sI0luZm9cbiAqL1xuZXhwb3J0cy5yaWZmSW5mb1RhZ01hcCA9IHtcbiAgICBJQVJUOiAnYXJ0aXN0JyxcbiAgICBJQ1JEOiAnZGF0ZScsXG4gICAgSU5BTTogJ3RpdGxlJyxcbiAgICBUSVRMOiAndGl0bGUnLFxuICAgIElQUkQ6ICdhbGJ1bScsXG4gICAgSVRSSzogJ3RyYWNrJyxcbiAgICBJUFJUOiAndHJhY2snLFxuICAgIENPTU06ICdjb21tZW50JyxcbiAgICBJQ01UOiAnY29tbWVudCcsXG4gICAgSUNOVDogJ3JlbGVhc2Vjb3VudHJ5JyxcbiAgICBHTlJFOiAnZ2VucmUnLFxuICAgIElXUkk6ICd3cml0ZXInLFxuICAgIFJBVEU6ICdyYXRpbmcnLFxuICAgIFlFQVI6ICd5ZWFyJyxcbiAgICBJU0ZUOiAnZW5jb2RlZGJ5JyxcbiAgICBDT0RFOiAnZW5jb2RlZGJ5JyxcbiAgICBUVVJMOiAnd2Vic2l0ZScsXG4gICAgSUdOUjogJ2dlbnJlJyxcbiAgICBJRU5HOiAnZW5naW5lZXInLFxuICAgIElUQ0g6ICd0ZWNobmljaWFuJyxcbiAgICBJTUVEOiAnbWVkaWEnLFxuICAgIElSUEQ6ICdhbGJ1bScgLy8gUHJvZHVjdCwgd2hlcmUgdGhlIGZpbGUgd2FzIGludGVuZGVkIGZvclxufTtcbmNsYXNzIFJpZmZJbmZvVGFnTWFwcGVyIGV4dGVuZHMgR2VuZXJpY1RhZ01hcHBlcl8xLkNvbW1vblRhZ01hcHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFsnZXhpZiddLCBleHBvcnRzLnJpZmZJbmZvVGFnTWFwKTtcbiAgICB9XG59XG5leHBvcnRzLlJpZmZJbmZvVGFnTWFwcGVyID0gUmlmZkluZm9UYWdNYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SaWZmSW5mb1RhZ01hcC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/riff/RiffInfoTagMap.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/type.js":
/*!*************************************************!*\
  !*** ./node_modules/music-metadata/lib/type.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TrackType = void 0;\nvar types_1 = __webpack_require__(/*! ./matroska/types */ \"(app-pages-browser)/./node_modules/music-metadata/lib/matroska/types.js\");\nObject.defineProperty(exports, \"TrackType\", ({ enumerable: true, get: function () { return types_1.TrackType; } }));\n//# sourceMappingURL=type.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsY0FBYyxtQkFBTyxDQUFDLGlHQUFrQjtBQUN4Qyw2Q0FBNEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDakgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi90eXBlLmpzPzJhNWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYWNrVHlwZSA9IHZvaWQgMDtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vbWF0cm9za2EvdHlwZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFja1R5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzEuVHJhY2tUeXBlOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/type.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/wav/BwfChunk.js":
/*!*********************************************************!*\
  !*** ./node_modules/music-metadata/lib/wav/BwfChunk.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BroadcastAudioExtensionChunk = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst Util_1 = __webpack_require__(/*! ../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\n/**\n * Broadcast Audio Extension Chunk\n * Ref: https://tech.ebu.ch/docs/tech/tech3285.pdf\n */\nexports.BroadcastAudioExtensionChunk = {\n    len: 420,\n    get: (uint8array, off) => {\n        return {\n            description: (0, Util_1.stripNulls)(new Token.StringType(256, 'ascii').get(uint8array, off)).trim(),\n            originator: (0, Util_1.stripNulls)(new Token.StringType(32, 'ascii').get(uint8array, off + 256)).trim(),\n            originatorReference: (0, Util_1.stripNulls)(new Token.StringType(32, 'ascii').get(uint8array, off + 288)).trim(),\n            originationDate: (0, Util_1.stripNulls)(new Token.StringType(10, 'ascii').get(uint8array, off + 320)).trim(),\n            originationTime: (0, Util_1.stripNulls)(new Token.StringType(8, 'ascii').get(uint8array, off + 330)).trim(),\n            timeReferenceLow: Token.UINT32_LE.get(uint8array, off + 338),\n            timeReferenceHigh: Token.UINT32_LE.get(uint8array, off + 342),\n            version: Token.UINT16_LE.get(uint8array, off + 346),\n            umid: new Token.Uint8ArrayType(64).get(uint8array, off + 348),\n            loudnessValue: Token.UINT16_LE.get(uint8array, off + 412),\n            maxTruePeakLevel: Token.UINT16_LE.get(uint8array, off + 414),\n            maxMomentaryLoudness: Token.UINT16_LE.get(uint8array, off + 416),\n            maxShortTermLoudness: Token.UINT16_LE.get(uint8array, off + 418)\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvd2F2L0J3ZkNodW5rLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9DQUFvQztBQUNwQyxjQUFjLG1CQUFPLENBQUMsZ0ZBQWE7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLDRGQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL3dhdi9Cd2ZDaHVuay5qcz9hOTUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ccm9hZGNhc3RBdWRpb0V4dGVuc2lvbkNodW5rID0gdm9pZCAwO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBVdGlsXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL1V0aWxcIik7XG4vKipcbiAqIEJyb2FkY2FzdCBBdWRpbyBFeHRlbnNpb24gQ2h1bmtcbiAqIFJlZjogaHR0cHM6Ly90ZWNoLmVidS5jaC9kb2NzL3RlY2gvdGVjaDMyODUucGRmXG4gKi9cbmV4cG9ydHMuQnJvYWRjYXN0QXVkaW9FeHRlbnNpb25DaHVuayA9IHtcbiAgICBsZW46IDQyMCxcbiAgICBnZXQ6ICh1aW50OGFycmF5LCBvZmYpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAoMCwgVXRpbF8xLnN0cmlwTnVsbHMpKG5ldyBUb2tlbi5TdHJpbmdUeXBlKDI1NiwgJ2FzY2lpJykuZ2V0KHVpbnQ4YXJyYXksIG9mZikpLnRyaW0oKSxcbiAgICAgICAgICAgIG9yaWdpbmF0b3I6ICgwLCBVdGlsXzEuc3RyaXBOdWxscykobmV3IFRva2VuLlN0cmluZ1R5cGUoMzIsICdhc2NpaScpLmdldCh1aW50OGFycmF5LCBvZmYgKyAyNTYpKS50cmltKCksXG4gICAgICAgICAgICBvcmlnaW5hdG9yUmVmZXJlbmNlOiAoMCwgVXRpbF8xLnN0cmlwTnVsbHMpKG5ldyBUb2tlbi5TdHJpbmdUeXBlKDMyLCAnYXNjaWknKS5nZXQodWludDhhcnJheSwgb2ZmICsgMjg4KSkudHJpbSgpLFxuICAgICAgICAgICAgb3JpZ2luYXRpb25EYXRlOiAoMCwgVXRpbF8xLnN0cmlwTnVsbHMpKG5ldyBUb2tlbi5TdHJpbmdUeXBlKDEwLCAnYXNjaWknKS5nZXQodWludDhhcnJheSwgb2ZmICsgMzIwKSkudHJpbSgpLFxuICAgICAgICAgICAgb3JpZ2luYXRpb25UaW1lOiAoMCwgVXRpbF8xLnN0cmlwTnVsbHMpKG5ldyBUb2tlbi5TdHJpbmdUeXBlKDgsICdhc2NpaScpLmdldCh1aW50OGFycmF5LCBvZmYgKyAzMzApKS50cmltKCksXG4gICAgICAgICAgICB0aW1lUmVmZXJlbmNlTG93OiBUb2tlbi5VSU5UMzJfTEUuZ2V0KHVpbnQ4YXJyYXksIG9mZiArIDMzOCksXG4gICAgICAgICAgICB0aW1lUmVmZXJlbmNlSGlnaDogVG9rZW4uVUlOVDMyX0xFLmdldCh1aW50OGFycmF5LCBvZmYgKyAzNDIpLFxuICAgICAgICAgICAgdmVyc2lvbjogVG9rZW4uVUlOVDE2X0xFLmdldCh1aW50OGFycmF5LCBvZmYgKyAzNDYpLFxuICAgICAgICAgICAgdW1pZDogbmV3IFRva2VuLlVpbnQ4QXJyYXlUeXBlKDY0KS5nZXQodWludDhhcnJheSwgb2ZmICsgMzQ4KSxcbiAgICAgICAgICAgIGxvdWRuZXNzVmFsdWU6IFRva2VuLlVJTlQxNl9MRS5nZXQodWludDhhcnJheSwgb2ZmICsgNDEyKSxcbiAgICAgICAgICAgIG1heFRydWVQZWFrTGV2ZWw6IFRva2VuLlVJTlQxNl9MRS5nZXQodWludDhhcnJheSwgb2ZmICsgNDE0KSxcbiAgICAgICAgICAgIG1heE1vbWVudGFyeUxvdWRuZXNzOiBUb2tlbi5VSU5UMTZfTEUuZ2V0KHVpbnQ4YXJyYXksIG9mZiArIDQxNiksXG4gICAgICAgICAgICBtYXhTaG9ydFRlcm1Mb3VkbmVzczogVG9rZW4uVUlOVDE2X0xFLmdldCh1aW50OGFycmF5LCBvZmYgKyA0MTgpXG4gICAgICAgIH07XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/wav/BwfChunk.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/wav/WaveChunk.js":
/*!**********************************************************!*\
  !*** ./node_modules/music-metadata/lib/wav/WaveChunk.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FactChunk = exports.Format = exports.WaveFormat = void 0;\n/**\n * Ref: https://msdn.microsoft.com/en-us/library/windows/desktop/dd317599(v=vs.85).aspx\n */\nvar WaveFormat;\n(function (WaveFormat) {\n    WaveFormat[WaveFormat[\"PCM\"] = 1] = \"PCM\";\n    // MPEG-4 and AAC Audio Types\n    WaveFormat[WaveFormat[\"ADPCM\"] = 2] = \"ADPCM\";\n    WaveFormat[WaveFormat[\"IEEE_FLOAT\"] = 3] = \"IEEE_FLOAT\";\n    WaveFormat[WaveFormat[\"MPEG_ADTS_AAC\"] = 5632] = \"MPEG_ADTS_AAC\";\n    WaveFormat[WaveFormat[\"MPEG_LOAS\"] = 5634] = \"MPEG_LOAS\";\n    WaveFormat[WaveFormat[\"RAW_AAC1\"] = 255] = \"RAW_AAC1\";\n    // Dolby Audio Types\n    WaveFormat[WaveFormat[\"DOLBY_AC3_SPDIF\"] = 146] = \"DOLBY_AC3_SPDIF\";\n    WaveFormat[WaveFormat[\"DVM\"] = 8192] = \"DVM\";\n    WaveFormat[WaveFormat[\"RAW_SPORT\"] = 576] = \"RAW_SPORT\";\n    WaveFormat[WaveFormat[\"ESST_AC3\"] = 577] = \"ESST_AC3\";\n    WaveFormat[WaveFormat[\"DRM\"] = 9] = \"DRM\";\n    WaveFormat[WaveFormat[\"DTS2\"] = 8193] = \"DTS2\";\n    WaveFormat[WaveFormat[\"MPEG\"] = 80] = \"MPEG\";\n})(WaveFormat = exports.WaveFormat || (exports.WaveFormat = {}));\n/**\n * format chunk; chunk-id is \"fmt \"\n * http://soundfile.sapp.org/doc/WaveFormat/\n */\nclass Format {\n    constructor(header) {\n        if (header.chunkSize < 16)\n            throw new Error('Invalid chunk size');\n        this.len = header.chunkSize;\n    }\n    get(buf, off) {\n        return {\n            wFormatTag: buf.readUInt16LE(off),\n            nChannels: buf.readUInt16LE(off + 2),\n            nSamplesPerSec: buf.readUInt32LE(off + 4),\n            nAvgBytesPerSec: buf.readUInt32LE(off + 8),\n            nBlockAlign: buf.readUInt16LE(off + 12),\n            wBitsPerSample: buf.readUInt16LE(off + 14)\n        };\n    }\n}\nexports.Format = Format;\n/**\n * Fact chunk; chunk-id is \"fact\"\n * http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html\n * http://www.recordingblogs.com/wiki/fact-chunk-of-a-wave-file\n */\nclass FactChunk {\n    constructor(header) {\n        if (header.chunkSize < 4) {\n            throw new Error('Invalid fact chunk size.');\n        }\n        this.len = header.chunkSize;\n    }\n    get(buf, off) {\n        return {\n            dwSampleLength: buf.readUInt32LE(off)\n        };\n    }\n}\nexports.FactChunk = FactChunk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvd2F2L1dhdmVDaHVuay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxjQUFjLEdBQUcsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQyxrQkFBa0IsS0FBSztBQUM5RDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbGliL3dhdi9XYXZlQ2h1bmsuanM/NGViOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmFjdENodW5rID0gZXhwb3J0cy5Gb3JtYXQgPSBleHBvcnRzLldhdmVGb3JtYXQgPSB2b2lkIDA7XG4vKipcbiAqIFJlZjogaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvZGQzMTc1OTkodj12cy44NSkuYXNweFxuICovXG52YXIgV2F2ZUZvcm1hdDtcbihmdW5jdGlvbiAoV2F2ZUZvcm1hdCkge1xuICAgIFdhdmVGb3JtYXRbV2F2ZUZvcm1hdFtcIlBDTVwiXSA9IDFdID0gXCJQQ01cIjtcbiAgICAvLyBNUEVHLTQgYW5kIEFBQyBBdWRpbyBUeXBlc1xuICAgIFdhdmVGb3JtYXRbV2F2ZUZvcm1hdFtcIkFEUENNXCJdID0gMl0gPSBcIkFEUENNXCI7XG4gICAgV2F2ZUZvcm1hdFtXYXZlRm9ybWF0W1wiSUVFRV9GTE9BVFwiXSA9IDNdID0gXCJJRUVFX0ZMT0FUXCI7XG4gICAgV2F2ZUZvcm1hdFtXYXZlRm9ybWF0W1wiTVBFR19BRFRTX0FBQ1wiXSA9IDU2MzJdID0gXCJNUEVHX0FEVFNfQUFDXCI7XG4gICAgV2F2ZUZvcm1hdFtXYXZlRm9ybWF0W1wiTVBFR19MT0FTXCJdID0gNTYzNF0gPSBcIk1QRUdfTE9BU1wiO1xuICAgIFdhdmVGb3JtYXRbV2F2ZUZvcm1hdFtcIlJBV19BQUMxXCJdID0gMjU1XSA9IFwiUkFXX0FBQzFcIjtcbiAgICAvLyBEb2xieSBBdWRpbyBUeXBlc1xuICAgIFdhdmVGb3JtYXRbV2F2ZUZvcm1hdFtcIkRPTEJZX0FDM19TUERJRlwiXSA9IDE0Nl0gPSBcIkRPTEJZX0FDM19TUERJRlwiO1xuICAgIFdhdmVGb3JtYXRbV2F2ZUZvcm1hdFtcIkRWTVwiXSA9IDgxOTJdID0gXCJEVk1cIjtcbiAgICBXYXZlRm9ybWF0W1dhdmVGb3JtYXRbXCJSQVdfU1BPUlRcIl0gPSA1NzZdID0gXCJSQVdfU1BPUlRcIjtcbiAgICBXYXZlRm9ybWF0W1dhdmVGb3JtYXRbXCJFU1NUX0FDM1wiXSA9IDU3N10gPSBcIkVTU1RfQUMzXCI7XG4gICAgV2F2ZUZvcm1hdFtXYXZlRm9ybWF0W1wiRFJNXCJdID0gOV0gPSBcIkRSTVwiO1xuICAgIFdhdmVGb3JtYXRbV2F2ZUZvcm1hdFtcIkRUUzJcIl0gPSA4MTkzXSA9IFwiRFRTMlwiO1xuICAgIFdhdmVGb3JtYXRbV2F2ZUZvcm1hdFtcIk1QRUdcIl0gPSA4MF0gPSBcIk1QRUdcIjtcbn0pKFdhdmVGb3JtYXQgPSBleHBvcnRzLldhdmVGb3JtYXQgfHwgKGV4cG9ydHMuV2F2ZUZvcm1hdCA9IHt9KSk7XG4vKipcbiAqIGZvcm1hdCBjaHVuazsgY2h1bmstaWQgaXMgXCJmbXQgXCJcbiAqIGh0dHA6Ly9zb3VuZGZpbGUuc2FwcC5vcmcvZG9jL1dhdmVGb3JtYXQvXG4gKi9cbmNsYXNzIEZvcm1hdCB7XG4gICAgY29uc3RydWN0b3IoaGVhZGVyKSB7XG4gICAgICAgIGlmIChoZWFkZXIuY2h1bmtTaXplIDwgMTYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2h1bmsgc2l6ZScpO1xuICAgICAgICB0aGlzLmxlbiA9IGhlYWRlci5jaHVua1NpemU7XG4gICAgfVxuICAgIGdldChidWYsIG9mZikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd0Zvcm1hdFRhZzogYnVmLnJlYWRVSW50MTZMRShvZmYpLFxuICAgICAgICAgICAgbkNoYW5uZWxzOiBidWYucmVhZFVJbnQxNkxFKG9mZiArIDIpLFxuICAgICAgICAgICAgblNhbXBsZXNQZXJTZWM6IGJ1Zi5yZWFkVUludDMyTEUob2ZmICsgNCksXG4gICAgICAgICAgICBuQXZnQnl0ZXNQZXJTZWM6IGJ1Zi5yZWFkVUludDMyTEUob2ZmICsgOCksXG4gICAgICAgICAgICBuQmxvY2tBbGlnbjogYnVmLnJlYWRVSW50MTZMRShvZmYgKyAxMiksXG4gICAgICAgICAgICB3Qml0c1BlclNhbXBsZTogYnVmLnJlYWRVSW50MTZMRShvZmYgKyAxNClcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkZvcm1hdCA9IEZvcm1hdDtcbi8qKlxuICogRmFjdCBjaHVuazsgY2h1bmstaWQgaXMgXCJmYWN0XCJcbiAqIGh0dHA6Ly93d3ctbW1zcC5lY2UubWNnaWxsLmNhL0RvY3VtZW50cy9BdWRpb0Zvcm1hdHMvV0FWRS9XQVZFLmh0bWxcbiAqIGh0dHA6Ly93d3cucmVjb3JkaW5nYmxvZ3MuY29tL3dpa2kvZmFjdC1jaHVuay1vZi1hLXdhdmUtZmlsZVxuICovXG5jbGFzcyBGYWN0Q2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGhlYWRlcikge1xuICAgICAgICBpZiAoaGVhZGVyLmNodW5rU2l6ZSA8IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmYWN0IGNodW5rIHNpemUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW4gPSBoZWFkZXIuY2h1bmtTaXplO1xuICAgIH1cbiAgICBnZXQoYnVmLCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGR3U2FtcGxlTGVuZ3RoOiBidWYucmVhZFVJbnQzMkxFKG9mZilcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkZhY3RDaHVuayA9IEZhY3RDaHVuaztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/wav/WaveChunk.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/wav/WaveParser.js":
/*!***********************************************************!*\
  !*** ./node_modules/music-metadata/lib/wav/WaveParser.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WaveParser = void 0;\nconst strtok3 = __webpack_require__(/*! strtok3/lib/core */ \"(app-pages-browser)/./node_modules/strtok3/lib/core.js\");\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst riff = __webpack_require__(/*! ../riff/RiffChunk */ \"(app-pages-browser)/./node_modules/music-metadata/lib/riff/RiffChunk.js\");\nconst WaveChunk = __webpack_require__(/*! ./../wav/WaveChunk */ \"(app-pages-browser)/./node_modules/music-metadata/lib/wav/WaveChunk.js\");\nconst ID3v2Parser_1 = __webpack_require__(/*! ../id3v2/ID3v2Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js\");\nconst util = __webpack_require__(/*! ../common/Util */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/Util.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/FourCC.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst BwfChunk_1 = __webpack_require__(/*! ../wav/BwfChunk */ \"(app-pages-browser)/./node_modules/music-metadata/lib/wav/BwfChunk.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:RIFF');\n/**\n * Resource Interchange File Format (RIFF) Parser\n *\n * WAVE PCM soundfile format\n *\n * Ref:\n * - http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\n * - http://soundfile.sapp.org/doc/WaveFormat\n *\n * ToDo: Split WAVE part from RIFF parser\n */\nclass WaveParser extends BasicParser_1.BasicParser {\n    async parse() {\n        const riffHeader = await this.tokenizer.readToken(riff.Header);\n        debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);\n        if (riffHeader.chunkID !== 'RIFF')\n            return; // Not RIFF format\n        return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {\n            if (!(err instanceof strtok3.EndOfStreamError)) {\n                throw err;\n            }\n        });\n    }\n    async parseRiffChunk(chunkSize) {\n        const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        this.metadata.setFormat('container', type);\n        switch (type) {\n            case 'WAVE':\n                return this.readWaveChunk(chunkSize - FourCC_1.FourCcToken.len);\n            default:\n                throw new Error(`Unsupported RIFF format: RIFF/${type}`);\n        }\n    }\n    async readWaveChunk(remaining) {\n        while (remaining >= riff.Header.len) {\n            const header = await this.tokenizer.readToken(riff.Header);\n            remaining -= riff.Header.len + header.chunkSize;\n            if (header.chunkSize > remaining) {\n                this.metadata.addWarning('Data chunk size exceeds file size');\n            }\n            this.header = header;\n            debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);\n            switch (header.chunkID) {\n                case 'LIST':\n                    await this.parseListTag(header);\n                    break;\n                case 'fact': // extended Format chunk,\n                    this.metadata.setFormat('lossless', false);\n                    this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));\n                    break;\n                case 'fmt ': // The Util Chunk, non-PCM Formats\n                    const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));\n                    let subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];\n                    if (!subFormat) {\n                        debug('WAVE/non-PCM format=' + fmt.wFormatTag);\n                        subFormat = 'non-PCM (' + fmt.wFormatTag + ')';\n                    }\n                    this.metadata.setFormat('codec', subFormat);\n                    this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\n                    this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\n                    this.metadata.setFormat('numberOfChannels', fmt.nChannels);\n                    this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\n                    this.blockAlign = fmt.nBlockAlign;\n                    break;\n                case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data\n                case 'ID3 ': // The way Mp3Tags stores ID3 meta-data\n                    const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\n                    const rst = strtok3.fromBuffer(id3_data);\n                    await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n                    break;\n                case 'data': // PCM-data\n                    if (this.metadata.format.lossless !== false) {\n                        this.metadata.setFormat('lossless', true);\n                    }\n                    let chunkSize = header.chunkSize;\n                    if (this.tokenizer.fileInfo.size) {\n                        const calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;\n                        if (calcRemaining < chunkSize) {\n                            this.metadata.addWarning('data chunk length exceeding file length');\n                            chunkSize = calcRemaining;\n                        }\n                    }\n                    const numberOfSamples = this.fact ? this.fact.dwSampleLength : (chunkSize === 0xffffffff ? undefined : chunkSize / this.blockAlign);\n                    if (numberOfSamples) {\n                        this.metadata.setFormat('numberOfSamples', numberOfSamples);\n                        this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\n                    }\n                    if (this.metadata.format.codec === 'ADPCM') { // ADPCM is 4 bits lossy encoding resulting in 352kbps\n                        this.metadata.setFormat('bitrate', 352000);\n                    }\n                    else {\n                        this.metadata.setFormat('bitrate', this.blockAlign * this.metadata.format.sampleRate * 8);\n                    }\n                    await this.tokenizer.ignore(header.chunkSize);\n                    break;\n                case 'bext': // Broadcast Audio Extension chunk\thttps://tech.ebu.ch/docs/tech/tech3285.pdf\n                    const bext = await this.tokenizer.readToken(BwfChunk_1.BroadcastAudioExtensionChunk);\n                    Object.keys(bext).forEach(key => {\n                        this.metadata.addTag('exif', 'bext.' + key, bext[key]);\n                    });\n                    const bextRemaining = header.chunkSize - BwfChunk_1.BroadcastAudioExtensionChunk.len;\n                    await this.tokenizer.ignore(bextRemaining);\n                    break;\n                case '\\x00\\x00\\x00\\x00': // padding ??\n                    debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n                    this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);\n                    await this.tokenizer.ignore(header.chunkSize);\n                    break;\n                default:\n                    debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n                    this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);\n                    await this.tokenizer.ignore(header.chunkSize);\n            }\n            if (this.header.chunkSize % 2 === 1) {\n                debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\n                await this.tokenizer.ignore(1);\n            }\n        }\n    }\n    async parseListTag(listHeader) {\n        const listType = await this.tokenizer.readToken(new Token.StringType(4, 'binary'));\n        debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\n        switch (listType) {\n            case 'INFO':\n                return this.parseRiffInfoTags(listHeader.chunkSize - 4);\n            case 'adtl':\n            default:\n                this.metadata.addWarning('Ignore chunk: RIFF/WAVE/LIST/' + listType);\n                debug('Ignoring chunkID=RIFF/WAVE/LIST/' + listType);\n                return this.tokenizer.ignore(listHeader.chunkSize - 4).then();\n        }\n    }\n    async parseRiffInfoTags(chunkSize) {\n        while (chunkSize >= 8) {\n            const header = await this.tokenizer.readToken(riff.Header);\n            const valueToken = new riff.ListInfoTagValue(header);\n            const value = await this.tokenizer.readToken(valueToken);\n            this.addTag(header.chunkID, util.stripNulls(value));\n            chunkSize -= (8 + valueToken.len);\n        }\n        if (chunkSize !== 0) {\n            throw Error('Illegal remaining size: ' + chunkSize);\n        }\n    }\n    addTag(id, value) {\n        this.metadata.addTag('exif', id, value);\n    }\n}\nexports.WaveParser = WaveParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvd2F2L1dhdmVQYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLGdCQUFnQixtQkFBTyxDQUFDLGdGQUFrQjtBQUMxQyxjQUFjLG1CQUFPLENBQUMsZ0ZBQWE7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQU87QUFDL0IsYUFBYSxtQkFBTyxDQUFDLGtHQUFtQjtBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyxrR0FBb0I7QUFDOUMsc0JBQXNCLG1CQUFPLENBQUMsd0dBQXNCO0FBQ3BELGFBQWEsbUJBQU8sQ0FBQyw0RkFBZ0I7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsZ0dBQWtCO0FBQzNDLHNCQUFzQixtQkFBTyxDQUFDLDBHQUF1QjtBQUNyRCxtQkFBbUIsbUJBQU8sQ0FBQyw4RkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QixtQkFBbUIsbUJBQW1CO0FBQ25GO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3QkFBd0IsaUNBQWlDLGVBQWU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0JBQWdCLEtBQUssa0JBQWtCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQixLQUFLLGtCQUFrQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi93YXYvV2F2ZVBhcnNlci5qcz9lOGZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XYXZlUGFyc2VyID0gdm9pZCAwO1xuY29uc3Qgc3RydG9rMyA9IHJlcXVpcmUoXCJzdHJ0b2szL2xpYi9jb3JlXCIpO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgcmlmZiA9IHJlcXVpcmUoXCIuLi9yaWZmL1JpZmZDaHVua1wiKTtcbmNvbnN0IFdhdmVDaHVuayA9IHJlcXVpcmUoXCIuLy4uL3dhdi9XYXZlQ2h1bmtcIik7XG5jb25zdCBJRDN2MlBhcnNlcl8xID0gcmVxdWlyZShcIi4uL2lkM3YyL0lEM3YyUGFyc2VyXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuLi9jb21tb24vVXRpbFwiKTtcbmNvbnN0IEZvdXJDQ18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Gb3VyQ0NcIik7XG5jb25zdCBCYXNpY1BhcnNlcl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9CYXNpY1BhcnNlclwiKTtcbmNvbnN0IEJ3ZkNodW5rXzEgPSByZXF1aXJlKFwiLi4vd2F2L0J3ZkNodW5rXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnbXVzaWMtbWV0YWRhdGE6cGFyc2VyOlJJRkYnKTtcbi8qKlxuICogUmVzb3VyY2UgSW50ZXJjaGFuZ2UgRmlsZSBGb3JtYXQgKFJJRkYpIFBhcnNlclxuICpcbiAqIFdBVkUgUENNIHNvdW5kZmlsZSBmb3JtYXRcbiAqXG4gKiBSZWY6XG4gKiAtIGh0dHA6Ly93d3cuam9obmxvb21pcy5vcmcvY3BlMTAyL2FzZ24vYXNnbjEvcmlmZi5odG1sXG4gKiAtIGh0dHA6Ly9zb3VuZGZpbGUuc2FwcC5vcmcvZG9jL1dhdmVGb3JtYXRcbiAqXG4gKiBUb0RvOiBTcGxpdCBXQVZFIHBhcnQgZnJvbSBSSUZGIHBhcnNlclxuICovXG5jbGFzcyBXYXZlUGFyc2VyIGV4dGVuZHMgQmFzaWNQYXJzZXJfMS5CYXNpY1BhcnNlciB7XG4gICAgYXN5bmMgcGFyc2UoKSB7XG4gICAgICAgIGNvbnN0IHJpZmZIZWFkZXIgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4ocmlmZi5IZWFkZXIpO1xuICAgICAgICBkZWJ1ZyhgcG9zPSR7dGhpcy50b2tlbml6ZXIucG9zaXRpb259LCBwYXJzZTogY2h1bmtJRD0ke3JpZmZIZWFkZXIuY2h1bmtJRH1gKTtcbiAgICAgICAgaWYgKHJpZmZIZWFkZXIuY2h1bmtJRCAhPT0gJ1JJRkYnKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBOb3QgUklGRiBmb3JtYXRcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSaWZmQ2h1bmsocmlmZkhlYWRlci5jaHVua1NpemUpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBzdHJ0b2szLkVuZE9mU3RyZWFtRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VSaWZmQ2h1bmsoY2h1bmtTaXplKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4oRm91ckNDXzEuRm91ckNjVG9rZW4pO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29udGFpbmVyJywgdHlwZSk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnV0FWRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZFdhdmVDaHVuayhjaHVua1NpemUgLSBGb3VyQ0NfMS5Gb3VyQ2NUb2tlbi5sZW4pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIFJJRkYgZm9ybWF0OiBSSUZGLyR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZWFkV2F2ZUNodW5rKHJlbWFpbmluZykge1xuICAgICAgICB3aGlsZSAocmVtYWluaW5nID49IHJpZmYuSGVhZGVyLmxlbikge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKHJpZmYuSGVhZGVyKTtcbiAgICAgICAgICAgIHJlbWFpbmluZyAtPSByaWZmLkhlYWRlci5sZW4gKyBoZWFkZXIuY2h1bmtTaXplO1xuICAgICAgICAgICAgaWYgKGhlYWRlci5jaHVua1NpemUgPiByZW1haW5pbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLmFkZFdhcm5pbmcoJ0RhdGEgY2h1bmsgc2l6ZSBleGNlZWRzIGZpbGUgc2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oZWFkZXIgPSBoZWFkZXI7XG4gICAgICAgICAgICBkZWJ1ZyhgcG9zPSR7dGhpcy50b2tlbml6ZXIucG9zaXRpb259LCByZWFkQ2h1bms6IGNodW5rSUQ9UklGRi9XQVZFLyR7aGVhZGVyLmNodW5rSUR9YCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGhlYWRlci5jaHVua0lEKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnTElTVCc6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGFyc2VMaXN0VGFnKGhlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhY3QnOiAvLyBleHRlbmRlZCBGb3JtYXQgY2h1bmssXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdsb3NzbGVzcycsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWN0ID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBXYXZlQ2h1bmsuRmFjdENodW5rKGhlYWRlcikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmbXQgJzogLy8gVGhlIFV0aWwgQ2h1bmssIG5vbi1QQ00gRm9ybWF0c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbXQgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4obmV3IFdhdmVDaHVuay5Gb3JtYXQoaGVhZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWJGb3JtYXQgPSBXYXZlQ2h1bmsuV2F2ZUZvcm1hdFtmbXQud0Zvcm1hdFRhZ107XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3ViRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnV0FWRS9ub24tUENNIGZvcm1hdD0nICsgZm10LndGb3JtYXRUYWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViRm9ybWF0ID0gJ25vbi1QQ00gKCcgKyBmbXQud0Zvcm1hdFRhZyArICcpJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnY29kZWMnLCBzdWJGb3JtYXQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnYml0c1BlclNhbXBsZScsIGZtdC53Qml0c1BlclNhbXBsZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdzYW1wbGVSYXRlJywgZm10Lm5TYW1wbGVzUGVyU2VjKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ251bWJlck9mQ2hhbm5lbHMnLCBmbXQubkNoYW5uZWxzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHJhdGUnLCBmbXQubkJsb2NrQWxpZ24gKiBmbXQublNhbXBsZXNQZXJTZWMgKiA4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ibG9ja0FsaWduID0gZm10Lm5CbG9ja0FsaWduO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpZDMgJzogLy8gVGhlIHdheSBQaWNhcmQsIEZvb0JhciBjdXJyZW50bHkgc3RvcmVzLCBJRDMgbWV0YS1kYXRhXG4gICAgICAgICAgICAgICAgY2FzZSAnSUQzICc6IC8vIFRoZSB3YXkgTXAzVGFncyBzdG9yZXMgSUQzIG1ldGEtZGF0YVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZDNfZGF0YSA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihuZXcgVG9rZW4uVWludDhBcnJheVR5cGUoaGVhZGVyLmNodW5rU2l6ZSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByc3QgPSBzdHJ0b2szLmZyb21CdWZmZXIoaWQzX2RhdGEpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgSUQzdjJQYXJzZXJfMS5JRDN2MlBhcnNlcigpLnBhcnNlKHRoaXMubWV0YWRhdGEsIHJzdCwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF0YSc6IC8vIFBDTS1kYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmZvcm1hdC5sb3NzbGVzcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdsb3NzbGVzcycsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaHVua1NpemUgPSBoZWFkZXIuY2h1bmtTaXplO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsY1JlbWFpbmluZyA9IHRoaXMudG9rZW5pemVyLmZpbGVJbmZvLnNpemUgLSB0aGlzLnRva2VuaXplci5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxjUmVtYWluaW5nIDwgY2h1bmtTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRXYXJuaW5nKCdkYXRhIGNodW5rIGxlbmd0aCBleGNlZWRpbmcgZmlsZSBsZW5ndGgnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua1NpemUgPSBjYWxjUmVtYWluaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlck9mU2FtcGxlcyA9IHRoaXMuZmFjdCA/IHRoaXMuZmFjdC5kd1NhbXBsZUxlbmd0aCA6IChjaHVua1NpemUgPT09IDB4ZmZmZmZmZmYgPyB1bmRlZmluZWQgOiBjaHVua1NpemUgLyB0aGlzLmJsb2NrQWxpZ24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobnVtYmVyT2ZTYW1wbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZTYW1wbGVzJywgbnVtYmVyT2ZTYW1wbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdkdXJhdGlvbicsIG51bWJlck9mU2FtcGxlcyAvIHRoaXMubWV0YWRhdGEuZm9ybWF0LnNhbXBsZVJhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmZvcm1hdC5jb2RlYyA9PT0gJ0FEUENNJykgeyAvLyBBRFBDTSBpcyA0IGJpdHMgbG9zc3kgZW5jb2RpbmcgcmVzdWx0aW5nIGluIDM1MmticHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdiaXRyYXRlJywgMzUyMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdiaXRyYXRlJywgdGhpcy5ibG9ja0FsaWduICogdGhpcy5tZXRhZGF0YS5mb3JtYXQuc2FtcGxlUmF0ZSAqIDgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLmlnbm9yZShoZWFkZXIuY2h1bmtTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmV4dCc6IC8vIEJyb2FkY2FzdCBBdWRpbyBFeHRlbnNpb24gY2h1bmtcdGh0dHBzOi8vdGVjaC5lYnUuY2gvZG9jcy90ZWNoL3RlY2gzMjg1LnBkZlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiZXh0ID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKEJ3ZkNodW5rXzEuQnJvYWRjYXN0QXVkaW9FeHRlbnNpb25DaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGJleHQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuYWRkVGFnKCdleGlmJywgJ2JleHQuJyArIGtleSwgYmV4dFtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJleHRSZW1haW5pbmcgPSBoZWFkZXIuY2h1bmtTaXplIC0gQndmQ2h1bmtfMS5Ccm9hZGNhc3RBdWRpb0V4dGVuc2lvbkNodW5rLmxlbjtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKGJleHRSZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdcXHgwMFxceDAwXFx4MDBcXHgwMCc6IC8vIHBhZGRpbmcgPz9cbiAgICAgICAgICAgICAgICAgICAgZGVidWcoYElnbm9yZSBwYWRkaW5nIGNodW5rOiBSSUZGLyR7aGVhZGVyLmNodW5rSUR9IG9mICR7aGVhZGVyLmNodW5rU2l6ZX0gYnl0ZXNgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRXYXJuaW5nKCdJZ25vcmUgY2h1bms6IFJJRkYvJyArIGhlYWRlci5jaHVua0lEKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKGhlYWRlci5jaHVua1NpemUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhgSWdub3JlIGNodW5rOiBSSUZGLyR7aGVhZGVyLmNodW5rSUR9IG9mICR7aGVhZGVyLmNodW5rU2l6ZX0gYnl0ZXNgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRXYXJuaW5nKCdJZ25vcmUgY2h1bms6IFJJRkYvJyArIGhlYWRlci5jaHVua0lEKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKGhlYWRlci5jaHVua1NpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVyLmNodW5rU2l6ZSAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnUmVhZCBvZGQgcGFkZGluZyBieXRlJyk7IC8vIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocC9SSUZGXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50b2tlbml6ZXIuaWdub3JlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlTGlzdFRhZyhsaXN0SGVhZGVyKSB7XG4gICAgICAgIGNvbnN0IGxpc3RUeXBlID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKG5ldyBUb2tlbi5TdHJpbmdUeXBlKDQsICdiaW5hcnknKSk7XG4gICAgICAgIGRlYnVnKCdwb3M9JXMsIHBhcnNlTGlzdFRhZzogY2h1bmtJRD1SSUZGL1dBVkUvTElTVC8lcycsIHRoaXMudG9rZW5pemVyLnBvc2l0aW9uLCBsaXN0VHlwZSk7XG4gICAgICAgIHN3aXRjaCAobGlzdFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0lORk8nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmlmZkluZm9UYWdzKGxpc3RIZWFkZXIuY2h1bmtTaXplIC0gNCk7XG4gICAgICAgICAgICBjYXNlICdhZHRsJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRXYXJuaW5nKCdJZ25vcmUgY2h1bms6IFJJRkYvV0FWRS9MSVNULycgKyBsaXN0VHlwZSk7XG4gICAgICAgICAgICAgICAgZGVidWcoJ0lnbm9yaW5nIGNodW5rSUQ9UklGRi9XQVZFL0xJU1QvJyArIGxpc3RUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbml6ZXIuaWdub3JlKGxpc3RIZWFkZXIuY2h1bmtTaXplIC0gNCkudGhlbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlUmlmZkluZm9UYWdzKGNodW5rU2l6ZSkge1xuICAgICAgICB3aGlsZSAoY2h1bmtTaXplID49IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihyaWZmLkhlYWRlcik7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZVRva2VuID0gbmV3IHJpZmYuTGlzdEluZm9UYWdWYWx1ZShoZWFkZXIpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkVG9rZW4odmFsdWVUb2tlbik7XG4gICAgICAgICAgICB0aGlzLmFkZFRhZyhoZWFkZXIuY2h1bmtJRCwgdXRpbC5zdHJpcE51bGxzKHZhbHVlKSk7XG4gICAgICAgICAgICBjaHVua1NpemUgLT0gKDggKyB2YWx1ZVRva2VuLmxlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNodW5rU2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0lsbGVnYWwgcmVtYWluaW5nIHNpemU6ICcgKyBjaHVua1NpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFRhZyhpZCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YS5hZGRUYWcoJ2V4aWYnLCBpZCwgdmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuV2F2ZVBhcnNlciA9IFdhdmVQYXJzZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/wav/WaveParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/wavpack/WavPackParser.js":
/*!******************************************************************!*\
  !*** ./node_modules/music-metadata/lib/wavpack/WavPackParser.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WavPackParser = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst APEv2Parser_1 = __webpack_require__(/*! ../apev2/APEv2Parser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/apev2/APEv2Parser.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/FourCC.js\");\nconst BasicParser_1 = __webpack_require__(/*! ../common/BasicParser */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/BasicParser.js\");\nconst WavPackToken_1 = __webpack_require__(/*! ./WavPackToken */ \"(app-pages-browser)/./node_modules/music-metadata/lib/wavpack/WavPackToken.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\nconst debug = (0, debug_1.default)('music-metadata:parser:WavPack');\n/**\n * WavPack Parser\n */\nclass WavPackParser extends BasicParser_1.BasicParser {\n    async parse() {\n        this.audioDataSize = 0;\n        // First parse all WavPack blocks\n        await this.parseWavPackBlocks();\n        // try to parse APEv2 header\n        return APEv2Parser_1.APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);\n    }\n    async parseWavPackBlocks() {\n        do {\n            const blockId = await this.tokenizer.peekToken(FourCC_1.FourCcToken);\n            if (blockId !== 'wvpk')\n                break;\n            const header = await this.tokenizer.readToken(WavPackToken_1.WavPack.BlockHeaderToken);\n            if (header.BlockID !== 'wvpk')\n                throw new Error('Invalid WavPack Block-ID');\n            debug(`WavPack header blockIndex=${header.blockIndex}, len=${WavPackToken_1.WavPack.BlockHeaderToken.len}`);\n            if (header.blockIndex === 0 && !this.metadata.format.container) {\n                this.metadata.setFormat('container', 'WavPack');\n                this.metadata.setFormat('lossless', !header.flags.isHybrid);\n                // tagTypes: this.type,\n                this.metadata.setFormat('bitsPerSample', header.flags.bitsPerSample);\n                if (!header.flags.isDSD) {\n                    // In case isDSD, these values will ne set in ID_DSD_BLOCK\n                    this.metadata.setFormat('sampleRate', header.flags.samplingRate);\n                    this.metadata.setFormat('duration', header.totalSamples / header.flags.samplingRate);\n                }\n                this.metadata.setFormat('numberOfChannels', header.flags.isMono ? 1 : 2);\n                this.metadata.setFormat('numberOfSamples', header.totalSamples);\n                this.metadata.setFormat('codec', header.flags.isDSD ? 'DSD' : 'PCM');\n            }\n            const ignoreBytes = header.blockSize - (WavPackToken_1.WavPack.BlockHeaderToken.len - 8);\n            await (header.blockIndex === 0 ? this.parseMetadataSubBlock(header, ignoreBytes) : this.tokenizer.ignore(ignoreBytes));\n            if (header.blockSamples > 0) {\n                this.audioDataSize += header.blockSize; // Count audio data for bit-rate calculation\n            }\n        } while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= WavPackToken_1.WavPack.BlockHeaderToken.len);\n        this.metadata.setFormat('bitrate', this.audioDataSize * 8 / this.metadata.format.duration);\n    }\n    /**\n     * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf, 3.0 Metadata Sub-blocks\n     * @param remainingLength\n     */\n    async parseMetadataSubBlock(header, remainingLength) {\n        while (remainingLength > WavPackToken_1.WavPack.MetadataIdToken.len) {\n            const id = await this.tokenizer.readToken(WavPackToken_1.WavPack.MetadataIdToken);\n            const dataSizeInWords = await this.tokenizer.readNumber(id.largeBlock ? Token.UINT24_LE : Token.UINT8);\n            const data = Buffer.alloc(dataSizeInWords * 2 - (id.isOddSize ? 1 : 0));\n            await this.tokenizer.readBuffer(data);\n            debug(`Metadata Sub-Blocks functionId=0x${id.functionId.toString(16)}, id.largeBlock=${id.largeBlock},data-size=${data.length}`);\n            switch (id.functionId) {\n                case 0x0: // ID_DUMMY: could be used to pad WavPack blocks\n                    break;\n                case 0xe: // ID_DSD_BLOCK\n                    debug('ID_DSD_BLOCK');\n                    // https://github.com/dbry/WavPack/issues/71#issuecomment-483094813\n                    const mp = 1 << data.readUInt8(0);\n                    const samplingRate = header.flags.samplingRate * mp * 8; // ToDo: second factor should be read from DSD-metadata block https://github.com/dbry/WavPack/issues/71#issuecomment-483094813\n                    if (!header.flags.isDSD)\n                        throw new Error('Only expect DSD block if DSD-flag is set');\n                    this.metadata.setFormat('sampleRate', samplingRate);\n                    this.metadata.setFormat('duration', header.totalSamples / samplingRate);\n                    break;\n                case 0x24: // ID_ALT_TRAILER: maybe used to embed original ID3 tag header\n                    debug('ID_ALT_TRAILER: trailer for non-wav files');\n                    break;\n                case 0x26: // ID_MD5_CHECKSUM\n                    this.metadata.setFormat('audioMD5', data);\n                    break;\n                case 0x2f: // ID_BLOCK_CHECKSUM\n                    debug(`ID_BLOCK_CHECKSUM: checksum=${data.toString('hex')}`);\n                    break;\n                default:\n                    debug(`Ignore unsupported meta-sub-block-id functionId=0x${id.functionId.toString(16)}`);\n                    break;\n            }\n            remainingLength -= WavPackToken_1.WavPack.MetadataIdToken.len + (id.largeBlock ? Token.UINT24_LE.len : Token.UINT8.len) + dataSizeInWords * 2;\n            debug(`remainingLength=${remainingLength}`);\n            if (id.isOddSize)\n                this.tokenizer.ignore(1);\n        }\n        if (remainingLength !== 0)\n            throw new Error('metadata-sub-block should fit it remaining length');\n    }\n}\nexports.WavPackParser = WavPackParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvd2F2cGFjay9XYXZQYWNrUGFyc2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsY0FBYyxtQkFBTyxDQUFDLGdGQUFhO0FBQ25DLHNCQUFzQixtQkFBTyxDQUFDLHdHQUFzQjtBQUNwRCxpQkFBaUIsbUJBQU8sQ0FBQyxnR0FBa0I7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsMEdBQXVCO0FBQ3JELHVCQUF1QixtQkFBTyxDQUFDLHFHQUFnQjtBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGtCQUFrQixRQUFRLDRDQUE0QztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0I7QUFDQSxzREFBc0QsMkJBQTJCLGtCQUFrQixjQUFjLGFBQWEsWUFBWTtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQscUJBQXFCO0FBQzlFO0FBQ0E7QUFDQSwrRUFBK0UsMkJBQTJCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi93YXZwYWNrL1dhdlBhY2tQYXJzZXIuanM/YWNmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2F2UGFja1BhcnNlciA9IHZvaWQgMDtcbmNvbnN0IFRva2VuID0gcmVxdWlyZShcInRva2VuLXR5cGVzXCIpO1xuY29uc3QgQVBFdjJQYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9hcGV2Mi9BUEV2MlBhcnNlclwiKTtcbmNvbnN0IEZvdXJDQ18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9Gb3VyQ0NcIik7XG5jb25zdCBCYXNpY1BhcnNlcl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9CYXNpY1BhcnNlclwiKTtcbmNvbnN0IFdhdlBhY2tUb2tlbl8xID0gcmVxdWlyZShcIi4vV2F2UGFja1Rva2VuXCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ211c2ljLW1ldGFkYXRhOnBhcnNlcjpXYXZQYWNrJyk7XG4vKipcbiAqIFdhdlBhY2sgUGFyc2VyXG4gKi9cbmNsYXNzIFdhdlBhY2tQYXJzZXIgZXh0ZW5kcyBCYXNpY1BhcnNlcl8xLkJhc2ljUGFyc2VyIHtcbiAgICBhc3luYyBwYXJzZSgpIHtcbiAgICAgICAgdGhpcy5hdWRpb0RhdGFTaXplID0gMDtcbiAgICAgICAgLy8gRmlyc3QgcGFyc2UgYWxsIFdhdlBhY2sgYmxvY2tzXG4gICAgICAgIGF3YWl0IHRoaXMucGFyc2VXYXZQYWNrQmxvY2tzKCk7XG4gICAgICAgIC8vIHRyeSB0byBwYXJzZSBBUEV2MiBoZWFkZXJcbiAgICAgICAgcmV0dXJuIEFQRXYyUGFyc2VyXzEuQVBFdjJQYXJzZXIudHJ5UGFyc2VBcGVIZWFkZXIodGhpcy5tZXRhZGF0YSwgdGhpcy50b2tlbml6ZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlV2F2UGFja0Jsb2NrcygpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tJZCA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnBlZWtUb2tlbihGb3VyQ0NfMS5Gb3VyQ2NUb2tlbik7XG4gICAgICAgICAgICBpZiAoYmxvY2tJZCAhPT0gJ3d2cGsnKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgdGhpcy50b2tlbml6ZXIucmVhZFRva2VuKFdhdlBhY2tUb2tlbl8xLldhdlBhY2suQmxvY2tIZWFkZXJUb2tlbik7XG4gICAgICAgICAgICBpZiAoaGVhZGVyLkJsb2NrSUQgIT09ICd3dnBrJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgV2F2UGFjayBCbG9jay1JRCcpO1xuICAgICAgICAgICAgZGVidWcoYFdhdlBhY2sgaGVhZGVyIGJsb2NrSW5kZXg9JHtoZWFkZXIuYmxvY2tJbmRleH0sIGxlbj0ke1dhdlBhY2tUb2tlbl8xLldhdlBhY2suQmxvY2tIZWFkZXJUb2tlbi5sZW59YCk7XG4gICAgICAgICAgICBpZiAoaGVhZGVyLmJsb2NrSW5kZXggPT09IDAgJiYgIXRoaXMubWV0YWRhdGEuZm9ybWF0LmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdjb250YWluZXInLCAnV2F2UGFjaycpO1xuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdsb3NzbGVzcycsICFoZWFkZXIuZmxhZ3MuaXNIeWJyaWQpO1xuICAgICAgICAgICAgICAgIC8vIHRhZ1R5cGVzOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2JpdHNQZXJTYW1wbGUnLCBoZWFkZXIuZmxhZ3MuYml0c1BlclNhbXBsZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkZXIuZmxhZ3MuaXNEU0QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBpc0RTRCwgdGhlc2UgdmFsdWVzIHdpbGwgbmUgc2V0IGluIElEX0RTRF9CTE9DS1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnc2FtcGxlUmF0ZScsIGhlYWRlci5mbGFncy5zYW1wbGluZ1JhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnZHVyYXRpb24nLCBoZWFkZXIudG90YWxTYW1wbGVzIC8gaGVhZGVyLmZsYWdzLnNhbXBsaW5nUmF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdudW1iZXJPZkNoYW5uZWxzJywgaGVhZGVyLmZsYWdzLmlzTW9ubyA/IDEgOiAyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnbnVtYmVyT2ZTYW1wbGVzJywgaGVhZGVyLnRvdGFsU2FtcGxlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2NvZGVjJywgaGVhZGVyLmZsYWdzLmlzRFNEID8gJ0RTRCcgOiAnUENNJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZ25vcmVCeXRlcyA9IGhlYWRlci5ibG9ja1NpemUgLSAoV2F2UGFja1Rva2VuXzEuV2F2UGFjay5CbG9ja0hlYWRlclRva2VuLmxlbiAtIDgpO1xuICAgICAgICAgICAgYXdhaXQgKGhlYWRlci5ibG9ja0luZGV4ID09PSAwID8gdGhpcy5wYXJzZU1ldGFkYXRhU3ViQmxvY2soaGVhZGVyLCBpZ25vcmVCeXRlcykgOiB0aGlzLnRva2VuaXplci5pZ25vcmUoaWdub3JlQnl0ZXMpKTtcbiAgICAgICAgICAgIGlmIChoZWFkZXIuYmxvY2tTYW1wbGVzID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9EYXRhU2l6ZSArPSBoZWFkZXIuYmxvY2tTaXplOyAvLyBDb3VudCBhdWRpbyBkYXRhIGZvciBiaXQtcmF0ZSBjYWxjdWxhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICghdGhpcy50b2tlbml6ZXIuZmlsZUluZm8uc2l6ZSB8fCB0aGlzLnRva2VuaXplci5maWxlSW5mby5zaXplIC0gdGhpcy50b2tlbml6ZXIucG9zaXRpb24gPj0gV2F2UGFja1Rva2VuXzEuV2F2UGFjay5CbG9ja0hlYWRlclRva2VuLmxlbik7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuc2V0Rm9ybWF0KCdiaXRyYXRlJywgdGhpcy5hdWRpb0RhdGFTaXplICogOCAvIHRoaXMubWV0YWRhdGEuZm9ybWF0LmR1cmF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmOiBodHRwOi8vd3d3LndhdnBhY2suY29tL1dhdlBhY2s1RmlsZUZvcm1hdC5wZGYsIDMuMCBNZXRhZGF0YSBTdWItYmxvY2tzXG4gICAgICogQHBhcmFtIHJlbWFpbmluZ0xlbmd0aFxuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlTWV0YWRhdGFTdWJCbG9jayhoZWFkZXIsIHJlbWFpbmluZ0xlbmd0aCkge1xuICAgICAgICB3aGlsZSAocmVtYWluaW5nTGVuZ3RoID4gV2F2UGFja1Rva2VuXzEuV2F2UGFjay5NZXRhZGF0YUlkVG9rZW4ubGVuKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRUb2tlbihXYXZQYWNrVG9rZW5fMS5XYXZQYWNrLk1ldGFkYXRhSWRUb2tlbik7XG4gICAgICAgICAgICBjb25zdCBkYXRhU2l6ZUluV29yZHMgPSBhd2FpdCB0aGlzLnRva2VuaXplci5yZWFkTnVtYmVyKGlkLmxhcmdlQmxvY2sgPyBUb2tlbi5VSU5UMjRfTEUgOiBUb2tlbi5VSU5UOCk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jKGRhdGFTaXplSW5Xb3JkcyAqIDIgLSAoaWQuaXNPZGRTaXplID8gMSA6IDApKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudG9rZW5pemVyLnJlYWRCdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICBkZWJ1ZyhgTWV0YWRhdGEgU3ViLUJsb2NrcyBmdW5jdGlvbklkPTB4JHtpZC5mdW5jdGlvbklkLnRvU3RyaW5nKDE2KX0sIGlkLmxhcmdlQmxvY2s9JHtpZC5sYXJnZUJsb2NrfSxkYXRhLXNpemU9JHtkYXRhLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHN3aXRjaCAoaWQuZnVuY3Rpb25JZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMHgwOiAvLyBJRF9EVU1NWTogY291bGQgYmUgdXNlZCB0byBwYWQgV2F2UGFjayBibG9ja3NcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAweGU6IC8vIElEX0RTRF9CTE9DS1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnSURfRFNEX0JMT0NLJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYnJ5L1dhdlBhY2svaXNzdWVzLzcxI2lzc3VlY29tbWVudC00ODMwOTQ4MTNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXAgPSAxIDw8IGRhdGEucmVhZFVJbnQ4KDApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzYW1wbGluZ1JhdGUgPSBoZWFkZXIuZmxhZ3Muc2FtcGxpbmdSYXRlICogbXAgKiA4OyAvLyBUb0RvOiBzZWNvbmQgZmFjdG9yIHNob3VsZCBiZSByZWFkIGZyb20gRFNELW1ldGFkYXRhIGJsb2NrIGh0dHBzOi8vZ2l0aHViLmNvbS9kYnJ5L1dhdlBhY2svaXNzdWVzLzcxI2lzc3VlY29tbWVudC00ODMwOTQ4MTNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkZXIuZmxhZ3MuaXNEU0QpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgZXhwZWN0IERTRCBibG9jayBpZiBEU0QtZmxhZyBpcyBzZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ3NhbXBsZVJhdGUnLCBzYW1wbGluZ1JhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnNldEZvcm1hdCgnZHVyYXRpb24nLCBoZWFkZXIudG90YWxTYW1wbGVzIC8gc2FtcGxpbmdSYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAweDI0OiAvLyBJRF9BTFRfVFJBSUxFUjogbWF5YmUgdXNlZCB0byBlbWJlZCBvcmlnaW5hbCBJRDMgdGFnIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnSURfQUxUX1RSQUlMRVI6IHRyYWlsZXIgZm9yIG5vbi13YXYgZmlsZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAweDI2OiAvLyBJRF9NRDVfQ0hFQ0tTVU1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YS5zZXRGb3JtYXQoJ2F1ZGlvTUQ1JywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMHgyZjogLy8gSURfQkxPQ0tfQ0hFQ0tTVU1cbiAgICAgICAgICAgICAgICAgICAgZGVidWcoYElEX0JMT0NLX0NIRUNLU1VNOiBjaGVja3N1bT0ke2RhdGEudG9TdHJpbmcoJ2hleCcpfWApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhgSWdub3JlIHVuc3VwcG9ydGVkIG1ldGEtc3ViLWJsb2NrLWlkIGZ1bmN0aW9uSWQ9MHgke2lkLmZ1bmN0aW9uSWQudG9TdHJpbmcoMTYpfWApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbWFpbmluZ0xlbmd0aCAtPSBXYXZQYWNrVG9rZW5fMS5XYXZQYWNrLk1ldGFkYXRhSWRUb2tlbi5sZW4gKyAoaWQubGFyZ2VCbG9jayA/IFRva2VuLlVJTlQyNF9MRS5sZW4gOiBUb2tlbi5VSU5UOC5sZW4pICsgZGF0YVNpemVJbldvcmRzICogMjtcbiAgICAgICAgICAgIGRlYnVnKGByZW1haW5pbmdMZW5ndGg9JHtyZW1haW5pbmdMZW5ndGh9YCk7XG4gICAgICAgICAgICBpZiAoaWQuaXNPZGRTaXplKVxuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5pemVyLmlnbm9yZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVtYWluaW5nTGVuZ3RoICE9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRhZGF0YS1zdWItYmxvY2sgc2hvdWxkIGZpdCBpdCByZW1haW5pbmcgbGVuZ3RoJyk7XG4gICAgfVxufVxuZXhwb3J0cy5XYXZQYWNrUGFyc2VyID0gV2F2UGFja1BhcnNlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/wavpack/WavPackParser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/lib/wavpack/WavPackToken.js":
/*!*****************************************************************!*\
  !*** ./node_modules/music-metadata/lib/wavpack/WavPackToken.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WavPack = void 0;\nconst Token = __webpack_require__(/*! token-types */ \"(app-pages-browser)/./node_modules/token-types/lib/index.js\");\nconst FourCC_1 = __webpack_require__(/*! ../common/FourCC */ \"(app-pages-browser)/./node_modules/music-metadata/lib/common/FourCC.js\");\nconst SampleRates = [6000, 8000, 9600, 11025, 12000, 16000, 22050, 24000, 32000, 44100,\n    48000, 64000, 88200, 96000, 192000, -1];\nclass WavPack {\n    static isBitSet(flags, bitOffset) {\n        return WavPack.getBitAllignedNumber(flags, bitOffset, 1) === 1;\n    }\n    static getBitAllignedNumber(flags, bitOffset, len) {\n        return (flags >>> bitOffset) & (0xffffffff >>> (32 - len));\n    }\n}\n/**\n * WavPack Block Header\n *\n * 32-byte little-endian header at the front of every WavPack block\n *\n * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf (page 2/6: 2.0 \"Block Header\")\n */\nWavPack.BlockHeaderToken = {\n    len: 32,\n    get: (buf, off) => {\n        const flags = Token.UINT32_LE.get(buf, off + 24);\n        const res = {\n            // should equal 'wvpk'\n            BlockID: FourCC_1.FourCcToken.get(buf, off),\n            //  0x402 to 0x410 are valid for decode\n            blockSize: Token.UINT32_LE.get(buf, off + 4),\n            //  0x402 (1026) to 0x410 are valid for decode\n            version: Token.UINT16_LE.get(buf, off + 8),\n            //  40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)\n            totalSamples: /* replace with bigint? (Token.UINT8.get(buf, off + 11) << 32) + */ Token.UINT32_LE.get(buf, off + 12),\n            // 40-bit block_index\n            blockIndex: /* replace with bigint? (Token.UINT8.get(buf, off + 10) << 32) + */ Token.UINT32_LE.get(buf, off + 16),\n            // 40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)\n            blockSamples: Token.UINT32_LE.get(buf, off + 20),\n            // various flags for id and decoding\n            flags: {\n                bitsPerSample: (1 + WavPack.getBitAllignedNumber(flags, 0, 2)) * 8,\n                isMono: WavPack.isBitSet(flags, 2),\n                isHybrid: WavPack.isBitSet(flags, 3),\n                isJointStereo: WavPack.isBitSet(flags, 4),\n                crossChannel: WavPack.isBitSet(flags, 5),\n                hybridNoiseShaping: WavPack.isBitSet(flags, 6),\n                floatingPoint: WavPack.isBitSet(flags, 7),\n                samplingRate: SampleRates[WavPack.getBitAllignedNumber(flags, 23, 4)],\n                isDSD: WavPack.isBitSet(flags, 31)\n            },\n            // crc for actual decoded data\n            crc: new Token.Uint8ArrayType(4).get(buf, off + 28)\n        };\n        if (res.flags.isDSD) {\n            res.totalSamples *= 8;\n        }\n        return res;\n    }\n};\n/**\n * 3.0 Metadata Sub-Blocks\n * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf (page 4/6: 3.0 \"Metadata Sub-Block\")\n */\nWavPack.MetadataIdToken = {\n    len: 1,\n    get: (buf, off) => {\n        return {\n            functionId: WavPack.getBitAllignedNumber(buf[off], 0, 6),\n            isOptional: WavPack.isBitSet(buf[off], 5),\n            isOddSize: WavPack.isBitSet(buf[off], 6),\n            largeBlock: WavPack.isBitSet(buf[off], 7)\n        };\n    }\n};\nexports.WavPack = WavPack;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9saWIvd2F2cGFjay9XYXZQYWNrVG9rZW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLGNBQWMsbUJBQU8sQ0FBQyxnRkFBYTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxnR0FBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL211c2ljLW1ldGFkYXRhL2xpYi93YXZwYWNrL1dhdlBhY2tUb2tlbi5qcz8yNTdiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XYXZQYWNrID0gdm9pZCAwO1xuY29uc3QgVG9rZW4gPSByZXF1aXJlKFwidG9rZW4tdHlwZXNcIik7XG5jb25zdCBGb3VyQ0NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vRm91ckNDXCIpO1xuY29uc3QgU2FtcGxlUmF0ZXMgPSBbNjAwMCwgODAwMCwgOTYwMCwgMTEwMjUsIDEyMDAwLCAxNjAwMCwgMjIwNTAsIDI0MDAwLCAzMjAwMCwgNDQxMDAsXG4gICAgNDgwMDAsIDY0MDAwLCA4ODIwMCwgOTYwMDAsIDE5MjAwMCwgLTFdO1xuY2xhc3MgV2F2UGFjayB7XG4gICAgc3RhdGljIGlzQml0U2V0KGZsYWdzLCBiaXRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIFdhdlBhY2suZ2V0Qml0QWxsaWduZWROdW1iZXIoZmxhZ3MsIGJpdE9mZnNldCwgMSkgPT09IDE7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCaXRBbGxpZ25lZE51bWJlcihmbGFncywgYml0T2Zmc2V0LCBsZW4pIHtcbiAgICAgICAgcmV0dXJuIChmbGFncyA+Pj4gYml0T2Zmc2V0KSAmICgweGZmZmZmZmZmID4+PiAoMzIgLSBsZW4pKTtcbiAgICB9XG59XG4vKipcbiAqIFdhdlBhY2sgQmxvY2sgSGVhZGVyXG4gKlxuICogMzItYnl0ZSBsaXR0bGUtZW5kaWFuIGhlYWRlciBhdCB0aGUgZnJvbnQgb2YgZXZlcnkgV2F2UGFjayBibG9ja1xuICpcbiAqIFJlZjogaHR0cDovL3d3dy53YXZwYWNrLmNvbS9XYXZQYWNrNUZpbGVGb3JtYXQucGRmIChwYWdlIDIvNjogMi4wIFwiQmxvY2sgSGVhZGVyXCIpXG4gKi9cbldhdlBhY2suQmxvY2tIZWFkZXJUb2tlbiA9IHtcbiAgICBsZW46IDMyLFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gVG9rZW4uVUlOVDMyX0xFLmdldChidWYsIG9mZiArIDI0KTtcbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgICAgLy8gc2hvdWxkIGVxdWFsICd3dnBrJ1xuICAgICAgICAgICAgQmxvY2tJRDogRm91ckNDXzEuRm91ckNjVG9rZW4uZ2V0KGJ1Ziwgb2ZmKSxcbiAgICAgICAgICAgIC8vICAweDQwMiB0byAweDQxMCBhcmUgdmFsaWQgZm9yIGRlY29kZVxuICAgICAgICAgICAgYmxvY2tTaXplOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgNCksXG4gICAgICAgICAgICAvLyAgMHg0MDIgKDEwMjYpIHRvIDB4NDEwIGFyZSB2YWxpZCBmb3IgZGVjb2RlXG4gICAgICAgICAgICB2ZXJzaW9uOiBUb2tlbi5VSU5UMTZfTEUuZ2V0KGJ1Ziwgb2ZmICsgOCksXG4gICAgICAgICAgICAvLyAgNDAtYml0IHRvdGFsIHNhbXBsZXMgZm9yIGVudGlyZSBmaWxlIChpZiBibG9ja19pbmRleCA9PSAwIGFuZCBhIHZhbHVlIG9mIC0xIGluZGljYXRlcyBhbiB1bmtub3duIGxlbmd0aClcbiAgICAgICAgICAgIHRvdGFsU2FtcGxlczogLyogcmVwbGFjZSB3aXRoIGJpZ2ludD8gKFRva2VuLlVJTlQ4LmdldChidWYsIG9mZiArIDExKSA8PCAzMikgKyAqLyBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgMTIpLFxuICAgICAgICAgICAgLy8gNDAtYml0IGJsb2NrX2luZGV4XG4gICAgICAgICAgICBibG9ja0luZGV4OiAvKiByZXBsYWNlIHdpdGggYmlnaW50PyAoVG9rZW4uVUlOVDguZ2V0KGJ1Ziwgb2ZmICsgMTApIDw8IDMyKSArICovIFRva2VuLlVJTlQzMl9MRS5nZXQoYnVmLCBvZmYgKyAxNiksXG4gICAgICAgICAgICAvLyA0MC1iaXQgdG90YWwgc2FtcGxlcyBmb3IgZW50aXJlIGZpbGUgKGlmIGJsb2NrX2luZGV4ID09IDAgYW5kIGEgdmFsdWUgb2YgLTEgaW5kaWNhdGVzIGFuIHVua25vd24gbGVuZ3RoKVxuICAgICAgICAgICAgYmxvY2tTYW1wbGVzOiBUb2tlbi5VSU5UMzJfTEUuZ2V0KGJ1Ziwgb2ZmICsgMjApLFxuICAgICAgICAgICAgLy8gdmFyaW91cyBmbGFncyBmb3IgaWQgYW5kIGRlY29kaW5nXG4gICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICAgIGJpdHNQZXJTYW1wbGU6ICgxICsgV2F2UGFjay5nZXRCaXRBbGxpZ25lZE51bWJlcihmbGFncywgMCwgMikpICogOCxcbiAgICAgICAgICAgICAgICBpc01vbm86IFdhdlBhY2suaXNCaXRTZXQoZmxhZ3MsIDIpLFxuICAgICAgICAgICAgICAgIGlzSHlicmlkOiBXYXZQYWNrLmlzQml0U2V0KGZsYWdzLCAzKSxcbiAgICAgICAgICAgICAgICBpc0pvaW50U3RlcmVvOiBXYXZQYWNrLmlzQml0U2V0KGZsYWdzLCA0KSxcbiAgICAgICAgICAgICAgICBjcm9zc0NoYW5uZWw6IFdhdlBhY2suaXNCaXRTZXQoZmxhZ3MsIDUpLFxuICAgICAgICAgICAgICAgIGh5YnJpZE5vaXNlU2hhcGluZzogV2F2UGFjay5pc0JpdFNldChmbGFncywgNiksXG4gICAgICAgICAgICAgICAgZmxvYXRpbmdQb2ludDogV2F2UGFjay5pc0JpdFNldChmbGFncywgNyksXG4gICAgICAgICAgICAgICAgc2FtcGxpbmdSYXRlOiBTYW1wbGVSYXRlc1tXYXZQYWNrLmdldEJpdEFsbGlnbmVkTnVtYmVyKGZsYWdzLCAyMywgNCldLFxuICAgICAgICAgICAgICAgIGlzRFNEOiBXYXZQYWNrLmlzQml0U2V0KGZsYWdzLCAzMSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBjcmMgZm9yIGFjdHVhbCBkZWNvZGVkIGRhdGFcbiAgICAgICAgICAgIGNyYzogbmV3IFRva2VuLlVpbnQ4QXJyYXlUeXBlKDQpLmdldChidWYsIG9mZiArIDI4KVxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVzLmZsYWdzLmlzRFNEKSB7XG4gICAgICAgICAgICByZXMudG90YWxTYW1wbGVzICo9IDg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59O1xuLyoqXG4gKiAzLjAgTWV0YWRhdGEgU3ViLUJsb2Nrc1xuICogUmVmOiBodHRwOi8vd3d3LndhdnBhY2suY29tL1dhdlBhY2s1RmlsZUZvcm1hdC5wZGYgKHBhZ2UgNC82OiAzLjAgXCJNZXRhZGF0YSBTdWItQmxvY2tcIilcbiAqL1xuV2F2UGFjay5NZXRhZGF0YUlkVG9rZW4gPSB7XG4gICAgbGVuOiAxLFxuICAgIGdldDogKGJ1Ziwgb2ZmKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmdW5jdGlvbklkOiBXYXZQYWNrLmdldEJpdEFsbGlnbmVkTnVtYmVyKGJ1ZltvZmZdLCAwLCA2KSxcbiAgICAgICAgICAgIGlzT3B0aW9uYWw6IFdhdlBhY2suaXNCaXRTZXQoYnVmW29mZl0sIDUpLFxuICAgICAgICAgICAgaXNPZGRTaXplOiBXYXZQYWNrLmlzQml0U2V0KGJ1ZltvZmZdLCA2KSxcbiAgICAgICAgICAgIGxhcmdlQmxvY2s6IFdhdlBhY2suaXNCaXRTZXQoYnVmW29mZl0sIDcpXG4gICAgICAgIH07XG4gICAgfVxufTtcbmV4cG9ydHMuV2F2UGFjayA9IFdhdlBhY2s7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/lib/wavpack/WavPackToken.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/music-metadata/node_modules/media-typer/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/music-metadata/node_modules/media-typer/index.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * media-typer\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n\n\n/**\n * RegExp to match type in RFC 6838\n *\n * type-name = restricted-name\n * subtype-name = restricted-name\n * restricted-name = restricted-name-first *126restricted-name-chars\n * restricted-name-first  = ALPHA / DIGIT\n * restricted-name-chars  = ALPHA / DIGIT / \"!\" / \"#\" /\n *                          \"$\" / \"&\" / \"-\" / \"^\" / \"_\"\n * restricted-name-chars =/ \".\" ; Characters before first dot always\n *                              ; specify a facet name\n * restricted-name-chars =/ \"+\" ; Characters after last plus always\n *                              ; specify a structured syntax suffix\n * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z\n * DIGIT =  %x30-39             ; 0-9\n */\nvar SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/\nvar TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/\nvar TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/\n\n/**\n * Module exports.\n */\n\nexports.format = format\nexports.parse = parse\nexports.test = test\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @public\n */\n\nfunction format (obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var subtype = obj.subtype\n  var suffix = obj.suffix\n  var type = obj.type\n\n  if (!type || !TYPE_NAME_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype)) {\n    throw new TypeError('invalid subtype')\n  }\n\n  // format as type/subtype\n  var string = type + '/' + subtype\n\n  // append +suffix\n  if (suffix) {\n    if (!TYPE_NAME_REGEXP.test(suffix)) {\n      throw new TypeError('invalid suffix')\n    }\n\n    string += '+' + suffix\n  }\n\n  return string\n}\n\n/**\n * Test media type.\n *\n * @param {string} string\n * @return {object}\n * @public\n */\n\nfunction test (string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  if (typeof string !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  return TYPE_REGEXP.test(string.toLowerCase())\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string} string\n * @return {object}\n * @public\n */\n\nfunction parse (string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  if (typeof string !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var match = TYPE_REGEXP.exec(string.toLowerCase())\n\n  if (!match) {\n    throw new TypeError('invalid media type')\n  }\n\n  var type = match[1]\n  var subtype = match[2]\n  var suffix\n\n  // suffix after last +\n  var index = subtype.lastIndexOf('+')\n  if (index !== -1) {\n    suffix = subtype.substr(index + 1)\n    subtype = subtype.substr(0, index)\n  }\n\n  return new MediaType(type, subtype, suffix)\n}\n\n/**\n * Class for MediaType object.\n * @public\n */\n\nfunction MediaType (type, subtype, suffix) {\n  this.type = type\n  this.subtype = subtype\n  this.suffix = suffix\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tdXNpYy1tZXRhZGF0YS9ub2RlX21vZHVsZXMvbWVkaWEtdHlwZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQztBQUNBLDJEQUEyRCxNQUFNO0FBQ2pFLHVEQUF1RCxNQUFNO0FBQzdELHFEQUFxRCxNQUFNLG9DQUFvQyxNQUFNOztBQUVyRztBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLGFBQWE7QUFDYixZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbXVzaWMtbWV0YWRhdGEvbm9kZV9tb2R1bGVzL21lZGlhLXR5cGVyL2luZGV4LmpzPzU3M2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBtZWRpYS10eXBlclxuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNyBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIHR5cGUgaW4gUkZDIDY4MzhcbiAqXG4gKiB0eXBlLW5hbWUgPSByZXN0cmljdGVkLW5hbWVcbiAqIHN1YnR5cGUtbmFtZSA9IHJlc3RyaWN0ZWQtbmFtZVxuICogcmVzdHJpY3RlZC1uYW1lID0gcmVzdHJpY3RlZC1uYW1lLWZpcnN0ICoxMjZyZXN0cmljdGVkLW5hbWUtY2hhcnNcbiAqIHJlc3RyaWN0ZWQtbmFtZS1maXJzdCAgPSBBTFBIQSAvIERJR0lUXG4gKiByZXN0cmljdGVkLW5hbWUtY2hhcnMgID0gQUxQSEEgLyBESUdJVCAvIFwiIVwiIC8gXCIjXCIgL1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIFwiJFwiIC8gXCImXCIgLyBcIi1cIiAvIFwiXlwiIC8gXCJfXCJcbiAqIHJlc3RyaWN0ZWQtbmFtZS1jaGFycyA9LyBcIi5cIiA7IENoYXJhY3RlcnMgYmVmb3JlIGZpcnN0IGRvdCBhbHdheXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBzcGVjaWZ5IGEgZmFjZXQgbmFtZVxuICogcmVzdHJpY3RlZC1uYW1lLWNoYXJzID0vIFwiK1wiIDsgQ2hhcmFjdGVycyBhZnRlciBsYXN0IHBsdXMgYWx3YXlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgc3BlY2lmeSBhIHN0cnVjdHVyZWQgc3ludGF4IHN1ZmZpeFxuICogQUxQSEEgPSAgJXg0MS01QSAvICV4NjEtN0EgICA7IEEtWiAvIGEtelxuICogRElHSVQgPSAgJXgzMC0zOSAgICAgICAgICAgICA7IDAtOVxuICovXG52YXIgU1VCVFlQRV9OQU1FX1JFR0VYUCA9IC9eW0EtWmEtejAtOV1bQS1aYS16MC05ISMkJl5fLi1dezAsMTI2fSQvXG52YXIgVFlQRV9OQU1FX1JFR0VYUCA9IC9eW0EtWmEtejAtOV1bQS1aYS16MC05ISMkJl5fLV17MCwxMjZ9JC9cbnZhciBUWVBFX1JFR0VYUCA9IC9eICooW0EtWmEtejAtOV1bQS1aYS16MC05ISMkJl5fLV17MCwxMjZ9KVxcLyhbQS1aYS16MC05XVtBLVphLXowLTkhIyQmXl8uKy1dezAsMTI2fSkgKiQvXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXRcbmV4cG9ydHMucGFyc2UgPSBwYXJzZVxuZXhwb3J0cy50ZXN0ID0gdGVzdFxuXG4vKipcbiAqIEZvcm1hdCBvYmplY3QgdG8gbWVkaWEgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0IChvYmopIHtcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBvYmogaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgdmFyIHN1YnR5cGUgPSBvYmouc3VidHlwZVxuICB2YXIgc3VmZml4ID0gb2JqLnN1ZmZpeFxuICB2YXIgdHlwZSA9IG9iai50eXBlXG5cbiAgaWYgKCF0eXBlIHx8ICFUWVBFX05BTUVfUkVHRVhQLnRlc3QodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHR5cGUnKVxuICB9XG5cbiAgaWYgKCFzdWJ0eXBlIHx8ICFTVUJUWVBFX05BTUVfUkVHRVhQLnRlc3Qoc3VidHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1YnR5cGUnKVxuICB9XG5cbiAgLy8gZm9ybWF0IGFzIHR5cGUvc3VidHlwZVxuICB2YXIgc3RyaW5nID0gdHlwZSArICcvJyArIHN1YnR5cGVcblxuICAvLyBhcHBlbmQgK3N1ZmZpeFxuICBpZiAoc3VmZml4KSB7XG4gICAgaWYgKCFUWVBFX05BTUVfUkVHRVhQLnRlc3Qoc3VmZml4KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWZmaXgnKVxuICAgIH1cblxuICAgIHN0cmluZyArPSAnKycgKyBzdWZmaXhcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdcbn1cblxuLyoqXG4gKiBUZXN0IG1lZGlhIHR5cGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7b2JqZWN0fVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHRlc3QgKHN0cmluZykge1xuICBpZiAoIXN0cmluZykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHN0cmluZyBpcyByZXF1aXJlZCcpXG4gIH1cblxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzdHJpbmcgaXMgcmVxdWlyZWQgdG8gYmUgYSBzdHJpbmcnKVxuICB9XG5cbiAgcmV0dXJuIFRZUEVfUkVHRVhQLnRlc3Qoc3RyaW5nLnRvTG93ZXJDYXNlKCkpXG59XG5cbi8qKlxuICogUGFyc2UgbWVkaWEgdHlwZSB0byBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7b2JqZWN0fVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHBhcnNlIChzdHJpbmcpIHtcbiAgaWYgKCFzdHJpbmcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzdHJpbmcgaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc3RyaW5nIGlzIHJlcXVpcmVkIHRvIGJlIGEgc3RyaW5nJylcbiAgfVxuXG4gIHZhciBtYXRjaCA9IFRZUEVfUkVHRVhQLmV4ZWMoc3RyaW5nLnRvTG93ZXJDYXNlKCkpXG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgbWVkaWEgdHlwZScpXG4gIH1cblxuICB2YXIgdHlwZSA9IG1hdGNoWzFdXG4gIHZhciBzdWJ0eXBlID0gbWF0Y2hbMl1cbiAgdmFyIHN1ZmZpeFxuXG4gIC8vIHN1ZmZpeCBhZnRlciBsYXN0ICtcbiAgdmFyIGluZGV4ID0gc3VidHlwZS5sYXN0SW5kZXhPZignKycpXG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBzdWZmaXggPSBzdWJ0eXBlLnN1YnN0cihpbmRleCArIDEpXG4gICAgc3VidHlwZSA9IHN1YnR5cGUuc3Vic3RyKDAsIGluZGV4KVxuICB9XG5cbiAgcmV0dXJuIG5ldyBNZWRpYVR5cGUodHlwZSwgc3VidHlwZSwgc3VmZml4KVxufVxuXG4vKipcbiAqIENsYXNzIGZvciBNZWRpYVR5cGUgb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1lZGlhVHlwZSAodHlwZSwgc3VidHlwZSwgc3VmZml4KSB7XG4gIHRoaXMudHlwZSA9IHR5cGVcbiAgdGhpcy5zdWJ0eXBlID0gc3VidHlwZVxuICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/music-metadata/node_modules/media-typer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/image.js":
/*!*********************************************!*\
  !*** ./node_modules/next/dist/api/image.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/lib/image-external */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\");\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n//# sourceMappingURL=image.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2ltYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF1RDtBQUNWOztBQUU3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9pbWFnZS5qcz81MjFiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbFwiO1xuZXhwb3J0ICogZnJvbSBcIi4uL3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWxcIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyw0R0FBNEI7O0FBRXpQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/Mzg5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={592:(e,r,t)=>{var n=t(722);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},722:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(592);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qcz8xYzcyIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs1OTI6KGUscix0KT0+e3ZhciBuPXQoNzIyKTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDcyMjplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNTkyKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/picomatch/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n(()=>{\"use strict\";var t={170:(t,e,u)=>{const n=u(510);const isWindows=()=>{if(typeof navigator!==\"undefined\"&&navigator.platform){const t=navigator.platform.toLowerCase();return t===\"win32\"||t===\"windows\"}if(typeof process!==\"undefined\"&&process.platform){return process.platform===\"win32\"}return false};function picomatch(t,e,u=false){if(e&&(e.windows===null||e.windows===undefined)){e={...e,windows:isWindows()}}return n(t,e,u)}Object.assign(picomatch,n);t.exports=picomatch},154:t=>{const e=\"\\\\\\\\/\";const u=`[^${e}]`;const n=\"\\\\.\";const o=\"\\\\+\";const s=\"\\\\?\";const r=\"\\\\/\";const a=\"(?=.)\";const i=\"[^/]\";const c=`(?:${r}|$)`;const p=`(?:^|${r})`;const l=`${n}{1,2}${c}`;const f=`(?!${n})`;const A=`(?!${p}${l})`;const _=`(?!${n}{0,1}${c})`;const R=`(?!${l})`;const E=`[^.${r}]`;const h=`${i}*?`;const g=\"/\";const b={DOT_LITERAL:n,PLUS_LITERAL:o,QMARK_LITERAL:s,SLASH_LITERAL:r,ONE_CHAR:a,QMARK:i,END_ANCHOR:c,DOTS_SLASH:l,NO_DOT:f,NO_DOTS:A,NO_DOT_SLASH:_,NO_DOTS_SLASH:R,QMARK_NO_DOT:E,STAR:h,START_ANCHOR:p,SEP:g};const C={...b,SLASH_LITERAL:`[${e}]`,QMARK:u,STAR:`${u}*?`,DOTS_SLASH:`${n}{1,2}(?:[${e}]|$)`,NO_DOT:`(?!${n})`,NO_DOTS:`(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,NO_DOT_SLASH:`(?!${n}{0,1}(?:[${e}]|$))`,NO_DOTS_SLASH:`(?!${n}{1,2}(?:[${e}]|$))`,QMARK_NO_DOT:`[^.${e}]`,START_ANCHOR:`(?:^|[${e}])`,END_ANCHOR:`(?:[${e}]|$)`,SEP:\"\\\\\"};const y={alnum:\"a-zA-Z0-9\",alpha:\"a-zA-Z\",ascii:\"\\\\x00-\\\\x7F\",blank:\" \\\\t\",cntrl:\"\\\\x00-\\\\x1F\\\\x7F\",digit:\"0-9\",graph:\"\\\\x21-\\\\x7E\",lower:\"a-z\",print:\"\\\\x20-\\\\x7E \",punct:\"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",space:\" \\\\t\\\\r\\\\n\\\\v\\\\f\",upper:\"A-Z\",word:\"A-Za-z0-9_\",xdigit:\"A-Fa-f0-9\"};t.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:y,REGEX_BACKSLASH:/\\\\(?![*+?^${}(|)[\\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\\].,$*+?^{}()|\\\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\\\?)((\\W)(\\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,REPLACEMENTS:{\"***\":\"*\",\"**/**\":\"**\",\"**/**/**\":\"**\"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,extglobChars(t){return{\"!\":{type:\"negate\",open:\"(?:(?!(?:\",close:`))${t.STAR})`},\"?\":{type:\"qmark\",open:\"(?:\",close:\")?\"},\"+\":{type:\"plus\",open:\"(?:\",close:\")+\"},\"*\":{type:\"star\",open:\"(?:\",close:\")*\"},\"@\":{type:\"at\",open:\"(?:\",close:\")\"}}},globChars(t){return t===true?C:b}}},697:(t,e,u)=>{const n=u(154);const o=u(96);const{MAX_LENGTH:s,POSIX_REGEX_SOURCE:r,REGEX_NON_SPECIAL_CHARS:a,REGEX_SPECIAL_CHARS_BACKREF:i,REPLACEMENTS:c}=n;const expandRange=(t,e)=>{if(typeof e.expandRange===\"function\"){return e.expandRange(...t,e)}t.sort();const u=`[${t.join(\"-\")}]`;try{new RegExp(u)}catch(e){return t.map((t=>o.escapeRegex(t))).join(\"..\")}return u};const syntaxError=(t,e)=>`Missing ${t}: \"${e}\" - use \"\\\\\\\\${e}\" to match literal characters`;const parse=(t,e)=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected a string\")}t=c[t]||t;const u={...e};const p=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;let l=t.length;if(l>p){throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`)}const f={type:\"bos\",value:\"\",output:u.prepend||\"\"};const A=[f];const _=u.capture?\"\":\"?:\";const R=n.globChars(u.windows);const E=n.extglobChars(R);const{DOT_LITERAL:h,PLUS_LITERAL:g,SLASH_LITERAL:b,ONE_CHAR:C,DOTS_SLASH:y,NO_DOT:$,NO_DOT_SLASH:x,NO_DOTS_SLASH:S,QMARK:H,QMARK_NO_DOT:v,STAR:d,START_ANCHOR:L}=R;const globstar=t=>`(${_}(?:(?!${L}${t.dot?y:h}).)*?)`;const T=u.dot?\"\":$;const O=u.dot?H:v;let k=u.bash===true?globstar(u):d;if(u.capture){k=`(${k})`}if(typeof u.noext===\"boolean\"){u.noextglob=u.noext}const m={input:t,index:-1,start:0,dot:u.dot===true,consumed:\"\",output:\"\",prefix:\"\",backtrack:false,negated:false,brackets:0,braces:0,parens:0,quotes:0,globstar:false,tokens:A};t=o.removePrefix(t,m);l=t.length;const w=[];const N=[];const I=[];let B=f;let G;const eos=()=>m.index===l-1;const D=m.peek=(e=1)=>t[m.index+e];const M=m.advance=()=>t[++m.index]||\"\";const remaining=()=>t.slice(m.index+1);const consume=(t=\"\",e=0)=>{m.consumed+=t;m.index+=e};const append=t=>{m.output+=t.output!=null?t.output:t.value;consume(t.value)};const negate=()=>{let t=1;while(D()===\"!\"&&(D(2)!==\"(\"||D(3)===\"?\")){M();m.start++;t++}if(t%2===0){return false}m.negated=true;m.start++;return true};const increment=t=>{m[t]++;I.push(t)};const decrement=t=>{m[t]--;I.pop()};const push=t=>{if(B.type===\"globstar\"){const e=m.braces>0&&(t.type===\"comma\"||t.type===\"brace\");const u=t.extglob===true||w.length&&(t.type===\"pipe\"||t.type===\"paren\");if(t.type!==\"slash\"&&t.type!==\"paren\"&&!e&&!u){m.output=m.output.slice(0,-B.output.length);B.type=\"star\";B.value=\"*\";B.output=k;m.output+=B.output}}if(w.length&&t.type!==\"paren\"){w[w.length-1].inner+=t.value}if(t.value||t.output)append(t);if(B&&B.type===\"text\"&&t.type===\"text\"){B.output=(B.output||B.value)+t.value;B.value+=t.value;return}t.prev=B;A.push(t);B=t};const extglobOpen=(t,e)=>{const n={...E[e],conditions:1,inner:\"\"};n.prev=B;n.parens=m.parens;n.output=m.output;const o=(u.capture?\"(\":\"\")+n.open;increment(\"parens\");push({type:t,value:e,output:m.output?\"\":C});push({type:\"paren\",extglob:true,value:M(),output:o});w.push(n)};const extglobClose=t=>{let n=t.close+(u.capture?\")\":\"\");let o;if(t.type===\"negate\"){let s=k;if(t.inner&&t.inner.length>1&&t.inner.includes(\"/\")){s=globstar(u)}if(s!==k||eos()||/^\\)+$/.test(remaining())){n=t.close=`)$))${s}`}if(t.inner.includes(\"*\")&&(o=remaining())&&/^\\.[^\\\\/.]+$/.test(o)){const u=parse(o,{...e,fastpaths:false}).output;n=t.close=`)${u})${s})`}if(t.prev.type===\"bos\"){m.negatedExtglob=true}}push({type:\"paren\",extglob:true,value:G,output:n});decrement(\"parens\")};if(u.fastpaths!==false&&!/(^[*!]|[/()[\\]{}\"])/.test(t)){let n=false;let s=t.replace(i,((t,e,u,o,s,r)=>{if(o===\"\\\\\"){n=true;return t}if(o===\"?\"){if(e){return e+o+(s?H.repeat(s.length):\"\")}if(r===0){return O+(s?H.repeat(s.length):\"\")}return H.repeat(u.length)}if(o===\".\"){return h.repeat(u.length)}if(o===\"*\"){if(e){return e+o+(s?k:\"\")}return k}return e?t:`\\\\${t}`}));if(n===true){if(u.unescape===true){s=s.replace(/\\\\/g,\"\")}else{s=s.replace(/\\\\+/g,(t=>t.length%2===0?\"\\\\\\\\\":t?\"\\\\\":\"\"))}}if(s===t&&u.contains===true){m.output=t;return m}m.output=o.wrapOutput(s,m,e);return m}while(!eos()){G=M();if(G===\"\\0\"){continue}if(G===\"\\\\\"){const t=D();if(t===\"/\"&&u.bash!==true){continue}if(t===\".\"||t===\";\"){continue}if(!t){G+=\"\\\\\";push({type:\"text\",value:G});continue}const e=/^\\\\+/.exec(remaining());let n=0;if(e&&e[0].length>2){n=e[0].length;m.index+=n;if(n%2!==0){G+=\"\\\\\"}}if(u.unescape===true){G=M()}else{G+=M()}if(m.brackets===0){push({type:\"text\",value:G});continue}}if(m.brackets>0&&(G!==\"]\"||B.value===\"[\"||B.value===\"[^\")){if(u.posix!==false&&G===\":\"){const t=B.value.slice(1);if(t.includes(\"[\")){B.posix=true;if(t.includes(\":\")){const t=B.value.lastIndexOf(\"[\");const e=B.value.slice(0,t);const u=B.value.slice(t+2);const n=r[u];if(n){B.value=e+n;m.backtrack=true;M();if(!f.output&&A.indexOf(B)===1){f.output=C}continue}}}}if(G===\"[\"&&D()!==\":\"||G===\"-\"&&D()===\"]\"){G=`\\\\${G}`}if(G===\"]\"&&(B.value===\"[\"||B.value===\"[^\")){G=`\\\\${G}`}if(u.posix===true&&G===\"!\"&&B.value===\"[\"){G=\"^\"}B.value+=G;append({value:G});continue}if(m.quotes===1&&G!=='\"'){G=o.escapeRegex(G);B.value+=G;append({value:G});continue}if(G==='\"'){m.quotes=m.quotes===1?0:1;if(u.keepQuotes===true){push({type:\"text\",value:G})}continue}if(G===\"(\"){increment(\"parens\");push({type:\"paren\",value:G});continue}if(G===\")\"){if(m.parens===0&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"(\"))}const t=w[w.length-1];if(t&&m.parens===t.parens+1){extglobClose(w.pop());continue}push({type:\"paren\",value:G,output:m.parens?\")\":\"\\\\)\"});decrement(\"parens\");continue}if(G===\"[\"){if(u.nobracket===true||!remaining().includes(\"]\")){if(u.nobracket!==true&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"closing\",\"]\"))}G=`\\\\${G}`}else{increment(\"brackets\")}push({type:\"bracket\",value:G});continue}if(G===\"]\"){if(u.nobracket===true||B&&B.type===\"bracket\"&&B.value.length===1){push({type:\"text\",value:G,output:`\\\\${G}`});continue}if(m.brackets===0){if(u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"[\"))}push({type:\"text\",value:G,output:`\\\\${G}`});continue}decrement(\"brackets\");const t=B.value.slice(1);if(B.posix!==true&&t[0]===\"^\"&&!t.includes(\"/\")){G=`/${G}`}B.value+=G;append({value:G});if(u.literalBrackets===false||o.hasRegexChars(t)){continue}const e=o.escapeRegex(B.value);m.output=m.output.slice(0,-B.value.length);if(u.literalBrackets===true){m.output+=e;B.value=e;continue}B.value=`(${_}${e}|${B.value})`;m.output+=B.value;continue}if(G===\"{\"&&u.nobrace!==true){increment(\"braces\");const t={type:\"brace\",value:G,output:\"(\",outputIndex:m.output.length,tokensIndex:m.tokens.length};N.push(t);push(t);continue}if(G===\"}\"){const t=N[N.length-1];if(u.nobrace===true||!t){push({type:\"text\",value:G,output:G});continue}let e=\")\";if(t.dots===true){const t=A.slice();const n=[];for(let e=t.length-1;e>=0;e--){A.pop();if(t[e].type===\"brace\"){break}if(t[e].type!==\"dots\"){n.unshift(t[e].value)}}e=expandRange(n,u);m.backtrack=true}if(t.comma!==true&&t.dots!==true){const u=m.output.slice(0,t.outputIndex);const n=m.tokens.slice(t.tokensIndex);t.value=t.output=\"\\\\{\";G=e=\"\\\\}\";m.output=u;for(const t of n){m.output+=t.output||t.value}}push({type:\"brace\",value:G,output:e});decrement(\"braces\");N.pop();continue}if(G===\"|\"){if(w.length>0){w[w.length-1].conditions++}push({type:\"text\",value:G});continue}if(G===\",\"){let t=G;const e=N[N.length-1];if(e&&I[I.length-1]===\"braces\"){e.comma=true;t=\"|\"}push({type:\"comma\",value:G,output:t});continue}if(G===\"/\"){if(B.type===\"dot\"&&m.index===m.start+1){m.start=m.index+1;m.consumed=\"\";m.output=\"\";A.pop();B=f;continue}push({type:\"slash\",value:G,output:b});continue}if(G===\".\"){if(m.braces>0&&B.type===\"dot\"){if(B.value===\".\")B.output=h;const t=N[N.length-1];B.type=\"dots\";B.output+=G;B.value+=G;t.dots=true;continue}if(m.braces+m.parens===0&&B.type!==\"bos\"&&B.type!==\"slash\"){push({type:\"text\",value:G,output:h});continue}push({type:\"dot\",value:G,output:h});continue}if(G===\"?\"){const t=B&&B.value===\"(\";if(!t&&u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"qmark\",G);continue}if(B&&B.type===\"paren\"){const t=D();let e=G;if(B.value===\"(\"&&!/[!=<:]/.test(t)||t===\"<\"&&!/<([!=]|\\w+>)/.test(remaining())){e=`\\\\${G}`}push({type:\"text\",value:G,output:e});continue}if(u.dot!==true&&(B.type===\"slash\"||B.type===\"bos\")){push({type:\"qmark\",value:G,output:v});continue}push({type:\"qmark\",value:G,output:H});continue}if(G===\"!\"){if(u.noextglob!==true&&D()===\"(\"){if(D(2)!==\"?\"||!/[!=<:]/.test(D(3))){extglobOpen(\"negate\",G);continue}}if(u.nonegate!==true&&m.index===0){negate();continue}}if(G===\"+\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"plus\",G);continue}if(B&&B.value===\"(\"||u.regex===false){push({type:\"plus\",value:G,output:g});continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\"||B.type===\"brace\")||m.parens>0){push({type:\"plus\",value:G});continue}push({type:\"plus\",value:g});continue}if(G===\"@\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){push({type:\"at\",extglob:true,value:G,output:\"\"});continue}push({type:\"text\",value:G});continue}if(G!==\"*\"){if(G===\"$\"||G===\"^\"){G=`\\\\${G}`}const t=a.exec(remaining());if(t){G+=t[0];m.index+=t[0].length}push({type:\"text\",value:G});continue}if(B&&(B.type===\"globstar\"||B.star===true)){B.type=\"star\";B.star=true;B.value+=G;B.output=k;m.backtrack=true;m.globstar=true;consume(G);continue}let e=remaining();if(u.noextglob!==true&&/^\\([^?]/.test(e)){extglobOpen(\"star\",G);continue}if(B.type===\"star\"){if(u.noglobstar===true){consume(G);continue}const n=B.prev;const o=n.prev;const s=n.type===\"slash\"||n.type===\"bos\";const r=o&&(o.type===\"star\"||o.type===\"globstar\");if(u.bash===true&&(!s||e[0]&&e[0]!==\"/\")){push({type:\"star\",value:G,output:\"\"});continue}const a=m.braces>0&&(n.type===\"comma\"||n.type===\"brace\");const i=w.length&&(n.type===\"pipe\"||n.type===\"paren\");if(!s&&n.type!==\"paren\"&&!a&&!i){push({type:\"star\",value:G,output:\"\"});continue}while(e.slice(0,3)===\"/**\"){const u=t[m.index+4];if(u&&u!==\"/\"){break}e=e.slice(3);consume(\"/**\",3)}if(n.type===\"bos\"&&eos()){B.type=\"globstar\";B.value+=G;B.output=globstar(u);m.output=B.output;m.globstar=true;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&!r&&eos()){m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=globstar(u)+(u.strictSlashes?\")\":\"|$)\");B.value+=G;m.globstar=true;m.output+=n.output+B.output;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&e[0]===\"/\"){const t=e[1]!==void 0?\"|$\":\"\";m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=`${globstar(u)}${b}|${b}${t})`;B.value+=G;m.output+=n.output+B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}if(n.type===\"bos\"&&e[0]===\"/\"){B.type=\"globstar\";B.value+=G;B.output=`(?:^|${b}|${globstar(u)}${b})`;m.output=B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}m.output=m.output.slice(0,-B.output.length);B.type=\"globstar\";B.output=globstar(u);B.value+=G;m.output+=B.output;m.globstar=true;consume(G);continue}const n={type:\"star\",value:G,output:k};if(u.bash===true){n.output=\".*?\";if(B.type===\"bos\"||B.type===\"slash\"){n.output=T+n.output}push(n);continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\")&&u.regex===true){n.output=G;push(n);continue}if(m.index===m.start||B.type===\"slash\"||B.type===\"dot\"){if(B.type===\"dot\"){m.output+=x;B.output+=x}else if(u.dot===true){m.output+=S;B.output+=S}else{m.output+=T;B.output+=T}if(D()!==\"*\"){m.output+=C;B.output+=C}}push(n)}while(m.brackets>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"]\"));m.output=o.escapeLast(m.output,\"[\");decrement(\"brackets\")}while(m.parens>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\")\"));m.output=o.escapeLast(m.output,\"(\");decrement(\"parens\")}while(m.braces>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"}\"));m.output=o.escapeLast(m.output,\"{\");decrement(\"braces\")}if(u.strictSlashes!==true&&(B.type===\"star\"||B.type===\"bracket\")){push({type:\"maybe_slash\",value:\"\",output:`${b}?`})}if(m.backtrack===true){m.output=\"\";for(const t of m.tokens){m.output+=t.output!=null?t.output:t.value;if(t.suffix){m.output+=t.suffix}}}return m};parse.fastpaths=(t,e)=>{const u={...e};const r=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;const a=t.length;if(a>r){throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`)}t=c[t]||t;const{DOT_LITERAL:i,SLASH_LITERAL:p,ONE_CHAR:l,DOTS_SLASH:f,NO_DOT:A,NO_DOTS:_,NO_DOTS_SLASH:R,STAR:E,START_ANCHOR:h}=n.globChars(u.windows);const g=u.dot?_:A;const b=u.dot?R:A;const C=u.capture?\"\":\"?:\";const y={negated:false,prefix:\"\"};let $=u.bash===true?\".*?\":E;if(u.capture){$=`(${$})`}const globstar=t=>{if(t.noglobstar===true)return $;return`(${C}(?:(?!${h}${t.dot?f:i}).)*?)`};const create=t=>{switch(t){case\"*\":return`${g}${l}${$}`;case\".*\":return`${i}${l}${$}`;case\"*.*\":return`${g}${$}${i}${l}${$}`;case\"*/*\":return`${g}${$}${p}${l}${b}${$}`;case\"**\":return g+globstar(u);case\"**/*\":return`(?:${g}${globstar(u)}${p})?${b}${l}${$}`;case\"**/*.*\":return`(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;case\"**/.*\":return`(?:${g}${globstar(u)}${p})?${i}${l}${$}`;default:{const e=/^(.*?)\\.(\\w+)$/.exec(t);if(!e)return;const u=create(e[1]);if(!u)return;return u+i+e[2]}}};const x=o.removePrefix(t,y);let S=create(x);if(S&&u.strictSlashes!==true){S+=`${p}?`}return S};t.exports=parse},510:(t,e,u)=>{const n=u(716);const o=u(697);const s=u(96);const r=u(154);const isObject=t=>t&&typeof t===\"object\"&&!Array.isArray(t);const picomatch=(t,e,u=false)=>{if(Array.isArray(t)){const n=t.map((t=>picomatch(t,e,u)));const arrayMatcher=t=>{for(const e of n){const u=e(t);if(u)return u}return false};return arrayMatcher}const n=isObject(t)&&t.tokens&&t.input;if(t===\"\"||typeof t!==\"string\"&&!n){throw new TypeError(\"Expected pattern to be a non-empty string\")}const o=e||{};const s=o.windows;const r=n?picomatch.compileRe(t,e):picomatch.makeRe(t,e,false,true);const a=r.state;delete r.state;let isIgnored=()=>false;if(o.ignore){const t={...e,ignore:null,onMatch:null,onResult:null};isIgnored=picomatch(o.ignore,t,u)}const matcher=(u,n=false)=>{const{isMatch:i,match:c,output:p}=picomatch.test(u,r,e,{glob:t,posix:s});const l={glob:t,state:a,regex:r,posix:s,input:u,output:p,match:c,isMatch:i};if(typeof o.onResult===\"function\"){o.onResult(l)}if(i===false){l.isMatch=false;return n?l:false}if(isIgnored(u)){if(typeof o.onIgnore===\"function\"){o.onIgnore(l)}l.isMatch=false;return n?l:false}if(typeof o.onMatch===\"function\"){o.onMatch(l)}return n?l:true};if(u){matcher.state=a}return matcher};picomatch.test=(t,e,u,{glob:n,posix:o}={})=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected input to be a string\")}if(t===\"\"){return{isMatch:false,output:\"\"}}const r=u||{};const a=r.format||(o?s.toPosixSlashes:null);let i=t===n;let c=i&&a?a(t):t;if(i===false){c=a?a(t):t;i=c===n}if(i===false||r.capture===true){if(r.matchBase===true||r.basename===true){i=picomatch.matchBase(t,e,u,o)}else{i=e.exec(c)}}return{isMatch:Boolean(i),match:i,output:c}};picomatch.matchBase=(t,e,u)=>{const n=e instanceof RegExp?e:picomatch.makeRe(e,u);return n.test(s.basename(t))};picomatch.isMatch=(t,e,u)=>picomatch(e,u)(t);picomatch.parse=(t,e)=>{if(Array.isArray(t))return t.map((t=>picomatch.parse(t,e)));return o(t,{...e,fastpaths:false})};picomatch.scan=(t,e)=>n(t,e);picomatch.compileRe=(t,e,u=false,n=false)=>{if(u===true){return t.output}const o=e||{};const s=o.contains?\"\":\"^\";const r=o.contains?\"\":\"$\";let a=`${s}(?:${t.output})${r}`;if(t&&t.negated===true){a=`^(?!${a}).*$`}const i=picomatch.toRegex(a,e);if(n===true){i.state=t}return i};picomatch.makeRe=(t,e={},u=false,n=false)=>{if(!t||typeof t!==\"string\"){throw new TypeError(\"Expected a non-empty string\")}let s={negated:false,fastpaths:true};if(e.fastpaths!==false&&(t[0]===\".\"||t[0]===\"*\")){s.output=o.fastpaths(t,e)}if(!s.output){s=o(t,e)}return picomatch.compileRe(s,e,u,n)};picomatch.toRegex=(t,e)=>{try{const u=e||{};return new RegExp(t,u.flags||(u.nocase?\"i\":\"\"))}catch(t){if(e&&e.debug===true)throw t;return/$^/}};picomatch.constants=r;t.exports=picomatch},716:(t,e,u)=>{const n=u(96);const{CHAR_ASTERISK:o,CHAR_AT:s,CHAR_BACKWARD_SLASH:r,CHAR_COMMA:a,CHAR_DOT:i,CHAR_EXCLAMATION_MARK:c,CHAR_FORWARD_SLASH:p,CHAR_LEFT_CURLY_BRACE:l,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_PLUS:_,CHAR_QUESTION_MARK:R,CHAR_RIGHT_CURLY_BRACE:E,CHAR_RIGHT_PARENTHESES:h,CHAR_RIGHT_SQUARE_BRACKET:g}=u(154);const isPathSeparator=t=>t===p||t===r;const depth=t=>{if(t.isPrefix!==true){t.depth=t.isGlobstar?Infinity:1}};const scan=(t,e)=>{const u=e||{};const b=t.length-1;const C=u.parts===true||u.scanToEnd===true;const y=[];const $=[];const x=[];let S=t;let H=-1;let v=0;let d=0;let L=false;let T=false;let O=false;let k=false;let m=false;let w=false;let N=false;let I=false;let B=false;let G=false;let D=0;let M;let P;let K={value:\"\",depth:0,isGlob:false};const eos=()=>H>=b;const peek=()=>S.charCodeAt(H+1);const advance=()=>{M=P;return S.charCodeAt(++H)};while(H<b){P=advance();let t;if(P===r){N=K.backslashes=true;P=advance();if(P===l){w=true}continue}if(w===true||P===l){D++;while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;advance();continue}if(P===l){D++;continue}if(w!==true&&P===i&&(P=advance())===i){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(w!==true&&P===a){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===E){D--;if(D===0){w=false;L=K.isBrace=true;G=true;break}}}if(C===true){continue}break}if(P===p){y.push(H);$.push(K);K={value:\"\",depth:0,isGlob:false};if(G===true)continue;if(M===i&&H===v+1){v+=2;continue}d=H+1;continue}if(u.noext!==true){const t=P===_||P===s||P===o||P===R||P===c;if(t===true&&peek()===f){O=K.isGlob=true;k=K.isExtglob=true;G=true;if(P===c&&H===v){B=true}if(C===true){while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;P=advance();continue}if(P===h){O=K.isGlob=true;G=true;break}}continue}break}}if(P===o){if(M===o)m=K.isGlobstar=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===R){O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===A){while(eos()!==true&&(t=advance())){if(t===r){N=K.backslashes=true;advance();continue}if(t===g){T=K.isBracket=true;O=K.isGlob=true;G=true;break}}if(C===true){continue}break}if(u.nonegate!==true&&P===c&&H===v){I=K.negated=true;v++;continue}if(u.noparen!==true&&P===f){O=K.isGlob=true;if(C===true){while(eos()!==true&&(P=advance())){if(P===f){N=K.backslashes=true;P=advance();continue}if(P===h){G=true;break}}continue}break}if(O===true){G=true;if(C===true){continue}break}}if(u.noext===true){k=false;O=false}let U=S;let X=\"\";let F=\"\";if(v>0){X=S.slice(0,v);S=S.slice(v);d-=v}if(U&&O===true&&d>0){U=S.slice(0,d);F=S.slice(d)}else if(O===true){U=\"\";F=S}else{U=S}if(U&&U!==\"\"&&U!==\"/\"&&U!==S){if(isPathSeparator(U.charCodeAt(U.length-1))){U=U.slice(0,-1)}}if(u.unescape===true){if(F)F=n.removeBackslashes(F);if(U&&N===true){U=n.removeBackslashes(U)}}const Q={prefix:X,input:t,start:v,base:U,glob:F,isBrace:L,isBracket:T,isGlob:O,isExtglob:k,isGlobstar:m,negated:I,negatedExtglob:B};if(u.tokens===true){Q.maxDepth=0;if(!isPathSeparator(P)){$.push(K)}Q.tokens=$}if(u.parts===true||u.tokens===true){let e;for(let n=0;n<y.length;n++){const o=e?e+1:v;const s=y[n];const r=t.slice(o,s);if(u.tokens){if(n===0&&v!==0){$[n].isPrefix=true;$[n].value=X}else{$[n].value=r}depth($[n]);Q.maxDepth+=$[n].depth}if(n!==0||r!==\"\"){x.push(r)}e=s}if(e&&e+1<t.length){const n=t.slice(e+1);x.push(n);if(u.tokens){$[$.length-1].value=n;depth($[$.length-1]);Q.maxDepth+=$[$.length-1].depth}}Q.slashes=y;Q.parts=x}return Q};t.exports=scan},96:(t,e,u)=>{const{REGEX_BACKSLASH:n,REGEX_REMOVE_BACKSLASH:o,REGEX_SPECIAL_CHARS:s,REGEX_SPECIAL_CHARS_GLOBAL:r}=u(154);e.isObject=t=>t!==null&&typeof t===\"object\"&&!Array.isArray(t);e.hasRegexChars=t=>s.test(t);e.isRegexChar=t=>t.length===1&&e.hasRegexChars(t);e.escapeRegex=t=>t.replace(r,\"\\\\$1\");e.toPosixSlashes=t=>t.replace(n,\"/\");e.removeBackslashes=t=>t.replace(o,(t=>t===\"\\\\\"?\"\":t));e.escapeLast=(t,u,n)=>{const o=t.lastIndexOf(u,n);if(o===-1)return t;if(t[o-1]===\"\\\\\")return e.escapeLast(t,u,o-1);return`${t.slice(0,o)}\\\\${t.slice(o)}`};e.removePrefix=(t,e={})=>{let u=t;if(u.startsWith(\"./\")){u=u.slice(2);e.prefix=\"./\"}return u};e.wrapOutput=(t,e={},u={})=>{const n=u.contains?\"\":\"^\";const o=u.contains?\"\":\"$\";let s=`${n}(?:${t})${o}`;if(e.negated===true){s=`(?:^(?!${s}).*$)`}return s};e.basename=(t,{windows:e}={})=>{const u=t.split(e?/[\\\\/]/:\"/\");const n=u[u.length-1];if(n===\"\"){return u[u.length-2]}return n}}};var e={};function __nccwpck_require__(u){var n=e[u];if(n!==undefined){return n.exports}var o=e[u]={exports:{}};var s=true;try{t[u](o,o.exports,__nccwpck_require__);s=false}finally{if(s)delete e[u]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var u=__nccwpck_require__(170);module.exports=u})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGljb21hdGNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTSxhQUFhLE9BQU8sY0FBYyxlQUFlLHFCQUFxQix1REFBdUQseUNBQXlDLGtDQUFrQyxVQUFVLE9BQU8sZ0JBQWdCLE9BQU8sV0FBVyxPQUFPLE9BQU8sb0JBQW9CLGNBQWMsZ0NBQWdDLGlEQUFpRCxHQUFHLDBCQUEwQixnQkFBZ0IsMkJBQTJCLG9CQUFvQixTQUFTLGdCQUFnQixhQUFhLEVBQUUsR0FBRyxjQUFjLGNBQWMsY0FBYyxjQUFjLGdCQUFnQixlQUFlLGNBQWMsRUFBRSxLQUFLLGdCQUFnQixFQUFFLEdBQUcsV0FBVyxHQUFHLElBQUksRUFBRSxFQUFFLEVBQUUsY0FBYyxFQUFFLEdBQUcsY0FBYyxFQUFFLEVBQUUsRUFBRSxHQUFHLGNBQWMsR0FBRyxJQUFJLEVBQUUsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLFdBQVcsRUFBRSxJQUFJLFlBQVksU0FBUyx3TUFBd00sU0FBUyx1QkFBdUIsRUFBRSxtQkFBbUIsRUFBRSxrQkFBa0IsR0FBRyxJQUFJLE1BQU0sRUFBRSxtQkFBbUIsRUFBRSx1QkFBdUIsRUFBRSxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMkJBQTJCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEVBQUUseUJBQXlCLEVBQUUsc0JBQXNCLEVBQUUsZ0JBQWdCLFNBQVMseUxBQXlMLGFBQWEsRUFBRSw4RUFBOEUsV0FBVyxzRUFBc0UscURBQXFELHlDQUF5QyxnR0FBZ0csNEVBQTRFLHVDQUF1QyxtM0JBQW0zQixPQUFPLEtBQUssMENBQTBDLE9BQU8sR0FBRyxNQUFNLG1DQUFtQyxNQUFNLGtDQUFrQyxNQUFNLGtDQUFrQyxNQUFNLGlDQUFpQyxjQUFjLHNCQUFzQixlQUFlLGVBQWUsY0FBYyxNQUFNLHlHQUF5RyxHQUFHLDBCQUEwQixzQ0FBc0MsNkJBQTZCLFNBQVMsWUFBWSxZQUFZLEdBQUcsSUFBSSxjQUFjLFNBQVMsK0NBQStDLFVBQVUsb0NBQW9DLEVBQUUsS0FBSyxFQUFFLGVBQWUsRUFBRSwrQkFBK0Isb0JBQW9CLHdCQUF3Qix5Q0FBeUMsVUFBVSxTQUFTLE1BQU0sZ0VBQWdFLGVBQWUsUUFBUSx1Q0FBdUMsRUFBRSxvQ0FBb0MsRUFBRSxHQUFHLFNBQVMsMENBQTBDLFlBQVksMEJBQTBCLCtCQUErQiwwQkFBMEIsTUFBTSwwSkFBMEosR0FBRyxzQkFBc0IsRUFBRSxRQUFRLEVBQUUsRUFBRSxVQUFVLFFBQVEsbUJBQW1CLGtCQUFrQixrQ0FBa0MsY0FBYyxNQUFNLEVBQUUsR0FBRywrQkFBK0Isb0JBQW9CLFNBQVMsdUtBQXVLLHNCQUFzQixXQUFXLFdBQVcsV0FBVyxXQUFXLFFBQVEsTUFBTSw0QkFBNEIsbUNBQW1DLHVDQUF1Qyx1Q0FBdUMsMkJBQTJCLGNBQWMsWUFBWSxpQkFBaUIsMENBQTBDLGtCQUFrQixrQkFBa0IsUUFBUSwyQ0FBMkMsSUFBSSxVQUFVLElBQUksWUFBWSxhQUFhLGVBQWUsVUFBVSxhQUFhLG9CQUFvQixPQUFPLFdBQVcsb0JBQW9CLE9BQU8sU0FBUyxlQUFlLHdCQUF3Qix5REFBeUQsd0VBQXdFLCtDQUErQyw0Q0FBNEMsY0FBYyxZQUFZLFdBQVcsb0JBQW9CLCtCQUErQiw2QkFBNkIsK0JBQStCLHdDQUF3QyxxQ0FBcUMsaUJBQWlCLE9BQU8sU0FBUyxVQUFVLEtBQUssMEJBQTBCLFNBQVMsK0JBQStCLFNBQVMsa0JBQWtCLGtCQUFrQixrQ0FBa0Msb0JBQW9CLE1BQU0sb0NBQW9DLEVBQUUsTUFBTSw2Q0FBNkMsRUFBRSxXQUFXLHVCQUF1QixpQ0FBaUMsTUFBTSxzQkFBc0IsUUFBUSxxREFBcUQsY0FBYyw0Q0FBNEMsaUJBQWlCLEVBQUUsRUFBRSxtRUFBbUUsaUJBQWlCLHFCQUFxQixTQUFTLGNBQWMsRUFBRSxHQUFHLEVBQUUsR0FBRyx3QkFBd0IsdUJBQXVCLE1BQU0sMkNBQTJDLEVBQUUscUJBQXFCLDBDQUEwQyxjQUFjLFlBQVksbUNBQW1DLGFBQWEsT0FBTyxTQUFTLFlBQVksTUFBTSxxQ0FBcUMsVUFBVSxtQ0FBbUMsMEJBQTBCLFlBQVksMEJBQTBCLFlBQVksTUFBTSxvQkFBb0IsU0FBUyxnQkFBZ0IsRUFBRSxFQUFFLEdBQUcsYUFBYSxzQkFBc0Isc0JBQXNCLEtBQUssMERBQTBELDZCQUE2QixXQUFXLFNBQVMsNkJBQTZCLFNBQVMsY0FBYyxNQUFNLGFBQWEsU0FBUyxhQUFhLFlBQVksMkJBQTJCLFNBQVMsa0JBQWtCLEdBQUcsU0FBUyxPQUFPLFFBQVEsTUFBTSxvQkFBb0IsRUFBRSxTQUFTLGlDQUFpQyxRQUFRLHFCQUFxQixjQUFjLFdBQVcsWUFBWSxTQUFTLHNCQUFzQixNQUFNLEtBQUssT0FBTyxtQkFBbUIsTUFBTSxvQkFBb0IsRUFBRSxVQUFVLDJEQUEyRCw2QkFBNkIseUJBQXlCLG9CQUFvQixhQUFhLG9CQUFvQixpQ0FBaUMsMkJBQTJCLDJCQUEyQixhQUFhLE1BQU0sWUFBWSxpQkFBaUIsSUFBSSxnQ0FBZ0MsV0FBVyxZQUFZLDJDQUEyQyxPQUFPLEVBQUUsRUFBRSw2Q0FBNkMsT0FBTyxFQUFFLEVBQUUsMkNBQTJDLE1BQU0sV0FBVyxRQUFRLFFBQVEsRUFBRSxTQUFTLDBCQUEwQixtQkFBbUIsV0FBVyxRQUFRLFFBQVEsRUFBRSxTQUFTLFlBQVksMEJBQTBCLHdCQUF3QixNQUFNLG9CQUFvQixFQUFFLFNBQVMsWUFBWSxvQkFBb0IsTUFBTSxxQkFBcUIsRUFBRSxTQUFTLFlBQVksMENBQTBDLGtEQUFrRCxzQkFBc0IsNkJBQTZCLHNCQUFzQixTQUFTLE1BQU0sK0NBQStDLEVBQUUsb0JBQW9CLFNBQVMsWUFBWSxtREFBbUQsZ0RBQWdELGtEQUFrRCxPQUFPLEVBQUUsRUFBRSxLQUFLLHNCQUFzQixNQUFNLHVCQUF1QixFQUFFLFNBQVMsWUFBWSxrRUFBa0UsTUFBTSxnQ0FBZ0MsRUFBRSxFQUFFLEVBQUUsU0FBUyxtQkFBbUIsNEJBQTRCLGtEQUFrRCxNQUFNLGdDQUFnQyxFQUFFLEVBQUUsRUFBRSxTQUFTLHNCQUFzQix5QkFBeUIsaURBQWlELE1BQU0sRUFBRSxFQUFFLFdBQVcsUUFBUSxRQUFRLEVBQUUsa0RBQWtELFNBQVMsK0JBQStCLDJDQUEyQyw2QkFBNkIsWUFBWSxVQUFVLFNBQVMsWUFBWSxFQUFFLEVBQUUsRUFBRSxHQUFHLFFBQVEsR0FBRyxrQkFBa0IsU0FBUyxTQUFTLHFCQUFxQixvQkFBb0IsU0FBUyx5RkFBeUYsVUFBVSxRQUFRLFNBQVMsU0FBUyxHQUFHLHNCQUFzQix5QkFBeUIsTUFBTSw2QkFBNkIsRUFBRSxTQUFTLFVBQVUsa0JBQWtCLGtCQUFrQixXQUFXLHFCQUFxQixLQUFLLEtBQUssUUFBUSx3QkFBd0IsTUFBTSx1QkFBdUIsdUJBQXVCLG1CQUFtQixpQkFBaUIsa0NBQWtDLHdDQUF3QyxzQ0FBc0MscUJBQXFCLEVBQUUsUUFBUSxFQUFFLFdBQVcsa0JBQWtCLDZCQUE2QixNQUFNLDhCQUE4QixFQUFFLG9CQUFvQixRQUFRLFNBQVMsWUFBWSxlQUFlLDJCQUEyQixNQUFNLG9CQUFvQixFQUFFLFNBQVMsWUFBWSxRQUFRLHNCQUFzQixnQ0FBZ0MsYUFBYSxNQUFNLE1BQU0sOEJBQThCLEVBQUUsU0FBUyxZQUFZLHdDQUF3QyxrQkFBa0IsY0FBYyxZQUFZLFFBQVEsSUFBSSxTQUFTLE1BQU0sOEJBQThCLEVBQUUsU0FBUyxZQUFZLCtCQUErQiw0QkFBNEIsc0JBQXNCLGNBQWMsWUFBWSxXQUFXLFlBQVksU0FBUyw0REFBNEQsTUFBTSw2QkFBNkIsRUFBRSxTQUFTLE1BQU0sNEJBQTRCLEVBQUUsU0FBUyxZQUFZLHlCQUF5QixrREFBa0QsdUJBQXVCLFNBQVMsd0JBQXdCLFlBQVksUUFBUSxpRkFBaUYsT0FBTyxFQUFFLEVBQUUsTUFBTSw2QkFBNkIsRUFBRSxTQUFTLHFEQUFxRCxNQUFNLDhCQUE4QixFQUFFLFNBQVMsTUFBTSw4QkFBOEIsRUFBRSxTQUFTLFlBQVksa0NBQWtDLHFDQUFxQyx3QkFBd0IsVUFBVSxtQ0FBbUMsU0FBUyxVQUFVLFlBQVksOENBQThDLHNCQUFzQixTQUFTLHNDQUFzQyxNQUFNLDZCQUE2QixFQUFFLFNBQVMsNEVBQTRFLE1BQU0sb0JBQW9CLEVBQUUsU0FBUyxNQUFNLG9CQUFvQixFQUFFLFNBQVMsWUFBWSw4Q0FBOEMsTUFBTSx5Q0FBeUMsRUFBRSxTQUFTLE1BQU0sb0JBQW9CLEVBQUUsU0FBUyxZQUFZLHFCQUFxQixPQUFPLEVBQUUsRUFBRSw0QkFBNEIsTUFBTSxRQUFRLHFCQUFxQixNQUFNLG9CQUFvQixFQUFFLFNBQVMsNENBQTRDLGNBQWMsWUFBWSxXQUFXLFdBQVcsaUJBQWlCLGdCQUFnQixXQUFXLFNBQVMsa0JBQWtCLDBDQUEwQyxzQkFBc0IsU0FBUyxvQkFBb0Isd0JBQXdCLFdBQVcsU0FBUyxlQUFlLGVBQWUseUNBQXlDLGtEQUFrRCwwQ0FBMEMsTUFBTSw4QkFBOEIsRUFBRSxTQUFTLHlEQUF5RCxzREFBc0QsaUNBQWlDLE1BQU0sOEJBQThCLEVBQUUsU0FBUyw0QkFBNEIscUJBQXFCLGVBQWUsTUFBTSxhQUFhLGlCQUFpQiwwQkFBMEIsa0JBQWtCLFdBQVcscUJBQXFCLGtCQUFrQixnQkFBZ0IsV0FBVyxTQUFTLHFEQUFxRCx1REFBdUQsZUFBZSxTQUFTLEVBQUUsa0JBQWtCLGlEQUFpRCxXQUFXLGdCQUFnQiw0QkFBNEIsV0FBVyxTQUFTLHNEQUFzRCw4QkFBOEIsdURBQXVELGVBQWUsU0FBUyxFQUFFLGtCQUFrQixZQUFZLFlBQVksRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxXQUFXLDRCQUE0QixnQkFBZ0IsZUFBZSxNQUFNLGlDQUFpQyxFQUFFLFNBQVMsK0JBQStCLGtCQUFrQixXQUFXLGlCQUFpQixFQUFFLEdBQUcsWUFBWSxFQUFFLEVBQUUsR0FBRyxrQkFBa0IsZ0JBQWdCLGVBQWUsTUFBTSxpQ0FBaUMsRUFBRSxTQUFTLDRDQUE0QyxrQkFBa0IscUJBQXFCLFdBQVcsbUJBQW1CLGdCQUFnQixXQUFXLFNBQVMsU0FBUyw4QkFBOEIsa0JBQWtCLGVBQWUscUNBQXFDLG9CQUFvQixRQUFRLFNBQVMsOERBQThELFdBQVcsUUFBUSxTQUFTLHdEQUF3RCxtQkFBbUIsWUFBWSxZQUFZLHNCQUFzQixZQUFZLFlBQVksS0FBSyxZQUFZLFlBQVksY0FBYyxZQUFZLGFBQWEsUUFBUSxvQkFBb0IsNkVBQTZFLG9DQUFvQyxzQkFBc0Isa0JBQWtCLDZFQUE2RSxvQ0FBb0Msb0JBQW9CLGtCQUFrQix5RUFBeUUsSUFBSSxpQ0FBaUMsR0FBRyxvQkFBb0Isa0VBQWtFLE1BQU0sc0NBQXNDLEVBQUUsR0FBRyxFQUFFLHVCQUF1QixZQUFZLHlCQUF5QiwwQ0FBMEMsYUFBYSxxQkFBcUIsVUFBVSx3QkFBd0IsU0FBUyxNQUFNLGdFQUFnRSxpQkFBaUIsUUFBUSx1Q0FBdUMsRUFBRSxvQ0FBb0MsRUFBRSxHQUFHLFVBQVUsTUFBTSwrR0FBK0csd0JBQXdCLGtCQUFrQixrQkFBa0IsMEJBQTBCLFNBQVMseUJBQXlCLDRCQUE0QixjQUFjLE1BQU0sRUFBRSxHQUFHLG1CQUFtQixnQ0FBZ0MsVUFBVSxFQUFFLFFBQVEsRUFBRSxFQUFFLFVBQVUsU0FBUyxpQkFBaUIsVUFBVSxpQkFBaUIsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLG1CQUFtQixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLG1CQUFtQixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSw4QkFBOEIsdUJBQXVCLEVBQUUsRUFBRSxZQUFZLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLHlCQUF5QixFQUFFLEVBQUUsWUFBWSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLHdCQUF3QixFQUFFLEVBQUUsWUFBWSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxTQUFTLGlDQUFpQyxhQUFhLHFCQUFxQixhQUFhLG1CQUFtQiw0QkFBNEIsZ0JBQWdCLDhCQUE4QixNQUFNLEVBQUUsR0FBRyxVQUFVLGdCQUFnQixlQUFlLGVBQWUsZUFBZSxjQUFjLGVBQWUsNERBQTRELGdDQUFnQyxxQkFBcUIscUNBQXFDLHVCQUF1QixrQkFBa0IsYUFBYSxjQUFjLGNBQWMsb0JBQW9CLHVDQUF1QyxvQ0FBb0MsaUVBQWlFLGNBQWMsa0JBQWtCLG9FQUFvRSxnQkFBZ0IsZUFBZSx3QkFBd0IsYUFBYSxTQUFTLDZDQUE2QyxrQ0FBa0MsNEJBQTRCLE1BQU0sMkJBQTJCLHVCQUF1QixlQUFlLEVBQUUsU0FBUyxtRUFBbUUsbUNBQW1DLGNBQWMsY0FBYyxnQkFBZ0IsaUJBQWlCLGlCQUFpQixtQ0FBbUMsY0FBYyxnQkFBZ0IsaUJBQWlCLGtDQUFrQyxhQUFhLGlCQUFpQixNQUFNLGdCQUFnQixnQkFBZ0IsdUJBQXVCLGVBQWUsR0FBRyxJQUFJLHdCQUF3QixxREFBcUQsV0FBVyxPQUFPLHlCQUF5QixjQUFjLDRDQUE0QyxZQUFZLGtCQUFrQixjQUFjLFdBQVcsUUFBUSxnQ0FBZ0MsMENBQTBDLCtCQUErQixLQUFLLGFBQWEsT0FBTyxzQ0FBc0MsOEJBQThCLG9EQUFvRCw4QkFBOEIsNkNBQTZDLHdCQUF3Qiw0REFBNEQsWUFBWSxxQkFBcUIsR0FBRyw2QkFBNkIsNENBQTRDLGFBQWEsZ0JBQWdCLGNBQWMsMEJBQTBCLDBCQUEwQixTQUFTLEVBQUUsS0FBSyxTQUFTLEdBQUcsRUFBRSxFQUFFLHdCQUF3QixTQUFTLEVBQUUsTUFBTSwrQkFBK0IsYUFBYSxVQUFVLFVBQVUsd0JBQXdCLG9CQUFvQiw0QkFBNEIsbURBQW1ELE9BQU8sOEJBQThCLGtEQUFrRCwwQkFBMEIsY0FBYyxTQUFTLHFDQUFxQywwQkFBMEIsSUFBSSxjQUFjLGdEQUFnRCxTQUFTLDZCQUE2QixhQUFhLHNCQUFzQixvQkFBb0IsZUFBZSxjQUFjLE1BQU0sK1NBQStTLFFBQVEsc0NBQXNDLGdCQUFnQixzQkFBc0Isa0NBQWtDLG1CQUFtQixjQUFjLG1CQUFtQiwyQ0FBMkMsV0FBVyxXQUFXLFdBQVcsUUFBUSxTQUFTLFFBQVEsUUFBUSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFFBQVEsTUFBTSxNQUFNLE9BQU8sK0JBQStCLG1CQUFtQixpQ0FBaUMsbUJBQW1CLElBQUksMEJBQTBCLFdBQVcsWUFBWSxNQUFNLFVBQVUscUJBQXFCLFlBQVksVUFBVSxPQUFPLFNBQVMsb0JBQW9CLElBQUksbUNBQW1DLFVBQVUscUJBQXFCLFVBQVUsU0FBUyxVQUFVLElBQUksU0FBUyx1Q0FBdUMsaUJBQWlCLGdCQUFnQixPQUFPLGFBQWEsU0FBUyxNQUFNLG9CQUFvQixpQkFBaUIsZ0JBQWdCLE9BQU8sYUFBYSxTQUFTLE1BQU0sVUFBVSxJQUFJLFVBQVUsUUFBUSxpQkFBaUIsT0FBTyxRQUFRLGFBQWEsU0FBUyxNQUFNLFVBQVUsVUFBVSxVQUFVLEdBQUcsK0JBQStCLHFCQUFxQixtQkFBbUIsS0FBSyxTQUFTLE1BQU0sU0FBUyxtQkFBbUIsMENBQTBDLHlCQUF5QixnQkFBZ0IsbUJBQW1CLE9BQU8saUJBQWlCLE9BQU8sYUFBYSxtQ0FBbUMsVUFBVSxxQkFBcUIsWUFBWSxTQUFTLFVBQVUsZ0JBQWdCLE9BQU8sT0FBTyxTQUFTLE9BQU8sVUFBVSw2QkFBNkIsZ0JBQWdCLE9BQU8sYUFBYSxTQUFTLE1BQU0sVUFBVSxnQkFBZ0IsT0FBTyxhQUFhLFNBQVMsTUFBTSxVQUFVLG1DQUFtQyxVQUFVLHFCQUFxQixVQUFVLFNBQVMsVUFBVSxtQkFBbUIsZ0JBQWdCLE9BQU8sT0FBTyxhQUFhLFNBQVMsTUFBTSxvQ0FBb0MsaUJBQWlCLElBQUksU0FBUyw0QkFBNEIsZ0JBQWdCLGFBQWEsbUNBQW1DLFVBQVUscUJBQXFCLFlBQVksU0FBUyxVQUFVLE9BQU8sT0FBTyxTQUFTLE1BQU0sYUFBYSxPQUFPLGFBQWEsU0FBUyxPQUFPLG1CQUFtQixRQUFRLFFBQVEsUUFBUSxTQUFTLFNBQVMsUUFBUSxlQUFlLGFBQWEsS0FBSyxxQkFBcUIsZUFBZSxhQUFhLGtCQUFrQixLQUFLLElBQUksS0FBSyxJQUFJLDhCQUE4Qiw4Q0FBOEMsaUJBQWlCLHNCQUFzQiw4QkFBOEIsZ0JBQWdCLDBCQUEwQixTQUFTLDJIQUEySCxvQkFBb0IsYUFBYSx3QkFBd0IsVUFBVSxXQUFXLG9DQUFvQyxNQUFNLFlBQVksV0FBVyxLQUFLLGdCQUFnQixhQUFhLHFCQUFxQixhQUFhLGlCQUFpQixtQkFBbUIsYUFBYSxLQUFLLGFBQWEsWUFBWSx1QkFBdUIsa0JBQWtCLFVBQVUsSUFBSSxvQkFBb0IscUJBQXFCLFVBQVUsYUFBYSxzQkFBc0IscUJBQXFCLGlDQUFpQyxZQUFZLFVBQVUsVUFBVSxlQUFlLGNBQWMsTUFBTSw4RkFBOEYsUUFBUSwrREFBK0QsNkJBQTZCLGtEQUFrRCxxQ0FBcUMscUNBQXFDLHVEQUF1RCx1QkFBdUIsMkJBQTJCLG1CQUFtQiw4Q0FBOEMsU0FBUyxhQUFhLElBQUksV0FBVyxHQUFHLHNCQUFzQixJQUFJLFFBQVEsdUJBQXVCLGFBQWEsY0FBYyxVQUFVLG9CQUFvQixLQUFLLElBQUksMEJBQTBCLDBCQUEwQixTQUFTLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFLHFCQUFxQixZQUFZLEVBQUUsT0FBTyxVQUFVLGVBQWUsVUFBVSxHQUFHLElBQUksK0JBQStCLHNCQUFzQixXQUFXLHFCQUFxQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9waWNvbWF0Y2gvaW5kZXguanM/YThhZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgdD17MTcwOih0LGUsdSk9Pntjb25zdCBuPXUoNTEwKTtjb25zdCBpc1dpbmRvd3M9KCk9PntpZih0eXBlb2YgbmF2aWdhdG9yIT09XCJ1bmRlZmluZWRcIiYmbmF2aWdhdG9yLnBsYXRmb3JtKXtjb25zdCB0PW5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO3JldHVybiB0PT09XCJ3aW4zMlwifHx0PT09XCJ3aW5kb3dzXCJ9aWYodHlwZW9mIHByb2Nlc3MhPT1cInVuZGVmaW5lZFwiJiZwcm9jZXNzLnBsYXRmb3JtKXtyZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybT09PVwid2luMzJcIn1yZXR1cm4gZmFsc2V9O2Z1bmN0aW9uIHBpY29tYXRjaCh0LGUsdT1mYWxzZSl7aWYoZSYmKGUud2luZG93cz09PW51bGx8fGUud2luZG93cz09PXVuZGVmaW5lZCkpe2U9ey4uLmUsd2luZG93czppc1dpbmRvd3MoKX19cmV0dXJuIG4odCxlLHUpfU9iamVjdC5hc3NpZ24ocGljb21hdGNoLG4pO3QuZXhwb3J0cz1waWNvbWF0Y2h9LDE1NDp0PT57Y29uc3QgZT1cIlxcXFxcXFxcL1wiO2NvbnN0IHU9YFteJHtlfV1gO2NvbnN0IG49XCJcXFxcLlwiO2NvbnN0IG89XCJcXFxcK1wiO2NvbnN0IHM9XCJcXFxcP1wiO2NvbnN0IHI9XCJcXFxcL1wiO2NvbnN0IGE9XCIoPz0uKVwiO2NvbnN0IGk9XCJbXi9dXCI7Y29uc3QgYz1gKD86JHtyfXwkKWA7Y29uc3QgcD1gKD86Xnwke3J9KWA7Y29uc3QgbD1gJHtufXsxLDJ9JHtjfWA7Y29uc3QgZj1gKD8hJHtufSlgO2NvbnN0IEE9YCg/ISR7cH0ke2x9KWA7Y29uc3QgXz1gKD8hJHtufXswLDF9JHtjfSlgO2NvbnN0IFI9YCg/ISR7bH0pYDtjb25zdCBFPWBbXi4ke3J9XWA7Y29uc3QgaD1gJHtpfSo/YDtjb25zdCBnPVwiL1wiO2NvbnN0IGI9e0RPVF9MSVRFUkFMOm4sUExVU19MSVRFUkFMOm8sUU1BUktfTElURVJBTDpzLFNMQVNIX0xJVEVSQUw6cixPTkVfQ0hBUjphLFFNQVJLOmksRU5EX0FOQ0hPUjpjLERPVFNfU0xBU0g6bCxOT19ET1Q6ZixOT19ET1RTOkEsTk9fRE9UX1NMQVNIOl8sTk9fRE9UU19TTEFTSDpSLFFNQVJLX05PX0RPVDpFLFNUQVI6aCxTVEFSVF9BTkNIT1I6cCxTRVA6Z307Y29uc3QgQz17Li4uYixTTEFTSF9MSVRFUkFMOmBbJHtlfV1gLFFNQVJLOnUsU1RBUjpgJHt1fSo/YCxET1RTX1NMQVNIOmAke259ezEsMn0oPzpbJHtlfV18JClgLE5PX0RPVDpgKD8hJHtufSlgLE5PX0RPVFM6YCg/ISg/Ol58WyR7ZX1dKSR7bn17MSwyfSg/Olske2V9XXwkKSlgLE5PX0RPVF9TTEFTSDpgKD8hJHtufXswLDF9KD86WyR7ZX1dfCQpKWAsTk9fRE9UU19TTEFTSDpgKD8hJHtufXsxLDJ9KD86WyR7ZX1dfCQpKWAsUU1BUktfTk9fRE9UOmBbXi4ke2V9XWAsU1RBUlRfQU5DSE9SOmAoPzpefFske2V9XSlgLEVORF9BTkNIT1I6YCg/Olske2V9XXwkKWAsU0VQOlwiXFxcXFwifTtjb25zdCB5PXthbG51bTpcImEtekEtWjAtOVwiLGFscGhhOlwiYS16QS1aXCIsYXNjaWk6XCJcXFxceDAwLVxcXFx4N0ZcIixibGFuazpcIiBcXFxcdFwiLGNudHJsOlwiXFxcXHgwMC1cXFxceDFGXFxcXHg3RlwiLGRpZ2l0OlwiMC05XCIsZ3JhcGg6XCJcXFxceDIxLVxcXFx4N0VcIixsb3dlcjpcImEtelwiLHByaW50OlwiXFxcXHgyMC1cXFxceDdFIFwiLHB1bmN0OlwiXFxcXC0hXFxcIiMkJSYnKClcXFxcKissLi86Ozw9Pj9AW1xcXFxdXl9ge3x9flwiLHNwYWNlOlwiIFxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGZcIix1cHBlcjpcIkEtWlwiLHdvcmQ6XCJBLVphLXowLTlfXCIseGRpZ2l0OlwiQS1GYS1mMC05XCJ9O3QuZXhwb3J0cz17TUFYX0xFTkdUSDoxMDI0KjY0LFBPU0lYX1JFR0VYX1NPVVJDRTp5LFJFR0VYX0JBQ0tTTEFTSDovXFxcXCg/IVsqKz9eJHt9KHwpW1xcXV0pL2csUkVHRVhfTk9OX1NQRUNJQUxfQ0hBUlM6L15bXkAhW1xcXS4sJCorP157fSgpfFxcXFwvXSsvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6L1stKis/Ll4ke30ofClbXFxdXS8sUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOi8oXFxcXD8pKChcXFcpKFxcMyopKS9nLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOi8oWy0qKz8uXiR7fSh8KVtcXF1dKS9nLFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6Lyg/OlxcWy4qP1teXFxcXF1cXF18XFxcXCg/PS4pKS9nLFJFUExBQ0VNRU5UUzp7XCIqKipcIjpcIipcIixcIioqLyoqXCI6XCIqKlwiLFwiKiovKiovKipcIjpcIioqXCJ9LENIQVJfMDo0OCxDSEFSXzk6NTcsQ0hBUl9VUFBFUkNBU0VfQTo2NSxDSEFSX0xPV0VSQ0FTRV9BOjk3LENIQVJfVVBQRVJDQVNFX1o6OTAsQ0hBUl9MT1dFUkNBU0VfWjoxMjIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOjQwLENIQVJfUklHSFRfUEFSRU5USEVTRVM6NDEsQ0hBUl9BU1RFUklTSzo0MixDSEFSX0FNUEVSU0FORDozOCxDSEFSX0FUOjY0LENIQVJfQkFDS1dBUkRfU0xBU0g6OTIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46MTMsQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVDo5NCxDSEFSX0NPTE9OOjU4LENIQVJfQ09NTUE6NDQsQ0hBUl9ET1Q6NDYsQ0hBUl9ET1VCTEVfUVVPVEU6MzQsQ0hBUl9FUVVBTDo2MSxDSEFSX0VYQ0xBTUFUSU9OX01BUks6MzMsQ0hBUl9GT1JNX0ZFRUQ6MTIsQ0hBUl9GT1JXQVJEX1NMQVNIOjQ3LENIQVJfR1JBVkVfQUNDRU5UOjk2LENIQVJfSEFTSDozNSxDSEFSX0hZUEhFTl9NSU5VUzo0NSxDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDo2MCxDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6MTIzLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDo5MSxDSEFSX0xJTkVfRkVFRDoxMCxDSEFSX05PX0JSRUFLX1NQQUNFOjE2MCxDSEFSX1BFUkNFTlQ6MzcsQ0hBUl9QTFVTOjQzLENIQVJfUVVFU1RJT05fTUFSSzo2MyxDSEFSX1JJR0hUX0FOR0xFX0JSQUNLRVQ6NjIsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRToxMjUsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDo5MyxDSEFSX1NFTUlDT0xPTjo1OSxDSEFSX1NJTkdMRV9RVU9URTozOSxDSEFSX1NQQUNFOjMyLENIQVJfVEFCOjksQ0hBUl9VTkRFUlNDT1JFOjk1LENIQVJfVkVSVElDQUxfTElORToxMjQsQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0U6NjUyNzksZXh0Z2xvYkNoYXJzKHQpe3JldHVybntcIiFcIjp7dHlwZTpcIm5lZ2F0ZVwiLG9wZW46XCIoPzooPyEoPzpcIixjbG9zZTpgKSkke3QuU1RBUn0pYH0sXCI/XCI6e3R5cGU6XCJxbWFya1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIik/XCJ9LFwiK1wiOnt0eXBlOlwicGx1c1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIikrXCJ9LFwiKlwiOnt0eXBlOlwic3RhclwiLG9wZW46XCIoPzpcIixjbG9zZTpcIikqXCJ9LFwiQFwiOnt0eXBlOlwiYXRcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpXCJ9fX0sZ2xvYkNoYXJzKHQpe3JldHVybiB0PT09dHJ1ZT9DOmJ9fX0sNjk3Oih0LGUsdSk9Pntjb25zdCBuPXUoMTU0KTtjb25zdCBvPXUoOTYpO2NvbnN0e01BWF9MRU5HVEg6cyxQT1NJWF9SRUdFWF9TT1VSQ0U6cixSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzphLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjppLFJFUExBQ0VNRU5UUzpjfT1uO2NvbnN0IGV4cGFuZFJhbmdlPSh0LGUpPT57aWYodHlwZW9mIGUuZXhwYW5kUmFuZ2U9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBlLmV4cGFuZFJhbmdlKC4uLnQsZSl9dC5zb3J0KCk7Y29uc3QgdT1gWyR7dC5qb2luKFwiLVwiKX1dYDt0cnl7bmV3IFJlZ0V4cCh1KX1jYXRjaChlKXtyZXR1cm4gdC5tYXAoKHQ9Pm8uZXNjYXBlUmVnZXgodCkpKS5qb2luKFwiLi5cIil9cmV0dXJuIHV9O2NvbnN0IHN5bnRheEVycm9yPSh0LGUpPT5gTWlzc2luZyAke3R9OiBcIiR7ZX1cIiAtIHVzZSBcIlxcXFxcXFxcJHtlfVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7Y29uc3QgcGFyc2U9KHQsZSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX10PWNbdF18fHQ7Y29uc3QgdT17Li4uZX07Y29uc3QgcD10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7bGV0IGw9dC5sZW5ndGg7aWYobD5wKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtsfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke3B9YCl9Y29uc3QgZj17dHlwZTpcImJvc1wiLHZhbHVlOlwiXCIsb3V0cHV0OnUucHJlcGVuZHx8XCJcIn07Y29uc3QgQT1bZl07Y29uc3QgXz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgUj1uLmdsb2JDaGFycyh1LndpbmRvd3MpO2NvbnN0IEU9bi5leHRnbG9iQ2hhcnMoUik7Y29uc3R7RE9UX0xJVEVSQUw6aCxQTFVTX0xJVEVSQUw6ZyxTTEFTSF9MSVRFUkFMOmIsT05FX0NIQVI6QyxET1RTX1NMQVNIOnksTk9fRE9UOiQsTk9fRE9UX1NMQVNIOngsTk9fRE9UU19TTEFTSDpTLFFNQVJLOkgsUU1BUktfTk9fRE9UOnYsU1RBUjpkLFNUQVJUX0FOQ0hPUjpMfT1SO2NvbnN0IGdsb2JzdGFyPXQ9PmAoJHtffSg/Oig/ISR7TH0ke3QuZG90P3k6aH0pLikqPylgO2NvbnN0IFQ9dS5kb3Q/XCJcIjokO2NvbnN0IE89dS5kb3Q/SDp2O2xldCBrPXUuYmFzaD09PXRydWU/Z2xvYnN0YXIodSk6ZDtpZih1LmNhcHR1cmUpe2s9YCgke2t9KWB9aWYodHlwZW9mIHUubm9leHQ9PT1cImJvb2xlYW5cIil7dS5ub2V4dGdsb2I9dS5ub2V4dH1jb25zdCBtPXtpbnB1dDp0LGluZGV4Oi0xLHN0YXJ0OjAsZG90OnUuZG90PT09dHJ1ZSxjb25zdW1lZDpcIlwiLG91dHB1dDpcIlwiLHByZWZpeDpcIlwiLGJhY2t0cmFjazpmYWxzZSxuZWdhdGVkOmZhbHNlLGJyYWNrZXRzOjAsYnJhY2VzOjAscGFyZW5zOjAscXVvdGVzOjAsZ2xvYnN0YXI6ZmFsc2UsdG9rZW5zOkF9O3Q9by5yZW1vdmVQcmVmaXgodCxtKTtsPXQubGVuZ3RoO2NvbnN0IHc9W107Y29uc3QgTj1bXTtjb25zdCBJPVtdO2xldCBCPWY7bGV0IEc7Y29uc3QgZW9zPSgpPT5tLmluZGV4PT09bC0xO2NvbnN0IEQ9bS5wZWVrPShlPTEpPT50W20uaW5kZXgrZV07Y29uc3QgTT1tLmFkdmFuY2U9KCk9PnRbKyttLmluZGV4XXx8XCJcIjtjb25zdCByZW1haW5pbmc9KCk9PnQuc2xpY2UobS5pbmRleCsxKTtjb25zdCBjb25zdW1lPSh0PVwiXCIsZT0wKT0+e20uY29uc3VtZWQrPXQ7bS5pbmRleCs9ZX07Y29uc3QgYXBwZW5kPXQ9PnttLm91dHB1dCs9dC5vdXRwdXQhPW51bGw/dC5vdXRwdXQ6dC52YWx1ZTtjb25zdW1lKHQudmFsdWUpfTtjb25zdCBuZWdhdGU9KCk9PntsZXQgdD0xO3doaWxlKEQoKT09PVwiIVwiJiYoRCgyKSE9PVwiKFwifHxEKDMpPT09XCI/XCIpKXtNKCk7bS5zdGFydCsrO3QrK31pZih0JTI9PT0wKXtyZXR1cm4gZmFsc2V9bS5uZWdhdGVkPXRydWU7bS5zdGFydCsrO3JldHVybiB0cnVlfTtjb25zdCBpbmNyZW1lbnQ9dD0+e21bdF0rKztJLnB1c2godCl9O2NvbnN0IGRlY3JlbWVudD10PT57bVt0XS0tO0kucG9wKCl9O2NvbnN0IHB1c2g9dD0+e2lmKEIudHlwZT09PVwiZ2xvYnN0YXJcIil7Y29uc3QgZT1tLmJyYWNlcz4wJiYodC50eXBlPT09XCJjb21tYVwifHx0LnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IHU9dC5leHRnbG9iPT09dHJ1ZXx8dy5sZW5ndGgmJih0LnR5cGU9PT1cInBpcGVcInx8dC50eXBlPT09XCJwYXJlblwiKTtpZih0LnR5cGUhPT1cInNsYXNoXCImJnQudHlwZSE9PVwicGFyZW5cIiYmIWUmJiF1KXttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLm91dHB1dC5sZW5ndGgpO0IudHlwZT1cInN0YXJcIjtCLnZhbHVlPVwiKlwiO0Iub3V0cHV0PWs7bS5vdXRwdXQrPUIub3V0cHV0fX1pZih3Lmxlbmd0aCYmdC50eXBlIT09XCJwYXJlblwiKXt3W3cubGVuZ3RoLTFdLmlubmVyKz10LnZhbHVlfWlmKHQudmFsdWV8fHQub3V0cHV0KWFwcGVuZCh0KTtpZihCJiZCLnR5cGU9PT1cInRleHRcIiYmdC50eXBlPT09XCJ0ZXh0XCIpe0Iub3V0cHV0PShCLm91dHB1dHx8Qi52YWx1ZSkrdC52YWx1ZTtCLnZhbHVlKz10LnZhbHVlO3JldHVybn10LnByZXY9QjtBLnB1c2godCk7Qj10fTtjb25zdCBleHRnbG9iT3Blbj0odCxlKT0+e2NvbnN0IG49ey4uLkVbZV0sY29uZGl0aW9uczoxLGlubmVyOlwiXCJ9O24ucHJldj1CO24ucGFyZW5zPW0ucGFyZW5zO24ub3V0cHV0PW0ub3V0cHV0O2NvbnN0IG89KHUuY2FwdHVyZT9cIihcIjpcIlwiKStuLm9wZW47aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6dCx2YWx1ZTplLG91dHB1dDptLm91dHB1dD9cIlwiOkN9KTtwdXNoKHt0eXBlOlwicGFyZW5cIixleHRnbG9iOnRydWUsdmFsdWU6TSgpLG91dHB1dDpvfSk7dy5wdXNoKG4pfTtjb25zdCBleHRnbG9iQ2xvc2U9dD0+e2xldCBuPXQuY2xvc2UrKHUuY2FwdHVyZT9cIilcIjpcIlwiKTtsZXQgbztpZih0LnR5cGU9PT1cIm5lZ2F0ZVwiKXtsZXQgcz1rO2lmKHQuaW5uZXImJnQuaW5uZXIubGVuZ3RoPjEmJnQuaW5uZXIuaW5jbHVkZXMoXCIvXCIpKXtzPWdsb2JzdGFyKHUpfWlmKHMhPT1rfHxlb3MoKXx8L15cXCkrJC8udGVzdChyZW1haW5pbmcoKSkpe249dC5jbG9zZT1gKSQpKSR7c31gfWlmKHQuaW5uZXIuaW5jbHVkZXMoXCIqXCIpJiYobz1yZW1haW5pbmcoKSkmJi9eXFwuW15cXFxcLy5dKyQvLnRlc3Qobykpe2NvbnN0IHU9cGFyc2Uobyx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KS5vdXRwdXQ7bj10LmNsb3NlPWApJHt1fSkke3N9KWB9aWYodC5wcmV2LnR5cGU9PT1cImJvc1wiKXttLm5lZ2F0ZWRFeHRnbG9iPXRydWV9fXB1c2goe3R5cGU6XCJwYXJlblwiLGV4dGdsb2I6dHJ1ZSx2YWx1ZTpHLG91dHB1dDpufSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpfTtpZih1LmZhc3RwYXRocyE9PWZhbHNlJiYhLyheWyohXXxbLygpW1xcXXt9XCJdKS8udGVzdCh0KSl7bGV0IG49ZmFsc2U7bGV0IHM9dC5yZXBsYWNlKGksKCh0LGUsdSxvLHMscik9PntpZihvPT09XCJcXFxcXCIpe249dHJ1ZTtyZXR1cm4gdH1pZihvPT09XCI/XCIpe2lmKGUpe3JldHVybiBlK28rKHM/SC5yZXBlYXQocy5sZW5ndGgpOlwiXCIpfWlmKHI9PT0wKXtyZXR1cm4gTysocz9ILnJlcGVhdChzLmxlbmd0aCk6XCJcIil9cmV0dXJuIEgucmVwZWF0KHUubGVuZ3RoKX1pZihvPT09XCIuXCIpe3JldHVybiBoLnJlcGVhdCh1Lmxlbmd0aCl9aWYobz09PVwiKlwiKXtpZihlKXtyZXR1cm4gZStvKyhzP2s6XCJcIil9cmV0dXJuIGt9cmV0dXJuIGU/dDpgXFxcXCR7dH1gfSkpO2lmKG49PT10cnVlKXtpZih1LnVuZXNjYXBlPT09dHJ1ZSl7cz1zLnJlcGxhY2UoL1xcXFwvZyxcIlwiKX1lbHNle3M9cy5yZXBsYWNlKC9cXFxcKy9nLCh0PT50Lmxlbmd0aCUyPT09MD9cIlxcXFxcXFxcXCI6dD9cIlxcXFxcIjpcIlwiKSl9fWlmKHM9PT10JiZ1LmNvbnRhaW5zPT09dHJ1ZSl7bS5vdXRwdXQ9dDtyZXR1cm4gbX1tLm91dHB1dD1vLndyYXBPdXRwdXQocyxtLGUpO3JldHVybiBtfXdoaWxlKCFlb3MoKSl7Rz1NKCk7aWYoRz09PVwiXFwwXCIpe2NvbnRpbnVlfWlmKEc9PT1cIlxcXFxcIil7Y29uc3QgdD1EKCk7aWYodD09PVwiL1wiJiZ1LmJhc2ghPT10cnVlKXtjb250aW51ZX1pZih0PT09XCIuXCJ8fHQ9PT1cIjtcIil7Y29udGludWV9aWYoIXQpe0crPVwiXFxcXFwiO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pO2NvbnRpbnVlfWNvbnN0IGU9L15cXFxcKy8uZXhlYyhyZW1haW5pbmcoKSk7bGV0IG49MDtpZihlJiZlWzBdLmxlbmd0aD4yKXtuPWVbMF0ubGVuZ3RoO20uaW5kZXgrPW47aWYobiUyIT09MCl7Rys9XCJcXFxcXCJ9fWlmKHUudW5lc2NhcGU9PT10cnVlKXtHPU0oKX1lbHNle0crPU0oKX1pZihtLmJyYWNrZXRzPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9fWlmKG0uYnJhY2tldHM+MCYmKEchPT1cIl1cInx8Qi52YWx1ZT09PVwiW1wifHxCLnZhbHVlPT09XCJbXlwiKSl7aWYodS5wb3NpeCE9PWZhbHNlJiZHPT09XCI6XCIpe2NvbnN0IHQ9Qi52YWx1ZS5zbGljZSgxKTtpZih0LmluY2x1ZGVzKFwiW1wiKSl7Qi5wb3NpeD10cnVlO2lmKHQuaW5jbHVkZXMoXCI6XCIpKXtjb25zdCB0PUIudmFsdWUubGFzdEluZGV4T2YoXCJbXCIpO2NvbnN0IGU9Qi52YWx1ZS5zbGljZSgwLHQpO2NvbnN0IHU9Qi52YWx1ZS5zbGljZSh0KzIpO2NvbnN0IG49clt1XTtpZihuKXtCLnZhbHVlPWUrbjttLmJhY2t0cmFjaz10cnVlO00oKTtpZighZi5vdXRwdXQmJkEuaW5kZXhPZihCKT09PTEpe2Yub3V0cHV0PUN9Y29udGludWV9fX19aWYoRz09PVwiW1wiJiZEKCkhPT1cIjpcInx8Rz09PVwiLVwiJiZEKCk9PT1cIl1cIil7Rz1gXFxcXCR7R31gfWlmKEc9PT1cIl1cIiYmKEIudmFsdWU9PT1cIltcInx8Qi52YWx1ZT09PVwiW15cIikpe0c9YFxcXFwke0d9YH1pZih1LnBvc2l4PT09dHJ1ZSYmRz09PVwiIVwiJiZCLnZhbHVlPT09XCJbXCIpe0c9XCJeXCJ9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihtLnF1b3Rlcz09PTEmJkchPT0nXCInKXtHPW8uZXNjYXBlUmVnZXgoRyk7Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09J1wiJyl7bS5xdW90ZXM9bS5xdW90ZXM9PT0xPzA6MTtpZih1LmtlZXBRdW90ZXM9PT10cnVlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KX1jb250aW51ZX1pZihHPT09XCIoXCIpe2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpHfSk7Y29udGludWV9aWYoRz09PVwiKVwiKXtpZihtLnBhcmVucz09PTAmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCIoXCIpKX1jb25zdCB0PXdbdy5sZW5ndGgtMV07aWYodCYmbS5wYXJlbnM9PT10LnBhcmVucysxKXtleHRnbG9iQ2xvc2Uody5wb3AoKSk7Y29udGludWV9cHVzaCh7dHlwZTpcInBhcmVuXCIsdmFsdWU6RyxvdXRwdXQ6bS5wYXJlbnM/XCIpXCI6XCJcXFxcKVwifSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpO2NvbnRpbnVlfWlmKEc9PT1cIltcIil7aWYodS5ub2JyYWNrZXQ9PT10cnVlfHwhcmVtYWluaW5nKCkuaW5jbHVkZXMoXCJdXCIpKXtpZih1Lm5vYnJhY2tldCE9PXRydWUmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJdXCIpKX1HPWBcXFxcJHtHfWB9ZWxzZXtpbmNyZW1lbnQoXCJicmFja2V0c1wiKX1wdXNoKHt0eXBlOlwiYnJhY2tldFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCJdXCIpe2lmKHUubm9icmFja2V0PT09dHJ1ZXx8QiYmQi50eXBlPT09XCJicmFja2V0XCImJkIudmFsdWUubGVuZ3RoPT09MSl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpgXFxcXCR7R31gfSk7Y29udGludWV9aWYobS5icmFja2V0cz09PTApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCJbXCIpKX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkcsb3V0cHV0OmBcXFxcJHtHfWB9KTtjb250aW51ZX1kZWNyZW1lbnQoXCJicmFja2V0c1wiKTtjb25zdCB0PUIudmFsdWUuc2xpY2UoMSk7aWYoQi5wb3NpeCE9PXRydWUmJnRbMF09PT1cIl5cIiYmIXQuaW5jbHVkZXMoXCIvXCIpKXtHPWAvJHtHfWB9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtpZih1LmxpdGVyYWxCcmFja2V0cz09PWZhbHNlfHxvLmhhc1JlZ2V4Q2hhcnModCkpe2NvbnRpbnVlfWNvbnN0IGU9by5lc2NhcGVSZWdleChCLnZhbHVlKTttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLnZhbHVlLmxlbmd0aCk7aWYodS5saXRlcmFsQnJhY2tldHM9PT10cnVlKXttLm91dHB1dCs9ZTtCLnZhbHVlPWU7Y29udGludWV9Qi52YWx1ZT1gKCR7X30ke2V9fCR7Qi52YWx1ZX0pYDttLm91dHB1dCs9Qi52YWx1ZTtjb250aW51ZX1pZihHPT09XCJ7XCImJnUubm9icmFjZSE9PXRydWUpe2luY3JlbWVudChcImJyYWNlc1wiKTtjb25zdCB0PXt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDpcIihcIixvdXRwdXRJbmRleDptLm91dHB1dC5sZW5ndGgsdG9rZW5zSW5kZXg6bS50b2tlbnMubGVuZ3RofTtOLnB1c2godCk7cHVzaCh0KTtjb250aW51ZX1pZihHPT09XCJ9XCIpe2NvbnN0IHQ9TltOLmxlbmd0aC0xXTtpZih1Lm5vYnJhY2U9PT10cnVlfHwhdCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpHfSk7Y29udGludWV9bGV0IGU9XCIpXCI7aWYodC5kb3RzPT09dHJ1ZSl7Y29uc3QgdD1BLnNsaWNlKCk7Y29uc3Qgbj1bXTtmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wO2UtLSl7QS5wb3AoKTtpZih0W2VdLnR5cGU9PT1cImJyYWNlXCIpe2JyZWFrfWlmKHRbZV0udHlwZSE9PVwiZG90c1wiKXtuLnVuc2hpZnQodFtlXS52YWx1ZSl9fWU9ZXhwYW5kUmFuZ2Uobix1KTttLmJhY2t0cmFjaz10cnVlfWlmKHQuY29tbWEhPT10cnVlJiZ0LmRvdHMhPT10cnVlKXtjb25zdCB1PW0ub3V0cHV0LnNsaWNlKDAsdC5vdXRwdXRJbmRleCk7Y29uc3Qgbj1tLnRva2Vucy5zbGljZSh0LnRva2Vuc0luZGV4KTt0LnZhbHVlPXQub3V0cHV0PVwiXFxcXHtcIjtHPWU9XCJcXFxcfVwiO20ub3V0cHV0PXU7Zm9yKGNvbnN0IHQgb2Ygbil7bS5vdXRwdXQrPXQub3V0cHV0fHx0LnZhbHVlfX1wdXNoKHt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDplfSk7ZGVjcmVtZW50KFwiYnJhY2VzXCIpO04ucG9wKCk7Y29udGludWV9aWYoRz09PVwifFwiKXtpZih3Lmxlbmd0aD4wKXt3W3cubGVuZ3RoLTFdLmNvbmRpdGlvbnMrK31wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCIsXCIpe2xldCB0PUc7Y29uc3QgZT1OW04ubGVuZ3RoLTFdO2lmKGUmJklbSS5sZW5ndGgtMV09PT1cImJyYWNlc1wiKXtlLmNvbW1hPXRydWU7dD1cInxcIn1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTpHLG91dHB1dDp0fSk7Y29udGludWV9aWYoRz09PVwiL1wiKXtpZihCLnR5cGU9PT1cImRvdFwiJiZtLmluZGV4PT09bS5zdGFydCsxKXttLnN0YXJ0PW0uaW5kZXgrMTttLmNvbnN1bWVkPVwiXCI7bS5vdXRwdXQ9XCJcIjtBLnBvcCgpO0I9Zjtjb250aW51ZX1wdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpHLG91dHB1dDpifSk7Y29udGludWV9aWYoRz09PVwiLlwiKXtpZihtLmJyYWNlcz4wJiZCLnR5cGU9PT1cImRvdFwiKXtpZihCLnZhbHVlPT09XCIuXCIpQi5vdXRwdXQ9aDtjb25zdCB0PU5bTi5sZW5ndGgtMV07Qi50eXBlPVwiZG90c1wiO0Iub3V0cHV0Kz1HO0IudmFsdWUrPUc7dC5kb3RzPXRydWU7Y29udGludWV9aWYobS5icmFjZXMrbS5wYXJlbnM9PT0wJiZCLnR5cGUhPT1cImJvc1wiJiZCLnR5cGUhPT1cInNsYXNoXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6aH0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJkb3RcIix2YWx1ZTpHLG91dHB1dDpofSk7Y29udGludWV9aWYoRz09PVwiP1wiKXtjb25zdCB0PUImJkIudmFsdWU9PT1cIihcIjtpZighdCYmdS5ub2V4dGdsb2IhPT10cnVlJiZEKCk9PT1cIihcIiYmRCgyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInFtYXJrXCIsRyk7Y29udGludWV9aWYoQiYmQi50eXBlPT09XCJwYXJlblwiKXtjb25zdCB0PUQoKTtsZXQgZT1HO2lmKEIudmFsdWU9PT1cIihcIiYmIS9bIT08Ol0vLnRlc3QodCl8fHQ9PT1cIjxcIiYmIS88KFshPV18XFx3Kz4pLy50ZXN0KHJlbWFpbmluZygpKSl7ZT1gXFxcXCR7R31gfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6ZX0pO2NvbnRpbnVlfWlmKHUuZG90IT09dHJ1ZSYmKEIudHlwZT09PVwic2xhc2hcInx8Qi50eXBlPT09XCJib3NcIikpe3B1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkcsb3V0cHV0OnZ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicW1hcmtcIix2YWx1ZTpHLG91dHB1dDpIfSk7Y29udGludWV9aWYoRz09PVwiIVwiKXtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJkQoKT09PVwiKFwiKXtpZihEKDIpIT09XCI/XCJ8fCEvWyE9PDpdLy50ZXN0KEQoMykpKXtleHRnbG9iT3BlbihcIm5lZ2F0ZVwiLEcpO2NvbnRpbnVlfX1pZih1Lm5vbmVnYXRlIT09dHJ1ZSYmbS5pbmRleD09PTApe25lZ2F0ZSgpO2NvbnRpbnVlfX1pZihHPT09XCIrXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7ZXh0Z2xvYk9wZW4oXCJwbHVzXCIsRyk7Y29udGludWV9aWYoQiYmQi52YWx1ZT09PVwiKFwifHx1LnJlZ2V4PT09ZmFsc2Upe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6RyxvdXRwdXQ6Z30pO2NvbnRpbnVlfWlmKEImJihCLnR5cGU9PT1cImJyYWNrZXRcInx8Qi50eXBlPT09XCJwYXJlblwifHxCLnR5cGU9PT1cImJyYWNlXCIpfHxtLnBhcmVucz4wKXtwdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOkd9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOmd9KTtjb250aW51ZX1pZihHPT09XCJAXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7cHVzaCh7dHlwZTpcImF0XCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHIT09XCIqXCIpe2lmKEc9PT1cIiRcInx8Rz09PVwiXlwiKXtHPWBcXFxcJHtHfWB9Y29uc3QgdD1hLmV4ZWMocmVtYWluaW5nKCkpO2lmKHQpe0crPXRbMF07bS5pbmRleCs9dFswXS5sZW5ndGh9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiZ2xvYnN0YXJcInx8Qi5zdGFyPT09dHJ1ZSkpe0IudHlwZT1cInN0YXJcIjtCLnN0YXI9dHJ1ZTtCLnZhbHVlKz1HO0Iub3V0cHV0PWs7bS5iYWNrdHJhY2s9dHJ1ZTttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1sZXQgZT1yZW1haW5pbmcoKTtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJi9eXFwoW14/XS8udGVzdChlKSl7ZXh0Z2xvYk9wZW4oXCJzdGFyXCIsRyk7Y29udGludWV9aWYoQi50eXBlPT09XCJzdGFyXCIpe2lmKHUubm9nbG9ic3Rhcj09PXRydWUpe2NvbnN1bWUoRyk7Y29udGludWV9Y29uc3Qgbj1CLnByZXY7Y29uc3Qgbz1uLnByZXY7Y29uc3Qgcz1uLnR5cGU9PT1cInNsYXNoXCJ8fG4udHlwZT09PVwiYm9zXCI7Y29uc3Qgcj1vJiYoby50eXBlPT09XCJzdGFyXCJ8fG8udHlwZT09PVwiZ2xvYnN0YXJcIik7aWYodS5iYXNoPT09dHJ1ZSYmKCFzfHxlWzBdJiZlWzBdIT09XCIvXCIpKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1jb25zdCBhPW0uYnJhY2VzPjAmJihuLnR5cGU9PT1cImNvbW1hXCJ8fG4udHlwZT09PVwiYnJhY2VcIik7Y29uc3QgaT13Lmxlbmd0aCYmKG4udHlwZT09PVwicGlwZVwifHxuLnR5cGU9PT1cInBhcmVuXCIpO2lmKCFzJiZuLnR5cGUhPT1cInBhcmVuXCImJiFhJiYhaSl7cHVzaCh7dHlwZTpcInN0YXJcIix2YWx1ZTpHLG91dHB1dDpcIlwifSk7Y29udGludWV9d2hpbGUoZS5zbGljZSgwLDMpPT09XCIvKipcIil7Y29uc3QgdT10W20uaW5kZXgrNF07aWYodSYmdSE9PVwiL1wiKXticmVha31lPWUuc2xpY2UoMyk7Y29uc3VtZShcIi8qKlwiLDMpfWlmKG4udHlwZT09PVwiYm9zXCImJmVvcygpKXtCLnR5cGU9XCJnbG9ic3RhclwiO0IudmFsdWUrPUc7Qi5vdXRwdXQ9Z2xvYnN0YXIodSk7bS5vdXRwdXQ9Qi5vdXRwdXQ7bS5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoRyk7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJiFyJiZlb3MoKSl7bS5vdXRwdXQ9bS5vdXRwdXQuc2xpY2UoMCwtKG4ub3V0cHV0K0Iub3V0cHV0KS5sZW5ndGgpO24ub3V0cHV0PWAoPzoke24ub3V0cHV0fWA7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KSsodS5zdHJpY3RTbGFzaGVzP1wiKVwiOlwifCQpXCIpO0IudmFsdWUrPUc7bS5nbG9ic3Rhcj10cnVlO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDtjb25zdW1lKEcpO2NvbnRpbnVlfWlmKG4udHlwZT09PVwic2xhc2hcIiYmbi5wcmV2LnR5cGUhPT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe2NvbnN0IHQ9ZVsxXSE9PXZvaWQgMD9cInwkXCI6XCJcIjttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrQi5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtCLnR5cGU9XCJnbG9ic3RhclwiO0Iub3V0cHV0PWAke2dsb2JzdGFyKHUpfSR7Yn18JHtifSR7dH0pYDtCLnZhbHVlKz1HO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHK00oKSk7cHVzaCh7dHlwZTpcInNsYXNoXCIsdmFsdWU6XCIvXCIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1pZihuLnR5cGU9PT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe0IudHlwZT1cImdsb2JzdGFyXCI7Qi52YWx1ZSs9RztCLm91dHB1dD1gKD86Xnwke2J9fCR7Z2xvYnN0YXIodSl9JHtifSlgO20ub3V0cHV0PUIub3V0cHV0O20uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEcrTSgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfW0ub3V0cHV0PW0ub3V0cHV0LnNsaWNlKDAsLUIub3V0cHV0Lmxlbmd0aCk7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KTtCLnZhbHVlKz1HO20ub3V0cHV0Kz1CLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1jb25zdCBuPXt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0Omt9O2lmKHUuYmFzaD09PXRydWUpe24ub3V0cHV0PVwiLio/XCI7aWYoQi50eXBlPT09XCJib3NcInx8Qi50eXBlPT09XCJzbGFzaFwiKXtuLm91dHB1dD1UK24ub3V0cHV0fXB1c2gobik7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiYnJhY2tldFwifHxCLnR5cGU9PT1cInBhcmVuXCIpJiZ1LnJlZ2V4PT09dHJ1ZSl7bi5vdXRwdXQ9RztwdXNoKG4pO2NvbnRpbnVlfWlmKG0uaW5kZXg9PT1tLnN0YXJ0fHxCLnR5cGU9PT1cInNsYXNoXCJ8fEIudHlwZT09PVwiZG90XCIpe2lmKEIudHlwZT09PVwiZG90XCIpe20ub3V0cHV0Kz14O0Iub3V0cHV0Kz14fWVsc2UgaWYodS5kb3Q9PT10cnVlKXttLm91dHB1dCs9UztCLm91dHB1dCs9U31lbHNle20ub3V0cHV0Kz1UO0Iub3V0cHV0Kz1UfWlmKEQoKSE9PVwiKlwiKXttLm91dHB1dCs9QztCLm91dHB1dCs9Q319cHVzaChuKX13aGlsZShtLmJyYWNrZXRzPjApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpO20ub3V0cHV0PW8uZXNjYXBlTGFzdChtLm91dHB1dCxcIltcIik7ZGVjcmVtZW50KFwiYnJhY2tldHNcIil9d2hpbGUobS5wYXJlbnM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiKVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwiKFwiKTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9d2hpbGUobS5icmFjZXM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwifVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwie1wiKTtkZWNyZW1lbnQoXCJicmFjZXNcIil9aWYodS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSYmKEIudHlwZT09PVwic3RhclwifHxCLnR5cGU9PT1cImJyYWNrZXRcIikpe3B1c2goe3R5cGU6XCJtYXliZV9zbGFzaFwiLHZhbHVlOlwiXCIsb3V0cHV0OmAke2J9P2B9KX1pZihtLmJhY2t0cmFjaz09PXRydWUpe20ub3V0cHV0PVwiXCI7Zm9yKGNvbnN0IHQgb2YgbS50b2tlbnMpe20ub3V0cHV0Kz10Lm91dHB1dCE9bnVsbD90Lm91dHB1dDp0LnZhbHVlO2lmKHQuc3VmZml4KXttLm91dHB1dCs9dC5zdWZmaXh9fX1yZXR1cm4gbX07cGFyc2UuZmFzdHBhdGhzPSh0LGUpPT57Y29uc3QgdT17Li4uZX07Y29uc3Qgcj10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7Y29uc3QgYT10Lmxlbmd0aDtpZihhPnIpe3Rocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke2F9LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7cn1gKX10PWNbdF18fHQ7Y29uc3R7RE9UX0xJVEVSQUw6aSxTTEFTSF9MSVRFUkFMOnAsT05FX0NIQVI6bCxET1RTX1NMQVNIOmYsTk9fRE9UOkEsTk9fRE9UUzpfLE5PX0RPVFNfU0xBU0g6UixTVEFSOkUsU1RBUlRfQU5DSE9SOmh9PW4uZ2xvYkNoYXJzKHUud2luZG93cyk7Y29uc3QgZz11LmRvdD9fOkE7Y29uc3QgYj11LmRvdD9SOkE7Y29uc3QgQz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgeT17bmVnYXRlZDpmYWxzZSxwcmVmaXg6XCJcIn07bGV0ICQ9dS5iYXNoPT09dHJ1ZT9cIi4qP1wiOkU7aWYodS5jYXB0dXJlKXskPWAoJHskfSlgfWNvbnN0IGdsb2JzdGFyPXQ9PntpZih0Lm5vZ2xvYnN0YXI9PT10cnVlKXJldHVybiAkO3JldHVybmAoJHtDfSg/Oig/ISR7aH0ke3QuZG90P2Y6aX0pLikqPylgfTtjb25zdCBjcmVhdGU9dD0+e3N3aXRjaCh0KXtjYXNlXCIqXCI6cmV0dXJuYCR7Z30ke2x9JHskfWA7Y2FzZVwiLipcIjpyZXR1cm5gJHtpfSR7bH0keyR9YDtjYXNlXCIqLipcIjpyZXR1cm5gJHtnfSR7JH0ke2l9JHtsfSR7JH1gO2Nhc2VcIiovKlwiOnJldHVybmAke2d9JHskfSR7cH0ke2x9JHtifSR7JH1gO2Nhc2VcIioqXCI6cmV0dXJuIGcrZ2xvYnN0YXIodSk7Y2FzZVwiKiovKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHtsfSR7JH1gO2Nhc2VcIioqLyouKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHskfSR7aX0ke2x9JHskfWA7Y2FzZVwiKiovLipcIjpyZXR1cm5gKD86JHtnfSR7Z2xvYnN0YXIodSl9JHtwfSk/JHtpfSR7bH0keyR9YDtkZWZhdWx0Ontjb25zdCBlPS9eKC4qPylcXC4oXFx3KykkLy5leGVjKHQpO2lmKCFlKXJldHVybjtjb25zdCB1PWNyZWF0ZShlWzFdKTtpZighdSlyZXR1cm47cmV0dXJuIHUraStlWzJdfX19O2NvbnN0IHg9by5yZW1vdmVQcmVmaXgodCx5KTtsZXQgUz1jcmVhdGUoeCk7aWYoUyYmdS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSl7Uys9YCR7cH0/YH1yZXR1cm4gU307dC5leHBvcnRzPXBhcnNlfSw1MTA6KHQsZSx1KT0+e2NvbnN0IG49dSg3MTYpO2NvbnN0IG89dSg2OTcpO2NvbnN0IHM9dSg5Nik7Y29uc3Qgcj11KDE1NCk7Y29uc3QgaXNPYmplY3Q9dD0+dCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtjb25zdCBwaWNvbWF0Y2g9KHQsZSx1PWZhbHNlKT0+e2lmKEFycmF5LmlzQXJyYXkodCkpe2NvbnN0IG49dC5tYXAoKHQ9PnBpY29tYXRjaCh0LGUsdSkpKTtjb25zdCBhcnJheU1hdGNoZXI9dD0+e2Zvcihjb25zdCBlIG9mIG4pe2NvbnN0IHU9ZSh0KTtpZih1KXJldHVybiB1fXJldHVybiBmYWxzZX07cmV0dXJuIGFycmF5TWF0Y2hlcn1jb25zdCBuPWlzT2JqZWN0KHQpJiZ0LnRva2VucyYmdC5pbnB1dDtpZih0PT09XCJcInx8dHlwZW9mIHQhPT1cInN0cmluZ1wiJiYhbil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWNvbnN0IG89ZXx8e307Y29uc3Qgcz1vLndpbmRvd3M7Y29uc3Qgcj1uP3BpY29tYXRjaC5jb21waWxlUmUodCxlKTpwaWNvbWF0Y2gubWFrZVJlKHQsZSxmYWxzZSx0cnVlKTtjb25zdCBhPXIuc3RhdGU7ZGVsZXRlIHIuc3RhdGU7bGV0IGlzSWdub3JlZD0oKT0+ZmFsc2U7aWYoby5pZ25vcmUpe2NvbnN0IHQ9ey4uLmUsaWdub3JlOm51bGwsb25NYXRjaDpudWxsLG9uUmVzdWx0Om51bGx9O2lzSWdub3JlZD1waWNvbWF0Y2goby5pZ25vcmUsdCx1KX1jb25zdCBtYXRjaGVyPSh1LG49ZmFsc2UpPT57Y29uc3R7aXNNYXRjaDppLG1hdGNoOmMsb3V0cHV0OnB9PXBpY29tYXRjaC50ZXN0KHUscixlLHtnbG9iOnQscG9zaXg6c30pO2NvbnN0IGw9e2dsb2I6dCxzdGF0ZTphLHJlZ2V4OnIscG9zaXg6cyxpbnB1dDp1LG91dHB1dDpwLG1hdGNoOmMsaXNNYXRjaDppfTtpZih0eXBlb2Ygby5vblJlc3VsdD09PVwiZnVuY3Rpb25cIil7by5vblJlc3VsdChsKX1pZihpPT09ZmFsc2Upe2wuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9sOmZhbHNlfWlmKGlzSWdub3JlZCh1KSl7aWYodHlwZW9mIG8ub25JZ25vcmU9PT1cImZ1bmN0aW9uXCIpe28ub25JZ25vcmUobCl9bC5pc01hdGNoPWZhbHNlO3JldHVybiBuP2w6ZmFsc2V9aWYodHlwZW9mIG8ub25NYXRjaD09PVwiZnVuY3Rpb25cIil7by5vbk1hdGNoKGwpfXJldHVybiBuP2w6dHJ1ZX07aWYodSl7bWF0Y2hlci5zdGF0ZT1hfXJldHVybiBtYXRjaGVyfTtwaWNvbWF0Y2gudGVzdD0odCxlLHUse2dsb2I6bixwb3NpeDpvfT17fSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbnB1dCB0byBiZSBhIHN0cmluZ1wiKX1pZih0PT09XCJcIil7cmV0dXJue2lzTWF0Y2g6ZmFsc2Usb3V0cHV0OlwiXCJ9fWNvbnN0IHI9dXx8e307Y29uc3QgYT1yLmZvcm1hdHx8KG8/cy50b1Bvc2l4U2xhc2hlczpudWxsKTtsZXQgaT10PT09bjtsZXQgYz1pJiZhP2EodCk6dDtpZihpPT09ZmFsc2Upe2M9YT9hKHQpOnQ7aT1jPT09bn1pZihpPT09ZmFsc2V8fHIuY2FwdHVyZT09PXRydWUpe2lmKHIubWF0Y2hCYXNlPT09dHJ1ZXx8ci5iYXNlbmFtZT09PXRydWUpe2k9cGljb21hdGNoLm1hdGNoQmFzZSh0LGUsdSxvKX1lbHNle2k9ZS5leGVjKGMpfX1yZXR1cm57aXNNYXRjaDpCb29sZWFuKGkpLG1hdGNoOmksb3V0cHV0OmN9fTtwaWNvbWF0Y2gubWF0Y2hCYXNlPSh0LGUsdSk9Pntjb25zdCBuPWUgaW5zdGFuY2VvZiBSZWdFeHA/ZTpwaWNvbWF0Y2gubWFrZVJlKGUsdSk7cmV0dXJuIG4udGVzdChzLmJhc2VuYW1lKHQpKX07cGljb21hdGNoLmlzTWF0Y2g9KHQsZSx1KT0+cGljb21hdGNoKGUsdSkodCk7cGljb21hdGNoLnBhcnNlPSh0LGUpPT57aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdC5tYXAoKHQ9PnBpY29tYXRjaC5wYXJzZSh0LGUpKSk7cmV0dXJuIG8odCx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KX07cGljb21hdGNoLnNjYW49KHQsZSk9Pm4odCxlKTtwaWNvbWF0Y2guY29tcGlsZVJlPSh0LGUsdT1mYWxzZSxuPWZhbHNlKT0+e2lmKHU9PT10cnVlKXtyZXR1cm4gdC5vdXRwdXR9Y29uc3Qgbz1lfHx7fTtjb25zdCBzPW8uY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCByPW8uY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgYT1gJHtzfSg/OiR7dC5vdXRwdXR9KSR7cn1gO2lmKHQmJnQubmVnYXRlZD09PXRydWUpe2E9YF4oPyEke2F9KS4qJGB9Y29uc3QgaT1waWNvbWF0Y2gudG9SZWdleChhLGUpO2lmKG49PT10cnVlKXtpLnN0YXRlPXR9cmV0dXJuIGl9O3BpY29tYXRjaC5tYWtlUmU9KHQsZT17fSx1PWZhbHNlLG49ZmFsc2UpPT57aWYoIXR8fHR5cGVvZiB0IT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1sZXQgcz17bmVnYXRlZDpmYWxzZSxmYXN0cGF0aHM6dHJ1ZX07aWYoZS5mYXN0cGF0aHMhPT1mYWxzZSYmKHRbMF09PT1cIi5cInx8dFswXT09PVwiKlwiKSl7cy5vdXRwdXQ9by5mYXN0cGF0aHModCxlKX1pZighcy5vdXRwdXQpe3M9byh0LGUpfXJldHVybiBwaWNvbWF0Y2guY29tcGlsZVJlKHMsZSx1LG4pfTtwaWNvbWF0Y2gudG9SZWdleD0odCxlKT0+e3RyeXtjb25zdCB1PWV8fHt9O3JldHVybiBuZXcgUmVnRXhwKHQsdS5mbGFnc3x8KHUubm9jYXNlP1wiaVwiOlwiXCIpKX1jYXRjaCh0KXtpZihlJiZlLmRlYnVnPT09dHJ1ZSl0aHJvdyB0O3JldHVybi8kXi99fTtwaWNvbWF0Y2guY29uc3RhbnRzPXI7dC5leHBvcnRzPXBpY29tYXRjaH0sNzE2Oih0LGUsdSk9Pntjb25zdCBuPXUoOTYpO2NvbnN0e0NIQVJfQVNURVJJU0s6byxDSEFSX0FUOnMsQ0hBUl9CQUNLV0FSRF9TTEFTSDpyLENIQVJfQ09NTUE6YSxDSEFSX0RPVDppLENIQVJfRVhDTEFNQVRJT05fTUFSSzpjLENIQVJfRk9SV0FSRF9TTEFTSDpwLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpsLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUExVUzpfLENIQVJfUVVFU1RJT05fTUFSSzpSLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6RSxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmgsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpnfT11KDE1NCk7Y29uc3QgaXNQYXRoU2VwYXJhdG9yPXQ9PnQ9PT1wfHx0PT09cjtjb25zdCBkZXB0aD10PT57aWYodC5pc1ByZWZpeCE9PXRydWUpe3QuZGVwdGg9dC5pc0dsb2JzdGFyP0luZmluaXR5OjF9fTtjb25zdCBzY2FuPSh0LGUpPT57Y29uc3QgdT1lfHx7fTtjb25zdCBiPXQubGVuZ3RoLTE7Y29uc3QgQz11LnBhcnRzPT09dHJ1ZXx8dS5zY2FuVG9FbmQ9PT10cnVlO2NvbnN0IHk9W107Y29uc3QgJD1bXTtjb25zdCB4PVtdO2xldCBTPXQ7bGV0IEg9LTE7bGV0IHY9MDtsZXQgZD0wO2xldCBMPWZhbHNlO2xldCBUPWZhbHNlO2xldCBPPWZhbHNlO2xldCBrPWZhbHNlO2xldCBtPWZhbHNlO2xldCB3PWZhbHNlO2xldCBOPWZhbHNlO2xldCBJPWZhbHNlO2xldCBCPWZhbHNlO2xldCBHPWZhbHNlO2xldCBEPTA7bGV0IE07bGV0IFA7bGV0IEs9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2NvbnN0IGVvcz0oKT0+SD49Yjtjb25zdCBwZWVrPSgpPT5TLmNoYXJDb2RlQXQoSCsxKTtjb25zdCBhZHZhbmNlPSgpPT57TT1QO3JldHVybiBTLmNoYXJDb2RlQXQoKytIKX07d2hpbGUoSDxiKXtQPWFkdmFuY2UoKTtsZXQgdDtpZihQPT09cil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7aWYoUD09PWwpe3c9dHJ1ZX1jb250aW51ZX1pZih3PT09dHJ1ZXx8UD09PWwpe0QrKzt3aGlsZShlb3MoKSE9PXRydWUmJihQPWFkdmFuY2UoKSkpe2lmKFA9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWwpe0QrKztjb250aW51ZX1pZih3IT09dHJ1ZSYmUD09PWkmJihQPWFkdmFuY2UoKSk9PT1pKXtMPUsuaXNCcmFjZT10cnVlO089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKHchPT10cnVlJiZQPT09YSl7TD1LLmlzQnJhY2U9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2lmKEM9PT10cnVlKXtjb250aW51ZX1icmVha31pZihQPT09RSl7RC0tO2lmKEQ9PT0wKXt3PWZhbHNlO0w9Sy5pc0JyYWNlPXRydWU7Rz10cnVlO2JyZWFrfX19aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1wKXt5LnB1c2goSCk7JC5wdXNoKEspO0s9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2lmKEc9PT10cnVlKWNvbnRpbnVlO2lmKE09PT1pJiZIPT09disxKXt2Kz0yO2NvbnRpbnVlfWQ9SCsxO2NvbnRpbnVlfWlmKHUubm9leHQhPT10cnVlKXtjb25zdCB0PVA9PT1ffHxQPT09c3x8UD09PW98fFA9PT1SfHxQPT09YztpZih0PT09dHJ1ZSYmcGVlaygpPT09Zil7Tz1LLmlzR2xvYj10cnVlO2s9Sy5pc0V4dGdsb2I9dHJ1ZTtHPXRydWU7aWYoUD09PWMmJkg9PT12KXtCPXRydWV9aWYoQz09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKFA9YWR2YW5jZSgpKSl7aWYoUD09PXIpe049Sy5iYWNrc2xhc2hlcz10cnVlO1A9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKFA9PT1oKXtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha319aWYoUD09PW8pe2lmKE09PT1vKW09Sy5pc0dsb2JzdGFyPXRydWU7Tz1LLmlzR2xvYj10cnVlO0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoUD09PVIpe089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1BKXt3aGlsZShlb3MoKSE9PXRydWUmJih0PWFkdmFuY2UoKSkpe2lmKHQ9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYodD09PWcpe1Q9Sy5pc0JyYWNrZXQ9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1pZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYodS5ub25lZ2F0ZSE9PXRydWUmJlA9PT1jJiZIPT09dil7ST1LLm5lZ2F0ZWQ9dHJ1ZTt2Kys7Y29udGludWV9aWYodS5ub3BhcmVuIT09dHJ1ZSYmUD09PWYpe089Sy5pc0dsb2I9dHJ1ZTtpZihDPT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoUD1hZHZhbmNlKCkpKXtpZihQPT09Zil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWgpe0c9dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9aWYoTz09PXRydWUpe0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9fWlmKHUubm9leHQ9PT10cnVlKXtrPWZhbHNlO089ZmFsc2V9bGV0IFU9UztsZXQgWD1cIlwiO2xldCBGPVwiXCI7aWYodj4wKXtYPVMuc2xpY2UoMCx2KTtTPVMuc2xpY2Uodik7ZC09dn1pZihVJiZPPT09dHJ1ZSYmZD4wKXtVPVMuc2xpY2UoMCxkKTtGPVMuc2xpY2UoZCl9ZWxzZSBpZihPPT09dHJ1ZSl7VT1cIlwiO0Y9U31lbHNle1U9U31pZihVJiZVIT09XCJcIiYmVSE9PVwiL1wiJiZVIT09Uyl7aWYoaXNQYXRoU2VwYXJhdG9yKFUuY2hhckNvZGVBdChVLmxlbmd0aC0xKSkpe1U9VS5zbGljZSgwLC0xKX19aWYodS51bmVzY2FwZT09PXRydWUpe2lmKEYpRj1uLnJlbW92ZUJhY2tzbGFzaGVzKEYpO2lmKFUmJk49PT10cnVlKXtVPW4ucmVtb3ZlQmFja3NsYXNoZXMoVSl9fWNvbnN0IFE9e3ByZWZpeDpYLGlucHV0OnQsc3RhcnQ6dixiYXNlOlUsZ2xvYjpGLGlzQnJhY2U6TCxpc0JyYWNrZXQ6VCxpc0dsb2I6Tyxpc0V4dGdsb2I6ayxpc0dsb2JzdGFyOm0sbmVnYXRlZDpJLG5lZ2F0ZWRFeHRnbG9iOkJ9O2lmKHUudG9rZW5zPT09dHJ1ZSl7US5tYXhEZXB0aD0wO2lmKCFpc1BhdGhTZXBhcmF0b3IoUCkpeyQucHVzaChLKX1RLnRva2Vucz0kfWlmKHUucGFydHM9PT10cnVlfHx1LnRva2Vucz09PXRydWUpe2xldCBlO2ZvcihsZXQgbj0wO248eS5sZW5ndGg7bisrKXtjb25zdCBvPWU/ZSsxOnY7Y29uc3Qgcz15W25dO2NvbnN0IHI9dC5zbGljZShvLHMpO2lmKHUudG9rZW5zKXtpZihuPT09MCYmdiE9PTApeyRbbl0uaXNQcmVmaXg9dHJ1ZTskW25dLnZhbHVlPVh9ZWxzZXskW25dLnZhbHVlPXJ9ZGVwdGgoJFtuXSk7US5tYXhEZXB0aCs9JFtuXS5kZXB0aH1pZihuIT09MHx8ciE9PVwiXCIpe3gucHVzaChyKX1lPXN9aWYoZSYmZSsxPHQubGVuZ3RoKXtjb25zdCBuPXQuc2xpY2UoZSsxKTt4LnB1c2gobik7aWYodS50b2tlbnMpeyRbJC5sZW5ndGgtMV0udmFsdWU9bjtkZXB0aCgkWyQubGVuZ3RoLTFdKTtRLm1heERlcHRoKz0kWyQubGVuZ3RoLTFdLmRlcHRofX1RLnNsYXNoZXM9eTtRLnBhcnRzPXh9cmV0dXJuIFF9O3QuZXhwb3J0cz1zY2FufSw5NjoodCxlLHUpPT57Y29uc3R7UkVHRVhfQkFDS1NMQVNIOm4sUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSDpvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6cyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDpyfT11KDE1NCk7ZS5pc09iamVjdD10PT50IT09bnVsbCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtlLmhhc1JlZ2V4Q2hhcnM9dD0+cy50ZXN0KHQpO2UuaXNSZWdleENoYXI9dD0+dC5sZW5ndGg9PT0xJiZlLmhhc1JlZ2V4Q2hhcnModCk7ZS5lc2NhcGVSZWdleD10PT50LnJlcGxhY2UocixcIlxcXFwkMVwiKTtlLnRvUG9zaXhTbGFzaGVzPXQ9PnQucmVwbGFjZShuLFwiL1wiKTtlLnJlbW92ZUJhY2tzbGFzaGVzPXQ9PnQucmVwbGFjZShvLCh0PT50PT09XCJcXFxcXCI/XCJcIjp0KSk7ZS5lc2NhcGVMYXN0PSh0LHUsbik9Pntjb25zdCBvPXQubGFzdEluZGV4T2YodSxuKTtpZihvPT09LTEpcmV0dXJuIHQ7aWYodFtvLTFdPT09XCJcXFxcXCIpcmV0dXJuIGUuZXNjYXBlTGFzdCh0LHUsby0xKTtyZXR1cm5gJHt0LnNsaWNlKDAsbyl9XFxcXCR7dC5zbGljZShvKX1gfTtlLnJlbW92ZVByZWZpeD0odCxlPXt9KT0+e2xldCB1PXQ7aWYodS5zdGFydHNXaXRoKFwiLi9cIikpe3U9dS5zbGljZSgyKTtlLnByZWZpeD1cIi4vXCJ9cmV0dXJuIHV9O2Uud3JhcE91dHB1dD0odCxlPXt9LHU9e30pPT57Y29uc3Qgbj11LmNvbnRhaW5zP1wiXCI6XCJeXCI7Y29uc3Qgbz11LmNvbnRhaW5zP1wiXCI6XCIkXCI7bGV0IHM9YCR7bn0oPzoke3R9KSR7b31gO2lmKGUubmVnYXRlZD09PXRydWUpe3M9YCg/Ol4oPyEke3N9KS4qJClgfXJldHVybiBzfTtlLmJhc2VuYW1lPSh0LHt3aW5kb3dzOmV9PXt9KT0+e2NvbnN0IHU9dC5zcGxpdChlPy9bXFxcXC9dLzpcIi9cIik7Y29uc3Qgbj11W3UubGVuZ3RoLTFdO2lmKG49PT1cIlwiKXtyZXR1cm4gdVt1Lmxlbmd0aC0yXX1yZXR1cm4gbn19fTt2YXIgZT17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHUpe3ZhciBuPWVbdV07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgbz1lW3VdPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXt0W3VdKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSBlW3VdfXJldHVybiBvLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB1PV9fbmNjd3Bja19yZXF1aXJlX18oMTcwKTttb2R1bGUuZXhwb3J0cz11fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz8zMTU4Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/peek-readable/lib/Deferred.js":
/*!****************************************************!*\
  !*** ./node_modules/peek-readable/lib/Deferred.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.Deferred = void 0;\r\nclass Deferred {\r\n    constructor() {\r\n        this.resolve = () => null;\r\n        this.reject = () => null;\r\n        this.promise = new Promise((resolve, reject) => {\r\n            this.reject = reject;\r\n            this.resolve = resolve;\r\n        });\r\n    }\r\n}\r\nexports.Deferred = Deferred;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wZWVrLXJlYWRhYmxlL2xpYi9EZWZlcnJlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcGVlay1yZWFkYWJsZS9saWIvRGVmZXJyZWQuanM/ZjQ0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkRlZmVycmVkID0gdm9pZCAwO1xyXG5jbGFzcyBEZWZlcnJlZCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnJlc29sdmUgPSAoKSA9PiBudWxsO1xyXG4gICAgICAgIHRoaXMucmVqZWN0ID0gKCkgPT4gbnVsbDtcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuRGVmZXJyZWQgPSBEZWZlcnJlZDtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/peek-readable/lib/Deferred.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/peek-readable/lib/EndOfFileStream.js":
/*!***********************************************************!*\
  !*** ./node_modules/peek-readable/lib/EndOfFileStream.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.EndOfStreamError = exports.defaultMessages = void 0;\r\nexports.defaultMessages = 'End-Of-Stream';\r\n/**\r\n * Thrown on read operation of the end of file or stream has been reached\r\n */\r\nclass EndOfStreamError extends Error {\r\n    constructor() {\r\n        super(exports.defaultMessages);\r\n    }\r\n}\r\nexports.EndOfStreamError = EndOfStreamError;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wZWVrLXJlYWRhYmxlL2xpYi9FbmRPZkZpbGVTdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsdUJBQXVCO0FBQ2xELHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wZWVrLXJlYWRhYmxlL2xpYi9FbmRPZkZpbGVTdHJlYW0uanM/ZDIwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkVuZE9mU3RyZWFtRXJyb3IgPSBleHBvcnRzLmRlZmF1bHRNZXNzYWdlcyA9IHZvaWQgMDtcclxuZXhwb3J0cy5kZWZhdWx0TWVzc2FnZXMgPSAnRW5kLU9mLVN0cmVhbSc7XHJcbi8qKlxyXG4gKiBUaHJvd24gb24gcmVhZCBvcGVyYXRpb24gb2YgdGhlIGVuZCBvZiBmaWxlIG9yIHN0cmVhbSBoYXMgYmVlbiByZWFjaGVkXHJcbiAqL1xyXG5jbGFzcyBFbmRPZlN0cmVhbUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoZXhwb3J0cy5kZWZhdWx0TWVzc2FnZXMpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuRW5kT2ZTdHJlYW1FcnJvciA9IEVuZE9mU3RyZWFtRXJyb3I7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/peek-readable/lib/EndOfFileStream.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/peek-readable/lib/StreamReader.js":
/*!********************************************************!*\
  !*** ./node_modules/peek-readable/lib/StreamReader.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.StreamReader = exports.EndOfStreamError = void 0;\r\nconst EndOfFileStream_1 = __webpack_require__(/*! ./EndOfFileStream */ \"(app-pages-browser)/./node_modules/peek-readable/lib/EndOfFileStream.js\");\r\nconst Deferred_1 = __webpack_require__(/*! ./Deferred */ \"(app-pages-browser)/./node_modules/peek-readable/lib/Deferred.js\");\r\nvar EndOfFileStream_2 = __webpack_require__(/*! ./EndOfFileStream */ \"(app-pages-browser)/./node_modules/peek-readable/lib/EndOfFileStream.js\");\r\nObject.defineProperty(exports, \"EndOfStreamError\", ({ enumerable: true, get: function () { return EndOfFileStream_2.EndOfStreamError; } }));\r\nconst maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\r\nclass StreamReader {\r\n    constructor(s) {\r\n        this.s = s;\r\n        /**\r\n         * Deferred used for postponed read request (as not data is yet available to read)\r\n         */\r\n        this.deferred = null;\r\n        this.endOfStream = false;\r\n        /**\r\n         * Store peeked data\r\n         * @type {Array}\r\n         */\r\n        this.peekQueue = [];\r\n        if (!s.read || !s.once) {\r\n            throw new Error('Expected an instance of stream.Readable');\r\n        }\r\n        this.s.once('end', () => this.reject(new EndOfFileStream_1.EndOfStreamError()));\r\n        this.s.once('error', err => this.reject(err));\r\n        this.s.once('close', () => this.reject(new Error('Stream closed')));\r\n    }\r\n    /**\r\n     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\r\n     * @param uint8Array - Uint8Array (or Buffer) to store data read from stream in\r\n     * @param offset - Offset target\r\n     * @param length - Number of bytes to read\r\n     * @returns Number of bytes peeked\r\n     */\r\n    async peek(uint8Array, offset, length) {\r\n        const bytesRead = await this.read(uint8Array, offset, length);\r\n        this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead)); // Put read data back to peek buffer\r\n        return bytesRead;\r\n    }\r\n    /**\r\n     * Read chunk from stream\r\n     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in\r\n     * @param offset - Offset target\r\n     * @param length - Number of bytes to read\r\n     * @returns Number of bytes read\r\n     */\r\n    async read(buffer, offset, length) {\r\n        if (length === 0) {\r\n            return 0;\r\n        }\r\n        if (this.peekQueue.length === 0 && this.endOfStream) {\r\n            throw new EndOfFileStream_1.EndOfStreamError();\r\n        }\r\n        let remaining = length;\r\n        let bytesRead = 0;\r\n        // consume peeked data first\r\n        while (this.peekQueue.length > 0 && remaining > 0) {\r\n            const peekData = this.peekQueue.pop(); // Front of queue\r\n            if (!peekData)\r\n                throw new Error('peekData should be defined');\r\n            const lenCopy = Math.min(peekData.length, remaining);\r\n            buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);\r\n            bytesRead += lenCopy;\r\n            remaining -= lenCopy;\r\n            if (lenCopy < peekData.length) {\r\n                // remainder back to queue\r\n                this.peekQueue.push(peekData.subarray(lenCopy));\r\n            }\r\n        }\r\n        // continue reading from stream if required\r\n        while (remaining > 0 && !this.endOfStream) {\r\n            const reqLen = Math.min(remaining, maxStreamReadSize);\r\n            const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);\r\n            bytesRead += chunkLen;\r\n            if (chunkLen < reqLen)\r\n                break;\r\n            remaining -= chunkLen;\r\n        }\r\n        return bytesRead;\r\n    }\r\n    /**\r\n     * Read chunk from stream\r\n     * @param buffer Target Uint8Array (or Buffer) to store data read from stream in\r\n     * @param offset Offset target\r\n     * @param length Number of bytes to read\r\n     * @returns Number of bytes read\r\n     */\r\n    async readFromStream(buffer, offset, length) {\r\n        const readBuffer = this.s.read(length);\r\n        if (readBuffer) {\r\n            buffer.set(readBuffer, offset);\r\n            return readBuffer.length;\r\n        }\r\n        else {\r\n            const request = {\r\n                buffer,\r\n                offset,\r\n                length,\r\n                deferred: new Deferred_1.Deferred()\r\n            };\r\n            this.deferred = request.deferred;\r\n            this.s.once('readable', () => {\r\n                this.readDeferred(request);\r\n            });\r\n            return request.deferred.promise;\r\n        }\r\n    }\r\n    /**\r\n     * Process deferred read request\r\n     * @param request Deferred read request\r\n     */\r\n    readDeferred(request) {\r\n        const readBuffer = this.s.read(request.length);\r\n        if (readBuffer) {\r\n            request.buffer.set(readBuffer, request.offset);\r\n            request.deferred.resolve(readBuffer.length);\r\n            this.deferred = null;\r\n        }\r\n        else {\r\n            this.s.once('readable', () => {\r\n                this.readDeferred(request);\r\n            });\r\n        }\r\n    }\r\n    reject(err) {\r\n        this.endOfStream = true;\r\n        if (this.deferred) {\r\n            this.deferred.reject(err);\r\n            this.deferred = null;\r\n        }\r\n    }\r\n}\r\nexports.StreamReader = StreamReader;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wZWVrLXJlYWRhYmxlL2xpYi9TdHJlYW1SZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsd0JBQXdCO0FBQy9DLDBCQUEwQixtQkFBTyxDQUFDLGtHQUFtQjtBQUNyRCxtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBWTtBQUN2Qyx3QkFBd0IsbUJBQU8sQ0FBQyxrR0FBbUI7QUFDbkQsb0RBQW1ELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQ3pJLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcGVlay1yZWFkYWJsZS9saWIvU3RyZWFtUmVhZGVyLmpzPzMyZjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5TdHJlYW1SZWFkZXIgPSBleHBvcnRzLkVuZE9mU3RyZWFtRXJyb3IgPSB2b2lkIDA7XHJcbmNvbnN0IEVuZE9mRmlsZVN0cmVhbV8xID0gcmVxdWlyZShcIi4vRW5kT2ZGaWxlU3RyZWFtXCIpO1xyXG5jb25zdCBEZWZlcnJlZF8xID0gcmVxdWlyZShcIi4vRGVmZXJyZWRcIik7XHJcbnZhciBFbmRPZkZpbGVTdHJlYW1fMiA9IHJlcXVpcmUoXCIuL0VuZE9mRmlsZVN0cmVhbVwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRW5kT2ZTdHJlYW1FcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRW5kT2ZGaWxlU3RyZWFtXzIuRW5kT2ZTdHJlYW1FcnJvcjsgfSB9KTtcclxuY29uc3QgbWF4U3RyZWFtUmVhZFNpemUgPSAxICogMTAyNCAqIDEwMjQ7IC8vIE1heGltdW0gcmVxdWVzdCBsZW5ndGggb24gcmVhZC1zdHJlYW0gb3BlcmF0aW9uXHJcbmNsYXNzIFN0cmVhbVJlYWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzKSB7XHJcbiAgICAgICAgdGhpcy5zID0gcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZlcnJlZCB1c2VkIGZvciBwb3N0cG9uZWQgcmVhZCByZXF1ZXN0IChhcyBub3QgZGF0YSBpcyB5ZXQgYXZhaWxhYmxlIHRvIHJlYWQpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZWZlcnJlZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbmRPZlN0cmVhbSA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0b3JlIHBlZWtlZCBkYXRhXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGVla1F1ZXVlID0gW107XHJcbiAgICAgICAgaWYgKCFzLnJlYWQgfHwgIXMub25jZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGFuIGluc3RhbmNlIG9mIHN0cmVhbS5SZWFkYWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnMub25jZSgnZW5kJywgKCkgPT4gdGhpcy5yZWplY3QobmV3IEVuZE9mRmlsZVN0cmVhbV8xLkVuZE9mU3RyZWFtRXJyb3IoKSkpO1xyXG4gICAgICAgIHRoaXMucy5vbmNlKCdlcnJvcicsIGVyciA9PiB0aGlzLnJlamVjdChlcnIpKTtcclxuICAgICAgICB0aGlzLnMub25jZSgnY2xvc2UnLCAoKSA9PiB0aGlzLnJlamVjdChuZXcgRXJyb3IoJ1N0cmVhbSBjbG9zZWQnKSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGFoZWFkIChwZWVrKSBmcm9tIHN0cmVhbS4gU3Vic2VxdWVudCByZWFkIG9yIHBlZWtzIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGRhdGFcclxuICAgICAqIEBwYXJhbSB1aW50OEFycmF5IC0gVWludDhBcnJheSAob3IgQnVmZmVyKSB0byBzdG9yZSBkYXRhIHJlYWQgZnJvbSBzdHJlYW0gaW5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgLSBPZmZzZXQgdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIC0gTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWRcclxuICAgICAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyBwZWVrZWRcclxuICAgICAqL1xyXG4gICAgYXN5bmMgcGVlayh1aW50OEFycmF5LCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGJ5dGVzUmVhZCA9IGF3YWl0IHRoaXMucmVhZCh1aW50OEFycmF5LCBvZmZzZXQsIGxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5wZWVrUXVldWUucHVzaCh1aW50OEFycmF5LnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgYnl0ZXNSZWFkKSk7IC8vIFB1dCByZWFkIGRhdGEgYmFjayB0byBwZWVrIGJ1ZmZlclxyXG4gICAgICAgIHJldHVybiBieXRlc1JlYWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgY2h1bmsgZnJvbSBzdHJlYW1cclxuICAgICAqIEBwYXJhbSBidWZmZXIgLSBUYXJnZXQgVWludDhBcnJheSAob3IgQnVmZmVyKSB0byBzdG9yZSBkYXRhIHJlYWQgZnJvbSBzdHJlYW0gaW5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgLSBPZmZzZXQgdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIC0gTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWRcclxuICAgICAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyByZWFkXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlYWQoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnBlZWtRdWV1ZS5sZW5ndGggPT09IDAgJiYgdGhpcy5lbmRPZlN0cmVhbSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRW5kT2ZGaWxlU3RyZWFtXzEuRW5kT2ZTdHJlYW1FcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmVtYWluaW5nID0gbGVuZ3RoO1xyXG4gICAgICAgIGxldCBieXRlc1JlYWQgPSAwO1xyXG4gICAgICAgIC8vIGNvbnN1bWUgcGVla2VkIGRhdGEgZmlyc3RcclxuICAgICAgICB3aGlsZSAodGhpcy5wZWVrUXVldWUubGVuZ3RoID4gMCAmJiByZW1haW5pbmcgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBlZWtEYXRhID0gdGhpcy5wZWVrUXVldWUucG9wKCk7IC8vIEZyb250IG9mIHF1ZXVlXHJcbiAgICAgICAgICAgIGlmICghcGVla0RhdGEpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BlZWtEYXRhIHNob3VsZCBiZSBkZWZpbmVkJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlbkNvcHkgPSBNYXRoLm1pbihwZWVrRGF0YS5sZW5ndGgsIHJlbWFpbmluZyk7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5zZXQocGVla0RhdGEuc3ViYXJyYXkoMCwgbGVuQ29weSksIG9mZnNldCArIGJ5dGVzUmVhZCk7XHJcbiAgICAgICAgICAgIGJ5dGVzUmVhZCArPSBsZW5Db3B5O1xyXG4gICAgICAgICAgICByZW1haW5pbmcgLT0gbGVuQ29weTtcclxuICAgICAgICAgICAgaWYgKGxlbkNvcHkgPCBwZWVrRGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbWFpbmRlciBiYWNrIHRvIHF1ZXVlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlZWtRdWV1ZS5wdXNoKHBlZWtEYXRhLnN1YmFycmF5KGxlbkNvcHkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb250aW51ZSByZWFkaW5nIGZyb20gc3RyZWFtIGlmIHJlcXVpcmVkXHJcbiAgICAgICAgd2hpbGUgKHJlbWFpbmluZyA+IDAgJiYgIXRoaXMuZW5kT2ZTdHJlYW0pIHtcclxuICAgICAgICAgICAgY29uc3QgcmVxTGVuID0gTWF0aC5taW4ocmVtYWluaW5nLCBtYXhTdHJlYW1SZWFkU2l6ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNodW5rTGVuID0gYXdhaXQgdGhpcy5yZWFkRnJvbVN0cmVhbShidWZmZXIsIG9mZnNldCArIGJ5dGVzUmVhZCwgcmVxTGVuKTtcclxuICAgICAgICAgICAgYnl0ZXNSZWFkICs9IGNodW5rTGVuO1xyXG4gICAgICAgICAgICBpZiAoY2h1bmtMZW4gPCByZXFMZW4pXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgcmVtYWluaW5nIC09IGNodW5rTGVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGNodW5rIGZyb20gc3RyZWFtXHJcbiAgICAgKiBAcGFyYW0gYnVmZmVyIFRhcmdldCBVaW50OEFycmF5IChvciBCdWZmZXIpIHRvIHN0b3JlIGRhdGEgcmVhZCBmcm9tIHN0cmVhbSBpblxyXG4gICAgICogQHBhcmFtIG9mZnNldCBPZmZzZXQgdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byByZWFkXHJcbiAgICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgcmVhZFxyXG4gICAgICovXHJcbiAgICBhc3luYyByZWFkRnJvbVN0cmVhbShidWZmZXIsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgcmVhZEJ1ZmZlciA9IHRoaXMucy5yZWFkKGxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHJlYWRCdWZmZXIpIHtcclxuICAgICAgICAgICAgYnVmZmVyLnNldChyZWFkQnVmZmVyLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVhZEJ1ZmZlci5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQ6IG5ldyBEZWZlcnJlZF8xLkRlZmVycmVkKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZCA9IHJlcXVlc3QuZGVmZXJyZWQ7XHJcbiAgICAgICAgICAgIHRoaXMucy5vbmNlKCdyZWFkYWJsZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVhZERlZmVycmVkKHJlcXVlc3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QuZGVmZXJyZWQucHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3MgZGVmZXJyZWQgcmVhZCByZXF1ZXN0XHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCBEZWZlcnJlZCByZWFkIHJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgcmVhZERlZmVycmVkKHJlcXVlc3QpIHtcclxuICAgICAgICBjb25zdCByZWFkQnVmZmVyID0gdGhpcy5zLnJlYWQocmVxdWVzdC5sZW5ndGgpO1xyXG4gICAgICAgIGlmIChyZWFkQnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3QuYnVmZmVyLnNldChyZWFkQnVmZmVyLCByZXF1ZXN0Lm9mZnNldCk7XHJcbiAgICAgICAgICAgIHJlcXVlc3QuZGVmZXJyZWQucmVzb2x2ZShyZWFkQnVmZmVyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zLm9uY2UoJ3JlYWRhYmxlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkRGVmZXJyZWQocmVxdWVzdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlamVjdChlcnIpIHtcclxuICAgICAgICB0aGlzLmVuZE9mU3RyZWFtID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5kZWZlcnJlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5TdHJlYW1SZWFkZXIgPSBTdHJlYW1SZWFkZXI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/peek-readable/lib/StreamReader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/peek-readable/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/peek-readable/lib/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.StreamReader = exports.EndOfStreamError = void 0;\r\nvar EndOfFileStream_1 = __webpack_require__(/*! ./EndOfFileStream */ \"(app-pages-browser)/./node_modules/peek-readable/lib/EndOfFileStream.js\");\r\nObject.defineProperty(exports, \"EndOfStreamError\", ({ enumerable: true, get: function () { return EndOfFileStream_1.EndOfStreamError; } }));\r\nvar StreamReader_1 = __webpack_require__(/*! ./StreamReader */ \"(app-pages-browser)/./node_modules/peek-readable/lib/StreamReader.js\");\r\nObject.defineProperty(exports, \"StreamReader\", ({ enumerable: true, get: function () { return StreamReader_1.StreamReader; } }));\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wZWVrLXJlYWRhYmxlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyx3QkFBd0I7QUFDL0Msd0JBQXdCLG1CQUFPLENBQUMsa0dBQW1CO0FBQ25ELG9EQUFtRCxFQUFFLHFDQUFxQyw4Q0FBOEMsRUFBQztBQUN6SSxxQkFBcUIsbUJBQU8sQ0FBQyw0RkFBZ0I7QUFDN0MsZ0RBQStDLEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wZWVrLXJlYWRhYmxlL2xpYi9pbmRleC5qcz9iYWRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU3RyZWFtUmVhZGVyID0gZXhwb3J0cy5FbmRPZlN0cmVhbUVycm9yID0gdm9pZCAwO1xyXG52YXIgRW5kT2ZGaWxlU3RyZWFtXzEgPSByZXF1aXJlKFwiLi9FbmRPZkZpbGVTdHJlYW1cIik7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVuZE9mU3RyZWFtRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEVuZE9mRmlsZVN0cmVhbV8xLkVuZE9mU3RyZWFtRXJyb3I7IH0gfSk7XHJcbnZhciBTdHJlYW1SZWFkZXJfMSA9IHJlcXVpcmUoXCIuL1N0cmVhbVJlYWRlclwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RyZWFtUmVhZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBTdHJlYW1SZWFkZXJfMS5TdHJlYW1SZWFkZXI7IH0gfSk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/peek-readable/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/readable-stream/errors-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/errors-browser.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZXJyb3JzLWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZ0RBQWdELDBEQUEwRCwyQ0FBMkM7O0FBRXJKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2Vycm9ycy1icm93c2VyLmpzPzZiMmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGNvZGVzID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gIGlmICghQmFzZSkge1xuICAgIEJhc2UgPSBFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTm9kZUVycm9yID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICBfaW5oZXJpdHNMb29zZShOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICByZXR1cm4gX0Jhc2UuY2FsbCh0aGlzLCBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlRXJyb3I7XG4gIH0oQmFzZSk7XG5cbiAgTm9kZUVycm9yLnByb3RvdHlwZS5uYW1lID0gQmFzZS5uYW1lO1xuICBOb2RlRXJyb3IucHJvdG90eXBlLmNvZGUgPSBjb2RlO1xuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiAnVGhlIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiJztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgZnVuY3Rpb24gKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH1cblxuICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KHR5cGVvZiBhY3R1YWwpO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRicsICdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnVGhlICcgKyBuYW1lICsgJyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScsICdQcmVtYXR1cmUgY2xvc2UnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ0Nhbm5vdCBjYWxsICcgKyBuYW1lICsgJyBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTVVMVElQTEVfQ0FMTEJBQ0snLCAnQ2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fQ0FOTk9UX1BJUEUnLCAnQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCcsICd3cml0ZSBhZnRlciBlbmQnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUycsICdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScsIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9VTktOT1dOX0VOQ09ESU5HJywgZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBhcmc7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UJywgJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/readable-stream/errors-browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"(app-pages-browser)/./node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"(app-pages-browser)/./node_modules/readable-stream/lib/_stream_writable.js\");\n__webpack_require__(/*! inherits */ \"(app-pages-browser)/./node_modules/inherits/inherits_browser.js\")(Duplex, Readable);\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(onEndNT, this);\n}\nfunction onEndNT(self) {\n  self.end();\n}\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHNHQUFvQjtBQUMzQyxlQUFlLG1CQUFPLENBQUMsc0dBQW9CO0FBQzNDLG1CQUFPLENBQUMsaUZBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUUsT0FBTztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzPzcyMzkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcbnJlcXVpcmUoJ2luaGVyaXRzJykoRHVwbGV4LCBSZWFkYWJsZSk7XG57XG4gIC8vIEFsbG93IHRoZSBrZXlzIGFycmF5IHRvIGJlIEdDJ2VkLlxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gICAgfVxuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBJZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCwgdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/readable-stream/lib/_stream_duplex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nmodule.exports = PassThrough;\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"(app-pages-browser)/./node_modules/readable-stream/lib/_stream_transform.js\");\n__webpack_require__(/*! inherits */ \"(app-pages-browser)/./node_modules/inherits/inherits_browser.js\")(PassThrough, Transform);\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyx3R0FBcUI7QUFDN0MsbUJBQU8sQ0FBQyxpRkFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzPzNkNDkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xucmVxdWlyZSgnaW5oZXJpdHMnKShQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/readable-stream/lib/_stream_passthrough.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = (__webpack_require__(/*! events */ \"(app-pages-browser)/./node_modules/events/events.js\").EventEmitter);\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\nvar Buffer = (__webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\").Buffer);\nvar OurUint8Array = (typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*<replacement>*/\nvar debugUtil = __webpack_require__(/*! util */ \"?8c28\");\nvar debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ \"(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/buffer_list.js\");\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/state.js\"),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"(app-pages-browser)/./node_modules/readable-stream/errors-browser.js\").codes),\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n\n// Lazy loaded to improve the startup performance.\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n__webpack_require__(/*! inherits */ \"(app-pages-browser)/./node_modules/inherits/inherits_browser.js\")(Readable, Stream);\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"(app-pages-browser)/./node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"(app-pages-browser)/./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"(app-pages-browser)/./node_modules/readable-stream/lib/_stream_duplex.js\");\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex);\n\n  // legacy\n  this.readable = true;\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n  Stream.call(this);\n}\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n  return er;\n}\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"(app-pages-browser)/./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null), decoder.encoding equals utf8\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  // Iterate over current buffer to convert already stored Buffers:\n  var p = this._readableState.buffer.head;\n  var content = '';\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n  this._readableState.buffer.clear();\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB\nvar MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n  return dest;\n};\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {\n      hasUnpiped: false\n    });\n    return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n  state.paused = false;\n  return this;\n};\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState.paused = true;\n  return this;\n};\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n  return this;\n};\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ \"(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/async_iterator.js\");\n    }\n    return createReadableStreamAsyncIterator(this);\n  };\n}\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n});\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = __webpack_require__(/*! ./internal/streams/from */ \"(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/from-browser.js\");\n    }\n    return from(Readable, iterable, opts);\n  };\n}\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUyx1R0FBOEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG1CQUFPLENBQUMsNEhBQTJCO0FBQ2hEOztBQUVBLGFBQWEsZ0dBQXdCO0FBQ3JDLDRCQUE0QixxQkFBTSxtQkFBbUIscUJBQU0sbUZBQW1GO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG1CQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsOEhBQWdDO0FBQ3pELGtCQUFrQixtQkFBTyxDQUFDLHNIQUE0QjtBQUN0RCxlQUFlLG1CQUFPLENBQUMsa0hBQTBCO0FBQ2pEO0FBQ0EscUJBQXFCLG9IQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFPLENBQUMsaUZBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLG1GQUFtRjtBQUM1SjtBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsa0dBQWtCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxSUFBd0M7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGtHQUFrQjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0YsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxxSUFBd0M7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLE9BQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxPQUFPLG9CQUFvQixPQUFPO0FBQ2xHO0FBQ0Esd0JBQXdCLE9BQU8saUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFPLENBQUMsb0lBQW1DO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsbURBQW1ELCtEQUErRDtBQUNsSDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyx3SEFBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanM/MmUzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBFRWxpc3RlbmVyQ291bnQoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fSkuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZztcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRixcbiAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7XG5cbi8vIExhenkgbG9hZGVkIHRvIGltcHJvdmUgdGhlIHN0YXJ0dXAgcGVyZm9ybWFuY2UuXG52YXIgU3RyaW5nRGVjb2RlcjtcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7XG52YXIgZnJvbTtcbnJlcXVpcmUoJ2luaGVyaXRzJykoUmVhZGFibGUsIFN0cmVhbSk7XG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuXG4gIC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlO1xuXG4gIC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZW5kJyAoYW5kIHBvdGVudGlhbGx5ICdmaW5pc2gnKVxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95O1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBSZWFkYWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIGRlYnVnKCdyZWFkYWJsZUFkZENodW5rJywgY2h1bmspO1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GKCkpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdmFyIGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyO1xuICAvLyBJZiBzZXRFbmNvZGluZyhudWxsKSwgZGVjb2Rlci5lbmNvZGluZyBlcXVhbHMgdXRmOFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG4gIHZhciBwID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDtcbiAgdmFyIGNvbnRlbnQgPSAnJztcbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICBjb250ZW50ICs9IGRlY29kZXIud3JpdGUocC5kYXRhKTtcbiAgICBwID0gcC5uZXh0O1xuICB9XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIGlmIChjb250ZW50ICE9PSAnJykgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCXG52YXIgTUFYX0hXTSA9IDB4NDAwMDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICAvLyBUT0RPKHJvbmFnKTogVGhyb3cgRVJSX1ZBTFVFX09VVF9PRl9SQU5HRS5cbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmICgoc3RhdGUuaGlnaFdhdGVyTWFyayAhPT0gMCA/IHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIDogc3RhdGUubGVuZ3RoID4gMCkgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICB9XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG4gIHJldHVybiByZXQ7XG59O1xuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdvbkVvZkNodW5rJyk7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gaWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGxcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUubmVlZFJlYWRhYmxlLCBzdGF0ZS5lbWl0dGVkUmVhZGFibGUpO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZV8nLCBzdGF0ZS5kZXN0cm95ZWQsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB9XG5cbiAgLy8gVGhlIHN0cmVhbSBuZWVkcyBhbm90aGVyIHJlYWRhYmxlIGV2ZW50IGlmXG4gIC8vIDEuIEl0IGlzIG5vdCBmbG93aW5nLCBhcyB0aGUgZmxvdyBtZWNoYW5pc20gd2lsbCB0YWtlXG4gIC8vICAgIGNhcmUgb2YgaXQuXG4gIC8vIDIuIEl0IGlzIG5vdCBlbmRlZC5cbiAgLy8gMy4gSXQgaXMgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmssIHNvIHdlIGNhbiBzY2hlZHVsZVxuICAvLyAgICBhbm90aGVyIHJlYWRhYmxlIGxhdGVyLlxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBBdHRlbXB0IHRvIHJlYWQgbW9yZSBkYXRhIGlmIHdlIHNob3VsZC5cbiAgLy9cbiAgLy8gVGhlIGNvbmRpdGlvbnMgZm9yIHJlYWRpbmcgbW9yZSBkYXRhIGFyZSAob25lIG9mKTpcbiAgLy8gLSBOb3QgZW5vdWdoIGRhdGEgYnVmZmVyZWQgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspLiBUaGUgbG9vcFxuICAvLyAgIGlzIHJlc3BvbnNpYmxlIGZvciBmaWxsaW5nIHRoZSBidWZmZXIgd2l0aCBlbm91Z2ggZGF0YSBpZiBzdWNoIGRhdGFcbiAgLy8gICBpcyBhdmFpbGFibGUuIElmIGhpZ2hXYXRlck1hcmsgaXMgMCBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZmxvd2luZyBtb2RlXG4gIC8vICAgd2Ugc2hvdWxkIF9ub3RfIGF0dGVtcHQgdG8gYnVmZmVyIGFueSBleHRyYSBkYXRhLiBXZSdsbCBnZXQgbW9yZSBkYXRhXG4gIC8vICAgd2hlbiB0aGUgc3RyZWFtIGNvbnN1bWVyIGNhbGxzIHJlYWQoKSBpbnN0ZWFkLlxuICAvLyAtIE5vIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYW5kIHRoZSBzdHJlYW0gaXMgaW4gZmxvd2luZyBtb2RlLiBJbiB0aGlzIG1vZGVcbiAgLy8gICB0aGUgbG9vcCBiZWxvdyBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgcmVhZCgpIGlzIGNhbGxlZC4gRmFpbGluZyB0b1xuICAvLyAgIGNhbGwgcmVhZCBoZXJlIHdvdWxkIGFib3J0IHRoZSBmbG93IGFuZCB0aGVyZSdzIG5vIG90aGVyIG1lY2hhbmlzbSBmb3JcbiAgLy8gICBjb250aW51aW5nIHRoZSBmbG93IGlmIHRoZSBzdHJlYW0gY29uc3VtZXIgaGFzIGp1c3Qgc3Vic2NyaWJlZCB0byB0aGVcbiAgLy8gICAnZGF0YScgZXZlbnQuXG4gIC8vXG4gIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBhYm92ZSBjb25kaXRpb25zIHRvIGtlZXAgcmVhZGluZyBkYXRhLCB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgcHJldmVudCB0aGUgZGF0YSBmcm9tIGJlaW5nIHJlYWQ6XG4gIC8vIC0gVGhlIHN0cmVhbSBoYXMgZW5kZWQgKHN0YXRlLmVuZGVkKS5cbiAgLy8gLSBUaGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyAncmVhZCcgb3BlcmF0aW9uIChzdGF0ZS5yZWFkaW5nKS4gVGhpcyBpcyBhXG4gIC8vICAgY2FzZSB3aGVyZSB0aGUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwKSkge1xuICAgIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfcmVhZCgpJykpO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGRlYnVnKCdkZXN0LndyaXRlJywgcmV0KTtcbiAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGVycm9yT3JEZXN0cm95KGRlc3QsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn07XG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB7XG4gICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyB1cGRhdGUgcmVhZGFibGVMaXN0ZW5pbmcgc28gdGhhdCByZXN1bWUoKSBtYXkgYmUgYSBuby1vcFxuICAgIC8vIGEgZmV3IGxpbmVzIGRvd24uIFRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgb25jZSgncmVhZGFibGUnKS5cbiAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRoaXMubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG5cbiAgICAvLyBUcnkgc3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBkZWJ1Zygnb24gcmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLnJlYWRpbmcpO1xuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbik7XG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICB2YXIgc3RhdGUgPSBzZWxmLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgIXN0YXRlLnBhdXNlZCkge1xuICAgIC8vIGZsb3dpbmcgbmVlZHMgdG8gYmUgc2V0IHRvIHRydWUgbm93LCBvdGhlcndpc2VcbiAgICAvLyB0aGUgdXBjb21pbmcgcmVzdW1lIHdpbGwgbm90IGZsb3cuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG5cbiAgICAvLyBjcnVkZSB3YXkgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHJlc3VtZVxuICB9IGVsc2UgaWYgKHNlbGYubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCkge1xuICAgIHNlbGYucmVzdW1lKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIC8vIHdlIGZsb3cgb25seSBpZiB0aGVyZSBpcyBubyBvbmUgbGlzdGVuaW5nXG4gICAgLy8gZm9yIHJlYWRhYmxlLCBidXQgd2Ugc3RpbGwgaGF2ZSB0byBjYWxsXG4gICAgLy8gcmVzdW1lKClcbiAgICBzdGF0ZS5mbG93aW5nID0gIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpO1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKTtcbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIG1ldGhvZFdyYXAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXRob2RXcmFwUmV0dXJuRnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0aGlzO1xufTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3InKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKTtcbiAgfTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVGbG93aW5nJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBzdGF0ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25zdW1lKG4sIHN0YXRlLmRlY29kZXIpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKTtcbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aCk7XG5cbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAvLyBpZiB0aGUgd3JpdGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgICAgIGlmICghd1N0YXRlIHx8IHdTdGF0ZS5hdXRvRGVzdHJveSAmJiB3U3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/readable-stream/lib/_stream_readable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nmodule.exports = Transform;\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"(app-pages-browser)/./node_modules/readable-stream/errors-browser.js\").codes),\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"(app-pages-browser)/./node_modules/readable-stream/lib/_stream_duplex.js\");\n__webpack_require__(/*! inherits */ \"(app-pages-browser)/./node_modules/inherits/inherits_browser.js\")(Transform, Duplex);\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\nfunction prefinish() {\n  var _this = this;\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQSxxQkFBcUIsb0hBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGtHQUFrQjtBQUN2QyxtQkFBTyxDQUFDLGlGQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzP2M0OTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gIEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HLFxuICBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzA7XG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xucmVxdWlyZSgnaW5oZXJpdHMnKShUcmFuc2Zvcm0sIER1cGxleCk7XG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG4gIGlmIChjYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpKTtcbiAgfVxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG4gIGlmIChkYXRhICE9IG51bGwpXG4gICAgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuICBjYihlcik7XG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfdHJhbnNmb3JtKCknKSk7XG59O1xuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIGlmIChkYXRhICE9IG51bGwpXG4gICAgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gVE9ETyhCcmlkZ2VBUik6IFdyaXRlIGEgdGVzdCBmb3IgdGhlc2UgdHdvIGVycm9yIGNhc2VzXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wKCk7XG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcoKTtcbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/readable-stream/lib/_stream_transform.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"(app-pages-browser)/./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\nvar Buffer = (__webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\").Buffer);\nvar OurUint8Array = (typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/state.js\"),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"(app-pages-browser)/./node_modules/readable-stream/errors-browser.js\").codes),\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n__webpack_require__(/*! inherits */ \"(app-pages-browser)/./node_modules/inherits/inherits_browser.js\")(Writable, Stream);\nfunction nop() {}\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"(app-pages-browser)/./node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"(app-pages-browser)/./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex);\n\n  // legacy.\n  this.writable = true;\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END();\n  // TODO: defer error events consistently everywhere, not just the cb\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n  return true;\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n  return ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n  return need;\n}\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsb0ZBQWdCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG1CQUFPLENBQUMsNEhBQTJCO0FBQ2hEOztBQUVBLGFBQWEsZ0dBQXdCO0FBQ3JDLDRCQUE0QixxQkFBTSxtQkFBbUIscUJBQU0sbUZBQW1GO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHNIQUE0QjtBQUN0RCxlQUFlLG1CQUFPLENBQUMsa0hBQTBCO0FBQ2pEO0FBQ0EscUJBQXFCLG9IQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBTyxDQUFDLGlGQUFVO0FBQ2xCO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxrR0FBa0I7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0osQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsa0dBQWtCOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsT0FBTztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLHNEQUFzRDtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTztBQUNYO0FBQ0E7QUFDQSxJQUFJLE9BQU87QUFDWDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU8sY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzPzg4YzQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9DQU5OT1RfUElQRSxcbiAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsXG4gIEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQsXG4gIEVSUl9VTktOT1dOX0VOQ09ESU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1VOS05PV05fRU5DT0RJTkc7XG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnJlcXVpcmUoJ2luaGVyaXRzJykoV3JpdGFibGUsIFN0cmVhbSk7XG5mdW5jdGlvbiBub3AoKSB7fVxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLFxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlO1xuXG4gIC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZmluaXNoJyAoYW5kIHBvdGVudGlhbGx5ICdlbmQnKVxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95O1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgV3JpdGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgaWYgKCFpc0R1cGxleCAmJiAhcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpKSByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTtcbn07XG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKCk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciBlcjtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInXSwgY2h1bmspO1xuICB9XG4gIGlmIChlcikge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG4gIGlmIChzdGF0ZS5lbmRpbmcpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrKztcbn07XG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgRVJSX1VOS05PV05fRU5DT0RJTkcoZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHN0YXRlLm9ud3JpdGUobmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCd3cml0ZScpKTtlbHNlIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpO1xuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDtcbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfd3JpdGUoKScpKTtcbn07XG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xuICByZXR1cm4gdGhpcztcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7XG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgICAgLy8gaWYgdGhlIHJlYWRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgICAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgICAgICAgaWYgKCFyU3RhdGUgfHwgclN0YXRlLmF1dG9EZXN0cm95ICYmIHJTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3MubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cblxuICAvLyByZXVzZSB0aGUgZnJlZSBjb3JrUmVxLlxuICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/readable-stream/lib/_stream_writable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/async_iterator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/async_iterator.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n\n\nvar _Object$setPrototypeO;\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar finished = __webpack_require__(/*! ./end-of-stream */ \"(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n  if (resolve !== null) {\n    var data = iter[kStream].read();\n    // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n  next: function next() {\n    var _this = this;\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    }\n\n    // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n    var lastPromise = this[kLastPromise];\n    var promise;\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n      promise = new Promise(this[kHandlePromise]);\n    }\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject];\n      // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n      iterator[kError] = err;\n      return;\n    }\n    var resolve = iterator[kLastResolve];\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\nmodule.exports = createReadableStreamAsyncIterator;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3IuanMiLCJtYXBwaW5ncyI6IjtBQUFhOztBQUViO0FBQ0EsNENBQTRDLDJCQUEyQixrQkFBa0Isa0NBQWtDLG9FQUFvRSxLQUFLLE9BQU8sb0JBQW9CO0FBQy9OLCtCQUErQix1Q0FBdUM7QUFDdEUscUNBQXFDLCtEQUErRCxzQ0FBc0MsMEJBQTBCLCtDQUErQyx5Q0FBeUMsdUVBQXVFO0FBQ25VLGVBQWUsbUJBQU8sQ0FBQyxpSEFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLE9BQU87QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzP2Q5MzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX09iamVjdCRzZXRQcm90b3R5cGVPO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxudmFyIGZpbmlzaGVkID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG52YXIga0xhc3RSZXNvbHZlID0gU3ltYm9sKCdsYXN0UmVzb2x2ZScpO1xudmFyIGtMYXN0UmVqZWN0ID0gU3ltYm9sKCdsYXN0UmVqZWN0Jyk7XG52YXIga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xudmFyIGtFbmRlZCA9IFN5bWJvbCgnZW5kZWQnKTtcbnZhciBrTGFzdFByb21pc2UgPSBTeW1ib2woJ2xhc3RQcm9taXNlJyk7XG52YXIga0hhbmRsZVByb21pc2UgPSBTeW1ib2woJ2hhbmRsZVByb21pc2UnKTtcbnZhciBrU3RyZWFtID0gU3ltYm9sKCdzdHJlYW0nKTtcbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJSZXN1bHQodmFsdWUsIGRvbmUpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZG9uZTogZG9uZVxuICB9O1xufVxuZnVuY3Rpb24gcmVhZEFuZFJlc29sdmUoaXRlcikge1xuICB2YXIgcmVzb2x2ZSA9IGl0ZXJba0xhc3RSZXNvbHZlXTtcbiAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICB2YXIgZGF0YSA9IGl0ZXJba1N0cmVhbV0ucmVhZCgpO1xuICAgIC8vIHdlIGRlZmVyIGlmIGRhdGEgaXMgbnVsbFxuICAgIC8vIHdlIGNhbiBiZSBleHBlY3RpbmcgZWl0aGVyICdlbmQnIG9yXG4gICAgLy8gJ2Vycm9yJ1xuICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICBpdGVyW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25SZWFkYWJsZShpdGVyKSB7XG4gIC8vIHdlIHdhaXQgZm9yIHRoZSBuZXh0IHRpY2ssIGJlY2F1c2UgaXQgbWlnaHRcbiAgLy8gZW1pdCBhbiBlcnJvciB3aXRoIHByb2Nlc3MubmV4dFRpY2tcbiAgcHJvY2Vzcy5uZXh0VGljayhyZWFkQW5kUmVzb2x2ZSwgaXRlcik7XG59XG5mdW5jdGlvbiB3cmFwRm9yTmV4dChsYXN0UHJvbWlzZSwgaXRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxhc3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGl0ZXJba0VuZGVkXSkge1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGl0ZXJba0hhbmRsZVByb21pc2VdKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfTtcbn1cbnZhciBBc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uICgpIHt9KTtcbnZhciBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YoKF9PYmplY3Qkc2V0UHJvdG90eXBlTyA9IHtcbiAgZ2V0IHN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpc1trU3RyZWFtXTtcbiAgfSxcbiAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8vIGlmIHdlIGhhdmUgZGV0ZWN0ZWQgYW4gZXJyb3IgaW4gdGhlIG1lYW53aGlsZVxuICAgIC8vIHJlamVjdCBzdHJhaWdodCBhd2F5XG4gICAgdmFyIGVycm9yID0gdGhpc1trRXJyb3JdO1xuICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgaWYgKHRoaXNba0VuZGVkXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cbiAgICBpZiAodGhpc1trU3RyZWFtXS5kZXN0cm95ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdmlhIG5leHRUaWNrIGJlY2F1c2UgaWYgLmRlc3Ryb3koZXJyKSBpc1xuICAgICAgLy8gY2FsbGVkLCB0aGUgZXJyb3Igd2lsbCBiZSBlbWl0dGVkIHZpYSBuZXh0VGljaywgYW5kXG4gICAgICAvLyB3ZSBjYW5ub3QgZ3VhcmFudGVlIHRoYXQgdGhlcmUgaXMgbm8gZXJyb3IgbGluZ2VyaW5nIGFyb3VuZFxuICAgICAgLy8gd2FpdGluZyB0byBiZSBlbWl0dGVkLlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzW2tFcnJvcl0pIHtcbiAgICAgICAgICAgIHJlamVjdChfdGhpc1trRXJyb3JdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIG11bHRpcGxlIG5leHQoKSBjYWxsc1xuICAgIC8vIHdlIHdpbGwgd2FpdCBmb3IgdGhlIHByZXZpb3VzIFByb21pc2UgdG8gZmluaXNoXG4gICAgLy8gdGhpcyBsb2dpYyBpcyBvcHRpbWl6ZWQgdG8gc3VwcG9ydCBmb3IgYXdhaXQgbG9vcHMsXG4gICAgLy8gd2hlcmUgbmV4dCgpIGlzIG9ubHkgY2FsbGVkIG9uY2UgYXQgYSB0aW1lXG4gICAgdmFyIGxhc3RQcm9taXNlID0gdGhpc1trTGFzdFByb21pc2VdO1xuICAgIHZhciBwcm9taXNlO1xuICAgIGlmIChsYXN0UHJvbWlzZSkge1xuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCB0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhc3QgcGF0aCBuZWVkZWQgdG8gc3VwcG9ydCBtdWx0aXBsZSB0aGlzLnB1c2goKVxuICAgICAgLy8gd2l0aG91dCB0cmlnZ2VyaW5nIHRoZSBuZXh0KCkgcXVldWVcbiAgICAgIHZhciBkYXRhID0gdGhpc1trU3RyZWFtXS5yZWFkKCk7XG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH1cbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh0aGlzW2tIYW5kbGVQcm9taXNlXSk7XG4gICAgfVxuICAgIHRoaXNba0xhc3RQcm9taXNlXSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn0sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFwicmV0dXJuXCIsIGZ1bmN0aW9uIF9yZXR1cm4oKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuICAvLyBkZXN0cm95KGVyciwgY2IpIGlzIGEgcHJpdmF0ZSBBUElcbiAgLy8gd2UgY2FuIGd1YXJhbnRlZSB3ZSBoYXZlIHRoYXQgaGVyZSwgYmVjYXVzZSB3ZSBjb250cm9sIHRoZVxuICAvLyBSZWFkYWJsZSBjbGFzcyB0aGlzIGlzIGF0dGFjaGVkIHRvXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgX3RoaXMyW2tTdHJlYW1dLmRlc3Ryb3kobnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9KTtcbn0pLCBfT2JqZWN0JHNldFByb3RvdHlwZU8pLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSBmdW5jdGlvbiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3Ioc3RyZWFtKSB7XG4gIHZhciBfT2JqZWN0JGNyZWF0ZTtcbiAgdmFyIGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIChfT2JqZWN0JGNyZWF0ZSA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtTdHJlYW0sIHtcbiAgICB2YWx1ZTogc3RyZWFtLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVzb2x2ZSwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtMYXN0UmVqZWN0LCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0Vycm9yLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0VuZGVkLCB7XG4gICAgdmFsdWU6IHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtIYW5kbGVQcm9taXNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGRhdGEgPSBpdGVyYXRvcltrU3RyZWFtXS5yZWFkKCk7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IHJlc29sdmU7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IHJlamVjdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfT2JqZWN0JGNyZWF0ZSkpO1xuICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgZmluaXNoZWQoc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJykge1xuICAgICAgdmFyIHJlamVjdCA9IGl0ZXJhdG9yW2tMYXN0UmVqZWN0XTtcbiAgICAgIC8vIHJlamVjdCBpZiB3ZSBhcmUgd2FpdGluZyBmb3IgZGF0YSBpbiB0aGUgUHJvbWlzZVxuICAgICAgLy8gcmV0dXJuZWQgYnkgbmV4dCgpIGFuZCBzdG9yZSB0aGUgZXJyb3JcbiAgICAgIGlmIChyZWplY3QgIT09IG51bGwpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIGl0ZXJhdG9yW2tFcnJvcl0gPSBlcnI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZXNvbHZlID0gaXRlcmF0b3Jba0xhc3RSZXNvbHZlXTtcbiAgICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuICAgIGl0ZXJhdG9yW2tFbmRlZF0gPSB0cnVlO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUuYmluZChudWxsLCBpdGVyYXRvcikpO1xuICByZXR1cm4gaXRlcmF0b3I7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/async_iterator.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!**************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar _require = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\"),\n  Buffer = _require.Buffer;\nvar _require2 = __webpack_require__(/*! util */ \"?c852\"),\n  inspect = _require2.inspect;\nvar custom = inspect && inspect.custom || 'inspect';\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\nmodule.exports = /*#__PURE__*/function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n      while (p = p.next) ret += s + p.data;\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes or characters from the buffered data.\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    }\n\n    // Consumes a specified amount of characters from the buffered data.\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes from the buffered data.\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Make sure the linked list only shows the minimal necessary information.\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n  return BufferList;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDZEQUE2RCxpRUFBaUUsc0NBQXNDO0FBQ3ZVLGlDQUFpQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELDZEQUE2RCw0Q0FBNEMsb0tBQW9LLG1GQUFtRixLQUFLO0FBQzFlLDRDQUE0QywyQkFBMkIsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjtBQUMvTixrREFBa0QsMENBQTBDO0FBQzVGLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEO0FBQy9QLDhEQUE4RCxzRUFBc0UsOERBQThELGtEQUFrRCxpQkFBaUIsR0FBRztBQUN4USwrQkFBK0IsdUNBQXVDO0FBQ3RFLHFDQUFxQywrREFBK0Qsc0NBQXNDLDBCQUEwQiwrQ0FBK0MseUNBQXlDLHVFQUF1RTtBQUNuVSxlQUFlLG1CQUFPLENBQUMsa0VBQVE7QUFDL0I7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxtQkFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdC5qcz9hODU4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdidWZmZXInKSxcbiAgQnVmZmVyID0gX3JlcXVpcmUuQnVmZmVyO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ3V0aWwnKSxcbiAgaW5zcGVjdCA9IF9yZXF1aXJlMi5pbnNwZWN0O1xudmFyIGN1c3RvbSA9IGluc3BlY3QgJiYgaW5zcGVjdC5jdXN0b20gfHwgJ2luc3BlY3QnO1xuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuY29weS5jYWxsKHNyYywgdGFyZ2V0LCBvZmZzZXQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhCdWZmZXJMaXN0LCBbe1xuICAgIGtleTogXCJwdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2godikge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICBkYXRhOiB2LFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICBkYXRhOiB2LFxuICAgICAgICBuZXh0OiB0aGlzLmhlYWRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgICAtLXRoaXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJqb2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSByZXQgKz0gcyArIHAuZGF0YTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbmNhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25jYXQobikge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIG9yIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgfSwge1xuICAgIGtleTogXCJjb25zdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnN1bWUobiwgaGFzU3RyaW5ncykge1xuICAgICAgdmFyIHJldDtcbiAgICAgIGlmIChuIDwgdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIGBzbGljZWAgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICAgIHJldCA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgICAgICB0aGlzLmhlYWQuZGF0YSA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICAgICAgfSBlbHNlIGlmIChuID09PSB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gRmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoLlxuICAgICAgICByZXQgPSB0aGlzLnNoaWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXIuXG4gICAgICAgIHJldCA9IGhhc1N0cmluZ3MgPyB0aGlzLl9nZXRTdHJpbmcobikgOiB0aGlzLl9nZXRCdWZmZXIobik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXJzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB9XG5cbiAgICAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0cmluZyhuKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHZhciByZXQgPSBwLmRhdGE7XG4gICAgICBuIC09IHJldC5sZW5ndGg7XG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgICAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgICAgICBuIC09IG5iO1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgICsrYztcbiAgICAgIH1cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEJ1ZmZlcihuKSB7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgYyA9IDE7XG4gICAgICBwLmRhdGEuY29weShyZXQpO1xuICAgICAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICAgICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgICAgICBuIC09IG5iO1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgICsrYztcbiAgICAgIH1cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGlua2VkIGxpc3Qgb25seSBzaG93cyB0aGUgbWluaW1hbCBuZWNlc3NhcnkgaW5mb3JtYXRpb24uXG4gIH0sIHtcbiAgICBrZXk6IGN1c3RvbSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoXywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGluc3BlY3QodGhpcywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgLy8gT25seSBpbnNwZWN0IG9uZSBsZXZlbC5cbiAgICAgICAgZGVwdGg6IDAsXG4gICAgICAgIC8vIEl0IHNob3VsZCBub3QgcmVjdXJzZS5cbiAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/buffer_list.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n  return this;\n}\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFFBQVEsT0FBTztBQUNmLFFBQVE7QUFDUjtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2YsUUFBUTtBQUNSO0FBQ0EsUUFBUSxPQUFPO0FBQ2YsUUFBUTtBQUNSLFFBQVEsT0FBTztBQUNmO0FBQ0EsTUFBTTtBQUNOLE1BQU0sT0FBTztBQUNiO0FBQ0EsTUFBTTtBQUNOLE1BQU0sT0FBTztBQUNiO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcz8zZGNhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlTlQoc2VsZiwgZXJyKSB7XG4gIGVtaXRFcnJvck5UKHNlbGYsIGVycik7XG4gIGVtaXRDbG9zZU5UKHNlbGYpO1xufVxuZnVuY3Rpb24gZW1pdENsb3NlTlQoc2VsZikge1xuICBpZiAoc2VsZi5fd3JpdGFibGVTdGF0ZSAmJiAhc2VsZi5fd3JpdGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgaWYgKHNlbGYuX3JlYWRhYmxlU3RhdGUgJiYgIXNlbGYuX3JlYWRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIHNlbGYuZW1pdCgnY2xvc2UnKTtcbn1cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5hbENhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpIHtcbiAgLy8gV2UgaGF2ZSB0ZXN0cyB0aGF0IHJlbHkgb24gZXJyb3JzIGJlaW5nIGVtaXR0ZWRcbiAgLy8gaW4gdGhlIHNhbWUgdGljaywgc28gY2hhbmdpbmcgdGhpcyBpcyBzZW12ZXIgbWFqb3IuXG4gIC8vIEZvciBub3cgd2hlbiB5b3Ugb3B0LWluIHRvIGF1dG9EZXN0cm95IHdlIGFsbG93XG4gIC8vIHRoZSBlcnJvciB0byBiZSBlbWl0dGVkIG5leHRUaWNrLiBJbiBhIGZ1dHVyZVxuICAvLyBzZW12ZXIgbWFqb3IgdXBkYXRlIHdlIHNob3VsZCBjaGFuZ2UgdGhlIGRlZmF1bHQgdG8gdGhpcy5cblxuICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICBpZiAoclN0YXRlICYmIHJTdGF0ZS5hdXRvRGVzdHJveSB8fCB3U3RhdGUgJiYgd1N0YXRlLmF1dG9EZXN0cm95KSBzdHJlYW0uZGVzdHJveShlcnIpO2Vsc2Ugc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveSxcbiAgZXJyb3JPckRlc3Ryb3k6IGVycm9yT3JEZXN0cm95XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/destroy.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n\n\nvar ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(/*! ../../../errors */ \"(app-pages-browser)/./node_modules/readable-stream/errors-browser.js\").codes).ERR_STREAM_PREMATURE_CLOSE;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    callback.apply(this, args);\n  };\n}\nfunction noop() {}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n  var writableEnded = stream._writableState && stream._writableState.finished;\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n  var onclose = function onclose() {\n    var err;\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\nmodule.exports = eos;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVhOztBQUViLGlDQUFpQywwSEFBZ0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcz8xMGYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvZW5kLW9mLXN0cmVhbSB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRTtcbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5mdW5jdGlvbiBub29wKCkge31cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGVvcyhzdHJlYW0sIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVvcyhzdHJlYW0sIG51bGwsIG9wdHMpO1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICB2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZTtcbiAgdmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCBvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGU7XG4gIHZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uIG9ubGVnYWN5ZmluaXNoKCkge1xuICAgIGlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpO1xuICB9O1xuICB2YXIgd3JpdGFibGVFbmRlZCA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZSAmJiBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQ7XG4gIHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIHdyaXRhYmxlID0gZmFsc2U7XG4gICAgd3JpdGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCFyZWFkYWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuICB2YXIgcmVhZGFibGVFbmRlZCA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZSAmJiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZDtcbiAgdmFyIG9uZW5kID0gZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICByZWFkYWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG4gIHZhciBvbmVycm9yID0gZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgfTtcbiAgdmFyIG9uY2xvc2UgPSBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIHZhciBlcnI7XG4gICAgaWYgKHJlYWRhYmxlICYmICFyZWFkYWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fcmVhZGFibGVTdGF0ZSB8fCAhc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG4gICAgaWYgKHdyaXRhYmxlICYmICF3cml0YWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSB8fCAhc3RyZWFtLl93cml0YWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG4gIH07XG4gIHZhciBvbnJlcXVlc3QgPSBmdW5jdGlvbiBvbnJlcXVlc3QoKSB7XG4gICAgc3RyZWFtLnJlcS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICB9O1xuICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcbiAgICBzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5vbignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgb25yZXF1ZXN0KCk7ZWxzZSBzdHJlYW0ub24oJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICB9IGVsc2UgaWYgKHdyaXRhYmxlICYmICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAvLyBsZWdhY3kgc3RyZWFtc1xuICAgIHN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gIH1cbiAgc3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XG4gIHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICBpZiAob3B0cy5lcnJvciAhPT0gZmFsc2UpIHN0cmVhbS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIHN0cmVhbS5yZXEucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGVvczsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/from-browser.js":
/*!***************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/from-browser.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZnJvbS1icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20tYnJvd3Nlci5qcz8yNWJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWRhYmxlLmZyb20gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3NlcicpXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/from-browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!***********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n\n\nvar eos;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\nvar _require$codes = (__webpack_require__(/*! ../../../errors */ \"(app-pages-browser)/./node_modules/readable-stream/errors-browser.js\").codes),\n  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = __webpack_require__(/*! ./end-of-stream */ \"(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true;\n\n    // request.destroy just do .end - .abort is what we want\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\nfunction call(fn) {\n  fn();\n}\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\nmodule.exports = pipeline;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMEhBQWdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsK0JBQStCLG1CQUFPLENBQUMsaUhBQWlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsYUFBYTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcz81MmFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvcHVtcCB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW9zO1xuZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgY2FsbGJhY2suYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICB9O1xufVxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMsXG4gIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTLFxuICBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVEO1xuZnVuY3Rpb24gbm9vcChlcnIpIHtcbiAgLy8gUmV0aHJvdyB0aGUgZXJyb3IgaWYgaXQgZXhpc3RzIHRvIGF2b2lkIHN3YWxsb3dpbmcgaXRcbiAgaWYgKGVycikgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKTtcbiAgdmFyIGNsb3NlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNsb3NlZCA9IHRydWU7XG4gIH0pO1xuICBpZiAoZW9zID09PSB1bmRlZmluZWQpIGVvcyA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuICBlb3Moc3RyZWFtLCB7XG4gICAgcmVhZGFibGU6IHJlYWRpbmcsXG4gICAgd3JpdGFibGU6IHdyaXRpbmdcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIGNsb3NlZCA9IHRydWU7XG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG4gIHZhciBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoY2xvc2VkKSByZXR1cm47XG4gICAgaWYgKGRlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGRlc3Ryb3llZCA9IHRydWU7XG5cbiAgICAvLyByZXF1ZXN0LmRlc3Ryb3kganVzdCBkbyAuZW5kIC0gLmFib3J0IGlzIHdoYXQgd2Ugd2FudFxuICAgIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5hYm9ydCgpO1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpO1xuICAgIGNhbGxiYWNrKGVyciB8fCBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3BpcGUnKSk7XG4gIH07XG59XG5mdW5jdGlvbiBjYWxsKGZuKSB7XG4gIGZuKCk7XG59XG5mdW5jdGlvbiBwaXBlKGZyb20sIHRvKSB7XG4gIHJldHVybiBmcm9tLnBpcGUodG8pO1xufVxuZnVuY3Rpb24gcG9wQ2FsbGJhY2soc3RyZWFtcykge1xuICBpZiAoIXN0cmVhbXMubGVuZ3RoKSByZXR1cm4gbm9vcDtcbiAgaWYgKHR5cGVvZiBzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0gIT09ICdmdW5jdGlvbicpIHJldHVybiBub29wO1xuICByZXR1cm4gc3RyZWFtcy5wb3AoKTtcbn1cbmZ1bmN0aW9uIHBpcGVsaW5lKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RyZWFtcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdHJlYW1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHZhciBjYWxsYmFjayA9IHBvcENhbGxiYWNrKHN0cmVhbXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zWzBdKSkgc3RyZWFtcyA9IHN0cmVhbXNbMF07XG4gIGlmIChzdHJlYW1zLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnc3RyZWFtcycpO1xuICB9XG4gIHZhciBlcnJvcjtcbiAgdmFyIGRlc3Ryb3lzID0gc3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbSwgaSkge1xuICAgIHZhciByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgd3JpdGluZyA9IGkgPiAwO1xuICAgIHJldHVybiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcbiAgICAgIGlmIChlcnIpIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBpZiAocmVhZGluZykgcmV0dXJuO1xuICAgICAgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzdHJlYW1zLnJlZHVjZShwaXBlKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gcGlwZWxpbmU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/pipeline.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/state.js":
/*!********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/state.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar ERR_INVALID_OPT_VALUE = (__webpack_require__(/*! ../../../errors */ \"(app-pages-browser)/./node_modules/readable-stream/errors-browser.js\").codes).ERR_INVALID_OPT_VALUE;\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n    return Math.floor(hwm);\n  }\n\n  // Default value\n  return state.objectMode ? 16 : 16 * 1024;\n}\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsNEJBQTRCLDBIQUFnQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanM/YzRkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBFUlJfSU5WQUxJRF9PUFRfVkFMVUUgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfSU5WQUxJRF9PUFRfVkFMVUU7XG5mdW5jdGlvbiBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KSB7XG4gIHJldHVybiBvcHRpb25zLmhpZ2hXYXRlck1hcmsgIT0gbnVsbCA/IG9wdGlvbnMuaGlnaFdhdGVyTWFyayA6IGlzRHVwbGV4ID8gb3B0aW9uc1tkdXBsZXhLZXldIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEhpZ2hXYXRlck1hcmsoc3RhdGUsIG9wdGlvbnMsIGR1cGxleEtleSwgaXNEdXBsZXgpIHtcbiAgdmFyIGh3bSA9IGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpO1xuICBpZiAoaHdtICE9IG51bGwpIHtcbiAgICBpZiAoIShpc0Zpbml0ZShod20pICYmIE1hdGguZmxvb3IoaHdtKSA9PT0gaHdtKSB8fCBod20gPCAwKSB7XG4gICAgICB2YXIgbmFtZSA9IGlzRHVwbGV4ID8gZHVwbGV4S2V5IDogJ2hpZ2hXYXRlck1hcmsnO1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX09QVF9WQUxVRShuYW1lLCBod20pO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5mbG9vcihod20pO1xuICB9XG5cbiAgLy8gRGVmYXVsdCB2YWx1ZVxuICByZXR1cm4gc3RhdGUub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEhpZ2hXYXRlck1hcms6IGdldEhpZ2hXYXRlck1hcmtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/state.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! events */ \"(app-pages-browser)/./node_modules/events/events.js\").EventEmitter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0hBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanM/YmM5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/stream-browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"(app-pages-browser)/./node_modules/readable-stream/lib/_stream_readable.js\");\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"(app-pages-browser)/./node_modules/readable-stream/lib/_stream_writable.js\");\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"(app-pages-browser)/./node_modules/readable-stream/lib/_stream_duplex.js\");\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"(app-pages-browser)/./node_modules/readable-stream/lib/_stream_transform.js\");\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"(app-pages-browser)/./node_modules/readable-stream/lib/_stream_passthrough.js\");\nexports.finished = __webpack_require__(/*! ./lib/internal/streams/end-of-stream.js */ \"(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\nexports.pipeline = __webpack_require__(/*! ./lib/internal/streams/pipeline.js */ \"(app-pages-browser)/./node_modules/readable-stream/lib/internal/streams/pipeline.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1KQUFxRDtBQUMvRCxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLHFKQUF1RDtBQUN2RCwrSUFBbUQ7QUFDbkQsd0pBQXlEO0FBQ3pELDhKQUE2RDtBQUM3RCxpTEFBcUU7QUFDckUsdUtBQWdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcz9mMDBhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5leHBvcnRzLmZpbmlzaGVkID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzJyk7XG5leHBvcnRzLnBpcGVsaW5lID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcycpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/readable-stream/readable-browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/readable-web-to-node-stream/lib/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-web-to-node-stream/lib/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReadableWebToNodeStream = void 0;\nconst readable_stream_1 = __webpack_require__(/*! readable-stream */ \"(app-pages-browser)/./node_modules/readable-stream/readable-browser.js\");\n/**\n * Converts a Web-API stream into Node stream.Readable class\n * Node stream readable: https://nodejs.org/api/stream.html#stream_readable_streams\n * Web API readable-stream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\n * Node readable stream: https://nodejs.org/api/stream.html#stream_readable_streams\n */\nclass ReadableWebToNodeStream extends readable_stream_1.Readable {\n    /**\n     *\n     * @param stream Readable​Stream: https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream\n     */\n    constructor(stream) {\n        super();\n        this.bytesRead = 0;\n        this.released = false;\n        this.reader = stream.getReader();\n    }\n    /**\n     * Implementation of readable._read(size).\n     * When readable._read() is called, if data is available from the resource,\n     * the implementation should begin pushing that data into the read queue\n     * https://nodejs.org/api/stream.html#stream_readable_read_size_1\n     */\n    async _read() {\n        // Should start pushing data into the queue\n        // Read data from the underlying Web-API-readable-stream\n        if (this.released) {\n            this.push(null); // Signal EOF\n            return;\n        }\n        this.pendingRead = this.reader.read();\n        const data = await this.pendingRead;\n        // clear the promise before pushing pushing new data to the queue and allow sequential calls to _read()\n        delete this.pendingRead;\n        if (data.done || this.released) {\n            this.push(null); // Signal EOF\n        }\n        else {\n            this.bytesRead += data.value.length;\n            this.push(data.value); // Push new data to the queue\n        }\n    }\n    /**\n     * If there is no unresolved read call to Web-API Readable​Stream immediately returns;\n     * otherwise will wait until the read is resolved.\n     */\n    async waitForReadToComplete() {\n        if (this.pendingRead) {\n            await this.pendingRead;\n        }\n    }\n    /**\n     * Close wrapper\n     */\n    async close() {\n        await this.syncAndRelease();\n    }\n    async syncAndRelease() {\n        this.released = true;\n        await this.waitForReadToComplete();\n        await this.reader.releaseLock();\n    }\n}\nexports.ReadableWebToNodeStream = ReadableWebToNodeStream;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS13ZWItdG8tbm9kZS1zdHJlYW0vbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQjtBQUMvQiwwQkFBMEIsbUJBQU8sQ0FBQywrRkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS13ZWItdG8tbm9kZS1zdHJlYW0vbGliL2luZGV4LmpzPzI0YjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlYWRhYmxlV2ViVG9Ob2RlU3RyZWFtID0gdm9pZCAwO1xuY29uc3QgcmVhZGFibGVfc3RyZWFtXzEgPSByZXF1aXJlKFwicmVhZGFibGUtc3RyZWFtXCIpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIFdlYi1BUEkgc3RyZWFtIGludG8gTm9kZSBzdHJlYW0uUmVhZGFibGUgY2xhc3NcbiAqIE5vZGUgc3RyZWFtIHJlYWRhYmxlOiBodHRwczovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9yZWFkYWJsZV9zdHJlYW1zXG4gKiBXZWIgQVBJIHJlYWRhYmxlLXN0cmVhbTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JlYWRhYmxlU3RyZWFtXG4gKiBOb2RlIHJlYWRhYmxlIHN0cmVhbTogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fcmVhZGFibGVfc3RyZWFtc1xuICovXG5jbGFzcyBSZWFkYWJsZVdlYlRvTm9kZVN0cmVhbSBleHRlbmRzIHJlYWRhYmxlX3N0cmVhbV8xLlJlYWRhYmxlIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdHJlYW0gUmVhZGFibGXigItTdHJlYW06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SZWFkYWJsZVN0cmVhbVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJ5dGVzUmVhZCA9IDA7XG4gICAgICAgIHRoaXMucmVsZWFzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGF0aW9uIG9mIHJlYWRhYmxlLl9yZWFkKHNpemUpLlxuICAgICAqIFdoZW4gcmVhZGFibGUuX3JlYWQoKSBpcyBjYWxsZWQsIGlmIGRhdGEgaXMgYXZhaWxhYmxlIGZyb20gdGhlIHJlc291cmNlLFxuICAgICAqIHRoZSBpbXBsZW1lbnRhdGlvbiBzaG91bGQgYmVnaW4gcHVzaGluZyB0aGF0IGRhdGEgaW50byB0aGUgcmVhZCBxdWV1ZVxuICAgICAqIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX3JlYWRhYmxlX3JlYWRfc2l6ZV8xXG4gICAgICovXG4gICAgYXN5bmMgX3JlYWQoKSB7XG4gICAgICAgIC8vIFNob3VsZCBzdGFydCBwdXNoaW5nIGRhdGEgaW50byB0aGUgcXVldWVcbiAgICAgICAgLy8gUmVhZCBkYXRhIGZyb20gdGhlIHVuZGVybHlpbmcgV2ViLUFQSS1yZWFkYWJsZS1zdHJlYW1cbiAgICAgICAgaWYgKHRoaXMucmVsZWFzZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChudWxsKTsgLy8gU2lnbmFsIEVPRlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ1JlYWQgPSB0aGlzLnJlYWRlci5yZWFkKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnBlbmRpbmdSZWFkO1xuICAgICAgICAvLyBjbGVhciB0aGUgcHJvbWlzZSBiZWZvcmUgcHVzaGluZyBwdXNoaW5nIG5ldyBkYXRhIHRvIHRoZSBxdWV1ZSBhbmQgYWxsb3cgc2VxdWVudGlhbCBjYWxscyB0byBfcmVhZCgpXG4gICAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZWFkO1xuICAgICAgICBpZiAoZGF0YS5kb25lIHx8IHRoaXMucmVsZWFzZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChudWxsKTsgLy8gU2lnbmFsIEVPRlxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ieXRlc1JlYWQgKz0gZGF0YS52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnB1c2goZGF0YS52YWx1ZSk7IC8vIFB1c2ggbmV3IGRhdGEgdG8gdGhlIHF1ZXVlXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlcmUgaXMgbm8gdW5yZXNvbHZlZCByZWFkIGNhbGwgdG8gV2ViLUFQSSBSZWFkYWJsZeKAi1N0cmVhbSBpbW1lZGlhdGVseSByZXR1cm5zO1xuICAgICAqIG90aGVyd2lzZSB3aWxsIHdhaXQgdW50aWwgdGhlIHJlYWQgaXMgcmVzb2x2ZWQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdEZvclJlYWRUb0NvbXBsZXRlKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nUmVhZCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wZW5kaW5nUmVhZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSB3cmFwcGVyXG4gICAgICovXG4gICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3luY0FuZFJlbGVhc2UoKTtcbiAgICB9XG4gICAgYXN5bmMgc3luY0FuZFJlbGVhc2UoKSB7XG4gICAgICAgIHRoaXMucmVsZWFzZWQgPSB0cnVlO1xuICAgICAgICBhd2FpdCB0aGlzLndhaXRGb3JSZWFkVG9Db21wbGV0ZSgpO1xuICAgICAgICBhd2FpdCB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVhZGFibGVXZWJUb05vZGVTdHJlYW0gPSBSZWFkYWJsZVdlYlRvTm9kZVN0cmVhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/readable-web-to-node-stream/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGtFQUFRO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUUsY0FBYztBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzPzRkN2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/safe-buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(app-pages-browser)/./node_modules/safe-buffer/index.js\").Buffer);\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxhQUFhLDBHQUE2QjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0NBQXNDLHNDQUFzQztBQUN6RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcz9kOGM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/string_decoder/lib/string_decoder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/strtok3/lib/AbstractTokenizer.js":
/*!*******************************************************!*\
  !*** ./node_modules/strtok3/lib/AbstractTokenizer.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.AbstractTokenizer = void 0;\r\nconst peek_readable_1 = __webpack_require__(/*! peek-readable */ \"(app-pages-browser)/./node_modules/peek-readable/lib/index.js\");\r\n/**\r\n * Core tokenizer\r\n */\r\nclass AbstractTokenizer {\r\n    constructor(fileInfo) {\r\n        /**\r\n         * Tokenizer-stream position\r\n         */\r\n        this.position = 0;\r\n        this.numBuffer = new Uint8Array(8);\r\n        this.fileInfo = fileInfo ? fileInfo : {};\r\n    }\r\n    /**\r\n     * Read a token from the tokenizer-stream\r\n     * @param token - The token to read\r\n     * @param position - If provided, the desired position in the tokenizer-stream\r\n     * @returns Promise with token data\r\n     */\r\n    async readToken(token, position = this.position) {\r\n        const uint8Array = Buffer.alloc(token.len);\r\n        const len = await this.readBuffer(uint8Array, { position });\r\n        if (len < token.len)\r\n            throw new peek_readable_1.EndOfStreamError();\r\n        return token.get(uint8Array, 0);\r\n    }\r\n    /**\r\n     * Peek a token from the tokenizer-stream.\r\n     * @param token - Token to peek from the tokenizer-stream.\r\n     * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.\r\n     * @returns Promise with token data\r\n     */\r\n    async peekToken(token, position = this.position) {\r\n        const uint8Array = Buffer.alloc(token.len);\r\n        const len = await this.peekBuffer(uint8Array, { position });\r\n        if (len < token.len)\r\n            throw new peek_readable_1.EndOfStreamError();\r\n        return token.get(uint8Array, 0);\r\n    }\r\n    /**\r\n     * Read a numeric token from the stream\r\n     * @param token - Numeric token\r\n     * @returns Promise with number\r\n     */\r\n    async readNumber(token) {\r\n        const len = await this.readBuffer(this.numBuffer, { length: token.len });\r\n        if (len < token.len)\r\n            throw new peek_readable_1.EndOfStreamError();\r\n        return token.get(this.numBuffer, 0);\r\n    }\r\n    /**\r\n     * Read a numeric token from the stream\r\n     * @param token - Numeric token\r\n     * @returns Promise with number\r\n     */\r\n    async peekNumber(token) {\r\n        const len = await this.peekBuffer(this.numBuffer, { length: token.len });\r\n        if (len < token.len)\r\n            throw new peek_readable_1.EndOfStreamError();\r\n        return token.get(this.numBuffer, 0);\r\n    }\r\n    /**\r\n     * Ignore number of bytes, advances the pointer in under tokenizer-stream.\r\n     * @param length - Number of bytes to ignore\r\n     * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available\r\n     */\r\n    async ignore(length) {\r\n        if (this.fileInfo.size !== undefined) {\r\n            const bytesLeft = this.fileInfo.size - this.position;\r\n            if (length > bytesLeft) {\r\n                this.position += bytesLeft;\r\n                return bytesLeft;\r\n            }\r\n        }\r\n        this.position += length;\r\n        return length;\r\n    }\r\n    async close() {\r\n        // empty\r\n    }\r\n    normalizeOptions(uint8Array, options) {\r\n        if (options && options.position !== undefined && options.position < this.position) {\r\n            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');\r\n        }\r\n        if (options) {\r\n            return {\r\n                mayBeLess: options.mayBeLess === true,\r\n                offset: options.offset ? options.offset : 0,\r\n                length: options.length ? options.length : (uint8Array.length - (options.offset ? options.offset : 0)),\r\n                position: options.position ? options.position : this.position\r\n            };\r\n        }\r\n        return {\r\n            mayBeLess: false,\r\n            offset: 0,\r\n            length: uint8Array.length,\r\n            position: this.position\r\n        };\r\n    }\r\n}\r\nexports.AbstractTokenizer = AbstractTokenizer;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHJ0b2szL2xpYi9BYnN0cmFjdFRva2VuaXplci5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLHdCQUF3QixtQkFBTyxDQUFDLG9GQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakMsd0RBQXdELFVBQVU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixNQUFNO0FBQ2pDLHdEQUF3RCxVQUFVO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELG1CQUFtQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxtQkFBbUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0cnRvazMvbGliL0Fic3RyYWN0VG9rZW5pemVyLmpzPzc4ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5BYnN0cmFjdFRva2VuaXplciA9IHZvaWQgMDtcclxuY29uc3QgcGVla19yZWFkYWJsZV8xID0gcmVxdWlyZShcInBlZWstcmVhZGFibGVcIik7XHJcbi8qKlxyXG4gKiBDb3JlIHRva2VuaXplclxyXG4gKi9cclxuY2xhc3MgQWJzdHJhY3RUb2tlbml6ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZmlsZUluZm8pIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUb2tlbml6ZXItc3RyZWFtIHBvc2l0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5udW1CdWZmZXIgPSBuZXcgVWludDhBcnJheSg4KTtcclxuICAgICAgICB0aGlzLmZpbGVJbmZvID0gZmlsZUluZm8gPyBmaWxlSW5mbyA6IHt9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGEgdG9rZW4gZnJvbSB0aGUgdG9rZW5pemVyLXN0cmVhbVxyXG4gICAgICogQHBhcmFtIHRva2VuIC0gVGhlIHRva2VuIHRvIHJlYWRcclxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiAtIElmIHByb3ZpZGVkLCB0aGUgZGVzaXJlZCBwb3NpdGlvbiBpbiB0aGUgdG9rZW5pemVyLXN0cmVhbVxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHRva2VuIGRhdGFcclxuICAgICAqL1xyXG4gICAgYXN5bmMgcmVhZFRva2VuKHRva2VuLCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24pIHtcclxuICAgICAgICBjb25zdCB1aW50OEFycmF5ID0gQnVmZmVyLmFsbG9jKHRva2VuLmxlbik7XHJcbiAgICAgICAgY29uc3QgbGVuID0gYXdhaXQgdGhpcy5yZWFkQnVmZmVyKHVpbnQ4QXJyYXksIHsgcG9zaXRpb24gfSk7XHJcbiAgICAgICAgaWYgKGxlbiA8IHRva2VuLmxlbilcclxuICAgICAgICAgICAgdGhyb3cgbmV3IHBlZWtfcmVhZGFibGVfMS5FbmRPZlN0cmVhbUVycm9yKCk7XHJcbiAgICAgICAgcmV0dXJuIHRva2VuLmdldCh1aW50OEFycmF5LCAwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVlayBhIHRva2VuIGZyb20gdGhlIHRva2VuaXplci1zdHJlYW0uXHJcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSBUb2tlbiB0byBwZWVrIGZyb20gdGhlIHRva2VuaXplci1zdHJlYW0uXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gLSBPZmZzZXQgd2hlcmUgdG8gYmVnaW4gcmVhZGluZyB3aXRoaW4gdGhlIGZpbGUuIElmIHBvc2l0aW9uIGlzIG51bGwsIGRhdGEgd2lsbCBiZSByZWFkIGZyb20gdGhlIGN1cnJlbnQgZmlsZSBwb3NpdGlvbi5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCB0b2tlbiBkYXRhXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHBlZWtUb2tlbih0b2tlbiwgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgdWludDhBcnJheSA9IEJ1ZmZlci5hbGxvYyh0b2tlbi5sZW4pO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IGF3YWl0IHRoaXMucGVla0J1ZmZlcih1aW50OEFycmF5LCB7IHBvc2l0aW9uIH0pO1xyXG4gICAgICAgIGlmIChsZW4gPCB0b2tlbi5sZW4pXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBwZWVrX3JlYWRhYmxlXzEuRW5kT2ZTdHJlYW1FcnJvcigpO1xyXG4gICAgICAgIHJldHVybiB0b2tlbi5nZXQodWludDhBcnJheSwgMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYSBudW1lcmljIHRva2VuIGZyb20gdGhlIHN0cmVhbVxyXG4gICAgICogQHBhcmFtIHRva2VuIC0gTnVtZXJpYyB0b2tlblxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIG51bWJlclxyXG4gICAgICovXHJcbiAgICBhc3luYyByZWFkTnVtYmVyKHRva2VuKSB7XHJcbiAgICAgICAgY29uc3QgbGVuID0gYXdhaXQgdGhpcy5yZWFkQnVmZmVyKHRoaXMubnVtQnVmZmVyLCB7IGxlbmd0aDogdG9rZW4ubGVuIH0pO1xyXG4gICAgICAgIGlmIChsZW4gPCB0b2tlbi5sZW4pXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBwZWVrX3JlYWRhYmxlXzEuRW5kT2ZTdHJlYW1FcnJvcigpO1xyXG4gICAgICAgIHJldHVybiB0b2tlbi5nZXQodGhpcy5udW1CdWZmZXIsIDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGEgbnVtZXJpYyB0b2tlbiBmcm9tIHRoZSBzdHJlYW1cclxuICAgICAqIEBwYXJhbSB0b2tlbiAtIE51bWVyaWMgdG9rZW5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBudW1iZXJcclxuICAgICAqL1xyXG4gICAgYXN5bmMgcGVla051bWJlcih0b2tlbikge1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IGF3YWl0IHRoaXMucGVla0J1ZmZlcih0aGlzLm51bUJ1ZmZlciwgeyBsZW5ndGg6IHRva2VuLmxlbiB9KTtcclxuICAgICAgICBpZiAobGVuIDwgdG9rZW4ubGVuKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgcGVla19yZWFkYWJsZV8xLkVuZE9mU3RyZWFtRXJyb3IoKTtcclxuICAgICAgICByZXR1cm4gdG9rZW4uZ2V0KHRoaXMubnVtQnVmZmVyLCAwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSWdub3JlIG51bWJlciBvZiBieXRlcywgYWR2YW5jZXMgdGhlIHBvaW50ZXIgaW4gdW5kZXIgdG9rZW5pemVyLXN0cmVhbS5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggLSBOdW1iZXIgb2YgYnl0ZXMgdG8gaWdub3JlXHJcbiAgICAgKiBAcmV0dXJuIHJlc29sdmVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgaWdub3JlZCwgZXF1YWxzIGxlbmd0aCBpZiB0aGlzIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHRoZSBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGlnbm9yZShsZW5ndGgpIHtcclxuICAgICAgICBpZiAodGhpcy5maWxlSW5mby5zaXplICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZXNMZWZ0ID0gdGhpcy5maWxlSW5mby5zaXplIC0gdGhpcy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IGJ5dGVzTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBieXRlc0xlZnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnl0ZXNMZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gbGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiBsZW5ndGg7XHJcbiAgICB9XHJcbiAgICBhc3luYyBjbG9zZSgpIHtcclxuICAgICAgICAvLyBlbXB0eVxyXG4gICAgfVxyXG4gICAgbm9ybWFsaXplT3B0aW9ucyh1aW50OEFycmF5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucG9zaXRpb24gPCB0aGlzLnBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYG9wdGlvbnMucG9zaXRpb25gIG11c3QgYmUgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIGB0b2tlbml6ZXIucG9zaXRpb25gJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBtYXlCZUxlc3M6IG9wdGlvbnMubWF5QmVMZXNzID09PSB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvcHRpb25zLm9mZnNldCA/IG9wdGlvbnMub2Zmc2V0IDogMCxcclxuICAgICAgICAgICAgICAgIGxlbmd0aDogb3B0aW9ucy5sZW5ndGggPyBvcHRpb25zLmxlbmd0aCA6ICh1aW50OEFycmF5Lmxlbmd0aCAtIChvcHRpb25zLm9mZnNldCA/IG9wdGlvbnMub2Zmc2V0IDogMCkpLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb24gPyBvcHRpb25zLnBvc2l0aW9uIDogdGhpcy5wb3NpdGlvblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtYXlCZUxlc3M6IGZhbHNlLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgIGxlbmd0aDogdWludDhBcnJheS5sZW5ndGgsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkFic3RyYWN0VG9rZW5pemVyID0gQWJzdHJhY3RUb2tlbml6ZXI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/strtok3/lib/AbstractTokenizer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/strtok3/lib/BufferTokenizer.js":
/*!*****************************************************!*\
  !*** ./node_modules/strtok3/lib/BufferTokenizer.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.BufferTokenizer = void 0;\r\nconst peek_readable_1 = __webpack_require__(/*! peek-readable */ \"(app-pages-browser)/./node_modules/peek-readable/lib/index.js\");\r\nconst AbstractTokenizer_1 = __webpack_require__(/*! ./AbstractTokenizer */ \"(app-pages-browser)/./node_modules/strtok3/lib/AbstractTokenizer.js\");\r\nclass BufferTokenizer extends AbstractTokenizer_1.AbstractTokenizer {\r\n    /**\r\n     * Construct BufferTokenizer\r\n     * @param uint8Array - Uint8Array to tokenize\r\n     * @param fileInfo - Pass additional file information to the tokenizer\r\n     */\r\n    constructor(uint8Array, fileInfo) {\r\n        super(fileInfo);\r\n        this.uint8Array = uint8Array;\r\n        this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;\r\n    }\r\n    /**\r\n     * Read buffer from tokenizer\r\n     * @param uint8Array - Uint8Array to tokenize\r\n     * @param options - Read behaviour options\r\n     * @returns {Promise<number>}\r\n     */\r\n    async readBuffer(uint8Array, options) {\r\n        if (options && options.position) {\r\n            if (options.position < this.position) {\r\n                throw new Error('`options.position` must be equal or greater than `tokenizer.position`');\r\n            }\r\n            this.position = options.position;\r\n        }\r\n        const bytesRead = await this.peekBuffer(uint8Array, options);\r\n        this.position += bytesRead;\r\n        return bytesRead;\r\n    }\r\n    /**\r\n     * Peek (read ahead) buffer from tokenizer\r\n     * @param uint8Array\r\n     * @param options - Read behaviour options\r\n     * @returns {Promise<number>}\r\n     */\r\n    async peekBuffer(uint8Array, options) {\r\n        const normOptions = this.normalizeOptions(uint8Array, options);\r\n        const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);\r\n        if ((!normOptions.mayBeLess) && bytes2read < normOptions.length) {\r\n            throw new peek_readable_1.EndOfStreamError();\r\n        }\r\n        else {\r\n            uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);\r\n            return bytes2read;\r\n        }\r\n    }\r\n    async close() {\r\n        // empty\r\n    }\r\n}\r\nexports.BufferTokenizer = BufferTokenizer;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHJ0b2szL2xpYi9CdWZmZXJUb2tlbml6ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLHdCQUF3QixtQkFBTyxDQUFDLG9GQUFlO0FBQy9DLDRCQUE0QixtQkFBTyxDQUFDLGdHQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0cnRvazMvbGliL0J1ZmZlclRva2VuaXplci5qcz9hYTVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQnVmZmVyVG9rZW5pemVyID0gdm9pZCAwO1xyXG5jb25zdCBwZWVrX3JlYWRhYmxlXzEgPSByZXF1aXJlKFwicGVlay1yZWFkYWJsZVwiKTtcclxuY29uc3QgQWJzdHJhY3RUb2tlbml6ZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0VG9rZW5pemVyXCIpO1xyXG5jbGFzcyBCdWZmZXJUb2tlbml6ZXIgZXh0ZW5kcyBBYnN0cmFjdFRva2VuaXplcl8xLkFic3RyYWN0VG9rZW5pemVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0IEJ1ZmZlclRva2VuaXplclxyXG4gICAgICogQHBhcmFtIHVpbnQ4QXJyYXkgLSBVaW50OEFycmF5IHRvIHRva2VuaXplXHJcbiAgICAgKiBAcGFyYW0gZmlsZUluZm8gLSBQYXNzIGFkZGl0aW9uYWwgZmlsZSBpbmZvcm1hdGlvbiB0byB0aGUgdG9rZW5pemVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHVpbnQ4QXJyYXksIGZpbGVJbmZvKSB7XHJcbiAgICAgICAgc3VwZXIoZmlsZUluZm8pO1xyXG4gICAgICAgIHRoaXMudWludDhBcnJheSA9IHVpbnQ4QXJyYXk7XHJcbiAgICAgICAgdGhpcy5maWxlSW5mby5zaXplID0gdGhpcy5maWxlSW5mby5zaXplID8gdGhpcy5maWxlSW5mby5zaXplIDogdWludDhBcnJheS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYnVmZmVyIGZyb20gdG9rZW5pemVyXHJcbiAgICAgKiBAcGFyYW0gdWludDhBcnJheSAtIFVpbnQ4QXJyYXkgdG8gdG9rZW5pemVcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVhZCBiZWhhdmlvdXIgb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn1cclxuICAgICAqL1xyXG4gICAgYXN5bmMgcmVhZEJ1ZmZlcih1aW50OEFycmF5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiA8IHRoaXMucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYG9wdGlvbnMucG9zaXRpb25gIG11c3QgYmUgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIGB0b2tlbml6ZXIucG9zaXRpb25gJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJ5dGVzUmVhZCA9IGF3YWl0IHRoaXMucGVla0J1ZmZlcih1aW50OEFycmF5LCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGJ5dGVzUmVhZDtcclxuICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZWVrIChyZWFkIGFoZWFkKSBidWZmZXIgZnJvbSB0b2tlbml6ZXJcclxuICAgICAqIEBwYXJhbSB1aW50OEFycmF5XHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlYWQgYmVoYXZpb3VyIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHBlZWtCdWZmZXIodWludDhBcnJheSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG5vcm1PcHRpb25zID0gdGhpcy5ub3JtYWxpemVPcHRpb25zKHVpbnQ4QXJyYXksIG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IGJ5dGVzMnJlYWQgPSBNYXRoLm1pbih0aGlzLnVpbnQ4QXJyYXkubGVuZ3RoIC0gbm9ybU9wdGlvbnMucG9zaXRpb24sIG5vcm1PcHRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgaWYgKCghbm9ybU9wdGlvbnMubWF5QmVMZXNzKSAmJiBieXRlczJyZWFkIDwgbm9ybU9wdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBwZWVrX3JlYWRhYmxlXzEuRW5kT2ZTdHJlYW1FcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdWludDhBcnJheS5zZXQodGhpcy51aW50OEFycmF5LnN1YmFycmF5KG5vcm1PcHRpb25zLnBvc2l0aW9uLCBub3JtT3B0aW9ucy5wb3NpdGlvbiArIGJ5dGVzMnJlYWQpLCBub3JtT3B0aW9ucy5vZmZzZXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gYnl0ZXMycmVhZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyBjbG9zZSgpIHtcclxuICAgICAgICAvLyBlbXB0eVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQnVmZmVyVG9rZW5pemVyID0gQnVmZmVyVG9rZW5pemVyO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/strtok3/lib/BufferTokenizer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/strtok3/lib/ReadStreamTokenizer.js":
/*!*********************************************************!*\
  !*** ./node_modules/strtok3/lib/ReadStreamTokenizer.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.ReadStreamTokenizer = void 0;\r\nconst AbstractTokenizer_1 = __webpack_require__(/*! ./AbstractTokenizer */ \"(app-pages-browser)/./node_modules/strtok3/lib/AbstractTokenizer.js\");\r\nconst peek_readable_1 = __webpack_require__(/*! peek-readable */ \"(app-pages-browser)/./node_modules/peek-readable/lib/index.js\");\r\nconst maxBufferSize = 256000;\r\nclass ReadStreamTokenizer extends AbstractTokenizer_1.AbstractTokenizer {\r\n    constructor(stream, fileInfo) {\r\n        super(fileInfo);\r\n        this.streamReader = new peek_readable_1.StreamReader(stream);\r\n    }\r\n    /**\r\n     * Get file information, an HTTP-client may implement this doing a HEAD request\r\n     * @return Promise with file information\r\n     */\r\n    async getFileInfo() {\r\n        return this.fileInfo;\r\n    }\r\n    /**\r\n     * Read buffer from tokenizer\r\n     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream\r\n     * @param options - Read behaviour options\r\n     * @returns Promise with number of bytes read\r\n     */\r\n    async readBuffer(uint8Array, options) {\r\n        const normOptions = this.normalizeOptions(uint8Array, options);\r\n        const skipBytes = normOptions.position - this.position;\r\n        if (skipBytes > 0) {\r\n            await this.ignore(skipBytes);\r\n            return this.readBuffer(uint8Array, options);\r\n        }\r\n        else if (skipBytes < 0) {\r\n            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');\r\n        }\r\n        if (normOptions.length === 0) {\r\n            return 0;\r\n        }\r\n        const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);\r\n        this.position += bytesRead;\r\n        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {\r\n            throw new peek_readable_1.EndOfStreamError();\r\n        }\r\n        return bytesRead;\r\n    }\r\n    /**\r\n     * Peek (read ahead) buffer from tokenizer\r\n     * @param uint8Array - Uint8Array (or Buffer) to write data to\r\n     * @param options - Read behaviour options\r\n     * @returns Promise with number of bytes peeked\r\n     */\r\n    async peekBuffer(uint8Array, options) {\r\n        const normOptions = this.normalizeOptions(uint8Array, options);\r\n        let bytesRead = 0;\r\n        if (normOptions.position) {\r\n            const skipBytes = normOptions.position - this.position;\r\n            if (skipBytes > 0) {\r\n                const skipBuffer = new Uint8Array(normOptions.length + skipBytes);\r\n                bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });\r\n                uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);\r\n                return bytesRead - skipBytes;\r\n            }\r\n            else if (skipBytes < 0) {\r\n                throw new Error('Cannot peek from a negative offset in a stream');\r\n            }\r\n        }\r\n        if (normOptions.length > 0) {\r\n            try {\r\n                bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);\r\n            }\r\n            catch (err) {\r\n                if (options && options.mayBeLess && err instanceof peek_readable_1.EndOfStreamError) {\r\n                    return 0;\r\n                }\r\n                throw err;\r\n            }\r\n            if ((!normOptions.mayBeLess) && bytesRead < normOptions.length) {\r\n                throw new peek_readable_1.EndOfStreamError();\r\n            }\r\n        }\r\n        return bytesRead;\r\n    }\r\n    async ignore(length) {\r\n        // debug(`ignore ${this.position}...${this.position + length - 1}`);\r\n        const bufSize = Math.min(maxBufferSize, length);\r\n        const buf = new Uint8Array(bufSize);\r\n        let totBytesRead = 0;\r\n        while (totBytesRead < length) {\r\n            const remaining = length - totBytesRead;\r\n            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });\r\n            if (bytesRead < 0) {\r\n                return bytesRead;\r\n            }\r\n            totBytesRead += bytesRead;\r\n        }\r\n        return totBytesRead;\r\n    }\r\n}\r\nexports.ReadStreamTokenizer = ReadStreamTokenizer;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHJ0b2szL2xpYi9SZWFkU3RyZWFtVG9rZW5pemVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQiw0QkFBNEIsbUJBQU8sQ0FBQyxnR0FBcUI7QUFDekQsd0JBQXdCLG1CQUFPLENBQUMsb0ZBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0NBQWtDO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjLEtBQUssMkJBQTJCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsc0NBQXNDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0cnRvazMvbGliL1JlYWRTdHJlYW1Ub2tlbml6ZXIuanM/MjZkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlJlYWRTdHJlYW1Ub2tlbml6ZXIgPSB2b2lkIDA7XHJcbmNvbnN0IEFic3RyYWN0VG9rZW5pemVyXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdFRva2VuaXplclwiKTtcclxuY29uc3QgcGVla19yZWFkYWJsZV8xID0gcmVxdWlyZShcInBlZWstcmVhZGFibGVcIik7XHJcbmNvbnN0IG1heEJ1ZmZlclNpemUgPSAyNTYwMDA7XHJcbmNsYXNzIFJlYWRTdHJlYW1Ub2tlbml6ZXIgZXh0ZW5kcyBBYnN0cmFjdFRva2VuaXplcl8xLkFic3RyYWN0VG9rZW5pemVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHN0cmVhbSwgZmlsZUluZm8pIHtcclxuICAgICAgICBzdXBlcihmaWxlSW5mbyk7XHJcbiAgICAgICAgdGhpcy5zdHJlYW1SZWFkZXIgPSBuZXcgcGVla19yZWFkYWJsZV8xLlN0cmVhbVJlYWRlcihzdHJlYW0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgZmlsZSBpbmZvcm1hdGlvbiwgYW4gSFRUUC1jbGllbnQgbWF5IGltcGxlbWVudCB0aGlzIGRvaW5nIGEgSEVBRCByZXF1ZXN0XHJcbiAgICAgKiBAcmV0dXJuIFByb21pc2Ugd2l0aCBmaWxlIGluZm9ybWF0aW9uXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEZpbGVJbmZvKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVJbmZvO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGJ1ZmZlciBmcm9tIHRva2VuaXplclxyXG4gICAgICogQHBhcmFtIHVpbnQ4QXJyYXkgLSBUYXJnZXQgVWludDhBcnJheSB0byBmaWxsIHdpdGggZGF0YSByZWFkIGZyb20gdGhlIHRva2VuaXplci1zdHJlYW1cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVhZCBiZWhhdmlvdXIgb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIG51bWJlciBvZiBieXRlcyByZWFkXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlYWRCdWZmZXIodWludDhBcnJheSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG5vcm1PcHRpb25zID0gdGhpcy5ub3JtYWxpemVPcHRpb25zKHVpbnQ4QXJyYXksIG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IHNraXBCeXRlcyA9IG5vcm1PcHRpb25zLnBvc2l0aW9uIC0gdGhpcy5wb3NpdGlvbjtcclxuICAgICAgICBpZiAoc2tpcEJ5dGVzID4gMCkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmlnbm9yZShza2lwQnl0ZXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkQnVmZmVyKHVpbnQ4QXJyYXksIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChza2lwQnl0ZXMgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYG9wdGlvbnMucG9zaXRpb25gIG11c3QgYmUgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIGB0b2tlbml6ZXIucG9zaXRpb25gJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub3JtT3B0aW9ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJ5dGVzUmVhZCA9IGF3YWl0IHRoaXMuc3RyZWFtUmVhZGVyLnJlYWQodWludDhBcnJheSwgbm9ybU9wdGlvbnMub2Zmc2V0LCBub3JtT3B0aW9ucy5sZW5ndGgpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gYnl0ZXNSZWFkO1xyXG4gICAgICAgIGlmICgoIW9wdGlvbnMgfHwgIW9wdGlvbnMubWF5QmVMZXNzKSAmJiBieXRlc1JlYWQgPCBub3JtT3B0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IHBlZWtfcmVhZGFibGVfMS5FbmRPZlN0cmVhbUVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBieXRlc1JlYWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBlZWsgKHJlYWQgYWhlYWQpIGJ1ZmZlciBmcm9tIHRva2VuaXplclxyXG4gICAgICogQHBhcmFtIHVpbnQ4QXJyYXkgLSBVaW50OEFycmF5IChvciBCdWZmZXIpIHRvIHdyaXRlIGRhdGEgdG9cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVhZCBiZWhhdmlvdXIgb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIG51bWJlciBvZiBieXRlcyBwZWVrZWRcclxuICAgICAqL1xyXG4gICAgYXN5bmMgcGVla0J1ZmZlcih1aW50OEFycmF5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3Qgbm9ybU9wdGlvbnMgPSB0aGlzLm5vcm1hbGl6ZU9wdGlvbnModWludDhBcnJheSwgb3B0aW9ucyk7XHJcbiAgICAgICAgbGV0IGJ5dGVzUmVhZCA9IDA7XHJcbiAgICAgICAgaWYgKG5vcm1PcHRpb25zLnBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNraXBCeXRlcyA9IG5vcm1PcHRpb25zLnBvc2l0aW9uIC0gdGhpcy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgaWYgKHNraXBCeXRlcyA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNraXBCdWZmZXIgPSBuZXcgVWludDhBcnJheShub3JtT3B0aW9ucy5sZW5ndGggKyBza2lwQnl0ZXMpO1xyXG4gICAgICAgICAgICAgICAgYnl0ZXNSZWFkID0gYXdhaXQgdGhpcy5wZWVrQnVmZmVyKHNraXBCdWZmZXIsIHsgbWF5QmVMZXNzOiBub3JtT3B0aW9ucy5tYXlCZUxlc3MgfSk7XHJcbiAgICAgICAgICAgICAgICB1aW50OEFycmF5LnNldChza2lwQnVmZmVyLnN1YmFycmF5KHNraXBCeXRlcyksIG5vcm1PcHRpb25zLm9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnl0ZXNSZWFkIC0gc2tpcEJ5dGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNraXBCeXRlcyA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBlZWsgZnJvbSBhIG5lZ2F0aXZlIG9mZnNldCBpbiBhIHN0cmVhbScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub3JtT3B0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBieXRlc1JlYWQgPSBhd2FpdCB0aGlzLnN0cmVhbVJlYWRlci5wZWVrKHVpbnQ4QXJyYXksIG5vcm1PcHRpb25zLm9mZnNldCwgbm9ybU9wdGlvbnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm1heUJlTGVzcyAmJiBlcnIgaW5zdGFuY2VvZiBwZWVrX3JlYWRhYmxlXzEuRW5kT2ZTdHJlYW1FcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoIW5vcm1PcHRpb25zLm1heUJlTGVzcykgJiYgYnl0ZXNSZWFkIDwgbm9ybU9wdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcGVla19yZWFkYWJsZV8xLkVuZE9mU3RyZWFtRXJyb3IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgaWdub3JlKGxlbmd0aCkge1xyXG4gICAgICAgIC8vIGRlYnVnKGBpZ25vcmUgJHt0aGlzLnBvc2l0aW9ufS4uLiR7dGhpcy5wb3NpdGlvbiArIGxlbmd0aCAtIDF9YCk7XHJcbiAgICAgICAgY29uc3QgYnVmU2l6ZSA9IE1hdGgubWluKG1heEJ1ZmZlclNpemUsIGxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmU2l6ZSk7XHJcbiAgICAgICAgbGV0IHRvdEJ5dGVzUmVhZCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHRvdEJ5dGVzUmVhZCA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmcgPSBsZW5ndGggLSB0b3RCeXRlc1JlYWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzUmVhZCA9IGF3YWl0IHRoaXMucmVhZEJ1ZmZlcihidWYsIHsgbGVuZ3RoOiBNYXRoLm1pbihidWZTaXplLCByZW1haW5pbmcpIH0pO1xyXG4gICAgICAgICAgICBpZiAoYnl0ZXNSZWFkIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0b3RCeXRlc1JlYWQgKz0gYnl0ZXNSZWFkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG90Qnl0ZXNSZWFkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUmVhZFN0cmVhbVRva2VuaXplciA9IFJlYWRTdHJlYW1Ub2tlbml6ZXI7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/strtok3/lib/ReadStreamTokenizer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/strtok3/lib/core.js":
/*!******************************************!*\
  !*** ./node_modules/strtok3/lib/core.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.fromBuffer = exports.fromStream = exports.EndOfStreamError = void 0;\r\nconst ReadStreamTokenizer_1 = __webpack_require__(/*! ./ReadStreamTokenizer */ \"(app-pages-browser)/./node_modules/strtok3/lib/ReadStreamTokenizer.js\");\r\nconst BufferTokenizer_1 = __webpack_require__(/*! ./BufferTokenizer */ \"(app-pages-browser)/./node_modules/strtok3/lib/BufferTokenizer.js\");\r\nvar peek_readable_1 = __webpack_require__(/*! peek-readable */ \"(app-pages-browser)/./node_modules/peek-readable/lib/index.js\");\r\nObject.defineProperty(exports, \"EndOfStreamError\", ({ enumerable: true, get: function () { return peek_readable_1.EndOfStreamError; } }));\r\n/**\r\n * Construct ReadStreamTokenizer from given Stream.\r\n * Will set fileSize, if provided given Stream has set the .path property/\r\n * @param stream - Read from Node.js Stream.Readable\r\n * @param fileInfo - Pass the file information, like size and MIME-type of the corresponding stream.\r\n * @returns ReadStreamTokenizer\r\n */\r\nfunction fromStream(stream, fileInfo) {\r\n    fileInfo = fileInfo ? fileInfo : {};\r\n    return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream, fileInfo);\r\n}\r\nexports.fromStream = fromStream;\r\n/**\r\n * Construct ReadStreamTokenizer from given Buffer.\r\n * @param uint8Array - Uint8Array to tokenize\r\n * @param fileInfo - Pass additional file information to the tokenizer\r\n * @returns BufferTokenizer\r\n */\r\nfunction fromBuffer(uint8Array, fileInfo) {\r\n    return new BufferTokenizer_1.BufferTokenizer(uint8Array, fileInfo);\r\n}\r\nexports.fromBuffer = fromBuffer;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHJ0b2szL2xpYi9jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLHdCQUF3QjtBQUNsRSw4QkFBOEIsbUJBQU8sQ0FBQyxvR0FBdUI7QUFDN0QsMEJBQTBCLG1CQUFPLENBQUMsNEZBQW1CO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLG9GQUFlO0FBQzdDLG9EQUFtRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3RydG9rMy9saWIvY29yZS5qcz8xNTg5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZnJvbUJ1ZmZlciA9IGV4cG9ydHMuZnJvbVN0cmVhbSA9IGV4cG9ydHMuRW5kT2ZTdHJlYW1FcnJvciA9IHZvaWQgMDtcclxuY29uc3QgUmVhZFN0cmVhbVRva2VuaXplcl8xID0gcmVxdWlyZShcIi4vUmVhZFN0cmVhbVRva2VuaXplclwiKTtcclxuY29uc3QgQnVmZmVyVG9rZW5pemVyXzEgPSByZXF1aXJlKFwiLi9CdWZmZXJUb2tlbml6ZXJcIik7XHJcbnZhciBwZWVrX3JlYWRhYmxlXzEgPSByZXF1aXJlKFwicGVlay1yZWFkYWJsZVwiKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRW5kT2ZTdHJlYW1FcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVla19yZWFkYWJsZV8xLkVuZE9mU3RyZWFtRXJyb3I7IH0gfSk7XHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3QgUmVhZFN0cmVhbVRva2VuaXplciBmcm9tIGdpdmVuIFN0cmVhbS5cclxuICogV2lsbCBzZXQgZmlsZVNpemUsIGlmIHByb3ZpZGVkIGdpdmVuIFN0cmVhbSBoYXMgc2V0IHRoZSAucGF0aCBwcm9wZXJ0eS9cclxuICogQHBhcmFtIHN0cmVhbSAtIFJlYWQgZnJvbSBOb2RlLmpzIFN0cmVhbS5SZWFkYWJsZVxyXG4gKiBAcGFyYW0gZmlsZUluZm8gLSBQYXNzIHRoZSBmaWxlIGluZm9ybWF0aW9uLCBsaWtlIHNpemUgYW5kIE1JTUUtdHlwZSBvZiB0aGUgY29ycmVzcG9uZGluZyBzdHJlYW0uXHJcbiAqIEByZXR1cm5zIFJlYWRTdHJlYW1Ub2tlbml6ZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21TdHJlYW0oc3RyZWFtLCBmaWxlSW5mbykge1xyXG4gICAgZmlsZUluZm8gPSBmaWxlSW5mbyA/IGZpbGVJbmZvIDoge307XHJcbiAgICByZXR1cm4gbmV3IFJlYWRTdHJlYW1Ub2tlbml6ZXJfMS5SZWFkU3RyZWFtVG9rZW5pemVyKHN0cmVhbSwgZmlsZUluZm8pO1xyXG59XHJcbmV4cG9ydHMuZnJvbVN0cmVhbSA9IGZyb21TdHJlYW07XHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3QgUmVhZFN0cmVhbVRva2VuaXplciBmcm9tIGdpdmVuIEJ1ZmZlci5cclxuICogQHBhcmFtIHVpbnQ4QXJyYXkgLSBVaW50OEFycmF5IHRvIHRva2VuaXplXHJcbiAqIEBwYXJhbSBmaWxlSW5mbyAtIFBhc3MgYWRkaXRpb25hbCBmaWxlIGluZm9ybWF0aW9uIHRvIHRoZSB0b2tlbml6ZXJcclxuICogQHJldHVybnMgQnVmZmVyVG9rZW5pemVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tQnVmZmVyKHVpbnQ4QXJyYXksIGZpbGVJbmZvKSB7XHJcbiAgICByZXR1cm4gbmV3IEJ1ZmZlclRva2VuaXplcl8xLkJ1ZmZlclRva2VuaXplcih1aW50OEFycmF5LCBmaWxlSW5mbyk7XHJcbn1cclxuZXhwb3J0cy5mcm9tQnVmZmVyID0gZnJvbUJ1ZmZlcjtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/strtok3/lib/core.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/token-types/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/token-types/lib/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AnsiStringType = exports.StringType = exports.BufferType = exports.Uint8ArrayType = exports.IgnoreType = exports.Float80_LE = exports.Float80_BE = exports.Float64_LE = exports.Float64_BE = exports.Float32_LE = exports.Float32_BE = exports.Float16_LE = exports.Float16_BE = exports.INT64_BE = exports.UINT64_BE = exports.INT64_LE = exports.UINT64_LE = exports.INT32_LE = exports.INT32_BE = exports.INT24_BE = exports.INT24_LE = exports.INT16_LE = exports.INT16_BE = exports.INT8 = exports.UINT32_BE = exports.UINT32_LE = exports.UINT24_BE = exports.UINT24_LE = exports.UINT16_BE = exports.UINT16_LE = exports.UINT8 = void 0;\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"(app-pages-browser)/./node_modules/ieee754/index.js\");\n// Primitive types\nfunction dv(array) {\n    return new DataView(array.buffer, array.byteOffset);\n}\n/**\n * 8-bit unsigned integer\n */\nexports.UINT8 = {\n    len: 1,\n    get(array, offset) {\n        return dv(array).getUint8(offset);\n    },\n    put(array, offset, value) {\n        dv(array).setUint8(offset, value);\n        return offset + 1;\n    }\n};\n/**\n * 16-bit unsigned integer, Little Endian byte order\n */\nexports.UINT16_LE = {\n    len: 2,\n    get(array, offset) {\n        return dv(array).getUint16(offset, true);\n    },\n    put(array, offset, value) {\n        dv(array).setUint16(offset, value, true);\n        return offset + 2;\n    }\n};\n/**\n * 16-bit unsigned integer, Big Endian byte order\n */\nexports.UINT16_BE = {\n    len: 2,\n    get(array, offset) {\n        return dv(array).getUint16(offset);\n    },\n    put(array, offset, value) {\n        dv(array).setUint16(offset, value);\n        return offset + 2;\n    }\n};\n/**\n * 24-bit unsigned integer, Little Endian byte order\n */\nexports.UINT24_LE = {\n    len: 3,\n    get(array, offset) {\n        const dataView = dv(array);\n        return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);\n    },\n    put(array, offset, value) {\n        const dataView = dv(array);\n        dataView.setUint8(offset, value & 0xff);\n        dataView.setUint16(offset + 1, value >> 8, true);\n        return offset + 3;\n    }\n};\n/**\n * 24-bit unsigned integer, Big Endian byte order\n */\nexports.UINT24_BE = {\n    len: 3,\n    get(array, offset) {\n        const dataView = dv(array);\n        return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);\n    },\n    put(array, offset, value) {\n        const dataView = dv(array);\n        dataView.setUint16(offset, value >> 8);\n        dataView.setUint8(offset + 2, value & 0xff);\n        return offset + 3;\n    }\n};\n/**\n * 32-bit unsigned integer, Little Endian byte order\n */\nexports.UINT32_LE = {\n    len: 4,\n    get(array, offset) {\n        return dv(array).getUint32(offset, true);\n    },\n    put(array, offset, value) {\n        dv(array).setUint32(offset, value, true);\n        return offset + 4;\n    }\n};\n/**\n * 32-bit unsigned integer, Big Endian byte order\n */\nexports.UINT32_BE = {\n    len: 4,\n    get(array, offset) {\n        return dv(array).getUint32(offset);\n    },\n    put(array, offset, value) {\n        dv(array).setUint32(offset, value);\n        return offset + 4;\n    }\n};\n/**\n * 8-bit signed integer\n */\nexports.INT8 = {\n    len: 1,\n    get(array, offset) {\n        return dv(array).getInt8(offset);\n    },\n    put(array, offset, value) {\n        dv(array).setInt8(offset, value);\n        return offset + 1;\n    }\n};\n/**\n * 16-bit signed integer, Big Endian byte order\n */\nexports.INT16_BE = {\n    len: 2,\n    get(array, offset) {\n        return dv(array).getInt16(offset);\n    },\n    put(array, offset, value) {\n        dv(array).setInt16(offset, value);\n        return offset + 2;\n    }\n};\n/**\n * 16-bit signed integer, Little Endian byte order\n */\nexports.INT16_LE = {\n    len: 2,\n    get(array, offset) {\n        return dv(array).getInt16(offset, true);\n    },\n    put(array, offset, value) {\n        dv(array).setInt16(offset, value, true);\n        return offset + 2;\n    }\n};\n/**\n * 24-bit signed integer, Little Endian byte order\n */\nexports.INT24_LE = {\n    len: 3,\n    get(array, offset) {\n        const unsigned = exports.UINT24_LE.get(array, offset);\n        return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;\n    },\n    put(array, offset, value) {\n        const dataView = dv(array);\n        dataView.setUint8(offset, value & 0xff);\n        dataView.setUint16(offset + 1, value >> 8, true);\n        return offset + 3;\n    }\n};\n/**\n * 24-bit signed integer, Big Endian byte order\n */\nexports.INT24_BE = {\n    len: 3,\n    get(array, offset) {\n        const unsigned = exports.UINT24_BE.get(array, offset);\n        return unsigned > 0x7fffff ? unsigned - 0x1000000 : unsigned;\n    },\n    put(array, offset, value) {\n        const dataView = dv(array);\n        dataView.setUint16(offset, value >> 8);\n        dataView.setUint8(offset + 2, value & 0xff);\n        return offset + 3;\n    }\n};\n/**\n * 32-bit signed integer, Big Endian byte order\n */\nexports.INT32_BE = {\n    len: 4,\n    get(array, offset) {\n        return dv(array).getInt32(offset);\n    },\n    put(array, offset, value) {\n        dv(array).setInt32(offset, value);\n        return offset + 4;\n    }\n};\n/**\n * 32-bit signed integer, Big Endian byte order\n */\nexports.INT32_LE = {\n    len: 4,\n    get(array, offset) {\n        return dv(array).getInt32(offset, true);\n    },\n    put(array, offset, value) {\n        dv(array).setInt32(offset, value, true);\n        return offset + 4;\n    }\n};\n/**\n * 64-bit unsigned integer, Little Endian byte order\n */\nexports.UINT64_LE = {\n    len: 8,\n    get(array, offset) {\n        return dv(array).getBigUint64(offset, true);\n    },\n    put(array, offset, value) {\n        dv(array).setBigUint64(offset, value, true);\n        return offset + 8;\n    }\n};\n/**\n * 64-bit signed integer, Little Endian byte order\n */\nexports.INT64_LE = {\n    len: 8,\n    get(array, offset) {\n        return dv(array).getBigInt64(offset, true);\n    },\n    put(array, offset, value) {\n        dv(array).setBigInt64(offset, value, true);\n        return offset + 8;\n    }\n};\n/**\n * 64-bit unsigned integer, Big Endian byte order\n */\nexports.UINT64_BE = {\n    len: 8,\n    get(array, offset) {\n        return dv(array).getBigUint64(offset);\n    },\n    put(array, offset, value) {\n        dv(array).setBigUint64(offset, value);\n        return offset + 8;\n    }\n};\n/**\n * 64-bit signed integer, Big Endian byte order\n */\nexports.INT64_BE = {\n    len: 8,\n    get(array, offset) {\n        return dv(array).getBigInt64(offset);\n    },\n    put(array, offset, value) {\n        dv(array).setBigInt64(offset, value);\n        return offset + 8;\n    }\n};\n/**\n * IEEE 754 16-bit (half precision) float, big endian\n */\nexports.Float16_BE = {\n    len: 2,\n    get(dataView, offset) {\n        return ieee754.read(dataView, offset, false, 10, this.len);\n    },\n    put(dataView, offset, value) {\n        ieee754.write(dataView, value, offset, false, 10, this.len);\n        return offset + this.len;\n    }\n};\n/**\n * IEEE 754 16-bit (half precision) float, little endian\n */\nexports.Float16_LE = {\n    len: 2,\n    get(array, offset) {\n        return ieee754.read(array, offset, true, 10, this.len);\n    },\n    put(array, offset, value) {\n        ieee754.write(array, value, offset, true, 10, this.len);\n        return offset + this.len;\n    }\n};\n/**\n * IEEE 754 32-bit (single precision) float, big endian\n */\nexports.Float32_BE = {\n    len: 4,\n    get(array, offset) {\n        return dv(array).getFloat32(offset);\n    },\n    put(array, offset, value) {\n        dv(array).setFloat32(offset, value);\n        return offset + 4;\n    }\n};\n/**\n * IEEE 754 32-bit (single precision) float, little endian\n */\nexports.Float32_LE = {\n    len: 4,\n    get(array, offset) {\n        return dv(array).getFloat32(offset, true);\n    },\n    put(array, offset, value) {\n        dv(array).setFloat32(offset, value, true);\n        return offset + 4;\n    }\n};\n/**\n * IEEE 754 64-bit (double precision) float, big endian\n */\nexports.Float64_BE = {\n    len: 8,\n    get(array, offset) {\n        return dv(array).getFloat64(offset);\n    },\n    put(array, offset, value) {\n        dv(array).setFloat64(offset, value);\n        return offset + 8;\n    }\n};\n/**\n * IEEE 754 64-bit (double precision) float, little endian\n */\nexports.Float64_LE = {\n    len: 8,\n    get(array, offset) {\n        return dv(array).getFloat64(offset, true);\n    },\n    put(array, offset, value) {\n        dv(array).setFloat64(offset, value, true);\n        return offset + 8;\n    }\n};\n/**\n * IEEE 754 80-bit (extended precision) float, big endian\n */\nexports.Float80_BE = {\n    len: 10,\n    get(array, offset) {\n        return ieee754.read(array, offset, false, 63, this.len);\n    },\n    put(array, offset, value) {\n        ieee754.write(array, value, offset, false, 63, this.len);\n        return offset + this.len;\n    }\n};\n/**\n * IEEE 754 80-bit (extended precision) float, little endian\n */\nexports.Float80_LE = {\n    len: 10,\n    get(array, offset) {\n        return ieee754.read(array, offset, true, 63, this.len);\n    },\n    put(array, offset, value) {\n        ieee754.write(array, value, offset, true, 63, this.len);\n        return offset + this.len;\n    }\n};\n/**\n * Ignore a given number of bytes\n */\nclass IgnoreType {\n    /**\n     * @param len number of bytes to ignore\n     */\n    constructor(len) {\n        this.len = len;\n    }\n    // ToDo: don't read, but skip data\n    get(array, off) {\n    }\n}\nexports.IgnoreType = IgnoreType;\nclass Uint8ArrayType {\n    constructor(len) {\n        this.len = len;\n    }\n    get(array, offset) {\n        return array.subarray(offset, offset + this.len);\n    }\n}\nexports.Uint8ArrayType = Uint8ArrayType;\nclass BufferType {\n    constructor(len) {\n        this.len = len;\n    }\n    get(uint8Array, off) {\n        return Buffer.from(uint8Array.subarray(off, off + this.len));\n    }\n}\nexports.BufferType = BufferType;\n/**\n * Consume a fixed number of bytes from the stream and return a string with a specified encoding.\n */\nclass StringType {\n    constructor(len, encoding) {\n        this.len = len;\n        this.encoding = encoding;\n    }\n    get(uint8Array, offset) {\n        return Buffer.from(uint8Array).toString(this.encoding, offset, offset + this.len);\n    }\n}\nexports.StringType = StringType;\n/**\n * ANSI Latin 1 String\n * Using windows-1252 / ISO 8859-1 decoding\n */\nclass AnsiStringType {\n    constructor(len) {\n        this.len = len;\n    }\n    static decode(buffer, offset, until) {\n        let str = '';\n        for (let i = offset; i < until; ++i) {\n            str += AnsiStringType.codePointToString(AnsiStringType.singleByteDecoder(buffer[i]));\n        }\n        return str;\n    }\n    static inRange(a, min, max) {\n        return min <= a && a <= max;\n    }\n    static codePointToString(cp) {\n        if (cp <= 0xFFFF) {\n            return String.fromCharCode(cp);\n        }\n        else {\n            cp -= 0x10000;\n            return String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);\n        }\n    }\n    static singleByteDecoder(bite) {\n        if (AnsiStringType.inRange(bite, 0x00, 0x7F)) {\n            return bite;\n        }\n        const codePoint = AnsiStringType.windows1252[bite - 0x80];\n        if (codePoint === null) {\n            throw Error('invaliding encoding');\n        }\n        return codePoint;\n    }\n    get(buffer, offset = 0) {\n        return AnsiStringType.decode(buffer, offset, offset + this.len);\n    }\n}\nexports.AnsiStringType = AnsiStringType;\nAnsiStringType.windows1252 = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352,\n    8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732,\n    8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168,\n    169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184,\n    185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200,\n    201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216,\n    217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232,\n    233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247,\n    248, 249, 250, 251, 252, 253, 254, 255];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b2tlbi10eXBlcy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLHNCQUFzQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGdCQUFnQixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLFlBQVksR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxhQUFhO0FBQzdtQixnQkFBZ0IsbUJBQU8sQ0FBQyxvRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90b2tlbi10eXBlcy9saWIvaW5kZXguanM/ZGM0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQW5zaVN0cmluZ1R5cGUgPSBleHBvcnRzLlN0cmluZ1R5cGUgPSBleHBvcnRzLkJ1ZmZlclR5cGUgPSBleHBvcnRzLlVpbnQ4QXJyYXlUeXBlID0gZXhwb3J0cy5JZ25vcmVUeXBlID0gZXhwb3J0cy5GbG9hdDgwX0xFID0gZXhwb3J0cy5GbG9hdDgwX0JFID0gZXhwb3J0cy5GbG9hdDY0X0xFID0gZXhwb3J0cy5GbG9hdDY0X0JFID0gZXhwb3J0cy5GbG9hdDMyX0xFID0gZXhwb3J0cy5GbG9hdDMyX0JFID0gZXhwb3J0cy5GbG9hdDE2X0xFID0gZXhwb3J0cy5GbG9hdDE2X0JFID0gZXhwb3J0cy5JTlQ2NF9CRSA9IGV4cG9ydHMuVUlOVDY0X0JFID0gZXhwb3J0cy5JTlQ2NF9MRSA9IGV4cG9ydHMuVUlOVDY0X0xFID0gZXhwb3J0cy5JTlQzMl9MRSA9IGV4cG9ydHMuSU5UMzJfQkUgPSBleHBvcnRzLklOVDI0X0JFID0gZXhwb3J0cy5JTlQyNF9MRSA9IGV4cG9ydHMuSU5UMTZfTEUgPSBleHBvcnRzLklOVDE2X0JFID0gZXhwb3J0cy5JTlQ4ID0gZXhwb3J0cy5VSU5UMzJfQkUgPSBleHBvcnRzLlVJTlQzMl9MRSA9IGV4cG9ydHMuVUlOVDI0X0JFID0gZXhwb3J0cy5VSU5UMjRfTEUgPSBleHBvcnRzLlVJTlQxNl9CRSA9IGV4cG9ydHMuVUlOVDE2X0xFID0gZXhwb3J0cy5VSU5UOCA9IHZvaWQgMDtcbmNvbnN0IGllZWU3NTQgPSByZXF1aXJlKFwiaWVlZTc1NFwiKTtcbi8vIFByaW1pdGl2ZSB0eXBlc1xuZnVuY3Rpb24gZHYoYXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGFycmF5LmJ1ZmZlciwgYXJyYXkuYnl0ZU9mZnNldCk7XG59XG4vKipcbiAqIDgtYml0IHVuc2lnbmVkIGludGVnZXJcbiAqL1xuZXhwb3J0cy5VSU5UOCA9IHtcbiAgICBsZW46IDEsXG4gICAgZ2V0KGFycmF5LCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGR2KGFycmF5KS5nZXRVaW50OChvZmZzZXQpO1xuICAgIH0sXG4gICAgcHV0KGFycmF5LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGR2KGFycmF5KS5zZXRVaW50OChvZmZzZXQsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIDE7XG4gICAgfVxufTtcbi8qKlxuICogMTYtYml0IHVuc2lnbmVkIGludGVnZXIsIExpdHRsZSBFbmRpYW4gYnl0ZSBvcmRlclxuICovXG5leHBvcnRzLlVJTlQxNl9MRSA9IHtcbiAgICBsZW46IDIsXG4gICAgZ2V0KGFycmF5LCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGR2KGFycmF5KS5nZXRVaW50MTYob2Zmc2V0LCB0cnVlKTtcbiAgICB9LFxuICAgIHB1dChhcnJheSwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBkdihhcnJheSkuc2V0VWludDE2KG9mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMjtcbiAgICB9XG59O1xuLyoqXG4gKiAxNi1iaXQgdW5zaWduZWQgaW50ZWdlciwgQmlnIEVuZGlhbiBieXRlIG9yZGVyXG4gKi9cbmV4cG9ydHMuVUlOVDE2X0JFID0ge1xuICAgIGxlbjogMixcbiAgICBnZXQoYXJyYXksIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gZHYoYXJyYXkpLmdldFVpbnQxNihvZmZzZXQpO1xuICAgIH0sXG4gICAgcHV0KGFycmF5LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGR2KGFycmF5KS5zZXRVaW50MTYob2Zmc2V0LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyAyO1xuICAgIH1cbn07XG4vKipcbiAqIDI0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyLCBMaXR0bGUgRW5kaWFuIGJ5dGUgb3JkZXJcbiAqL1xuZXhwb3J0cy5VSU5UMjRfTEUgPSB7XG4gICAgbGVuOiAzLFxuICAgIGdldChhcnJheSwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gZHYoYXJyYXkpO1xuICAgICAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KSArIChkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMSwgdHJ1ZSkgPDwgOCk7XG4gICAgfSxcbiAgICBwdXQoYXJyYXksIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBkdihhcnJheSk7XG4gICAgICAgIGRhdGFWaWV3LnNldFVpbnQ4KG9mZnNldCwgdmFsdWUgJiAweGZmKTtcbiAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIHZhbHVlID4+IDgsIHRydWUpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMztcbiAgICB9XG59O1xuLyoqXG4gKiAyNC1iaXQgdW5zaWduZWQgaW50ZWdlciwgQmlnIEVuZGlhbiBieXRlIG9yZGVyXG4gKi9cbmV4cG9ydHMuVUlOVDI0X0JFID0ge1xuICAgIGxlbjogMyxcbiAgICBnZXQoYXJyYXksIG9mZnNldCkge1xuICAgICAgICBjb25zdCBkYXRhVmlldyA9IGR2KGFycmF5KTtcbiAgICAgICAgcmV0dXJuIChkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0KSA8PCA4KSArIGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDIpO1xuICAgIH0sXG4gICAgcHV0KGFycmF5LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gZHYoYXJyYXkpO1xuICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0LCB2YWx1ZSA+PiA4KTtcbiAgICAgICAgZGF0YVZpZXcuc2V0VWludDgob2Zmc2V0ICsgMiwgdmFsdWUgJiAweGZmKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIDM7XG4gICAgfVxufTtcbi8qKlxuICogMzItYml0IHVuc2lnbmVkIGludGVnZXIsIExpdHRsZSBFbmRpYW4gYnl0ZSBvcmRlclxuICovXG5leHBvcnRzLlVJTlQzMl9MRSA9IHtcbiAgICBsZW46IDQsXG4gICAgZ2V0KGFycmF5LCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGR2KGFycmF5KS5nZXRVaW50MzIob2Zmc2V0LCB0cnVlKTtcbiAgICB9LFxuICAgIHB1dChhcnJheSwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBkdihhcnJheSkuc2V0VWludDMyKG9mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgNDtcbiAgICB9XG59O1xuLyoqXG4gKiAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciwgQmlnIEVuZGlhbiBieXRlIG9yZGVyXG4gKi9cbmV4cG9ydHMuVUlOVDMyX0JFID0ge1xuICAgIGxlbjogNCxcbiAgICBnZXQoYXJyYXksIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gZHYoYXJyYXkpLmdldFVpbnQzMihvZmZzZXQpO1xuICAgIH0sXG4gICAgcHV0KGFycmF5LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGR2KGFycmF5KS5zZXRVaW50MzIob2Zmc2V0LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyA0O1xuICAgIH1cbn07XG4vKipcbiAqIDgtYml0IHNpZ25lZCBpbnRlZ2VyXG4gKi9cbmV4cG9ydHMuSU5UOCA9IHtcbiAgICBsZW46IDEsXG4gICAgZ2V0KGFycmF5LCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGR2KGFycmF5KS5nZXRJbnQ4KG9mZnNldCk7XG4gICAgfSxcbiAgICBwdXQoYXJyYXksIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgZHYoYXJyYXkpLnNldEludDgob2Zmc2V0LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyAxO1xuICAgIH1cbn07XG4vKipcbiAqIDE2LWJpdCBzaWduZWQgaW50ZWdlciwgQmlnIEVuZGlhbiBieXRlIG9yZGVyXG4gKi9cbmV4cG9ydHMuSU5UMTZfQkUgPSB7XG4gICAgbGVuOiAyLFxuICAgIGdldChhcnJheSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBkdihhcnJheSkuZ2V0SW50MTYob2Zmc2V0KTtcbiAgICB9LFxuICAgIHB1dChhcnJheSwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBkdihhcnJheSkuc2V0SW50MTYob2Zmc2V0LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyAyO1xuICAgIH1cbn07XG4vKipcbiAqIDE2LWJpdCBzaWduZWQgaW50ZWdlciwgTGl0dGxlIEVuZGlhbiBieXRlIG9yZGVyXG4gKi9cbmV4cG9ydHMuSU5UMTZfTEUgPSB7XG4gICAgbGVuOiAyLFxuICAgIGdldChhcnJheSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBkdihhcnJheSkuZ2V0SW50MTYob2Zmc2V0LCB0cnVlKTtcbiAgICB9LFxuICAgIHB1dChhcnJheSwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBkdihhcnJheSkuc2V0SW50MTYob2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyAyO1xuICAgIH1cbn07XG4vKipcbiAqIDI0LWJpdCBzaWduZWQgaW50ZWdlciwgTGl0dGxlIEVuZGlhbiBieXRlIG9yZGVyXG4gKi9cbmV4cG9ydHMuSU5UMjRfTEUgPSB7XG4gICAgbGVuOiAzLFxuICAgIGdldChhcnJheSwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHVuc2lnbmVkID0gZXhwb3J0cy5VSU5UMjRfTEUuZ2V0KGFycmF5LCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gdW5zaWduZWQgPiAweDdmZmZmZiA/IHVuc2lnbmVkIC0gMHgxMDAwMDAwIDogdW5zaWduZWQ7XG4gICAgfSxcbiAgICBwdXQoYXJyYXksIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBkdihhcnJheSk7XG4gICAgICAgIGRhdGFWaWV3LnNldFVpbnQ4KG9mZnNldCwgdmFsdWUgJiAweGZmKTtcbiAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIHZhbHVlID4+IDgsIHRydWUpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgMztcbiAgICB9XG59O1xuLyoqXG4gKiAyNC1iaXQgc2lnbmVkIGludGVnZXIsIEJpZyBFbmRpYW4gYnl0ZSBvcmRlclxuICovXG5leHBvcnRzLklOVDI0X0JFID0ge1xuICAgIGxlbjogMyxcbiAgICBnZXQoYXJyYXksIG9mZnNldCkge1xuICAgICAgICBjb25zdCB1bnNpZ25lZCA9IGV4cG9ydHMuVUlOVDI0X0JFLmdldChhcnJheSwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHVuc2lnbmVkID4gMHg3ZmZmZmYgPyB1bnNpZ25lZCAtIDB4MTAwMDAwMCA6IHVuc2lnbmVkO1xuICAgIH0sXG4gICAgcHV0KGFycmF5LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gZHYoYXJyYXkpO1xuICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0LCB2YWx1ZSA+PiA4KTtcbiAgICAgICAgZGF0YVZpZXcuc2V0VWludDgob2Zmc2V0ICsgMiwgdmFsdWUgJiAweGZmKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIDM7XG4gICAgfVxufTtcbi8qKlxuICogMzItYml0IHNpZ25lZCBpbnRlZ2VyLCBCaWcgRW5kaWFuIGJ5dGUgb3JkZXJcbiAqL1xuZXhwb3J0cy5JTlQzMl9CRSA9IHtcbiAgICBsZW46IDQsXG4gICAgZ2V0KGFycmF5LCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGR2KGFycmF5KS5nZXRJbnQzMihvZmZzZXQpO1xuICAgIH0sXG4gICAgcHV0KGFycmF5LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGR2KGFycmF5KS5zZXRJbnQzMihvZmZzZXQsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7XG4gICAgfVxufTtcbi8qKlxuICogMzItYml0IHNpZ25lZCBpbnRlZ2VyLCBCaWcgRW5kaWFuIGJ5dGUgb3JkZXJcbiAqL1xuZXhwb3J0cy5JTlQzMl9MRSA9IHtcbiAgICBsZW46IDQsXG4gICAgZ2V0KGFycmF5LCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGR2KGFycmF5KS5nZXRJbnQzMihvZmZzZXQsIHRydWUpO1xuICAgIH0sXG4gICAgcHV0KGFycmF5LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGR2KGFycmF5KS5zZXRJbnQzMihvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7XG4gICAgfVxufTtcbi8qKlxuICogNjQtYml0IHVuc2lnbmVkIGludGVnZXIsIExpdHRsZSBFbmRpYW4gYnl0ZSBvcmRlclxuICovXG5leHBvcnRzLlVJTlQ2NF9MRSA9IHtcbiAgICBsZW46IDgsXG4gICAgZ2V0KGFycmF5LCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGR2KGFycmF5KS5nZXRCaWdVaW50NjQob2Zmc2V0LCB0cnVlKTtcbiAgICB9LFxuICAgIHB1dChhcnJheSwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBkdihhcnJheSkuc2V0QmlnVWludDY0KG9mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgODtcbiAgICB9XG59O1xuLyoqXG4gKiA2NC1iaXQgc2lnbmVkIGludGVnZXIsIExpdHRsZSBFbmRpYW4gYnl0ZSBvcmRlclxuICovXG5leHBvcnRzLklOVDY0X0xFID0ge1xuICAgIGxlbjogOCxcbiAgICBnZXQoYXJyYXksIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gZHYoYXJyYXkpLmdldEJpZ0ludDY0KG9mZnNldCwgdHJ1ZSk7XG4gICAgfSxcbiAgICBwdXQoYXJyYXksIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgZHYoYXJyYXkpLnNldEJpZ0ludDY0KG9mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgODtcbiAgICB9XG59O1xuLyoqXG4gKiA2NC1iaXQgdW5zaWduZWQgaW50ZWdlciwgQmlnIEVuZGlhbiBieXRlIG9yZGVyXG4gKi9cbmV4cG9ydHMuVUlOVDY0X0JFID0ge1xuICAgIGxlbjogOCxcbiAgICBnZXQoYXJyYXksIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gZHYoYXJyYXkpLmdldEJpZ1VpbnQ2NChvZmZzZXQpO1xuICAgIH0sXG4gICAgcHV0KGFycmF5LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGR2KGFycmF5KS5zZXRCaWdVaW50NjQob2Zmc2V0LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyA4O1xuICAgIH1cbn07XG4vKipcbiAqIDY0LWJpdCBzaWduZWQgaW50ZWdlciwgQmlnIEVuZGlhbiBieXRlIG9yZGVyXG4gKi9cbmV4cG9ydHMuSU5UNjRfQkUgPSB7XG4gICAgbGVuOiA4LFxuICAgIGdldChhcnJheSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBkdihhcnJheSkuZ2V0QmlnSW50NjQob2Zmc2V0KTtcbiAgICB9LFxuICAgIHB1dChhcnJheSwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBkdihhcnJheSkuc2V0QmlnSW50NjQob2Zmc2V0LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyA4O1xuICAgIH1cbn07XG4vKipcbiAqIElFRUUgNzU0IDE2LWJpdCAoaGFsZiBwcmVjaXNpb24pIGZsb2F0LCBiaWcgZW5kaWFuXG4gKi9cbmV4cG9ydHMuRmxvYXQxNl9CRSA9IHtcbiAgICBsZW46IDIsXG4gICAgZ2V0KGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGllZWU3NTQucmVhZChkYXRhVmlldywgb2Zmc2V0LCBmYWxzZSwgMTAsIHRoaXMubGVuKTtcbiAgICB9LFxuICAgIHB1dChkYXRhVmlldywgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBpZWVlNzU0LndyaXRlKGRhdGFWaWV3LCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgMTAsIHRoaXMubGVuKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIHRoaXMubGVuO1xuICAgIH1cbn07XG4vKipcbiAqIElFRUUgNzU0IDE2LWJpdCAoaGFsZiBwcmVjaXNpb24pIGZsb2F0LCBsaXR0bGUgZW5kaWFuXG4gKi9cbmV4cG9ydHMuRmxvYXQxNl9MRSA9IHtcbiAgICBsZW46IDIsXG4gICAgZ2V0KGFycmF5LCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGllZWU3NTQucmVhZChhcnJheSwgb2Zmc2V0LCB0cnVlLCAxMCwgdGhpcy5sZW4pO1xuICAgIH0sXG4gICAgcHV0KGFycmF5LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGllZWU3NTQud3JpdGUoYXJyYXksIHZhbHVlLCBvZmZzZXQsIHRydWUsIDEwLCB0aGlzLmxlbik7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyB0aGlzLmxlbjtcbiAgICB9XG59O1xuLyoqXG4gKiBJRUVFIDc1NCAzMi1iaXQgKHNpbmdsZSBwcmVjaXNpb24pIGZsb2F0LCBiaWcgZW5kaWFuXG4gKi9cbmV4cG9ydHMuRmxvYXQzMl9CRSA9IHtcbiAgICBsZW46IDQsXG4gICAgZ2V0KGFycmF5LCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGR2KGFycmF5KS5nZXRGbG9hdDMyKG9mZnNldCk7XG4gICAgfSxcbiAgICBwdXQoYXJyYXksIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgZHYoYXJyYXkpLnNldEZsb2F0MzIob2Zmc2V0LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyA0O1xuICAgIH1cbn07XG4vKipcbiAqIElFRUUgNzU0IDMyLWJpdCAoc2luZ2xlIHByZWNpc2lvbikgZmxvYXQsIGxpdHRsZSBlbmRpYW5cbiAqL1xuZXhwb3J0cy5GbG9hdDMyX0xFID0ge1xuICAgIGxlbjogNCxcbiAgICBnZXQoYXJyYXksIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gZHYoYXJyYXkpLmdldEZsb2F0MzIob2Zmc2V0LCB0cnVlKTtcbiAgICB9LFxuICAgIHB1dChhcnJheSwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBkdihhcnJheSkuc2V0RmxvYXQzMihvZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIDQ7XG4gICAgfVxufTtcbi8qKlxuICogSUVFRSA3NTQgNjQtYml0IChkb3VibGUgcHJlY2lzaW9uKSBmbG9hdCwgYmlnIGVuZGlhblxuICovXG5leHBvcnRzLkZsb2F0NjRfQkUgPSB7XG4gICAgbGVuOiA4LFxuICAgIGdldChhcnJheSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBkdihhcnJheSkuZ2V0RmxvYXQ2NChvZmZzZXQpO1xuICAgIH0sXG4gICAgcHV0KGFycmF5LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGR2KGFycmF5KS5zZXRGbG9hdDY0KG9mZnNldCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgODtcbiAgICB9XG59O1xuLyoqXG4gKiBJRUVFIDc1NCA2NC1iaXQgKGRvdWJsZSBwcmVjaXNpb24pIGZsb2F0LCBsaXR0bGUgZW5kaWFuXG4gKi9cbmV4cG9ydHMuRmxvYXQ2NF9MRSA9IHtcbiAgICBsZW46IDgsXG4gICAgZ2V0KGFycmF5LCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGR2KGFycmF5KS5nZXRGbG9hdDY0KG9mZnNldCwgdHJ1ZSk7XG4gICAgfSxcbiAgICBwdXQoYXJyYXksIG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgZHYoYXJyYXkpLnNldEZsb2F0NjQob2Zmc2V0LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyA4O1xuICAgIH1cbn07XG4vKipcbiAqIElFRUUgNzU0IDgwLWJpdCAoZXh0ZW5kZWQgcHJlY2lzaW9uKSBmbG9hdCwgYmlnIGVuZGlhblxuICovXG5leHBvcnRzLkZsb2F0ODBfQkUgPSB7XG4gICAgbGVuOiAxMCxcbiAgICBnZXQoYXJyYXksIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gaWVlZTc1NC5yZWFkKGFycmF5LCBvZmZzZXQsIGZhbHNlLCA2MywgdGhpcy5sZW4pO1xuICAgIH0sXG4gICAgcHV0KGFycmF5LCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGllZWU3NTQud3JpdGUoYXJyYXksIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCA2MywgdGhpcy5sZW4pO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgdGhpcy5sZW47XG4gICAgfVxufTtcbi8qKlxuICogSUVFRSA3NTQgODAtYml0IChleHRlbmRlZCBwcmVjaXNpb24pIGZsb2F0LCBsaXR0bGUgZW5kaWFuXG4gKi9cbmV4cG9ydHMuRmxvYXQ4MF9MRSA9IHtcbiAgICBsZW46IDEwLFxuICAgIGdldChhcnJheSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBpZWVlNzU0LnJlYWQoYXJyYXksIG9mZnNldCwgdHJ1ZSwgNjMsIHRoaXMubGVuKTtcbiAgICB9LFxuICAgIHB1dChhcnJheSwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBpZWVlNzU0LndyaXRlKGFycmF5LCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCA2MywgdGhpcy5sZW4pO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgdGhpcy5sZW47XG4gICAgfVxufTtcbi8qKlxuICogSWdub3JlIGEgZ2l2ZW4gbnVtYmVyIG9mIGJ5dGVzXG4gKi9cbmNsYXNzIElnbm9yZVR5cGUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBsZW4gbnVtYmVyIG9mIGJ5dGVzIHRvIGlnbm9yZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGxlbikge1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB9XG4gICAgLy8gVG9EbzogZG9uJ3QgcmVhZCwgYnV0IHNraXAgZGF0YVxuICAgIGdldChhcnJheSwgb2ZmKSB7XG4gICAgfVxufVxuZXhwb3J0cy5JZ25vcmVUeXBlID0gSWdub3JlVHlwZTtcbmNsYXNzIFVpbnQ4QXJyYXlUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihsZW4pIHtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgfVxuICAgIGdldChhcnJheSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBhcnJheS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIHRoaXMubGVuKTtcbiAgICB9XG59XG5leHBvcnRzLlVpbnQ4QXJyYXlUeXBlID0gVWludDhBcnJheVR5cGU7XG5jbGFzcyBCdWZmZXJUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihsZW4pIHtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgfVxuICAgIGdldCh1aW50OEFycmF5LCBvZmYpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHVpbnQ4QXJyYXkuc3ViYXJyYXkob2ZmLCBvZmYgKyB0aGlzLmxlbikpO1xuICAgIH1cbn1cbmV4cG9ydHMuQnVmZmVyVHlwZSA9IEJ1ZmZlclR5cGU7XG4vKipcbiAqIENvbnN1bWUgYSBmaXhlZCBudW1iZXIgb2YgYnl0ZXMgZnJvbSB0aGUgc3RyZWFtIGFuZCByZXR1cm4gYSBzdHJpbmcgd2l0aCBhIHNwZWNpZmllZCBlbmNvZGluZy5cbiAqL1xuY2xhc3MgU3RyaW5nVHlwZSB7XG4gICAgY29uc3RydWN0b3IobGVuLCBlbmNvZGluZykge1xuICAgICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICAgICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgIH1cbiAgICBnZXQodWludDhBcnJheSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh1aW50OEFycmF5KS50b1N0cmluZyh0aGlzLmVuY29kaW5nLCBvZmZzZXQsIG9mZnNldCArIHRoaXMubGVuKTtcbiAgICB9XG59XG5leHBvcnRzLlN0cmluZ1R5cGUgPSBTdHJpbmdUeXBlO1xuLyoqXG4gKiBBTlNJIExhdGluIDEgU3RyaW5nXG4gKiBVc2luZyB3aW5kb3dzLTEyNTIgLyBJU08gODg1OS0xIGRlY29kaW5nXG4gKi9cbmNsYXNzIEFuc2lTdHJpbmdUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihsZW4pIHtcbiAgICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgfVxuICAgIHN0YXRpYyBkZWNvZGUoYnVmZmVyLCBvZmZzZXQsIHVudGlsKSB7XG4gICAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHVudGlsOyArK2kpIHtcbiAgICAgICAgICAgIHN0ciArPSBBbnNpU3RyaW5nVHlwZS5jb2RlUG9pbnRUb1N0cmluZyhBbnNpU3RyaW5nVHlwZS5zaW5nbGVCeXRlRGVjb2RlcihidWZmZXJbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBzdGF0aWMgaW5SYW5nZShhLCBtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gbWluIDw9IGEgJiYgYSA8PSBtYXg7XG4gICAgfVxuICAgIHN0YXRpYyBjb2RlUG9pbnRUb1N0cmluZyhjcCkge1xuICAgICAgICBpZiAoY3AgPD0gMHhGRkZGKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjcCAtPSAweDEwMDAwO1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNwID4+IDEwKSArIDB4RDgwMCwgKGNwICYgMHgzRkYpICsgMHhEQzAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgc2luZ2xlQnl0ZURlY29kZXIoYml0ZSkge1xuICAgICAgICBpZiAoQW5zaVN0cmluZ1R5cGUuaW5SYW5nZShiaXRlLCAweDAwLCAweDdGKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJpdGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZVBvaW50ID0gQW5zaVN0cmluZ1R5cGUud2luZG93czEyNTJbYml0ZSAtIDB4ODBdO1xuICAgICAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignaW52YWxpZGluZyBlbmNvZGluZycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQ7XG4gICAgfVxuICAgIGdldChidWZmZXIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIEFuc2lTdHJpbmdUeXBlLmRlY29kZShidWZmZXIsIG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5sZW4pO1xuICAgIH1cbn1cbmV4cG9ydHMuQW5zaVN0cmluZ1R5cGUgPSBBbnNpU3RyaW5nVHlwZTtcbkFuc2lTdHJpbmdUeXBlLndpbmRvd3MxMjUyID0gWzgzNjQsIDEyOSwgODIxOCwgNDAyLCA4MjIyLCA4MjMwLCA4MjI0LCA4MjI1LCA3MTAsIDgyNDAsIDM1MixcbiAgICA4MjQ5LCAzMzgsIDE0MSwgMzgxLCAxNDMsIDE0NCwgODIxNiwgODIxNywgODIyMCwgODIyMSwgODIyNiwgODIxMSwgODIxMiwgNzMyLFxuICAgIDg0ODIsIDM1MywgODI1MCwgMzM5LCAxNTcsIDM4MiwgMzc2LCAxNjAsIDE2MSwgMTYyLCAxNjMsIDE2NCwgMTY1LCAxNjYsIDE2NywgMTY4LFxuICAgIDE2OSwgMTcwLCAxNzEsIDE3MiwgMTczLCAxNzQsIDE3NSwgMTc2LCAxNzcsIDE3OCwgMTc5LCAxODAsIDE4MSwgMTgyLCAxODMsIDE4NCxcbiAgICAxODUsIDE4NiwgMTg3LCAxODgsIDE4OSwgMTkwLCAxOTEsIDE5MiwgMTkzLCAxOTQsIDE5NSwgMTk2LCAxOTcsIDE5OCwgMTk5LCAyMDAsXG4gICAgMjAxLCAyMDIsIDIwMywgMjA0LCAyMDUsIDIwNiwgMjA3LCAyMDgsIDIwOSwgMjEwLCAyMTEsIDIxMiwgMjEzLCAyMTQsIDIxNSwgMjE2LFxuICAgIDIxNywgMjE4LCAyMTksIDIyMCwgMjIxLCAyMjIsIDIyMywgMjI0LCAyMjUsIDIyNiwgMjI3LCAyMjgsIDIyOSwgMjMwLCAyMzEsIDIzMixcbiAgICAyMzMsIDIzNCwgMjM1LCAyMzYsIDIzNywgMjM4LCAyMzksIDI0MCwgMjQxLCAyNDIsIDI0MywgMjQ0LCAyNDUsIDI0NiwgMjQ3LFxuICAgIDI0OCwgMjQ5LCAyNTAsIDI1MSwgMjUyLCAyNTMsIDI1NCwgMjU1XTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/token-types/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!__webpack_require__.g.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = __webpack_require__.g.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFVBQVU7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFNO0FBQ2YsSUFBSTtBQUNKO0FBQ0E7QUFDQSxZQUFZLHFCQUFNO0FBQ2xCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcz83NjUyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/util-deprecate/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/Home/components/player.module.css":
/*!***********************************************!*\
  !*** ./app/Home/components/player.module.css ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"card\":\"player_card__i2KUO\",\"informations\":\"player_informations__8eDbB\",\"titleCard\":\"player_titleCard__2ocQD\",\"controls\":\"player_controls__Gyxzl\",\"btn\":\"player_btn__cunml\",\"play\":\"player_play__OsuZA\",\"pause\":\"player_pause__86NQZ\",\"playing\":\"player_playing__iuDJ_\",\"timeContainer\":\"player_timeContainer__GsaYo\",\"progressBar\":\"player_progressBar__fAXoa\",\"progress\":\"player_progress__XIyl0\",\"time\":\"player_time__nLyAA\"};\n    if(true) {\n      // 1723486166613\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"02da926f9cf8\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9Ib21lL2NvbXBvbmVudHMvcGxheWVyLm1vZHVsZS5jc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsd01BQW9LLGNBQWMsc0RBQXNEO0FBQ3RRLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL0hvbWUvY29tcG9uZW50cy9wbGF5ZXIubW9kdWxlLmNzcz9mZmE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJjYXJkXCI6XCJwbGF5ZXJfY2FyZF9faTJLVU9cIixcImluZm9ybWF0aW9uc1wiOlwicGxheWVyX2luZm9ybWF0aW9uc19fOGVEYkJcIixcInRpdGxlQ2FyZFwiOlwicGxheWVyX3RpdGxlQ2FyZF9fMm9jUURcIixcImNvbnRyb2xzXCI6XCJwbGF5ZXJfY29udHJvbHNfX0d5eHpsXCIsXCJidG5cIjpcInBsYXllcl9idG5fX2N1bm1sXCIsXCJwbGF5XCI6XCJwbGF5ZXJfcGxheV9fT3N1WkFcIixcInBhdXNlXCI6XCJwbGF5ZXJfcGF1c2VfXzg2TlFaXCIsXCJwbGF5aW5nXCI6XCJwbGF5ZXJfcGxheWluZ19faXVESl9cIixcInRpbWVDb250YWluZXJcIjpcInBsYXllcl90aW1lQ29udGFpbmVyX19Hc2FZb1wiLFwicHJvZ3Jlc3NCYXJcIjpcInBsYXllcl9wcm9ncmVzc0Jhcl9fZkFYb2FcIixcInByb2dyZXNzXCI6XCJwbGF5ZXJfcHJvZ3Jlc3NfX1hJeWwwXCIsXCJ0aW1lXCI6XCJwbGF5ZXJfdGltZV9fbkx5QUFcIn07XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgLy8gMTcyMzQ4NjE2NjYxM1xuICAgICAgdmFyIGNzc1JlbG9hZCA9IHJlcXVpcmUoXCJDOi9Vc2Vycy9QZWRybyBWYXNjby9Eb2N1bWVudHMvRGVzYWZpb3MvUGxheWVyIGRlIE3DunNpY2Eg4oCiIERlc2FmaW8gMDEvZGVzYWZpbzEvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gIFxubW9kdWxlLmV4cG9ydHMuX19jaGVja3N1bSA9IFwiMDJkYTkyNmY5Y2Y4XCJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/Home/components/player.module.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/Home/assets/images/album.png":
/*!******************************************!*\
  !*** ./app/Home/assets/images/album.png ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/album.d815dafa.png\",\"height\":85,\"width\":85,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Falbum.d815dafa.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9Ib21lL2Fzc2V0cy9pbWFnZXMvYWxidW0ucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDRMQUE0TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvSG9tZS9hc3NldHMvaW1hZ2VzL2FsYnVtLnBuZz9kMjM3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9hbGJ1bS5kODE1ZGFmYS5wbmdcIixcImhlaWdodFwiOjg1LFwid2lkdGhcIjo4NSxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZhbGJ1bS5kODE1ZGFmYS5wbmcmdz04JnE9NzBcIixcImJsdXJXaWR0aFwiOjgsXCJibHVySGVpZ2h0XCI6OH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/Home/assets/images/album.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/Home/components/Player.tsx":
/*!****************************************!*\
  !*** ./app/Home/components/Player.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @swc/helpers/_/_async_to_generator */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_async_to_generator.js\");\n/* harmony import */ var _swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_sliced_to_array.js\");\n/* harmony import */ var _swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @swc/helpers/_/_ts_generator */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var music_metadata_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! music-metadata-browser */ \"(app-pages-browser)/./node_modules/music-metadata-browser/lib/index.js\");\n/* harmony import */ var _player_module_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./player.module.css */ \"(app-pages-browser)/./app/Home/components/player.module.css\");\n/* harmony import */ var _player_module_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_player_module_css__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var _assets_images_album_png__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../assets/images/album.png */ \"(app-pages-browser)/./app/Home/assets/images/album.png\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\nvar _this = undefined;\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nvar Player = function(param) {\n    var songs = param.songs;\n    _s();\n    var _useState = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_6__._)((0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"player_playing__iuDJ_\"), 2), play = _useState[0], setPlay = _useState[1];\n    var _useState1 = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_6__._)((0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0), 2), currentSongIndex = _useState1[0], setCurrentSongIndex = _useState1[1];\n    var audioRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    var _useState2 = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_6__._)((0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), 2), duration = _useState2[0], setDuration = _useState2[1];\n    var _useState3 = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_6__._)((0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"T\\xedtulo Desconhecido\"), 2), title = _useState3[0], setTitle = _useState3[1];\n    var _useState4 = (0,_swc_helpers_sliced_to_array__WEBPACK_IMPORTED_MODULE_6__._)((0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"Artista Desconhecido\"), 2), artist = _useState4[0], setArtist = _useState4[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function() {\n        var fetchMetadata = function() {\n            var _ref = (0,_swc_helpers_async_to_generator__WEBPACK_IMPORTED_MODULE_7__._)(function() {\n                var audioElement, response, blob, metadata, error;\n                return (0,_swc_helpers_ts_generator__WEBPACK_IMPORTED_MODULE_8__.__generator)(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            audioElement = audioRef.current;\n                            if (!audioElement) return [\n                                3,\n                                6\n                            ];\n                            _state.label = 1;\n                        case 1:\n                            _state.trys.push([\n                                1,\n                                5,\n                                ,\n                                6\n                            ]);\n                            return [\n                                4,\n                                fetch(songs[currentSongIndex])\n                            ];\n                        case 2:\n                            response = _state.sent();\n                            return [\n                                4,\n                                response.blob()\n                            ];\n                        case 3:\n                            blob = _state.sent();\n                            return [\n                                4,\n                                (0,music_metadata_browser__WEBPACK_IMPORTED_MODULE_2__.parseBlob)(blob)\n                            ];\n                        case 4:\n                            metadata = _state.sent();\n                            setTitle(metadata.common.title || \"T\\xedtulo Desconhecido\");\n                            setArtist(metadata.common.artist || \"Artista Desconhecido\");\n                            return [\n                                3,\n                                6\n                            ];\n                        case 5:\n                            error = _state.sent();\n                            console.error(\"Error reading metadata:\", error);\n                            setTitle(\"T\\xedtulo Desconhecido\");\n                            return [\n                                3,\n                                6\n                            ];\n                        case 6:\n                            return [\n                                2\n                            ];\n                    }\n                });\n            });\n            return function fetchMetadata() {\n                return _ref.apply(this, arguments);\n            };\n        }();\n        fetchMetadata();\n    }, [\n        currentSongIndex\n    ]);\n    var Played = function() {\n        setPlay(function(prev) {\n            return prev === \"player_playing__iuDJ_\" ? \"\" : \"player_playing__iuDJ_\";\n        });\n    };\n    var playAudio = function() {\n        var _audioRef_current;\n        (_audioRef_current = audioRef.current) === null || _audioRef_current === void 0 ? void 0 : _audioRef_current.play();\n    };\n    var pauseAudio = function() {\n        var _audioRef_current;\n        (_audioRef_current = audioRef.current) === null || _audioRef_current === void 0 ? void 0 : _audioRef_current.pause();\n    };\n    var playNextSong = function() {\n        setCurrentSongIndex(function(prevIndex) {\n            return prevIndex === songs.length - 1 ? 0 : prevIndex + 1;\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_player_module_css__WEBPACK_IMPORTED_MODULE_3___default().card) + \" card\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_player_module_css__WEBPACK_IMPORTED_MODULE_3___default().informations),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_player_module_css__WEBPACK_IMPORTED_MODULE_3___default().imageCard) + \" image-card\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                            alt: \"img-Album\",\n                            src: _assets_images_album_png__WEBPACK_IMPORTED_MODULE_5__[\"default\"]\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                            lineNumber: 64,\n                            columnNumber: 21\n                        }, _this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                        lineNumber: 63,\n                        columnNumber: 17\n                    }, _this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_player_module_css__WEBPACK_IMPORTED_MODULE_3___default().titleCard) + \" title-card\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                children: title\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                                lineNumber: 67,\n                                columnNumber: 21\n                            }, _this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                children: artist\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                                lineNumber: 68,\n                                columnNumber: 21\n                            }, _this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                        lineNumber: 66,\n                        columnNumber: 17\n                    }, _this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                lineNumber: 62,\n                columnNumber: 13\n            }, _this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_player_module_css__WEBPACK_IMPORTED_MODULE_3___default().controls),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                        className: (_player_module_css__WEBPACK_IMPORTED_MODULE_3___default().btn) + \" fas fa-backward\",\n                        \"aria-hidden\": \"true\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                        lineNumber: 73,\n                        columnNumber: 17\n                    }, _this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                        onClick: function() {\n                            Played();\n                            playAudio();\n                        },\n                        className: (_player_module_css__WEBPACK_IMPORTED_MODULE_3___default().btn) + \" \" + (_player_module_css__WEBPACK_IMPORTED_MODULE_3___default().play) + \" fas fa-play \" + play,\n                        \"aria-hidden\": \"true\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                        lineNumber: 74,\n                        columnNumber: 17\n                    }, _this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                        onClick: function() {\n                            Played();\n                            pauseAudio();\n                        },\n                        className: (_player_module_css__WEBPACK_IMPORTED_MODULE_3___default().btn) + \" \" + (_player_module_css__WEBPACK_IMPORTED_MODULE_3___default().pause) + \" fas fa-pause \" + play,\n                        \"aria-hidden\": \"true\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                        lineNumber: 75,\n                        columnNumber: 17\n                    }, _this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                        className: (_player_module_css__WEBPACK_IMPORTED_MODULE_3___default().btn) + \" fas fa-forward\",\n                        onClick: playNextSong,\n                        \"aria-hidden\": \"true\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                        lineNumber: 76,\n                        columnNumber: 17\n                    }, _this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                lineNumber: 72,\n                columnNumber: 13\n            }, _this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_player_module_css__WEBPACK_IMPORTED_MODULE_3___default().player),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"audio\", {\n                    src: songs[currentSongIndex],\n                    ref: audioRef\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                    lineNumber: 80,\n                    columnNumber: 17\n                }, _this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                lineNumber: 79,\n                columnNumber: 13\n            }, _this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_player_module_css__WEBPACK_IMPORTED_MODULE_3___default().timeContainer),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_player_module_css__WEBPACK_IMPORTED_MODULE_3___default().progressBar),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_player_module_css__WEBPACK_IMPORTED_MODULE_3___default().progress)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                            lineNumber: 85,\n                            columnNumber: 21\n                        }, _this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                        lineNumber: 84,\n                        columnNumber: 17\n                    }, _this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_player_module_css__WEBPACK_IMPORTED_MODULE_3___default().time),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                children: \"0:00\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                                lineNumber: 88,\n                                columnNumber: 21\n                            }, _this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                children: duration !== null ? \"\".concat(Math.floor(duration / 60), \":\").concat(Math.floor(duration % 60)) : \"Carregando...\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                                lineNumber: 89,\n                                columnNumber: 21\n                            }, _this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                        lineNumber: 87,\n                        columnNumber: 17\n                    }, _this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n                lineNumber: 83,\n                columnNumber: 13\n            }, _this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Pedro Vasco\\\\Documents\\\\Desafios\\\\Player de M\\xfasica • Desafio 01\\\\desafio1\\\\app\\\\Home\\\\components\\\\Player.tsx\",\n        lineNumber: 61,\n        columnNumber: 9\n    }, _this);\n};\n_s(Player, \"3X2vFRUvn2DkVc1IMoO1uP365L4=\");\n_c = Player;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Player);\nvar _c;\n$RefreshReg$(_c, \"Player\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9Ib21lL2NvbXBvbmVudHMvUGxheWVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFMkQ7QUFDUjtBQUNYO0FBQ1Q7QUFDYztBQU03QyxJQUFNUSxTQUFnQztRQUFHQyxjQUFBQTs7SUFDckMsSUFBd0JSLFlBQUFBLCtEQUFBQSxDQUFBQSwrQ0FBUUEsQ0FBUyw4QkFBbENTLE9BQWlCVCxjQUFYVSxVQUFXVjtJQUN4QixJQUFnREEsYUFBQUEsK0RBQUFBLENBQUFBLCtDQUFRQSxDQUFDLFFBQWxEVyxtQkFBeUNYLGVBQXZCWSxzQkFBdUJaO0lBQ2hELElBQU1hLFdBQVdaLDZDQUFNQSxDQUFtQjtJQUMxQyxJQUFnQ0QsYUFBQUEsK0RBQUFBLENBQUFBLCtDQUFRQSxDQUFnQixXQUFqRGMsV0FBeUJkLGVBQWZlLGNBQWVmO0lBQ2hDLElBQTBCQSxhQUFBQSwrREFBQUEsQ0FBQUEsK0NBQVFBLENBQVMsK0JBQXBDZ0IsUUFBbUJoQixlQUFaaUIsV0FBWWpCO0lBQzFCLElBQTRCQSxhQUFBQSwrREFBQUEsQ0FBQUEsK0NBQVFBLENBQVMsNkJBQXRDa0IsU0FBcUJsQixlQUFibUIsWUFBYW5CO0lBRTVCRSxnREFBU0EsQ0FBQztRQUNOLElBQU1rQjt1QkFBZ0I7b0JBQ1pDLGNBSVFDLFVBQ0FDLE1BQ0FDLFVBR0RDOzs7OzRCQVRQSixlQUFlUixTQUFTYSxPQUFPO2lDQUVqQ0wsY0FBQUE7Ozs7Ozs7Ozs7Ozs0QkFFcUI7O2dDQUFNTSxNQUFNbkIsS0FBSyxDQUFDRyxpQkFBaUI7Ozs0QkFBOUNXLFdBQVc7NEJBQ0o7O2dDQUFNQSxTQUFTQyxJQUFJOzs7NEJBQTFCQSxPQUFPOzRCQUNJOztnQ0FBTXBCLGlFQUFTQSxDQUFDb0I7Ozs0QkFBM0JDLFdBQVc7NEJBQ2pCUCxTQUFTTyxTQUFTSSxNQUFNLENBQUNaLEtBQUssSUFBSTs0QkFDbENHLFVBQVVLLFNBQVNJLE1BQU0sQ0FBQ1YsTUFBTSxJQUFJOzs7Ozs7NEJBQy9CTzs0QkFDTEksUUFBUUosS0FBSyxDQUFDLDJCQUEyQkE7NEJBQ3pDUixTQUFTOzs7Ozs7Ozs7OztZQUdyQjs0QkFmTUc7Ozs7UUFpQk5BO0lBQ0osR0FBRztRQUFDVDtLQUFpQjtJQUlyQixJQUFNbUIsU0FBUztRQUNYcEIsUUFBUSxTQUFDcUI7bUJBQVVBLFNBQVMsMEJBQTBCLEtBQUs7O0lBQy9EO0lBRUEsSUFBTUMsWUFBWTtZQUNkbkI7U0FBQUEsb0JBQUFBLFNBQVNhLE9BQU8sY0FBaEJiLHdDQUFBQSxrQkFBa0JKLElBQUk7SUFDMUI7SUFFQSxJQUFNd0IsYUFBYTtZQUNmcEI7U0FBQUEsb0JBQUFBLFNBQVNhLE9BQU8sY0FBaEJiLHdDQUFBQSxrQkFBa0JxQixLQUFLO0lBQzNCO0lBRUEsSUFBTUMsZUFBZTtRQUNqQnZCLG9CQUFvQixTQUFDd0I7bUJBQWVBLGNBQWM1QixNQUFNNkIsTUFBTSxHQUFHLElBQUksSUFBSUQsWUFBWTs7SUFDekY7SUFFQSxxQkFDSSw4REFBQ0U7UUFBSUMsV0FBV25DLGdFQUFVLEdBQUc7OzBCQUN6Qiw4REFBQ2tDO2dCQUFJQyxXQUFXbkMsd0VBQWtCOztrQ0FDOUIsOERBQUNrQzt3QkFBSUMsV0FBV25DLHFFQUFlLEdBQUc7a0NBQzlCLDRFQUFDQyxrREFBS0E7NEJBQUNzQyxLQUFJOzRCQUFZQyxLQUFLdEMsZ0VBQUdBOzs7Ozs7Ozs7OztrQ0FFbkMsOERBQUNnQzt3QkFBSUMsV0FBV25DLHFFQUFlLEdBQUc7OzBDQUM5Qiw4REFBQzBDOzBDQUFJOUI7Ozs7OzswQ0FDTCw4REFBQytCOzBDQUFHN0I7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFJWiw4REFBQ29CO2dCQUFJQyxXQUFXbkMsb0VBQWM7O2tDQUMxQiw4REFBQzZDO3dCQUFFVixXQUFXbkMsK0RBQVMsR0FBRzt3QkFBb0IrQyxlQUFZOzs7Ozs7a0NBQzFELDhEQUFDRjt3QkFBRUcsU0FBUzs0QkFBUXRCOzRCQUFVRTt3QkFBYTt3QkFBR08sV0FBV25DLCtEQUFTLEdBQUcsTUFBTUEsZ0VBQVUsR0FBRyxrQkFBa0JLO3dCQUFNMEMsZUFBWTs7Ozs7O2tDQUM1SCw4REFBQ0Y7d0JBQUVHLFNBQVM7NEJBQVF0Qjs0QkFBVUc7d0JBQWM7d0JBQUdNLFdBQVduQywrREFBUyxHQUFHLE1BQU1BLGlFQUFXLEdBQUcsbUJBQW1CSzt3QkFBTTBDLGVBQVk7Ozs7OztrQ0FDL0gsOERBQUNGO3dCQUFFVixXQUFXbkMsK0RBQVMsR0FBRzt3QkFBbUJnRCxTQUFTakI7d0JBQWNnQixlQUFZOzs7Ozs7Ozs7Ozs7MEJBR3BGLDhEQUFDYjtnQkFBSUMsV0FBV25DLGtFQUFZOzBCQUN4Qiw0RUFBQ2tEO29CQUFNVixLQUFLcEMsS0FBSyxDQUFDRyxpQkFBaUI7b0JBQUU0QyxLQUFLMUM7Ozs7Ozs7Ozs7OzBCQUc5Qyw4REFBQ3lCO2dCQUFJQyxXQUFXbkMseUVBQW1COztrQ0FDL0IsOERBQUNrQzt3QkFBSUMsV0FBV25DLHVFQUFpQjtrQ0FDN0IsNEVBQUNrQzs0QkFBSUMsV0FBV25DLG9FQUFjOzs7Ozs7Ozs7OztrQ0FFbEMsOERBQUNrQzt3QkFBSUMsV0FBV25DLGdFQUFVOzswQ0FDdEIsOERBQUN3RDswQ0FBSzs7Ozs7OzBDQUNOLDhEQUFDQTswQ0FBTTlDLGFBQWEsT0FBTyxHQUFnQytDLE9BQTdCQSxLQUFLQyxLQUFLLENBQUNoRCxXQUFXLEtBQUksS0FBNkIsT0FBMUIrQyxLQUFLQyxLQUFLLENBQUNoRCxXQUFXLE9BQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUs3RztHQWpGTVA7S0FBQUE7QUFtRk4sK0RBQWVBLE1BQU1BLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL0hvbWUvY29tcG9uZW50cy9QbGF5ZXIudHN4PzEyYzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcclxuXHJcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgcGFyc2VCbG9iIH0gZnJvbSAnbXVzaWMtbWV0YWRhdGEtYnJvd3Nlcic7XHJcbmltcG9ydCBzdHlsZSBmcm9tIFwiLi9wbGF5ZXIubW9kdWxlLmNzc1wiO1xyXG5pbXBvcnQgSW1hZ2UgZnJvbSBcIm5leHQvaW1hZ2VcIjtcclxuaW1wb3J0IGltMSBmcm9tICcuLi9hc3NldHMvaW1hZ2VzL2FsYnVtLnBuZyc7XHJcblxyXG5pbnRlcmZhY2UgUGxheWVyUHJvcHMge1xyXG4gIHNvbmdzOiBzdHJpbmdbXTtcclxufVxyXG5cclxuY29uc3QgUGxheWVyOiBSZWFjdC5GQzxQbGF5ZXJQcm9wcz4gPSAoeyBzb25ncyB9KSA9PiB7XHJcbiAgICBjb25zdCBbcGxheSwgc2V0UGxheV0gPSB1c2VTdGF0ZTxzdHJpbmc+KCdwbGF5ZXJfcGxheWluZ19faXVESl8nKTtcclxuICAgIGNvbnN0IFtjdXJyZW50U29uZ0luZGV4LCBzZXRDdXJyZW50U29uZ0luZGV4XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgYXVkaW9SZWYgPSB1c2VSZWY8SFRNTEF1ZGlvRWxlbWVudD4obnVsbCk7XHJcbiAgICBjb25zdCBbZHVyYXRpb24sIHNldER1cmF0aW9uXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG4gICAgY29uc3QgW3RpdGxlLCBzZXRUaXRsZV0gPSB1c2VTdGF0ZTxzdHJpbmc+KCdUw610dWxvIERlc2NvbmhlY2lkbycpO1xyXG4gICAgY29uc3QgW2FydGlzdCwgc2V0QXJ0aXN0XSA9IHVzZVN0YXRlPHN0cmluZz4oJ0FydGlzdGEgRGVzY29uaGVjaWRvJyk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBmZXRjaE1ldGFkYXRhID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhdWRpb0VsZW1lbnQgPSBhdWRpb1JlZi5jdXJyZW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKGF1ZGlvRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHNvbmdzW2N1cnJlbnRTb25nSW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgcGFyc2VCbG9iKGJsb2IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpdGxlKG1ldGFkYXRhLmNvbW1vbi50aXRsZSB8fCAnVMOtdHVsbyBEZXNjb25oZWNpZG8nKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRBcnRpc3QobWV0YWRhdGEuY29tbW9uLmFydGlzdCB8fCAnQXJ0aXN0YSBEZXNjb25oZWNpZG8nKVxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWFkaW5nIG1ldGFkYXRhOicsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaXRsZSgnVMOtdHVsbyBEZXNjb25oZWNpZG8nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGZldGNoTWV0YWRhdGEoKTtcclxuICAgIH0sIFtjdXJyZW50U29uZ0luZGV4XSk7XHJcblxyXG4gICAgXHJcblxyXG4gICAgY29uc3QgUGxheWVkID0gKCkgPT4ge1xyXG4gICAgICAgIHNldFBsYXkoKHByZXYpID0+IChwcmV2ID09PSAncGxheWVyX3BsYXlpbmdfX2l1REpfJyA/ICcnIDogJ3BsYXllcl9wbGF5aW5nX19pdURKXycpKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcGxheUF1ZGlvID0gKCkgPT4ge1xyXG4gICAgICAgIGF1ZGlvUmVmLmN1cnJlbnQ/LnBsYXkoKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcGF1c2VBdWRpbyA9ICgpID0+IHtcclxuICAgICAgICBhdWRpb1JlZi5jdXJyZW50Py5wYXVzZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBwbGF5TmV4dFNvbmcgPSAoKSA9PiB7XHJcbiAgICAgICAgc2V0Q3VycmVudFNvbmdJbmRleCgocHJldkluZGV4KSA9PiAocHJldkluZGV4ID09PSBzb25ncy5sZW5ndGggLSAxID8gMCA6IHByZXZJbmRleCArIDEpKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGUuY2FyZCArIFwiIGNhcmRcIn0+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZS5pbmZvcm1hdGlvbnN9PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlLmltYWdlQ2FyZCArIFwiIGltYWdlLWNhcmRcIn0+XHJcbiAgICAgICAgICAgICAgICAgICAgPEltYWdlIGFsdD0naW1nLUFsYnVtJyBzcmM9e2ltMX0gLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlLnRpdGxlQ2FyZCArIFwiIHRpdGxlLWNhcmRcIn0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGgzPnt0aXRsZX08L2gzPlxyXG4gICAgICAgICAgICAgICAgICAgIDxwPnthcnRpc3R9PC9wPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlLmNvbnRyb2xzfT5cclxuICAgICAgICAgICAgICAgIDxpIGNsYXNzTmFtZT17c3R5bGUuYnRuICsgXCIgZmFzIGZhLWJhY2t3YXJkXCJ9IGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cclxuICAgICAgICAgICAgICAgIDxpIG9uQ2xpY2s9eygpID0+IHsgUGxheWVkKCk7IHBsYXlBdWRpbygpOyB9fSBjbGFzc05hbWU9e3N0eWxlLmJ0biArIFwiIFwiICsgc3R5bGUucGxheSArIFwiIGZhcyBmYS1wbGF5IFwiICsgcGxheX0gYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxyXG4gICAgICAgICAgICAgICAgPGkgb25DbGljaz17KCkgPT4geyBQbGF5ZWQoKTsgcGF1c2VBdWRpbygpOyB9fSBjbGFzc05hbWU9e3N0eWxlLmJ0biArIFwiIFwiICsgc3R5bGUucGF1c2UgKyBcIiBmYXMgZmEtcGF1c2UgXCIgKyBwbGF5fSBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XHJcbiAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9e3N0eWxlLmJ0biArIFwiIGZhcyBmYS1mb3J3YXJkXCJ9IG9uQ2xpY2s9e3BsYXlOZXh0U29uZ30gYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICBcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlLnBsYXllcn0+XHJcbiAgICAgICAgICAgICAgICA8YXVkaW8gc3JjPXtzb25nc1tjdXJyZW50U29uZ0luZGV4XX0gcmVmPXthdWRpb1JlZn0gLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGUudGltZUNvbnRhaW5lcn0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGUucHJvZ3Jlc3NCYXJ9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZS5wcm9ncmVzc30+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZS50aW1lfT5cclxuICAgICAgICAgICAgICAgICAgICA8c3Bhbj4wOjAwPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuPntkdXJhdGlvbiAhPT0gbnVsbCA/IGAke01hdGguZmxvb3IoZHVyYXRpb24gLyA2MCl9OiR7TWF0aC5mbG9vcihkdXJhdGlvbiAlIDYwKX1gIDogJ0NhcnJlZ2FuZG8uLi4nfTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQbGF5ZXI7XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlUmVmIiwidXNlRWZmZWN0IiwicGFyc2VCbG9iIiwic3R5bGUiLCJJbWFnZSIsImltMSIsIlBsYXllciIsInNvbmdzIiwicGxheSIsInNldFBsYXkiLCJjdXJyZW50U29uZ0luZGV4Iiwic2V0Q3VycmVudFNvbmdJbmRleCIsImF1ZGlvUmVmIiwiZHVyYXRpb24iLCJzZXREdXJhdGlvbiIsInRpdGxlIiwic2V0VGl0bGUiLCJhcnRpc3QiLCJzZXRBcnRpc3QiLCJmZXRjaE1ldGFkYXRhIiwiYXVkaW9FbGVtZW50IiwicmVzcG9uc2UiLCJibG9iIiwibWV0YWRhdGEiLCJlcnJvciIsImN1cnJlbnQiLCJmZXRjaCIsImNvbW1vbiIsImNvbnNvbGUiLCJQbGF5ZWQiLCJwcmV2IiwicGxheUF1ZGlvIiwicGF1c2VBdWRpbyIsInBhdXNlIiwicGxheU5leHRTb25nIiwicHJldkluZGV4IiwibGVuZ3RoIiwiZGl2IiwiY2xhc3NOYW1lIiwiY2FyZCIsImluZm9ybWF0aW9ucyIsImltYWdlQ2FyZCIsImFsdCIsInNyYyIsInRpdGxlQ2FyZCIsImgzIiwicCIsImNvbnRyb2xzIiwiaSIsImJ0biIsImFyaWEtaGlkZGVuIiwib25DbGljayIsInBsYXllciIsImF1ZGlvIiwicmVmIiwidGltZUNvbnRhaW5lciIsInByb2dyZXNzQmFyIiwicHJvZ3Jlc3MiLCJ0aW1lIiwic3BhbiIsIk1hdGgiLCJmbG9vciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/Home/components/Player.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/image-component.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/client/image-component.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _object_without_properties = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_without_properties.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nvar _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_to_consumable_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function get() {\n        return Image;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nvar _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nvar _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\"));\nvar _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nvar _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nvar _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nvar _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nvar _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nvar _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\n// This is replaced by webpack define plugin\nvar configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]};\nif (typeof window === \"undefined\") {\n    globalThis.__NEXT_IMAGE_IMPORTED = true;\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {\n    var src = img == null ? void 0 : img.src;\n    if (!img || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    var p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p[\"catch\"](function() {}).then(function() {\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== \"empty\") {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            var event = new Event(\"load\");\n            Object.defineProperty(event, \"target\", {\n                writable: false,\n                value: img\n            });\n            var prevented = false;\n            var stopped = false;\n            onLoadRef.current(_object_spread_props._(_object_spread._({}, event), {\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: function() {\n                    return prevented;\n                },\n                isPropagationStopped: function() {\n                    return stopped;\n                },\n                persist: function() {},\n                preventDefault: function() {\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: function() {\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            }));\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            var origSrc = new URL(src, \"http://n\").searchParams.get(\"url\") || src;\n            if (img.getAttribute(\"data-nimg\") === \"fill\") {\n                if (!unoptimized && (!sizesInput || sizesInput === \"100vw\")) {\n                    var widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        if (sizesInput === \"100vw\") {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" prop and \"sizes\" prop of \"100vw\", but image is not rendered at full viewport width. Please adjust \"sizes\" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        } else {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        }\n                    }\n                }\n                if (img.parentElement) {\n                    var position = window.getComputedStyle(img.parentElement).position;\n                    var valid = [\n                        \"absolute\",\n                        \"fixed\",\n                        \"relative\"\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(\",\") + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            var heightModified = img.height.toString() !== img.getAttribute(\"height\");\n            var widthModified = img.width.toString() !== img.getAttribute(\"width\");\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    if (Boolean(_react.use)) {\n        // In React 19.0.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority: fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nvar ImageElement = /*#__PURE__*/ (0, _react.forwardRef)(function(param, forwardedRef) {\n    var src = param.src, srcSet = param.srcSet, sizes = param.sizes, height = param.height, width = param.width, decoding = param.decoding, className = param.className, style = param.style, fetchPriority = param.fetchPriority, placeholder = param.placeholder, loading = param.loading, unoptimized = param.unoptimized, fill = param.fill, onLoadRef = param.onLoadRef, onLoadingCompleteRef = param.onLoadingCompleteRef, setBlurComplete = param.setBlurComplete, setShowAltText = param.setShowAltText, sizesInput = param.sizesInput, onLoad = param.onLoad, onError = param.onError, rest = _object_without_properties._(param, [\n        \"src\",\n        \"srcSet\",\n        \"sizes\",\n        \"height\",\n        \"width\",\n        \"decoding\",\n        \"className\",\n        \"style\",\n        \"fetchPriority\",\n        \"placeholder\",\n        \"loading\",\n        \"unoptimized\",\n        \"fill\",\n        \"onLoadRef\",\n        \"onLoadingCompleteRef\",\n        \"setBlurComplete\",\n        \"setShowAltText\",\n        \"sizesInput\",\n        \"onLoad\",\n        \"onError\"\n    ]);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"img\", _object_spread_props._(_object_spread._({}, rest, getDynamicProps(fetchPriority)), {\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? \"fill\" : \"1\",\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: (0, _react.useCallback)(function(img) {\n            if (forwardedRef) {\n                if (typeof forwardedRef === \"function\") forwardedRef(img);\n                else if (typeof forwardedRef === \"object\") {\n                    // @ts-ignore - .current is read only it's usually assigned by react internally\n                    forwardedRef.current = img;\n                }\n            }\n            if (!img) {\n                return;\n            }\n            if (onError) {\n                // If the image has an error before react hydrates, then the error is lost.\n                // The workaround is to wait until the image is mounted which is after hydration,\n                // then we set the src again to trigger the error handler (if there was an error).\n                // eslint-disable-next-line no-self-assign\n                img.src = img.src;\n            }\n            if (true) {\n                if (!src) {\n                    console.error('Image is missing required \"src\" property:', img);\n                }\n                if (img.getAttribute(\"alt\") === null) {\n                    console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n                }\n            }\n            if (img.complete) {\n                handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n            }\n        }, [\n            src,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            onError,\n            unoptimized,\n            sizesInput,\n            forwardedRef\n        ]),\n        onLoad: function(event) {\n            var img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        },\n        onError: function(event) {\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== \"empty\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    }));\n});\nfunction ImagePreload(param) {\n    var isAppRouter = param.isAppRouter, imgAttributes = param.imgAttributes;\n    var opts = _object_spread._({\n        as: \"image\",\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy\n    }, getDynamicProps(imgAttributes.fetchPriority));\n    if (isAppRouter && _reactdom[\"default\"].preload) {\n        // See https://github.com/facebook/react/pull/26940\n        _reactdom[\"default\"].preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head[\"default\"], {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", _object_spread._({\n            rel: \"preload\",\n            // Note how we omit the `href` attribute, as it would only be relevant\n            // for browsers that do not support `imagesrcset`, and in those cases\n            // it would cause the incorrect image to be preloaded.\n            //\n            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n            href: imgAttributes.srcSet ? undefined : imgAttributes.src\n        }, opts), \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n    });\n}\n_c = ImagePreload;\nvar Image = /*#__PURE__*/ (0, _react.forwardRef)(function(props, forwardedRef) {\n    var pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    var isAppRouter = !pagesRouter;\n    var configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    var config = (0, _react.useMemo)(function() {\n        var c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        var allSizes = _to_consumable_array._(c.deviceSizes).concat(_to_consumable_array._(c.imageSizes)).sort(function(a, b) {\n            return a - b;\n        });\n        var deviceSizes = c.deviceSizes.sort(function(a, b) {\n            return a - b;\n        });\n        return _object_spread_props._(_object_spread._({}, c), {\n            allSizes: allSizes,\n            deviceSizes: deviceSizes\n        });\n    }, [\n        configContext\n    ]);\n    var onLoad = props.onLoad, onLoadingComplete = props.onLoadingComplete;\n    var onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(function() {\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    var onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(function() {\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    var _ref = _sliced_to_array._((0, _react.useState)(false), 2), blurComplete = _ref[0], setBlurComplete = _ref[1];\n    var _ref1 = _sliced_to_array._((0, _react.useState)(false), 2), showAltText = _ref1[0], setShowAltText = _ref1[1];\n    var _ref2 = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader[\"default\"],\n        imgConf: config,\n        blurComplete: blurComplete,\n        showAltText: showAltText\n    }), imgAttributes = _ref2.props, imgMeta = _ref2.meta;\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, _object_spread_props._(_object_spread._({}, imgAttributes), {\n                unoptimized: imgMeta.unoptimized,\n                placeholder: imgMeta.placeholder,\n                fill: imgMeta.fill,\n                onLoadRef: onLoadRef,\n                onLoadingCompleteRef: onLoadingCompleteRef,\n                setBlurComplete: setBlurComplete,\n                setShowAltText: setShowAltText,\n                sizesInput: props.sizes,\n                ref: forwardedRef\n            })),\n            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {\n                isAppRouter: isAppRouter,\n                imgAttributes: imgAttributes\n            }) : null\n        ]\n    });\n});\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=image-component.js.map\nvar _c;\n$RefreshReg$(_c, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLWNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZFQWFpQjttREFDV0EsQ0FBQSxDQUFBQyxtQkFBQUEsQ0FBQTt1Q0FZTzs7dUNBRVZBLG1CQUFBQSxDQUFBOzs7QUFNekIsSUFBQUMsZUFBQSxjQUFBQyx5QkFBNENILENBQUEsQ0FBQUMsbUJBQUFBLENBQUE7QUFDNUMsNENBQThCRztBQUU5QixJQUFJQyxZQUFPQywwTkFBd0I7SUFDL0JFLE9BQUFBLFdBQW1CQyxhQUFBQTtJQUN2QkQsV0FBQUMscUJBQUE7QUFtQkE7QUFDQSwwRUFBaUQ7QUFDakQsaURBR0VDO1NBTUFDLGNBQVlDLEdBQUFBLEVBQUFBLFdBQUFBLEVBQUFBLFNBQVEsRUFBQUMsb0JBQUEsRUFBQUMsZUFBQSxFQUFBQyxXQUFBLEVBQUFDLFVBQUE7SUFDcEIsSUFBS0osTUFBT0EsT0FBSSxnQkFBa0JBLElBQUtLLEdBQUFBO1FBQ3JDLENBQUFMLE9BQUFBLEdBQUEsd0JBQUFLLEtBQUE7UUFDRjtJQUNBTDtJQUNBQSxHQUFBLG1CQUFzQkEsR0FBQUE7SUFDdEJNLElBQUVDLElBQU0sWUFBZVAsTUFBQUEsSUFBQVEsTUFBQSxLQUFBQyxRQUFBQyxPQUFBO2NBQ3JCLENBQUksWUFBS0MsR0FBQUEsSUFBQUEsQ0FBQUE7WUFDUCxDQUFBWCxJQUFBVyxhQUFBLEtBQUFYLElBQUFZLFdBQUEsRUFBd0M7WUFDeEMsd0NBQXVCO1lBQ3ZCO1lBQ0Esc0NBQXNCO1lBQ3RCO1lBQ0E7WUFDRjtRQUNBO1lBQ0VWLGdCQUFnQjtZQUNsQkEsZ0JBQUE7UUFDQTtZQUNFSixhQUFBLGdCQUFBQSxVQUFBZSxPQUFBLEVBQStDO1lBQy9DLCtDQUEwQztZQUMxQztZQUNBLDJDQUF3QjtZQUN4QkMsSUFBQUEsUUFBT0MsSUFBQUEsTUFBZUM7bUJBQW1CQyxjQUFVLENBQUFELE9BQUE7Z0JBQU9FLFVBQU9sQjtnQkFBSWtCLE9BQUFsQjtZQUNyRTtZQUNBLElBQUltQixZQUFVO1lBQ2RyQixJQUFBQSxVQUFVZTtzQkFDTEcsT0FBSyw2Q0FDUkk7Z0JBQ0FDLGFBQUFBO2dCQUNBQyxlQUFRdEI7Z0JBQ1J1QixRQUFBQTtnQkFDQUMsb0JBQUFBOzJCQUFzQkM7O2dCQUN0QkMsc0JBQWdCOzJCQUFBUDs7Z0JBQ2hCUSxTQUFBQSxZQUFBQTtnQ0FDYztvQkFDWlgsWUFBTVc7b0JBQ1JYLE1BQUFXLGNBQUE7Z0JBQ0FDO2lDQUNZO29CQUNWWixVQUFNWTtvQkFDUlosTUFBQVksZUFBQTtnQkFDRjs7UUFFRjtZQUNFM0Isd0JBQXFCWSxPQUFRYixLQUFBQSxJQUFBQSxxQkFBQUEsT0FBQUEsRUFBQUE7WUFDL0JDLHFCQUFBWSxPQUFBLENBQUFiO1FBQ0E7WUFDRTZCLElBQXdCeEIsRUFBSztZQUM3QixJQUFJTCxVQUFJOEIsSUFBWUMsSUFBQzFCLEtBQUEsWUFBaUIyQixZQUFRLENBQUFDLEdBQUEsV0FBQTVCO2dCQUM1Q0wsSUFBSThCLFlBQUMzQixDQUFBQSxpQkFBaUJDLFFBQWNBO29CQUNsQyxDQUFBRCxlQUFJK0IsQ0FBQUEsQ0FBQUEsY0FDRUMsZUFBQUEsT0FBd0JDLEdBQUFBO29CQUM5QixJQUFJRixxQkFBcUJsQyxJQUFBbUMscUJBQUssR0FBQUMsS0FBQSxHQUFBMUMsT0FBQTJDLFVBQUE7d0JBQzVCSCxxQkFBbUI7NEJBQ2pCSSxlQUFBQSxTQUNFOzRCQUVKLElBQU9DLFVBQUFELFFBQUEsdUJBQUFFLFVBQUE7K0JBQ0xGOzRCQUdGLElBQUFDLFVBQUFELFFBQUEsdUJBQUFFLFVBQUE7d0JBQ0Y7b0JBQ0Y7Z0JBQ0E7b0JBQ0V4QyxJQUFBVyxhQUFnQixFQUFFO29CQUNsQixJQUFNOEIsV0FBUS9DLE9BQUFnRCxnQkFBQSxDQUFBMUMsSUFBQVcsYUFBQSxFQUFSOEI7d0JBQVNBLFFBQUE7d0JBQVk7d0JBQVM7d0JBQVc7cUJBQy9DO3dCQUNFSCxDQUFBQSxNQUFBQSxRQUFBQSxDQUFBQSxXQUNHO3dCQUlMLElBQUFDLFVBQUFELFFBQUEsdUJBQUFFLFVBQUEsd0VBQUFHLFdBQUEsd0JBQUFGLE1BQUFHLEdBQUEsQ0FBQUMsUUFBQUMsSUFBQTtvQkFDRjtnQkFDQTtvQkFDRVIsSUFBQUEsTUFBQUEsS0FBQUEsR0FBQUE7b0JBR0YsSUFBQUMsVUFBQUQsUUFBQSx1QkFBQUUsVUFBQTtnQkFDRjtZQUVBO1lBRUEsSUFBTU8saUJBQWdCL0MsSUFBSW9DLE1BQU1ZLENBQUFBLFFBQVEsT0FBT2hELElBQUk4QixZQUFhO1lBQ2hFLElBQ0dtQixnQkFBa0JqRCxJQUFDK0MsS0FBQUEsQ0FBQUEsUUFDbkIsT0FBQ0UsSUFBQUEsWUFBa0JGLENBQUFBO2dCQUVwQlQsa0JBQUFBLENBQUFBLGlCQUNHLENBQUFXLGtCQUEwQkYsZUFBQTtnQkFFL0IsSUFBQVIsVUFBQUQsUUFBQSx1QkFBQUUsVUFBQTtZQUNGO1FBQ0Y7SUFDRjtBQUVBO1NBR01VLGdCQUFRQyxhQUFNO1FBQ2hCRCxRQUFBRSxPQUFBRCxHQUFBO1FBQ0Esa0RBQWlEO1FBQ2pEO1FBQ0EsbURBQU87ZUFBRUU7WUFBY0EsZUFBQUE7UUFDekI7SUFDQTtJQUNBLHVEQUE0QztJQUM1Qyw0Q0FBTztXQUFFQztRQUE2QkEsZUFBQUQ7SUFDeEM7QUFFQTttQkFNTUUsV0FBQUEsR0FBTSxJQUNObkIsT0FDQW9CLFVBQ0FDLEVBQUFBLFNBQUFBLE9BQ0FDO0lBaUJGLElBQUFyRCxNQUNHTCxNQURISyxLQUFBc0QsU0FDRzNELE1BREgyRCxRQUFBQyxRQUNHNUQsTUFESDRELE9BQ0VMLFNBQUN2RCxNQUFEdUQsUUFBQW5CLFFBQUNwQyxNQUFEb0MsT0FBQW9CLFdBQUN4RCxNQUFEd0QsVUFBQ3hELFlBQUFBLE1BQUFBLFdBQUFBLFFBQUFBLE1BQUFBLE9BQUFBLGdCQUFBQSxNQUFBQSxlQUFBQSxjQUFBQSxNQUFBQSxhQUFBQSxVQUFBQSxNQUFBQSxTQUFBQSxjQUFBQSxNQUFBQSxhQUFBQSxPQUFBQSxNQUFBQSxNQUFBQSxZQUFBQSxNQUFBQSxXQUFBQSx1QkFBQUEsTUFBQUEsc0JBQUFBLGtCQUFBQSxNQUFBQSxpQkFBQUEsaUJBQUFBLE1BQUFBLGdCQUFBQSxhQUFBQSxNQUFBQSxZQUFBQSxTQUFBQSxNQUFBQSxRQUFBQSxVQUFBQSxNQUFBQSxTQUFBQSxvQ0FBQUE7UUFESEs7UUFBQXNEO1FBQUFDO1FBQ0VMO1FBQUFuQjtRQUFBb0I7UUFBQ3hEO1FBQUFBO1FBQUFBO1FBQUFBO1FBQUFBO1FBQUFBO1FBQUFBO1FBQUFBO1FBQUFBO1FBQUFBO1FBQUFBO1FBQUFBO1FBQUFBO1FBQUFBOztXQUNTLGtCQUFBOEQsWUFBQUMsR0FBQSxxREFDSkMsTUFDSkEsZ0JBQUFYO1FBQ0E7UUFDQSx3RUFBcUQ7UUFDckRZLHFEQUFTQTtRQUNUN0IsU0FBT0E7UUFDUG1CLE9BQUFBO1FBQ0FDLFFBQUFBO1FBQ0FVLFVBQUFBO1FBQ0FULGFBQVdBLE9BQUFBLFNBQUFBO1FBQ1hDLFdBQU9BO1FBQ1BBLE9BQUFBO1FBQ0EsdUVBQW1FO1FBQ25FO1FBQ0E7UUFDQSwwRUFBMkI7UUFDM0I7UUFDQUUsc0RBQU9BO1FBQ1BELE9BQUFBO1FBQ0F0RCxRQUFLQTtRQUNMOEQsS0FBS0M7YUFFRCxJQUFJQyxPQUFBQSxXQUFjLFdBQUFyRTtnQkFDaEJxRSxjQUFXQTsyQkFDRkEsaUJBQU9BLFlBQWlCQSxhQUFVckU7cUJBQ3pDLFdBQUFxRSxpQkFBQTtvQkFDQUEsK0VBQXVCckU7b0JBQ3pCcUUsYUFBQXhELE9BQUEsR0FBQWI7Z0JBQ0Y7WUFDQTtnQkFDRSxDQUFBQSxLQUFBO2dCQUNGO1lBQ0E7Z0JBQ0VzRSxTQUFBO2dCQUNBO2dCQUNBO2dCQUNBLGtGQUEwQztnQkFDMUN0RSwwQ0FBaUI7Z0JBQ25CQSxJQUFBSyxHQUFBLEdBQUFMLElBQUFLLEdBQUE7WUFDQTtnQkFDRXdCLElBQVU7b0JBQ1IwQyxDQUFBQSxLQUFBQTtvQkFDRkEsUUFBQUMsS0FBQSw4Q0FBQXhFO2dCQUNBO29CQUNFdUUsSUFBQUEsWUFDRztvQkFFTEEsUUFBQUMsS0FBQTtnQkFDRjtZQUNBO2dCQUNFekUsSUFBQUEsUUFBQUEsRUFDRUM7Z0JBUUpELGNBQUFDLEtBQUF5RSxhQUFBM0UsV0FBQUcsc0JBQUFDLGlCQUFBQyxhQUFBQztZQUVGOztZQUVFcUU7WUFDQTNFO1lBQ0FHO1lBQ0FDO1lBQ0FvRTtZQUNBbkU7WUFDQUM7WUFDQWlFO1lBQ0RBO1NBRUhLO2dCQUNFLFNBQUExRDtZQUNBakIsSUFBQUEsTUFBQUEsTUFDRUMsYUFDQXlFO1lBT0oxRSxjQUFBQyxLQUFBeUUsYUFBQTNFLFdBQUFHLHNCQUFBQyxpQkFBQUMsYUFBQUM7UUFDQWtFO2lCQUNFLFNBQUF0RDtZQUNBMkQscUVBQWU7WUFDZkEsZUFBSUY7Z0JBQ0ZBLGdCQUFBO2dCQUNBdkUsMkVBQWdCO2dCQUNsQkEsZ0JBQUE7WUFDQTtnQkFDRW9FLFNBQVF0RDtnQkFDVnNELFFBQUF0RDtZQUNGOzs7QUFNUjtTQUFzQjRELGFBQ1RDLEtBQ1hDO0lBS0EsSUFBTUMsY0FBT0YsTUFBUEUsYUFBT0QsZ0JBQUFELE1BQUFDO1FBQ1hFLE9BQUk7UUFDSkMsSUFBQUE7UUFDQUMsYUFBWUosY0FBY2xCLE1BQUs7UUFDL0J1QixZQUFBQSxjQUFhTCxLQUFjSztRQUMzQkMsYUFBQUEsY0FBZ0JOLFdBQWNNO1FBQzlCQSxnQkFBR3BCLGNBQWdCYyxjQUFjekI7T0FDbkNXLGdCQUFBYyxjQUFBekIsYUFBQTtRQUdFZ0MsZUFBQUMsU0FBQUMsQ0FBQUEsVUFBQSxDQUFBQyxPQUFBO1FBQ0FDLG1EQUVFO1FBQ0FWLFNBQUFBLENBQUFBLFVBQUFBLENBQUFBLE9BQUFBLENBQUFBLGNBQUFBLEdBQUFBLEVBRUZBO1FBQ0Y7SUFFQTtXQUVJLGtCQUFBakIsWUFBQUMsR0FBQSxFQUFBMkIsS0FBQUgsQ0FBQUEsVUFBQ0ksRUFBQUE7a0JBT0ssa0JBQUE3QixZQUFBQyxHQUFBO1lBQ0o2QixLQUFBO1lBQ0Esc0VBQXFFO1lBQ3JFLHFFQUFzRDtZQUN0RCxzREFBRTtZQUNGO1lBQ0FDLDhFQUEwRDtZQUN6REEsTUFBR2QsY0FBSXBCLE1BQUEsR0FBQW1DLFlBQUFoQixjQUFBekUsR0FBQTtXQVpOMEU7SUFnQlY7QUFPTztLQXJEZUg7SUF1RGxCbUIsUUFBb0JDLFdBQUFBLEdBQUFBLENBQUFBLEdBQUFBLE9BQUFBLFVBQVdFLEVBQUFBLFNBQUFBLE9BQUFBO0lBQy9CLElBQUFELGNBQUEsSUFBQTdDLE9BQUE0QyxVQUFBLEVBQUFHLDRCQUEwREQsYUFBQTtJQUMxRCwwREFBcUJEO0lBRXJCLElBQU1HLGNBQUFBLENBQUFBO0lBQ04sSUFBTUMsZ0JBQVNDLENBQUFBLEdBQUFBLE9BQU9OLFVBQUMsRUFBQU8saUNBQUFDLGtCQUFBO1FBQ3JCSCxTQUFVNUcsQ0FBQUEsR0FBQUEsT0FBQUEsT0FBYTJHLEVBQUFBO1FBQ3ZCLElBQU1LLElBQUFBLGFBQVdMLGlCQUFBTSxhQUFBQyxrQkFBQTt1QkFBTUMsdUJBQWdCQyxFQUFFM0IsV0FBVSxTQUFFNEIsdUJBQUtELEVBQUNFLFVBQWFDLEdBQ3hFRixJQUFNRixDQUFBQSxTQUFBQSxHQUFBQTttQkFBQUEsSUFBQUE7O1FBQ04sSUFBQUEsY0FBT0MsRUFBQUQsV0FBQSxDQUFBRSxJQUFBLFVBQUFDLEdBQUFDO21CQUFBRCxJQUFBQzs7ZUFBS0gsNENBQUdKO1lBQVVHLFVBQUFBO1lBQVlBLGFBQUFBOzs7UUFDckJSO0tBRWxCO0lBQ0EsSUFBTXRHLFNBQW1CNEUsTUFBbkI1RSxRQUFBQSxvQkFBbUI0RSxNQUFuQjVFO0lBRU5tSCxJQUFBQSxZQUFBQSxDQUFBQSxHQUFVN0QsT0FBQThELE1BQUEsRUFBQXhDO1FBQ1I1RSxPQUFBQSxTQUFVZSxFQUFPO1FBQ2hCZixVQUFBZSxPQUFBLEdBQUE2RDs7UUFBUUE7S0FFWDtJQUVBdUMsSUFBQUEsdUJBQVUsSUFBQTdELE9BQUE4RCxNQUFBLEVBQUFDO1FBQ1JsSCxPQUFBQSxTQUFBQSxFQUFBQTtRQUNDQSxxQkFBQVksT0FBQSxHQUFBc0c7O1FBQW1CQTtLQUV0QjtJQUNBLElBQXNDQywwQkFBQUEsQ0FBQUEsR0FBQUEsT0FBQUEsUUFBUyxjQUF4Q0MsZUFBK0JELFNBQWxCekMsa0JBQWtCeUM7SUFFdEMsSUFBb0NFLDJCQUFBQSxDQUFBQSxHQUFBQSxPQUFZQyxRQUFBQSxFQUFBQSxZQUExQ0YsY0FBOEJDLFVBQXJCeEMsaUJBQXFCd0M7UUFDckIsWUFBQUUsYUFBQUQsV0FBQSxFQUFBRSxPQUFBO1FBQ2JDLGVBQVNyQixZQUFBQSxDQUFBQSxVQUFBQTtRQUNUc0IsU0FBQUE7UUFDQU4sY0FBQUE7UUFDRkEsYUFBQUE7SUFFQSxJQU5FTyxnQkFBYSxNQUFiQSxPQUFBQSxVQUFhLE1BQWJBOzs7dUJBVVU5QyxHQUFBQSxDQUFBQSxHQUFBQSxZQUFhZixHQUFBLEVBQUE4RCxjQUFBLDRDQUNqQjFIO2dCQUNBc0UsYUFBYTZDLFFBQVE3QyxXQUFXO2dCQUNoQ3FELGFBQU1SLFFBQVk3QyxXQUFBO2dCQUNsQjNFLE1BQUFBLFFBQVdBLElBQUFBO2dCQUNYRyxXQUFBQTtnQkFDQUMsc0JBQWlCQTtnQkFDakJ5RSxpQkFBZ0JBO2dCQUNoQnZFLGdCQUFZcUg7Z0JBQ1p0RCxZQUFLRSxNQUFBQSxLQUFBQTs7O29CQUtMZ0IsUUFBQUEsR0FBYUEsV0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsWUFBQUEsR0FBQUEsRUFBQUEsY0FBQUE7Z0JBQ2JQLGFBQUFBOytCQUVBQTs7O0lBR1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9jbGllbnQvaW1hZ2UtY29tcG9uZW50LnRzeD81MWUxIl0sIm5hbWVzIjpbIl8iLCJyZXF1aXJlIiwiX2ltYWdlbG9hZGVyIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX19ORVhUX0lNQUdFX09QVFMiLCJjb25maWdFbnYiLCJ3aW5kb3ciLCJlbnYiLCJnbG9iYWxUaGlzIiwiX19ORVhUX0lNQUdFX0lNUE9SVEVEIiwib25Mb2FkUmVmIiwiaGFuZGxlTG9hZGluZyIsImltZyIsIm9uTG9hZGluZ0NvbXBsZXRlUmVmIiwic2V0Qmx1ckNvbXBsZXRlIiwidW5vcHRpbWl6ZWQiLCJzaXplc0lucHV0Iiwic3JjIiwicCIsImNhdGNoIiwiZGVjb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwYXJlbnRFbGVtZW50IiwiaXNDb25uZWN0ZWQiLCJjdXJyZW50IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJldmVudCIsIndyaXRhYmxlIiwidmFsdWUiLCJzdG9wcGVkIiwibmF0aXZlRXZlbnQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwcmV2ZW50ZWQiLCJwZXJzaXN0IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJwcm9jZXNzIiwiZ2V0QXR0cmlidXRlIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwiZ2V0Iiwid2lkdGhWaWV3cG9ydFJhdGlvIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJpbm5lcldpZHRoIiwid2Fybk9uY2UiLCJfd2Fybm9uY2UiLCJvcmlnU3JjIiwidmFsaWQiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJtYXAiLCJTdHJpbmciLCJqb2luIiwid2lkdGhNb2RpZmllZCIsInRvU3RyaW5nIiwiaGVpZ2h0TW9kaWZpZWQiLCJCb29sZWFuIiwidXNlIiwiX3JlYWN0IiwiZmV0Y2hQcmlvcml0eSIsImZldGNocHJpb3JpdHkiLCJoZWlnaHQiLCJkZWNvZGluZyIsImNsYXNzTmFtZSIsInN0eWxlIiwic3JjU2V0Iiwic2l6ZXMiLCJyZXN0IiwiX2pzeHJ1bnRpbWUiLCJqc3giLCJnZXREeW5hbWljUHJvcHMiLCJsb2FkaW5nIiwiZGF0YS1uaW1nIiwicmVmIiwidXNlQ2FsbGJhY2siLCJmb3J3YXJkZWRSZWYiLCJvbkVycm9yIiwiY29uc29sZSIsImVycm9yIiwicGxhY2Vob2xkZXIiLCJvbkxvYWQiLCJzZXRTaG93QWx0VGV4dCIsIkltYWdlUHJlbG9hZCIsInBhcmFtIiwiaW1nQXR0cmlidXRlcyIsIm9wdHMiLCJhcyIsImltYWdlU3JjU2V0IiwiaW1hZ2VTaXplcyIsImNyb3NzT3JpZ2luIiwicmVmZXJyZXJQb2xpY3kiLCJpc0FwcFJvdXRlciIsIl9yZWFjdGRvbSIsImRlZmF1bHQiLCJwcmVsb2FkIiwiUmVhY3RET00iLCJfaGVhZCIsImxpbmsiLCJyZWwiLCJocmVmIiwidW5kZWZpbmVkIiwiSW1hZ2UiLCJ1c2VDb250ZXh0IiwicGFnZXNSb3V0ZXIiLCJSb3V0ZXJDb250ZXh0IiwiX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiY29uZmlnQ29udGV4dCIsImNvbmZpZyIsInVzZU1lbW8iLCJfaW1hZ2Vjb25maWdjb250ZXh0c2hhcmVkcnVudGltZSIsIkltYWdlQ29uZmlnQ29udGV4dCIsImFsbFNpemVzIiwiX2ltYWdlY29uZmlnIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiZGV2aWNlU2l6ZXMiLCJjIiwic29ydCIsImEiLCJiIiwidXNlRWZmZWN0IiwidXNlUmVmIiwib25Mb2FkaW5nQ29tcGxldGUiLCJ1c2VTdGF0ZSIsInNob3dBbHRUZXh0IiwiaW1nTWV0YSIsImdldEltZ1Byb3BzIiwiX2dldGltZ3Byb3BzIiwicHJvcHMiLCJpbWdDb25mIiwiYmx1ckNvbXBsZXRlIiwiZGVmYXVsdExvYWRlciIsIkltYWdlRWxlbWVudCIsImZpbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function get() {\n        return AmpStateContext;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar AmpStateContext = _react[\"default\"].createContext({});\nif (true) {\n    AmpStateContext.displayName = \"AmpStateContext\";\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQUVhQTs7O2VBQUFBOzs7OzBFQUZLO0FBRVgsSUFBTUEsa0JBQXNDQyxNQUFBQSxDQUFBQSxVQUFLLENBQUNDLGFBQWEsQ0FBQyxDQUFDO0FBRXhFLElBQUlDLElBQXlCLEVBQWM7SUFDekNILGdCQUFnQkksV0FBVyxHQUFHO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS50cz85NjQxIl0sIm5hbWVzIjpbIkFtcFN0YXRlQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-mode.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function get() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    var _ref = param === void 0 ? {} : param, _ref_ampFirst = _ref.ampFirst, ampFirst = _ref_ampFirst === void 0 ? false : _ref_ampFirst, _ref_hybrid = _ref.hybrid, hybrid = _ref_hybrid === void 0 ? false : _ref_hybrid, _ref_hasQuery = _ref.hasQuery, hasQuery = _ref_hasQuery === void 0 ? false : _ref_hasQuery;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtbW9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsWUFBWUMsS0FBQTtJQUFBLElBQUFBLE9BQUFBLFVBQUEsU0FJeEIsQ0FBQyxJQUp1QkEsdUJBQUFBLEtBQzFCQyxVQUFBQSxzQ0FBVyxxQ0FEZUQsS0FFMUJFLFFBQUFBLGtDQUFTLHFDQUZpQkYsS0FHMUJHLFVBQUFBLHNDQUFXO0lBRVgsT0FBT0YsWUFBYUMsVUFBVUM7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2FtcC1tb2RlLnRzP2NlMDQiXSwibmFtZXMiOlsiaXNJbkFtcE1vZGUiLCJwYXJhbSIsImFtcEZpcnN0IiwiaHlicmlkIiwiaGFzUXVlcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/get-img-props.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _object_without_properties = __webpack_require__(/*! @swc/helpers/_/_object_without_properties */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_without_properties.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nvar _to_consumable_array = __webpack_require__(/*! @swc/helpers/_/_to_consumable_array */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_to_consumable_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImgProps\", ({\n    enumerable: true,\n    get: function get() {\n        return getImgProps;\n    }\n}));\nvar _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nvar _imageblursvg = __webpack_require__(/*! ./image-blur-svg */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\");\nvar _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nvar VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src[\"default\"] !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nvar allImgs = new Map();\nvar perfObserver;\nfunction getInt(x) {\n    if (typeof x === \"undefined\") {\n        return x;\n    }\n    if (typeof x === \"number\") {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === \"string\" && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\nfunction getWidths(param, width, sizes) {\n    var deviceSizes = param.deviceSizes, allSizes = param.allSizes;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        var viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        var percentSizes = [];\n        for(var match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            var _Math;\n            var smallestRatio = (_Math = Math).min.apply(_Math, _to_consumable_array._(percentSizes)) * 0.01;\n            return {\n                widths: allSizes.filter(function(s) {\n                    return s >= deviceSizes[0] * smallestRatio;\n                }),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    var widths = _to_consumable_array._(new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n    // > blue colors. Showing a 3x resolution image in the app vs a 2x\n    // > resolution image will be visually the same, though the 3x image\n    // > takes significantly more data. Even true 3x resolution screens are\n    // > wasteful as the human eye cannot see that level of detail without\n    // > something like a magnifying glass.\n    // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n    [\n        width,\n        width * 2 /*, width * 3*/ \n    ].map(function(w) {\n        return allSizes.find(function(p) {\n            return p >= w;\n        }) || allSizes[allSizes.length - 1];\n    })));\n    return {\n        widths: widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs(param) {\n    var config = param.config, src = param.src, unoptimized = param.unoptimized, width = param.width, quality = param.quality, sizes = param.sizes, loader = param.loader;\n    if (unoptimized) {\n        return {\n            src: src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    var _getWidths = getWidths(config, width, sizes), widths = _getWidths.widths, kind = _getWidths.kind;\n    var last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map(function(w, i) {\n            return loader({\n                config: config,\n                src: src,\n                quality: quality,\n                width: w\n            }) + \" \" + (kind === \"w\" ? w : i + 1) + kind;\n        }).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config: config,\n            src: src,\n            quality: quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getImgProps(param, _state) {\n    var src = param.src, sizes = param.sizes, _param_unoptimized = param.unoptimized, unoptimized = _param_unoptimized === void 0 ? false : _param_unoptimized, _param_priority = param.priority, priority = _param_priority === void 0 ? false : _param_priority, loading = param.loading, className = param.className, quality = param.quality, width = param.width, height = param.height, _param_fill = param.fill, fill = _param_fill === void 0 ? false : _param_fill, style = param.style, overrideSrc = param.overrideSrc, onLoad = param.onLoad, onLoadingComplete = param.onLoadingComplete, _param_placeholder = param.placeholder, placeholder = _param_placeholder === void 0 ? \"empty\" : _param_placeholder, blurDataURL = param.blurDataURL, fetchPriority = param.fetchPriority, layout = param.layout, objectFit = param.objectFit, objectPosition = param.objectPosition, lazyBoundary = param.lazyBoundary, lazyRoot = param.lazyRoot, rest = _object_without_properties._(param, [\n        \"src\",\n        \"sizes\",\n        \"unoptimized\",\n        \"priority\",\n        \"loading\",\n        \"className\",\n        \"quality\",\n        \"width\",\n        \"height\",\n        \"fill\",\n        \"style\",\n        \"overrideSrc\",\n        \"onLoad\",\n        \"onLoadingComplete\",\n        \"placeholder\",\n        \"blurDataURL\",\n        \"fetchPriority\",\n        \"layout\",\n        \"objectFit\",\n        \"objectPosition\",\n        \"lazyBoundary\",\n        \"lazyRoot\"\n    ]);\n    var imgConf = _state.imgConf, showAltText = _state.showAltText, blurComplete = _state.blurComplete, defaultLoader = _state.defaultLoader;\n    var config;\n    var c = imgConf || _imageconfig.imageConfigDefault;\n    if (\"allSizes\" in c) {\n        config = c;\n    } else {\n        var allSizes = _to_consumable_array._(c.deviceSizes).concat(_to_consumable_array._(c.imageSizes)).sort(function(a, b) {\n            return a - b;\n        });\n        var deviceSizes = c.deviceSizes.sort(function(a, b) {\n            return a - b;\n        });\n        config = _object_spread_props._(_object_spread._({}, c), {\n            allSizes: allSizes,\n            deviceSizes: deviceSizes\n        });\n    }\n    if (typeof defaultLoader === \"undefined\") {\n        throw new Error(\"images.loaderFile detected but the file is missing default export.\\nRead more: https://nextjs.org/docs/messages/invalid-images-config\");\n    }\n    var loader = rest.loader || defaultLoader;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    delete rest.srcSet;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    var isDefaultLoader = \"__next_img_default\" in loader;\n    if (isDefaultLoader) {\n        if (config.loader === \"custom\") {\n            throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        var customImageLoader = loader;\n        loader = function(obj) {\n            var _ = obj.config, opts = _object_without_properties._(obj, [\n                \"config\"\n            ]);\n            return customImageLoader(opts);\n        };\n    }\n    if (layout) {\n        if (layout === \"fill\") {\n            fill = true;\n        }\n        var layoutToStyle = {\n            intrinsic: {\n                maxWidth: \"100%\",\n                height: \"auto\"\n            },\n            responsive: {\n                width: \"100%\",\n                height: \"auto\"\n            }\n        };\n        var layoutToSizes = {\n            responsive: \"100vw\",\n            fill: \"100vw\"\n        };\n        var layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = _object_spread._({}, style, layoutStyle);\n        }\n        var layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    var staticSrc = \"\";\n    var widthInt = getInt(width);\n    var heightInt = getInt(height);\n    var blurWidth;\n    var blurHeight;\n    if (isStaticImport(src)) {\n        var staticImageData = isStaticRequire(src) ? src[\"default\"] : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                var ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                var ratio1 = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio1);\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    var isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (!src || src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    if (priority) {\n        fetchPriority = \"high\";\n    }\n    var qualityInt = getInt(quality);\n    if (true) {\n        if (config.output === \"export\" && isDefaultLoader && !unoptimized) {\n            throw new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\");\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.');\n                }\n                if (height) {\n                    throw new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.');\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== \"absolute\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.');\n                }\n            } else {\n                if (typeof widthInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"width\" property.');\n                } else if (isNaN(widthInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".');\n                }\n                if (typeof heightInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"height\" property.');\n                } else if (isNaN(heightInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".');\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(\",\") + \".\");\n        }\n        if (priority && loading === \"lazy\") {\n            throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n        }\n        if (placeholder !== \"empty\" && placeholder !== \"blur\" && !placeholder.startsWith(\"data:image/\")) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"placeholder\" property \"' + placeholder + '\".');\n        }\n        if (placeholder !== \"empty\") {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.');\n            }\n        }\n        if (placeholder === \"blur\" && !blurDataURL) {\n            var VALID_BLUR_EXT = [\n                \"jpeg\",\n                \"png\",\n                \"webp\",\n                \"avif\"\n            ] // should match next-image-loader\n            ;\n            throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n        Possible solutions:\\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n          - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(\",\") + ' (animated images not supported)\\n          - Remove the \"placeholder\" property, effectively no blur effect\\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n        }\n        if (\"ref\" in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.');\n        }\n        if (!unoptimized && !isDefaultLoader) {\n            var urlStr = loader({\n                config: config,\n                src: src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            var url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (onLoadingComplete) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.');\n        }\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            for(var _iterator = Object.entries({\n                layout: layout,\n                objectFit: objectFit,\n                objectPosition: objectPosition,\n                lazyBoundary: lazyBoundary,\n                lazyRoot: lazyRoot\n            })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var _step_value = _sliced_to_array._(_step.value, 2), legacyKey = _step_value[0], legacyValue = _step_value[1];\n                if (legacyValue) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                    _iterator[\"return\"]();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n        if (typeof window !== \"undefined\" && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver(function(entryList) {\n                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n                try {\n                    for(var _iterator = entryList.getEntries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                        var entry = _step.value;\n                        var _entry_element;\n                        // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                        var imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || \"\";\n                        var lcpImage = allImgs.get(imgSrc);\n                        if (lcpImage && !lcpImage.priority && lcpImage.placeholder === \"empty\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                            // https://web.dev/lcp/#measure-lcp-in-javascript\n                            (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally{\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                            _iterator[\"return\"]();\n                        }\n                    } finally{\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: \"largest-contentful-paint\",\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    var imgStyle = Object.assign(fill ? {\n        position: \"absolute\",\n        height: \"100%\",\n        width: \"100%\",\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit: objectFit,\n        objectPosition: objectPosition\n    } : {}, showAltText ? {} : {\n        color: \"transparent\"\n    }, style);\n    var backgroundImage = !blurComplete && placeholder !== \"empty\" ? placeholder === \"blur\" ? 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n        widthInt: widthInt,\n        heightInt: heightInt,\n        blurWidth: blurWidth,\n        blurHeight: blurHeight,\n        blurDataURL: blurDataURL || \"\",\n        objectFit: imgStyle.objectFit\n    }) + '\")' : 'url(\"' + placeholder + '\")' // assume `data:image/`\n     : null;\n    var placeholderStyle = backgroundImage ? {\n        backgroundSize: imgStyle.objectFit || \"cover\",\n        backgroundPosition: imgStyle.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage: backgroundImage\n    } : {};\n    if (true) {\n        if (placeholderStyle.backgroundImage && placeholder === \"blur\" && (blurDataURL == null ? void 0 : blurDataURL.startsWith(\"/\"))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            placeholderStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    var imgAttributes = generateImgAttrs({\n        config: config,\n        src: src,\n        unoptimized: unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes: sizes,\n        loader: loader\n    });\n    if (true) {\n        if (typeof window !== \"undefined\") {\n            var fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src: src,\n                priority: priority,\n                placeholder: placeholder\n            });\n        }\n    }\n    var props = _object_spread_props._(_object_spread._({}, rest), {\n        loading: isLazy ? \"lazy\" : loading,\n        fetchPriority: fetchPriority,\n        width: widthInt,\n        height: heightInt,\n        decoding: \"async\",\n        className: className,\n        style: _object_spread._({}, imgStyle, placeholderStyle),\n        sizes: imgAttributes.sizes,\n        srcSet: imgAttributes.srcSet,\n        src: overrideSrc || imgAttributes.src\n    });\n    var meta = {\n        unoptimized: unoptimized,\n        priority: priority,\n        placeholder: placeholder,\n        fill: fill\n    };\n    return {\n        props: props,\n        meta: meta\n    };\n} //# sourceMappingURL=get-img-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OzsrQ0EyT2dCQTs7O2VBQUFBOzs7b0NBM09TO3dDQUNPO3VDQUNHO0FBNkVuQyxJQUFNQyx1QkFBdUI7SUFBQztJQUFRO0lBQVNDO0NBQVU7QUFrQnpELFNBQVNDLGdCQUNQQyxHQUFvQztJQUVwQyxPQUFPQSxHQUF1QkMsQ0FBQUEsVUFBTyxLQUFLSDtBQUM1QztBQUVBLFNBQVNJLGtCQUNQRixHQUFvQztJQUVwQyxPQUFPQSxJQUF5QkEsR0FBRyxLQUFLRjtBQUMxQztBQUVBLFNBQVNLLGVBQWVILEdBQTBCO0lBQ2hELE9BQ0UsT0FBT0EsUUFBUSxZQUNkRCxDQUFBQSxnQkFBZ0JDLFFBQ2ZFLGtCQUFrQkYsSUFBQUE7QUFFeEI7QUFFQSxJQUFNSSxVQUFVLElBQUlDO0FBSXBCLElBQUlDO0FBRUosU0FBU0MsT0FBT0MsQ0FBVTtJQUN4QixJQUFJLE9BQU9BLE1BQU0sYUFBYTtRQUM1QixPQUFPQTtJQUNUO0lBQ0EsSUFBSSxPQUFPQSxNQUFNLFVBQVU7UUFDekIsT0FBT0MsT0FBT0MsUUFBUSxDQUFDRixLQUFLQSxJQUFJRztJQUNsQztJQUNBLElBQUksT0FBT0gsTUFBTSxZQUFZLFdBQVdJLElBQUksQ0FBQ0osSUFBSTtRQUMvQyxPQUFPSyxTQUFTTCxHQUFHO0lBQ3JCO0lBQ0EsT0FBT0c7QUFDVDtBQUVBLFNBQVNHLFVBQ1BDLEtBQXNDLEVBQ3RDQyxLQUF5QixFQUN6QkMsS0FBeUI7SUFGekIsSUFBRUMsY0FBRkgsTUFBRUcsYUFBYUMsV0FBZkosTUFBZUk7SUFJZixJQUFJRixPQUFPO1FBQ1QseURBQXlEO1FBQ3pELElBQU1HLGtCQUFrQjtRQUN4QixJQUFNQyxlQUFlLEVBQUU7UUFDdkIsSUFBSyxJQUFJQyxPQUFRQSxRQUFRRixnQkFBZ0JHLElBQUksQ0FBQ04sUUFBU0ssTUFBTztZQUM1REQsYUFBYUcsSUFBSSxDQUFDWCxTQUFTUyxLQUFLLENBQUMsRUFBRTtRQUNyQztRQUNBLElBQUlELGFBQWFJLE1BQU0sRUFBRTtnQkFDREM7WUFBdEIsSUFBTUMsZ0JBQWdCRCxDQUFBQSxRQUFBQSxNQUFLRSxHQUFHLENBQVJGLE1BQUFBLE9BQVEsdUJBQUlMLGlCQUFnQjtZQUNsRCxPQUFPO2dCQUNMUSxRQUFRVixTQUFTVyxNQUFNLENBQUMsU0FBQ0M7MkJBQU1BLEtBQUtiLFdBQVcsQ0FBQyxFQUFFLEdBQUdTOztnQkFDckRLLE1BQU07WUFDUjtRQUNGO1FBQ0EsT0FBTztZQUFFSCxRQUFRVjtZQUFVYSxNQUFNO1FBQUk7SUFDdkM7SUFDQSxJQUFJLE9BQU9oQixVQUFVLFVBQVU7UUFDN0IsT0FBTztZQUFFYSxRQUFRWDtZQUFhYyxNQUFNO1FBQUk7SUFDMUM7SUFFQSxJQUFNSCxnQ0FDRCxJQUFJSSxJQUVMLHFFQUFxRTtJQUNyRSxrRUFBa0U7SUFDbEUsb0VBQW9FO0lBQ3BFLHVFQUF1RTtJQUN2RSxzRUFBc0U7SUFDdEUsdUNBQXVDO0lBQ3ZDLHFJQUFxSTtJQUNySTtRQUFDakI7UUFBT0EsUUFBUSxFQUFFLGFBQWE7S0FBRyxDQUFDa0IsR0FBRyxDQUNwQyxTQUFDQztlQUFNaEIsU0FBU2lCLElBQUksQ0FBQyxTQUFDQzttQkFBTUEsS0FBS0Y7Y0FBTWhCLFFBQVEsQ0FBQ0EsU0FBU00sTUFBTSxHQUFHLEVBQUU7O0lBSTFFLE9BQU87UUFBRUksUUFBQUE7UUFBUUcsTUFBTTtJQUFJO0FBQzdCO0FBa0JBLFNBQVNNLGlCQUFpQnZCLEtBUVI7SUFSUSxJQUN4QndCLFNBRHdCeEIsTUFDeEJ3QixRQUNBdkMsTUFGd0JlLE1BRXhCZixLQUNBd0MsY0FId0J6QixNQUd4QnlCLGFBQ0F4QixRQUp3QkQsTUFJeEJDLE9BQ0F5QixVQUx3QjFCLE1BS3hCMEIsU0FDQXhCLFFBTndCRixNQU14QkUsT0FDQXlCLFNBUHdCM0IsTUFPeEIyQjtJQUVBLElBQUlGLGFBQWE7UUFDZixPQUFPO1lBQUV4QyxLQUFBQTtZQUFLMkMsUUFBUTdDO1lBQVdtQixPQUFPbkI7UUFBVTtJQUNwRDtJQUVBLElBQXlCZ0IsYUFBQUEsVUFBVXlCLFFBQVF2QixPQUFPQyxRQUExQ1ksU0FBaUJmLFdBQWpCZSxRQUFRRyxPQUFTbEIsV0FBVGtCO0lBQ2hCLElBQU1ZLE9BQU9mLE9BQU9KLE1BQU0sR0FBRztJQUU3QixPQUFPO1FBQ0xSLE9BQU8sQ0FBQ0EsU0FBU2UsU0FBUyxNQUFNLFVBQVVmO1FBQzFDMEIsUUFBUWQsT0FDTEssR0FBRyxDQUNGLFNBQUNDLEdBQUdVO21CQUNGSCxPQUFVO2dCQUFFSCxRQUFBQTtnQkFBUXZDLEtBQUFBO2dCQUFLeUMsU0FBQUE7Z0JBQVN6QixPQUFPbUI7WUFBRSxLQUFHLE1BQzVDSCxDQUFBQSxTQUFTLE1BQU1HLElBQUlVLElBQUksS0FDdEJiO1dBRU5jLElBQUksQ0FBQztRQUVSLHVFQUF1RTtRQUN2RSxtRUFBbUU7UUFDbkUseUVBQXlFO1FBQ3pFLDBFQUEwRTtRQUMxRSwyQkFBMkI7UUFDM0Isc0RBQXNEO1FBQ3REOUMsS0FBSzBDLE9BQU87WUFBRUgsUUFBQUE7WUFBUXZDLEtBQUFBO1lBQUt5QyxTQUFBQTtZQUFTekIsT0FBT2EsTUFBTSxDQUFDZSxLQUFLO1FBQUM7SUFDMUQ7QUFDRjtBQUtPLFNBQVNoRCxZQUNkbUIsS0F3QmEsRUFDYmdDLE1BS0M7SUE5QkQsSUFDRS9DLE1BREZlLE1BQ0VmLEtBQ0FpQixRQUZGRixNQUVFRSw0QkFGRkYsTUFHRXlCLGFBQUFBLDhDQUFjLDhDQUhoQnpCLE1BSUVpQyxVQUFBQSx3Q0FBVyx5QkFDWEMsVUFMRmxDLE1BS0VrQyxTQUNBQyxZQU5GbkMsTUFNRW1DLFdBQ0FULFVBUEYxQixNQU9FMEIsU0FDQXpCLFFBUkZELE1BUUVDLE9BQ0FtQyxTQVRGcEMsTUFTRW9DLHNCQVRGcEMsTUFVRXFDLE1BQUFBLGdDQUFPLHFCQUNQQyxRQVhGdEMsTUFXRXNDLE9BQ0FDLGNBWkZ2QyxNQVlFdUMsYUFDQUMsU0FiRnhDLE1BYUV3QyxRQUNBQyxvQkFkRnpDLE1BY0V5Qyx3Q0FkRnpDLE1BZUUwQyxhQUFBQSw4Q0FBYyw4QkFDZEMsY0FoQkYzQyxNQWdCRTJDLGFBQ0FDLGdCQWpCRjVDLE1BaUJFNEMsZUFDQUMsU0FsQkY3QyxNQWtCRTZDLFFBQ0FDLFlBbkJGOUMsTUFtQkU4QyxXQUNBQyxpQkFwQkYvQyxNQW9CRStDLGdCQUNBQyxlQXJCRmhELE1BcUJFZ0QsY0FDQUMsV0F0QkZqRCxNQXNCRWlELFVBQ0dDLG9DQXZCTGxEO1FBQ0VmO1FBQ0FpQjtRQUNBdUI7UUFDQVE7UUFDQUM7UUFDQUM7UUFDQVQ7UUFDQXpCO1FBQ0FtQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQzs7SUFrQkYsSUFBUUUsVUFBc0RuQixPQUF0RG1CLFNBQVNDLGNBQTZDcEIsT0FBN0NvQixhQUFhQyxlQUFnQ3JCLE9BQWhDcUIsY0FBY0MsZ0JBQWtCdEIsT0FBbEJzQjtJQUM1QyxJQUFJOUI7SUFDSixJQUFJK0IsSUFBSUosV0FBV0ssYUFBQUEsa0JBQWtCO0lBQ3JDLElBQUksY0FBY0QsR0FBRztRQUNuQi9CLFNBQVMrQjtJQUNYLE9BQU87UUFDTCxJQUFNbkQsV0FBVyx1QkFBSW1ELEVBQUVwRCxXQUFXLGdDQUFLb0QsRUFBRUUsVUFBVSxHQUFFQyxJQUFJLENBQUMsU0FBQ0MsR0FBR0M7bUJBQU1ELElBQUlDOztRQUN4RSxJQUFNekQsY0FBY29ELEVBQUVwRCxXQUFXLENBQUN1RCxJQUFJLENBQUMsU0FBQ0MsR0FBR0M7bUJBQU1ELElBQUlDOztRQUNyRHBDLFNBQVMsNENBQUsrQjtZQUFHbkQsVUFBQUE7WUFBVUQsYUFBQUE7O0lBQzdCO0lBRUEsSUFBSSxPQUFPbUQsa0JBQWtCLGFBQWE7UUFDeEMsTUFBTSxJQUFJTyxNQUNSO0lBRUo7SUFDQSxJQUFJbEMsU0FBZ0N1QixLQUFLdkIsTUFBTSxJQUFJMkI7SUFFbkQsc0RBQXNEO0lBQ3RELE9BQU9KLEtBQUt2QixNQUFNO0lBQ2xCLE9BQU91QixLQUFjdEIsTUFBTTtJQUUzQiw2Q0FBNkM7SUFDN0Msb0RBQW9EO0lBQ3BELElBQU1rQyxrQkFBa0Isd0JBQXdCbkM7SUFFaEQsSUFBSW1DLGlCQUFpQjtRQUNuQixJQUFJdEMsT0FBT0csTUFBTSxLQUFLLFVBQVU7WUFDOUIsTUFBTSxJQUFJa0MsTUFDUixxQkFBbUI1RSxNQUFJLGdDQUNwQjtRQUVQO0lBQ0YsT0FBTztRQUNMLDhDQUE4QztRQUM5QywrQ0FBK0M7UUFDL0MsaURBQWlEO1FBQ2pELElBQU04RSxvQkFBb0JwQztRQUMxQkEsU0FBUyxTQUFDcUM7WUFDUixJQUFReEMsSUFBdUJ3QyxJQUF2QnhDLFFBQWMwQyxvQ0FBU0Y7Z0JBQXZCeEM7O1lBQ1IsT0FBT3VDLGtCQUFrQkc7UUFDM0I7SUFDRjtJQUVBLElBQUlyQixRQUFRO1FBQ1YsSUFBSUEsV0FBVyxRQUFRO1lBQ3JCUixPQUFPO1FBQ1Q7UUFDQSxJQUFNOEIsZ0JBQW9FO1lBQ3hFQyxXQUFXO2dCQUFFQyxVQUFVO2dCQUFRakMsUUFBUTtZQUFPO1lBQzlDa0MsWUFBWTtnQkFBRXJFLE9BQU87Z0JBQVFtQyxRQUFRO1lBQU87UUFDOUM7UUFDQSxJQUFNbUMsZ0JBQW9EO1lBQ3hERCxZQUFZO1lBQ1pqQyxNQUFNO1FBQ1I7UUFDQSxJQUFNbUMsY0FBY0wsYUFBYSxDQUFDdEIsT0FBTztRQUN6QyxJQUFJMkIsYUFBYTtZQUNmbEMsUUFBUSxxQkFBS0EsT0FBVWtDO1FBQ3pCO1FBQ0EsSUFBTUMsY0FBY0YsYUFBYSxDQUFDMUIsT0FBTztRQUN6QyxJQUFJNEIsZUFBZSxDQUFDdkUsT0FBTztZQUN6QkEsUUFBUXVFO1FBQ1Y7SUFDRjtJQUVBLElBQUlDLFlBQVk7SUFDaEIsSUFBSUMsV0FBV25GLE9BQU9TO0lBQ3RCLElBQUkyRSxZQUFZcEYsT0FBTzRDO0lBQ3ZCLElBQUl5QztJQUNKLElBQUlDO0lBQ0osSUFBSTFGLGVBQWVILE1BQU07UUFDdkIsSUFBTThGLGtCQUFrQi9GLGdCQUFnQkMsT0FBT0EsR0FBSUMsQ0FBQUEsVUFBTyxHQUFHRDtRQUU3RCxJQUFJLENBQUM4RixnQkFBZ0I5RixHQUFHLEVBQUU7WUFDeEIsTUFBTSxJQUFJNEUsTUFDUixnSkFBOEltQixLQUFLQyxTQUFTLENBQzFKRjtRQUdOO1FBQ0EsSUFBSSxDQUFDQSxnQkFBZ0IzQyxNQUFNLElBQUksQ0FBQzJDLGdCQUFnQjlFLEtBQUssRUFBRTtZQUNyRCxNQUFNLElBQUk0RCxNQUNSLDZKQUEySm1CLEtBQUtDLFNBQVMsQ0FDdktGO1FBR047UUFFQUYsWUFBWUUsZ0JBQWdCRixTQUFTO1FBQ3JDQyxhQUFhQyxnQkFBZ0JELFVBQVU7UUFDdkNuQyxjQUFjQSxlQUFlb0MsZ0JBQWdCcEMsV0FBVztRQUN4RCtCLFlBQVlLLGdCQUFnQjlGLEdBQUc7UUFFL0IsSUFBSSxDQUFDb0QsTUFBTTtZQUNULElBQUksQ0FBQ3NDLFlBQVksQ0FBQ0MsV0FBVztnQkFDM0JELFdBQVdJLGdCQUFnQjlFLEtBQUs7Z0JBQ2hDMkUsWUFBWUcsZ0JBQWdCM0MsTUFBTTtZQUNwQyxPQUFPLElBQUl1QyxZQUFZLENBQUNDLFdBQVc7Z0JBQ2pDLElBQU1NLFFBQVFQLFdBQVdJLGdCQUFnQjlFLEtBQUs7Z0JBQzlDMkUsWUFBWWpFLEtBQUt3RSxLQUFLLENBQUNKLGdCQUFnQjNDLE1BQU0sR0FBRzhDO1lBQ2xELE9BQU8sSUFBSSxDQUFDUCxZQUFZQyxXQUFXO2dCQUNqQyxJQUFNTSxTQUFRTixZQUFZRyxnQkFBZ0IzQyxNQUFNO2dCQUNoRHVDLFdBQVdoRSxLQUFLd0UsS0FBSyxDQUFDSixnQkFBZ0I5RSxLQUFLLEdBQUdpRjtZQUNoRDtRQUNGO0lBQ0Y7SUFDQWpHLE1BQU0sT0FBT0EsUUFBUSxXQUFXQSxNQUFNeUY7SUFFdEMsSUFBSVUsU0FDRixDQUFDbkQsWUFBYUMsQ0FBQUEsWUFBWSxVQUFVLE9BQU9BLFlBQVk7SUFDekQsSUFBSSxDQUFDakQsT0FBT0EsSUFBSW9HLFVBQVUsQ0FBQyxZQUFZcEcsSUFBSW9HLFVBQVUsQ0FBQyxVQUFVO1FBQzlELHVFQUF1RTtRQUN2RTVELGNBQWM7UUFDZDJELFNBQVM7SUFDWDtJQUNBLElBQUk1RCxPQUFPQyxXQUFXLEVBQUU7UUFDdEJBLGNBQWM7SUFDaEI7SUFDQSxJQUFJcUMsbUJBQW1CN0UsSUFBSXFHLFFBQVEsQ0FBQyxXQUFXLENBQUM5RCxPQUFPK0QsbUJBQW1CLEVBQUU7UUFDMUUseURBQXlEO1FBQ3pELCtDQUErQztRQUMvQzlELGNBQWM7SUFDaEI7SUFDQSxJQUFJUSxVQUFVO1FBQ1pXLGdCQUFnQjtJQUNsQjtJQUVBLElBQU00QyxhQUFhaEcsT0FBT2tDO0lBRTFCLElBQUkrRCxJQUF5QixFQUFjO1FBQ3pDLElBQUlqRSxPQUFPa0UsTUFBTSxLQUFLLFlBQVk1QixtQkFBbUIsQ0FBQ3JDLGFBQWE7WUFDakUsTUFBTSxJQUFJb0MsTUFDUDtRQU1MO1FBQ0EsSUFBSSxDQUFDNUUsS0FBSztZQUNSLGlEQUFpRDtZQUNqRCwrQ0FBK0M7WUFDL0MsMkNBQTJDO1lBQzNDd0MsY0FBYztRQUNoQixPQUFPO1lBQ0wsSUFBSVksTUFBTTtnQkFDUixJQUFJcEMsT0FBTztvQkFDVCxNQUFNLElBQUk0RCxNQUNSLHFCQUFtQjVFLE1BQUk7Z0JBRTNCO2dCQUNBLElBQUltRCxRQUFRO29CQUNWLE1BQU0sSUFBSXlCLE1BQ1IscUJBQW1CNUUsTUFBSTtnQkFFM0I7Z0JBQ0EsSUFBSXFELENBQUFBLFNBQUFBLE9BQUFBLEtBQUFBLElBQUFBLE1BQU9xRCxRQUFRLEtBQUlyRCxNQUFNcUQsUUFBUSxLQUFLLFlBQVk7b0JBQ3BELE1BQU0sSUFBSTlCLE1BQ1IscUJBQW1CNUUsTUFBSTtnQkFFM0I7Z0JBQ0EsSUFBSXFELENBQUFBLFNBQUFBLE9BQUFBLEtBQUFBLElBQUFBLE1BQU9yQyxLQUFLLEtBQUlxQyxNQUFNckMsS0FBSyxLQUFLLFFBQVE7b0JBQzFDLE1BQU0sSUFBSTRELE1BQ1IscUJBQW1CNUUsTUFBSTtnQkFFM0I7Z0JBQ0EsSUFBSXFELENBQUFBLFNBQUFBLE9BQUFBLEtBQUFBLElBQUFBLE1BQU9GLE1BQU0sS0FBSUUsTUFBTUYsTUFBTSxLQUFLLFFBQVE7b0JBQzVDLE1BQU0sSUFBSXlCLE1BQ1IscUJBQW1CNUUsTUFBSTtnQkFFM0I7WUFDRixPQUFPO2dCQUNMLElBQUksT0FBTzBGLGFBQWEsYUFBYTtvQkFDbkMsTUFBTSxJQUFJZCxNQUNSLHFCQUFtQjVFLE1BQUk7Z0JBRTNCLE9BQU8sSUFBSTJHLE1BQU1qQixXQUFXO29CQUMxQixNQUFNLElBQUlkLE1BQ1IscUJBQW1CNUUsTUFBSSxzRkFBbUZnQixRQUFNO2dCQUVwSDtnQkFDQSxJQUFJLE9BQU8yRSxjQUFjLGFBQWE7b0JBQ3BDLE1BQU0sSUFBSWYsTUFDUixxQkFBbUI1RSxNQUFJO2dCQUUzQixPQUFPLElBQUkyRyxNQUFNaEIsWUFBWTtvQkFDM0IsTUFBTSxJQUFJZixNQUNSLHFCQUFtQjVFLE1BQUksdUZBQW9GbUQsU0FBTztnQkFFdEg7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDdEQscUJBQXFCK0csUUFBUSxDQUFDM0QsVUFBVTtZQUMzQyxNQUFNLElBQUkyQixNQUNSLHFCQUFtQjVFLE1BQUksaURBQThDaUQsVUFBUSx3QkFBcUJwRCxxQkFBcUJxQyxHQUFHLENBQ3hIMkUsUUFDQS9ELElBQUksQ0FBQyxPQUFLO1FBRWhCO1FBQ0EsSUFBSUUsWUFBWUMsWUFBWSxRQUFRO1lBQ2xDLE1BQU0sSUFBSTJCLE1BQ1IscUJBQW1CNUUsTUFBSTtRQUUzQjtRQUNBLElBQ0V5RCxnQkFBZ0IsV0FDaEJBLGdCQUFnQixVQUNoQixDQUFDQSxZQUFZMkMsVUFBVSxDQUFDLGdCQUN4QjtZQUNBLE1BQU0sSUFBSXhCLE1BQ1IscUJBQW1CNUUsTUFBSSwyQ0FBd0N5RCxjQUFZO1FBRS9FO1FBQ0EsSUFBSUEsZ0JBQWdCLFNBQVM7WUFDM0IsSUFBSWlDLFlBQVlDLGFBQWFELFdBQVdDLFlBQVksTUFBTTtnQkFDeERtQixDQUFBQSxHQUFBQSxVQUFBQSxRQUFRLEVBQ04scUJBQW1COUcsTUFBSTtZQUUzQjtRQUNGO1FBQ0EsSUFBSXlELGdCQUFnQixVQUFVLENBQUNDLGFBQWE7WUFDMUMsSUFBTXFELGlCQUFpQjtnQkFBQztnQkFBUTtnQkFBTztnQkFBUTthQUFPLENBQUMsaUNBQWlDOztZQUV4RixNQUFNLElBQUluQyxNQUNSLHFCQUFtQjVFLE1BQUksNlRBR2tFK0csZUFBZWpFLElBQUksQ0FDeEcsT0FDQTtRQUlSO1FBQ0EsSUFBSSxTQUFTbUIsTUFBTTtZQUNqQjZDLENBQUFBLEdBQUFBLFVBQUFBLFFBQVEsRUFDTixxQkFBbUI5RyxNQUFJO1FBRTNCO1FBRUEsSUFBSSxDQUFDd0MsZUFBZSxDQUFDcUMsaUJBQWlCO1lBQ3BDLElBQU1tQyxTQUFTdEUsT0FBTztnQkFDcEJILFFBQUFBO2dCQUNBdkMsS0FBQUE7Z0JBQ0FnQixPQUFPMEUsWUFBWTtnQkFDbkJqRCxTQUFTOEQsY0FBYztZQUN6QjtZQUNBLElBQUlVO1lBQ0osSUFBSTtnQkFDRkEsTUFBTSxJQUFJQyxJQUFJRjtZQUNoQixFQUFFLE9BQU9HLEtBQUssQ0FBQztZQUNmLElBQUlILFdBQVdoSCxPQUFRaUgsT0FBT0EsSUFBSUcsUUFBUSxLQUFLcEgsT0FBTyxDQUFDaUgsSUFBSUksTUFBTSxFQUFHO2dCQUNsRVAsQ0FBQUEsR0FBQUEsVUFBQUEsUUFBUSxFQUNOLHFCQUFtQjlHLE1BQUksNEhBQ3BCO1lBRVA7UUFDRjtRQUVBLElBQUl3RCxtQkFBbUI7WUFDckJzRCxDQUFBQSxHQUFBQSxVQUFBQSxRQUFRLEVBQ04scUJBQW1COUcsTUFBSTtRQUUzQjtZQUVLOztZQUFMLFFBQUssWUFBa0NzSCxPQUFPQyxPQUFPLENBQUM7Z0JBQ3BEM0QsUUFBQUE7Z0JBQ0FDLFdBQUFBO2dCQUNBQyxnQkFBQUE7Z0JBQ0FDLGNBQUFBO2dCQUNBQyxVQUFBQTtZQUNGLHVCQU5LLHdHQU1EO2dCQU5DLHNEQUFPd0QsNEJBQVdDO2dCQU9yQixJQUFJQSxhQUFhO29CQUNmWCxDQUFBQSxHQUFBQSxVQUFBQSxRQUFRLEVBQ04scUJBQW1COUcsTUFBSSx3QkFBcUJ3SCxZQUFVLDBDQUNuRDtnQkFFUDtZQUNGOztZQWJLO1lBQUE7OztxQkFBQTtvQkFBQTs7O29CQUFBOzBCQUFBOzs7O1FBZUwsSUFDRSxPQUFPRSxXQUFXLGVBQ2xCLENBQUNwSCxnQkFDRG9ILE9BQU9DLG1CQUFtQixFQUMxQjtZQUNBckgsZUFBZSxJQUFJcUgsb0JBQW9CLFNBQUNDO29CQUNqQzs7b0JBQUwsUUFBSyxZQUFlQSxVQUFVQyxVQUFVLHVCQUFuQyx3R0FBdUM7d0JBQXZDLElBQU1DLFFBQU47NEJBRVlBO3dCQURmLDBFQUEwRTt3QkFDMUUsSUFBTUMsU0FBU0QsQ0FBQUEsU0FBQUEsT0FBQUEsS0FBQUEsSUFBQUEsQ0FBQUEsaUJBQUFBLE1BQU9FLE9BQU8scUJBQWRGLGVBQWdCOUgsR0FBRyxLQUFJO3dCQUN0QyxJQUFNaUksV0FBVzdILFFBQVE4SCxHQUFHLENBQUNIO3dCQUM3QixJQUNFRSxZQUNBLENBQUNBLFNBQVNqRixRQUFRLElBQ2xCaUYsU0FBU3hFLFdBQVcsS0FBSyxXQUN6QixDQUFDd0UsU0FBU2pJLEdBQUcsQ0FBQ29HLFVBQVUsQ0FBQyxZQUN6QixDQUFDNkIsU0FBU2pJLEdBQUcsQ0FBQ29HLFVBQVUsQ0FBQyxVQUN6Qjs0QkFDQSxpREFBaUQ7NEJBQ2pEVSxDQUFBQSxHQUFBQSxVQUFBQSxRQUFRLEVBQ04scUJBQW1CbUIsU0FBU2pJLEdBQUcsR0FBQyw4SEFDN0I7d0JBRVA7b0JBQ0Y7O29CQWpCSztvQkFBQTs7OzZCQUFBOzRCQUFBOzs7NEJBQUE7a0NBQUE7Ozs7WUFrQlA7WUFDQSxJQUFJO2dCQUNGTSxhQUFhNkgsT0FBTyxDQUFDO29CQUNuQkMsTUFBTTtvQkFDTkMsVUFBVTtnQkFDWjtZQUNGLEVBQUUsT0FBT2xCLEtBQUs7Z0JBQ1osb0NBQW9DO2dCQUNwQ21CLFFBQVFDLEtBQUssQ0FBQ3BCO1lBQ2hCO1FBQ0Y7SUFDRjtJQUNBLElBQU1xQixXQUFXbEIsT0FBT21CLE1BQU0sQ0FDNUJyRixPQUNJO1FBQ0VzRCxVQUFVO1FBQ1Z2RCxRQUFRO1FBQ1JuQyxPQUFPO1FBQ1AwSCxNQUFNO1FBQ05DLEtBQUs7UUFDTEMsT0FBTztRQUNQQyxRQUFRO1FBQ1JoRixXQUFBQTtRQUNBQyxnQkFBQUE7SUFDRixJQUNBLENBQUMsR0FDTEssY0FBYyxDQUFDLElBQUk7UUFBRTJFLE9BQU87SUFBYyxHQUMxQ3pGO0lBR0YsSUFBTTBGLGtCQUNKLENBQUMzRSxnQkFBZ0JYLGdCQUFnQixVQUM3QkEsZ0JBQWdCLFNBQ2QsMkNBQXlDdUYsQ0FBQUEsR0FBQUEsY0FBQUEsZUFBZSxFQUFDO1FBQ3ZEdEQsVUFBQUE7UUFDQUMsV0FBQUE7UUFDQUMsV0FBQUE7UUFDQUMsWUFBQUE7UUFDQW5DLGFBQWFBLGVBQWU7UUFDNUJHLFdBQVcyRSxTQUFTM0UsU0FBUztJQUMvQixLQUFHLE9BQ0gsVUFBUUosY0FBWSxLQUFJLHVCQUF1QjtPQUNqRDtJQUVOLElBQUl3RixtQkFBbUJGLGtCQUNuQjtRQUNFRyxnQkFBZ0JWLFNBQVMzRSxTQUFTLElBQUk7UUFDdENzRixvQkFBb0JYLFNBQVMxRSxjQUFjLElBQUk7UUFDL0NzRixrQkFBa0I7UUFDbEJMLGlCQUFBQTtJQUNGLElBQ0EsQ0FBQztJQUVMLElBQUl2QyxJQUF5QixFQUFlO1FBQzFDLElBQ0V5QyxpQkFBaUJGLGVBQWUsSUFDaEN0RixnQkFBZ0IsVUFDaEJDLENBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFlBQWEwQyxVQUFVLENBQUMsT0FDeEI7WUFDQSw4RUFBOEU7WUFDOUUsZ0ZBQWdGO1lBQ2hGLHFGQUFxRjtZQUNyRjZDLGlCQUFpQkYsZUFBZSxHQUFHLFVBQVFyRixjQUFZO1FBQ3pEO0lBQ0Y7SUFFQSxJQUFNMkYsZ0JBQWdCL0csaUJBQWlCO1FBQ3JDQyxRQUFBQTtRQUNBdkMsS0FBQUE7UUFDQXdDLGFBQUFBO1FBQ0F4QixPQUFPMEU7UUFDUGpELFNBQVM4RDtRQUNUdEYsT0FBQUE7UUFDQXlCLFFBQUFBO0lBQ0Y7SUFFQSxJQUFJOEQsSUFBeUIsRUFBYztRQUN6QyxJQUFJLE9BQU9rQixXQUFXLGFBQWE7WUFDakMsSUFBSTRCO1lBQ0osSUFBSTtnQkFDRkEsVUFBVSxJQUFJcEMsSUFBSW1DLGNBQWNySixHQUFHO1lBQ3JDLEVBQUUsT0FBT3VKLEdBQUc7Z0JBQ1ZELFVBQVUsSUFBSXBDLElBQUltQyxjQUFjckosR0FBRyxFQUFFMEgsT0FBTzhCLFFBQVEsQ0FBQ0MsSUFBSTtZQUMzRDtZQUNBckosUUFBUXNKLEdBQUcsQ0FBQ0osUUFBUUcsSUFBSSxFQUFFO2dCQUFFekosS0FBQUE7Z0JBQUtnRCxVQUFBQTtnQkFBVVMsYUFBQUE7WUFBWTtRQUN6RDtJQUNGO0lBRUEsSUFBTWtHLFFBQWtCLDRDQUNuQjFGO1FBQ0hoQixTQUFTa0QsU0FBUyxTQUFTbEQ7UUFDM0JVLGVBQUFBO1FBQ0EzQyxPQUFPMEU7UUFDUHZDLFFBQVF3QztRQUNSaUUsVUFBVTtRQUNWMUcsV0FBQUE7UUFDQUcsT0FBTyxxQkFBS21GLFVBQWFTO1FBQ3pCaEksT0FBT29JLGNBQWNwSSxLQUFLO1FBQzFCMEIsUUFBUTBHLGNBQWMxRyxNQUFNO1FBQzVCM0MsS0FBS3NELGVBQWUrRixjQUFjckosR0FBRzs7SUFFdkMsSUFBTTZKLE9BQU87UUFBRXJILGFBQUFBO1FBQWFRLFVBQUFBO1FBQVVTLGFBQUFBO1FBQWFMLE1BQUFBO0lBQUs7SUFDeEQsT0FBTztRQUFFdUcsT0FBQUE7UUFBT0UsTUFBQUE7SUFBSztBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvZ2V0LWltZy1wcm9wcy50cz9lYzkxIl0sIm5hbWVzIjpbImdldEltZ1Byb3BzIiwiVkFMSURfTE9BRElOR19WQUxVRVMiLCJ1bmRlZmluZWQiLCJpc1N0YXRpY1JlcXVpcmUiLCJzcmMiLCJkZWZhdWx0IiwiaXNTdGF0aWNJbWFnZURhdGEiLCJpc1N0YXRpY0ltcG9ydCIsImFsbEltZ3MiLCJNYXAiLCJwZXJmT2JzZXJ2ZXIiLCJnZXRJbnQiLCJ4IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJOYU4iLCJ0ZXN0IiwicGFyc2VJbnQiLCJnZXRXaWR0aHMiLCJwYXJhbSIsIndpZHRoIiwic2l6ZXMiLCJkZXZpY2VTaXplcyIsImFsbFNpemVzIiwidmlld3BvcnRXaWR0aFJlIiwicGVyY2VudFNpemVzIiwibWF0Y2giLCJleGVjIiwicHVzaCIsImxlbmd0aCIsIk1hdGgiLCJzbWFsbGVzdFJhdGlvIiwibWluIiwid2lkdGhzIiwiZmlsdGVyIiwicyIsImtpbmQiLCJTZXQiLCJtYXAiLCJ3IiwiZmluZCIsInAiLCJnZW5lcmF0ZUltZ0F0dHJzIiwiY29uZmlnIiwidW5vcHRpbWl6ZWQiLCJxdWFsaXR5IiwibG9hZGVyIiwic3JjU2V0IiwibGFzdCIsImkiLCJqb2luIiwiX3N0YXRlIiwicHJpb3JpdHkiLCJsb2FkaW5nIiwiY2xhc3NOYW1lIiwiaGVpZ2h0IiwiZmlsbCIsInN0eWxlIiwib3ZlcnJpZGVTcmMiLCJvbkxvYWQiLCJvbkxvYWRpbmdDb21wbGV0ZSIsInBsYWNlaG9sZGVyIiwiYmx1ckRhdGFVUkwiLCJmZXRjaFByaW9yaXR5IiwibGF5b3V0Iiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJsYXp5Qm91bmRhcnkiLCJsYXp5Um9vdCIsInJlc3QiLCJpbWdDb25mIiwic2hvd0FsdFRleHQiLCJibHVyQ29tcGxldGUiLCJkZWZhdWx0TG9hZGVyIiwiYyIsImltYWdlQ29uZmlnRGVmYXVsdCIsImltYWdlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJFcnJvciIsImlzRGVmYXVsdExvYWRlciIsImN1c3RvbUltYWdlTG9hZGVyIiwib2JqIiwiXyIsIm9wdHMiLCJsYXlvdXRUb1N0eWxlIiwiaW50cmluc2ljIiwibWF4V2lkdGgiLCJyZXNwb25zaXZlIiwibGF5b3V0VG9TaXplcyIsImxheW91dFN0eWxlIiwibGF5b3V0U2l6ZXMiLCJzdGF0aWNTcmMiLCJ3aWR0aEludCIsImhlaWdodEludCIsImJsdXJXaWR0aCIsImJsdXJIZWlnaHQiLCJzdGF0aWNJbWFnZURhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwicmF0aW8iLCJyb3VuZCIsImlzTGF6eSIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJxdWFsaXR5SW50IiwicHJvY2VzcyIsIm91dHB1dCIsInBvc2l0aW9uIiwiaXNOYU4iLCJpbmNsdWRlcyIsIlN0cmluZyIsIndhcm5PbmNlIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJ1cmwiLCJVUkwiLCJlcnIiLCJwYXRobmFtZSIsInNlYXJjaCIsIk9iamVjdCIsImVudHJpZXMiLCJsZWdhY3lLZXkiLCJsZWdhY3lWYWx1ZSIsIndpbmRvdyIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJlbnRyeUxpc3QiLCJnZXRFbnRyaWVzIiwiZW50cnkiLCJpbWdTcmMiLCJlbGVtZW50IiwibGNwSW1hZ2UiLCJnZXQiLCJvYnNlcnZlIiwidHlwZSIsImJ1ZmZlcmVkIiwiY29uc29sZSIsImVycm9yIiwiaW1nU3R5bGUiLCJhc3NpZ24iLCJsZWZ0IiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJjb2xvciIsImJhY2tncm91bmRJbWFnZSIsImdldEltYWdlQmx1clN2ZyIsInBsYWNlaG9sZGVyU3R5bGUiLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRQb3NpdGlvbiIsImJhY2tncm91bmRSZXBlYXQiLCJpbWdBdHRyaWJ1dGVzIiwiZnVsbFVybCIsImUiLCJsb2NhdGlvbiIsImhyZWYiLCJzZXQiLCJwcm9wcyIsImRlY29kaW5nIiwibWV0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_object_spread.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    \"default\": function _default1() {\n        return _default;\n    },\n    defaultHead: function defaultHead1() {\n        return defaultHead;\n    }\n});\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nvar _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\"));\nvar _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nvar _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nvar _ampmode = __webpack_require__(/*! ./amp-mode */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\");\nvar _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    var head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        })\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === \"string\" || typeof child === \"number\") {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react[\"default\"].Fragment) {\n        return list.concat(_react[\"default\"].Children.toArray(child.props.children).reduce(function(fragmentList, fragmentChild) {\n            if (typeof fragmentChild === \"string\" || typeof fragmentChild === \"number\") {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nvar METATYPES = [\n    \"name\",\n    \"httpEquiv\",\n    \"charSet\",\n    \"itemProp\"\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    var keys = new Set();\n    var tags = new Set();\n    var metaTypes = new Set();\n    var metaCategories = {};\n    return function(h) {\n        var isUnique = true;\n        var hasKey = false;\n        if (h.key && typeof h.key !== \"number\" && h.key.indexOf(\"$\") > 0) {\n            hasKey = true;\n            var key = h.key.slice(h.key.indexOf(\"$\") + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case \"title\":\n            case \"base\":\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case \"meta\":\n                for(var i = 0, len = METATYPES.length; i < len; i++){\n                    var metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === \"charSet\") {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        var category = h.props[metatype];\n                        var categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== \"name\" || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    var inAmpMode = props.inAmpMode;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map(function(c, i) {\n        var key = c.key || i;\n        if (false) { var newProps; }\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === \"script\" && c.props[\"type\"] !== \"application/ld+json\") {\n                var srcMessage = c.props[\"src\"] ? '<script> tag with src=\"' + c.props[\"src\"] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === \"link\" && c.props[\"rel\"] === \"stylesheet\") {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props[\"href\"] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react[\"default\"].cloneElement(c, {\n            key: key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    var children = param.children;\n    var ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    var headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect[\"default\"], {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nvar _default = Head;\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztRQXFNQUEsU0FBbUI7OztJQXhMSEM7aUJBQUFBOzs7Ozs7Ozt5REFUZ0JDLENBQUEsQ0FBQUMsbUJBQUFBLENBQUE7O3VDQUVKQSxtQkFBQUEsQ0FBQTs7QUFPckIsSUFBQUMsWUFBU0gsbUJBQUFBLENBQVlJLHFHQUFBQTtTQUFBQSxZQUFBQSxTQUFBQTtJQUMxQixJQUFBQSxjQUFhLFFBQUFBLFlBQUE7O21CQUFPQyxHQUFRLElBQUFDLFlBQUFDLEdBQUE7O1FBQVc7S0FDdkM7UUFDRUMsQ0FBQUEsV0FBUzthQUFPQyxJQUFBQSxDQUFLLGtCQUFBSCxZQUFBQyxHQUFBO1lBQVdHLE1BQUFBOztRQUNsQztJQUNBO0lBQ0YsT0FBQUY7QUFFQTtTQUlFRyxpQkFBQUMsSUFBQSxFQUFBQyxLQUFBO0lBQ0EsOEZBQTREO1FBQzFELE9BQU9ELFVBQUFBLFlBQUFBLE9BQUFBLFVBQUFBLFVBQUFBO1FBQ1QsT0FBQUE7SUFDQTtJQUNBLGtDQUF5QkU7UUFDdkJELE1BQUFFLElBQU9ILEtBQUtJLE1BQ1ZDLENBQUFBLFVBQUEsQ0FBQUgsUUFBQTtRQUNBSSxPQUFBQSxLQUFBQSxNQUFNQyxDQUVKQyxNQUNFQyxDQUFBQSxVQUFBQSxDQUNBQyxRQUFBQSxDQUFBQSxPQUFBQSxDQUFBQSxNQUFBQSxLQUFBQSxDQUFBQSxRQUFBQSxFQUFBQSxNQUFBQSx3QkFHU0E7Z0JBR1AsT0FBT0Qsa0JBQUFBLFlBQUFBLE9BQUFBLGtCQUFBQSxVQUFBQTtnQkFDVCxPQUFBQTtZQUNBO1lBRUYsT0FBRUEsYUFBQUwsTUFBQSxDQUFBTTtRQUdSO0lBQ0E7SUFDRixPQUFBVixLQUFBSSxNQUFBLENBQUFIO0FBRUE7SUFBbUJVLFlBQUE7SUFBUTtJQUFhO0lBQVc7SUFBVztDQUU5RDs7Ozs7WUFNUUM7SUFDTixJQUFNQyxPQUFPLElBQUlDO0lBQ2pCLElBQU1DLE9BQUFBLElBQUFBO0lBQ04sSUFBTUMsWUFBQUEsSUFBQUE7SUFFTixJQUFBQSxpQkFBUUMsQ0FBQUE7V0FDTixTQUFJQztRQUNKLElBQUlDLFdBQVM7UUFFYixJQUFJRixTQUFTO1lBQ1hFLEVBQUFBLEdBQUFBLElBQVMsT0FBQUYsRUFBQUcsR0FBQSxpQkFBQUgsRUFBQUcsR0FBQSxDQUFBQyxPQUFBO1lBQ1RGLFNBQU1DO1lBQ04sSUFBSVIsTUFBUUssRUFBQ0csR0FBQUEsQ0FBQUEsS0FBTSxDQUFBSCxFQUFBRyxHQUFBLENBQUFDLE9BQUE7Z0JBQ2pCSCxLQUFBQSxHQUFBQSxDQUFBQSxNQUFXO2dCQUNiQSxXQUFPO21CQUNMTjtnQkFDRkEsS0FBQVUsR0FBQSxDQUFBRjtZQUNGO1FBRUE7UUFDQSx3Q0FBYztlQUNaSCxFQUFLZCxJQUFBO1lBQ0wsS0FBSztpQkFDSDtvQkFDRWUsS0FBQUEsR0FBQUEsQ0FBQUEsRUFBV2YsSUFBQTtvQkFDYmUsV0FBTzt1QkFDTEw7b0JBQ0ZBLEtBQUFTLEdBQUEsQ0FBQUwsRUFBQWQsSUFBQTtnQkFDQTtnQkFDRjtpQkFDRTtvQkFDRSxJQUFBb0IsSUFBTUMsR0FBQUEsTUFBV2IsVUFBVVksTUFBRSxFQUFBQSxJQUFBRSxLQUFBRixJQUFBO29CQUM3QixJQUFLTixXQUFRUyxTQUFBQSxDQUFjSCxFQUFDQztvQkFFNUIsSUFBSUEsQ0FBQUEsRUFBQUEsS0FBQUEsQ0FBQUEsY0FBYSxDQUFXQSxXQUFBO3dCQUMxQkEsYUFBSVQsV0FBY1M7NEJBQ2hCTixVQUFBQSxHQUFXLENBQUFNLFdBQUE7NEJBQ2JOLFdBQU87K0JBQ0xIOzRCQUNGQSxVQUFBTyxHQUFBLENBQUFFO3dCQUNGOzJCQUNFO3dCQUNBLElBQU1HLFdBQUFBLEVBQWFYLEtBQUFBLENBQUFBLFNBQWVRO3dCQUNsQyxJQUFLQSxhQUFhUixjQUFXRyxDQUFBQSxTQUFXUSxJQUFBQSxJQUFXQzs0QkFDakRWLENBQUFBLGFBQVcsV0FBQUMsTUFBQSxLQUFBUSxXQUFBQyxHQUFBLENBQUFDLFdBQUE7NEJBQ2JYLFdBQU87K0JBQ0xTOzRCQUNBWCxXQUFBQSxHQUFjLENBQUNROzRCQUNqQlIsY0FBQSxDQUFBUSxTQUFBLEdBQUFHO3dCQUNGO29CQUNGO2dCQUNBO2dCQUNKO1FBRUE7UUFDRixPQUFBVDtJQUNGO0FBRUE7Ozs7SUFRRSxTQUFRMUIsaUJBQWNzQyxvQkFBQUEsRUFBQUEsS0FBQUE7SUFDdEIsZ0JBQU9DLE1BQUFBO1dBT0hBLHFCQUFxQlIsTUFBQUEsQ0FBQUEsa0JBQUFBLEVBQUFBLEVBQUFBLE9BQUFBLEdBQUFBLE1BQUFBLENBQUFBLFlBQUFBLFdBQUFBLE9BQUFBLElBQUFBLE1BQUFBLENBQUFBLFVBQUFBLE9BQUFBLEdBQUFBLEdBQUFBLENBQUFBLFNBQUFBLEdBQUFBO1FBQ3JCLElBQ0VTLE1BQVFDLEVBQUFBLEdBQUlDLElBQUFBO1lBSVpGLEtBR0V4QyxFQUFBLGlCQWVKO1lBQ0V3QyxJQUFBO1lBQ0EseURBQStDO2dCQUM3Q0csRUFBQWhDLElBQU13QyxLQUFBQSxZQUFlYixFQUFBQSxLQUFNLFFBQ3RCLDRCQUEyQkE7Z0JBRWhDYyxJQUFBQSxhQUFBQSxFQUFBQSxLQUNHLHNDQUFBVCxFQUFBTCxLQUFBLE9BQWdEYSxHQUFBQSxNQUFBQTtnQkFFckQsSUFBT3BELFVBQVVxRCxRQUFLLHFEQUEyQ0QsYUFBQTttQkFDL0RDLElBQUFBLEVBQUFBLElBQUFBLEtBQUFBLFVBQ0dULEVBQUFMLEtBQUE7Z0JBRUwsSUFBQXZDLFVBQUFxRCxRQUFBLDBGQUFBVCxFQUFBTCxLQUFBO1lBQ0Y7UUFDQTtlQUErQlYsV0FBQUEsR0FBQUEsTUFBQUEsQ0FBQUEsVUFBQUEsQ0FBQUEsWUFBQUEsQ0FBQUEsR0FBQUE7WUFBSUEsS0FBQUE7UUFDckM7SUFDSjtBQUVBOzs7O0lBSWMsU0FBRXlCLEtBQVFDLEtBQVY7SUFDWixlQUFpQkUsTUFBWEQ7SUFDTixJQUFNRSxXQUFBQSxDQUFBQSxHQUFjRCxPQUFBQSxVQUFBQSxFQUFBQSx5QkFBV0UsZUFBQUE7SUFDL0IsSUFBQUQsY0FBQSxDQUNFLEdBQUF6QyxPQUFBd0MsVUFBQSxFQUFDRyxpQ0FBTUQsa0JBQUE7V0FDTEUsV0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsWUFBeUJDLEdBQUFBLEVBQUFBLFdBQUFBLENBQUFBLFVBQUFBLEVBQUFBO1FBQ3pCSix5QkFBYUE7UUFDYnpELGFBQVc4RDttQkFFVlQsQ0FBQUEsR0FBQUEsU0FBQUEsV0FBQUEsRUFBQUE7O0lBR1A7O0tBWmdCQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvaGVhZC50c3g/MzY3MCJdLCJuYW1lcyI6WyJleHBvcnRzIiwiZGVmYXVsdEhlYWQiLCJfIiwicmVxdWlyZSIsIl93YXJub25jZSIsImluQW1wTW9kZSIsImNoYXJTZXQiLCJfanN4cnVudGltZSIsImpzeCIsImhlYWQiLCJuYW1lIiwiY29udGVudCIsIm9ubHlSZWFjdEVsZW1lbnQiLCJsaXN0IiwiY2hpbGQiLCJGcmFnbWVudCIsInR5cGUiLCJjb25jYXQiLCJkZWZhdWx0IiwiUmVhY3QiLCJDaGlsZHJlbiIsIl9yZWFjdCIsImZyYWdtZW50TGlzdCIsImZyYWdtZW50Q2hpbGQiLCJNRVRBVFlQRVMiLCJrZXlzIiwidGFncyIsIlNldCIsIm1ldGFUeXBlcyIsIm1ldGFDYXRlZ29yaWVzIiwiaCIsImlzVW5pcXVlIiwiaGFzS2V5Iiwia2V5IiwiaW5kZXhPZiIsImFkZCIsImkiLCJtZXRhdHlwZSIsImxlbiIsImhhc093blByb3BlcnR5IiwiY2F0ZWdvcmllcyIsImhhcyIsImNhdGVnb3J5IiwicHJvcHMiLCJoZWFkQ2hpbGRyZW5FbGVtZW50cyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImMiLCJfX05FWFRfT1BUSU1JWkVfRk9OVFMiLCJzb21lIiwidXJsIiwibmV3UHJvcHMiLCJzdGFydHNXaXRoIiwidW5kZWZpbmVkIiwiY2xvbmVFbGVtZW50Iiwic3JjTWVzc2FnZSIsIndhcm5PbmNlIiwiY2hpbGRyZW4iLCJwYXJhbSIsImFtcFN0YXRlIiwidXNlQ29udGV4dCIsImhlYWRNYW5hZ2VyIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiRWZmZWN0IiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJyZWR1Y2VDb21wb25lbnRzIiwiaXNJbkFtcE1vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function get() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    var widthInt = param.widthInt, heightInt = param.heightInt, blurWidth = param.blurWidth, blurHeight = param.blurHeight, blurDataURL = param.blurDataURL, objectFit = param.objectFit;\n    var std = 20;\n    var svgWidth = blurWidth ? blurWidth * 40 : widthInt;\n    var svgHeight = blurHeight ? blurHeight * 40 : heightInt;\n    var viewBox = svgWidth && svgHeight ? \"viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'\" : \"\";\n    var preserveAspectRatio = viewBox ? \"none\" : objectFit === \"contain\" ? \"xMidYMid\" : objectFit === \"cover\" ? \"xMidYMid slice\" : \"none\";\n    return \"%3Csvg xmlns='http://www.w3.org/2000/svg' \" + viewBox + \"%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='\" + preserveAspectRatio + \"' style='filter: url(%23b);' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQzs7OzttREFDZUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsZ0JBQWdCQyxLQWMvQjtJQWQrQixJQUM5QkMsV0FEOEJELE1BQzlCQyxVQUNBQyxZQUY4QkYsTUFFOUJFLFdBQ0FDLFlBSDhCSCxNQUc5QkcsV0FDQUMsYUFKOEJKLE1BSTlCSSxZQUNBQyxjQUw4QkwsTUFLOUJLLGFBQ0FDLFlBTjhCTixNQU05Qk07SUFTQSxJQUFNQyxNQUFNO0lBQ1osSUFBTUMsV0FBV0wsWUFBWUEsWUFBWSxLQUFLRjtJQUM5QyxJQUFNUSxZQUFZTCxhQUFhQSxhQUFhLEtBQUtGO0lBRWpELElBQU1RLFVBQ0pGLFlBQVlDLFlBQVksa0JBQWdCRCxXQUFTLE1BQUdDLFlBQVUsTUFBSztJQUNyRSxJQUFNRSxzQkFBc0JELFVBQ3hCLFNBQ0FKLGNBQWMsWUFDZCxhQUNBQSxjQUFjLFVBQ2QsbUJBQ0E7SUFFSixPQUFPLCtDQUE2Q0ksVUFBUSw4RkFBMkZILE1BQUksb1FBQWlRQSxNQUFJLGdHQUE2Rkksc0JBQW9CLHdDQUFxQ04sY0FBWTtBQUNwa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWJsdXItc3ZnLnRzP2M3OWMiXSwibmFtZXMiOlsiZ2V0SW1hZ2VCbHVyU3ZnIiwicGFyYW0iLCJ3aWR0aEludCIsImhlaWdodEludCIsImJsdXJXaWR0aCIsImJsdXJIZWlnaHQiLCJibHVyRGF0YVVSTCIsIm9iamVjdEZpdCIsInN0ZCIsInN2Z1dpZHRoIiwic3ZnSGVpZ2h0Iiwidmlld0JveCIsInByZXNlcnZlQXNwZWN0UmF0aW8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ImageConfigContext\", ({\n    enumerable: true,\n    get: function get() {\n        return ImageConfigContext;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nvar ImageConfigContext = _react[\"default\"].createContext(_imageconfig.imageConfigDefault);\nif (true) {\n    ImageConfigContext.displayName = \"ImageConfigContext\";\n} //# sourceMappingURL=image-config-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O3NEQUlhQTs7O2VBQUFBOzs7OzBFQUpLO3VDQUVpQjtBQUU1QixJQUFNQSxxQkFDWEMsTUFBQUEsQ0FBQUEsVUFBSyxDQUFDQyxhQUFhLENBQXNCQyxhQUFBQSxrQkFBa0I7QUFFN0QsSUFBSUMsSUFBeUIsRUFBYztJQUN6Q0osbUJBQW1CSyxXQUFXLEdBQUc7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzPzNkNzUiXSwibmFtZXMiOlsiSW1hZ2VDb25maWdDb250ZXh0IiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwiaW1hZ2VDb25maWdEZWZhdWx0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    VALID_LOADERS: function VALID_LOADERS1() {\n        return VALID_LOADERS;\n    },\n    imageConfigDefault: function imageConfigDefault1() {\n        return imageConfigDefault;\n    }\n});\nvar VALID_LOADERS = [\n    \"default\",\n    \"imgix\",\n    \"cloudinary\",\n    \"akamai\",\n    \"custom\"\n];\nvar imageConfigDefault = {\n    deviceSizes: [\n        640,\n        750,\n        828,\n        1080,\n        1200,\n        1920,\n        2048,\n        3840\n    ],\n    imageSizes: [\n        16,\n        32,\n        48,\n        64,\n        96,\n        128,\n        256,\n        384\n    ],\n    path: \"/_next/image\",\n    loader: \"default\",\n    loaderFile: \"\",\n    domains: [],\n    disableStaticImages: false,\n    minimumCacheTTL: 60,\n    formats: [\n        \"image/webp\"\n    ],\n    dangerouslyAllowSVG: false,\n    contentSecurityPolicy: \"script-src 'none'; frame-src 'none'; sandbox;\",\n    contentDispositionType: \"inline\",\n    remotePatterns: [],\n    unoptimized: false\n}; //# sourceMappingURL=image-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBQWFBLGVBQWEsU0FBYkE7ZUFBQUE7O0lBc0dBQyxvQkFBa0IsU0FBbEJBO2VBQUFBOzs7QUF0R04sSUFBTUQsZ0JBQWdCO0lBQzNCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQWdHTSxJQUFNQyxxQkFBMEM7SUFDckRDLGFBQWE7UUFBQztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO0tBQUs7SUFDMURDLFlBQVk7UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSztRQUFLO0tBQUk7SUFDL0NDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLFNBQVMsRUFBRTtJQUNYQyxxQkFBcUI7SUFDckJDLGlCQUFpQjtJQUNqQkMsU0FBUztRQUFDO0tBQWE7SUFDdkJDLHFCQUFxQjtJQUNyQkMsdUJBQXdCO0lBQ3hCQyx3QkFBd0I7SUFDeEJDLGdCQUFnQixFQUFFO0lBQ2xCQyxhQUFhO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy50cz8xMzRhIl0sIm5hbWVzIjpbIlZBTElEX0xPQURFUlMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJkZXZpY2VTaXplcyIsImltYWdlU2l6ZXMiLCJwYXRoIiwibG9hZGVyIiwibG9hZGVyRmlsZSIsImRvbWFpbnMiLCJkaXNhYmxlU3RhdGljSW1hZ2VzIiwibWluaW11bUNhY2hlVFRMIiwiZm9ybWF0cyIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJjb250ZW50U2VjdXJpdHlQb2xpY3kiLCJjb250ZW50RGlzcG9zaXRpb25UeXBlIiwicmVtb3RlUGF0dGVybnMiLCJ1bm9wdGltaXplZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-external.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    \"default\": function _default1() {\n        return _default;\n    },\n    getImageProps: function getImageProps1() {\n        return getImageProps;\n    }\n});\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _getimgprops = __webpack_require__(/*! ./get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nvar _imagecomponent = __webpack_require__(/*! ../../client/image-component */ \"(app-pages-browser)/./node_modules/next/dist/client/image-component.js\");\nvar _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\nfunction getImageProps(imgProps) {\n    var props = (0, _getimgprops.getImgProps)(imgProps, {\n        defaultLoader: _imageloader[\"default\"],\n        // This is replaced by webpack define plugin\n        imgConf: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]}\n    }).props;\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        // Normally we don't care about undefined props because we pass to JSX,\n        // but this exported function could be used by the end user for anything\n        // so we delete undefined props to clean it up a little.\n        for(var _iterator = Object.entries(props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var _step_value = _sliced_to_array._(_step.value, 2), key = _step_value[0], value = _step_value[1];\n            if (value === undefined) {\n                delete props[key];\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                _iterator[\"return\"]();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    return {\n        props: props\n    };\n}\nvar _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0lBaUNBQSxXQUFvQixTQUFwQkE7ZUFBQUM7O0lBakJnQkMsZUFBYSxTQUFiQTtlQUFBQTs7Ozt1Q0FiWTswQ0FDTjtnRkFHSTtBQVNuQixTQUFTQSxjQUFjQyxRQUFvQjtJQUNoRCxJQUFNLFFBQVlFLENBQUFBLEdBQUFBLGFBQUFBLFdBQVcsRUFBQ0YsVUFBVTtRQUN0Q0csZUFBQUEsWUFBQUEsQ0FBQUEsVUFBYTtRQUNiLDRDQUE0QztRQUM1Q0MsU0FBU0MsME5BQTZCO0lBQ3hDLEdBSlFKO1FBUUg7O1FBSEwsdUVBQXVFO1FBQ3ZFLHdFQUF3RTtRQUN4RSx3REFBd0Q7UUFDeEQsUUFBSyxZQUFzQk8sT0FBT0MsT0FBTyxDQUFDUiwyQkFBckMsd0dBQTZDO1lBQTdDLHNEQUFPUyxzQkFBS0M7WUFDZixJQUFJQSxVQUFVQyxXQUFXO2dCQUN2QixPQUFPWCxLQUFLLENBQUNTLElBQTBCO1lBQ3pDO1FBQ0Y7O1FBSks7UUFBQTs7O2lCQUFBO2dCQUFBOzs7Z0JBQUE7c0JBQUE7Ozs7SUFLTCxPQUFPO1FBQUVULE9BQUFBO0lBQU07QUFDakI7SUFFQUgsV0FBZWUsZ0JBQUFBLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWV4dGVybmFsLnRzeD8zODI2Il0sIm5hbWVzIjpbImRlZmF1bHQiLCJfZGVmYXVsdCIsImdldEltYWdlUHJvcHMiLCJpbWdQcm9wcyIsInByb3BzIiwiZ2V0SW1nUHJvcHMiLCJkZWZhdWx0TG9hZGVyIiwiaW1nQ29uZiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSU1BR0VfT1BUUyIsIk9iamVjdCIsImVudHJpZXMiLCJrZXkiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsIkltYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-loader.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return _default;\n    }\n}));\nfunction defaultLoader(param) {\n    var config = param.config, src = param.src, width = param.width, quality = param.quality;\n    if (true) {\n        var missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push(\"src\");\n        if (!width) missingValues.push(\"width\");\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(\", \") + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src: src,\n                width: width,\n                quality: quality\n            }));\n        }\n        if (src.startsWith(\"//\")) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (!src.startsWith(\"/\") && (config.domains || config.remotePatterns)) {\n            var parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                var hasMatch = (__webpack_require__(/*! ./match-remote-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\").hasMatch);\n                if (!hasMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n    }\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + (quality || 75) + ( false ? 0 : \"\");\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nvar _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7OzsyQ0F3RUE7OztlQUFBQTs7O0FBdEVBLFNBQVNDLGNBQWNDLEtBS007SUFMTixJQUNyQkMsU0FEcUJELE1BQ3JCQyxRQUNBQyxNQUZxQkYsTUFFckJFLEtBQ0FDLFFBSHFCSCxNQUdyQkcsT0FDQUMsVUFKcUJKLE1BSXJCSTtJQUVBLElBQUlDLElBQXlCLEVBQWM7UUFDekMsSUFBTUMsZ0JBQWdCLEVBQUU7UUFFeEIseURBQXlEO1FBQ3pELElBQUksQ0FBQ0osS0FBS0ksY0FBY0MsSUFBSSxDQUFDO1FBQzdCLElBQUksQ0FBQ0osT0FBT0csY0FBY0MsSUFBSSxDQUFDO1FBRS9CLElBQUlELGNBQWNFLE1BQU0sR0FBRyxHQUFHO1lBQzVCLE1BQU0sSUFBSUMsTUFDUixzQ0FBb0NILGNBQWNJLElBQUksQ0FDcEQsUUFDQSxnR0FBK0ZDLEtBQUtDLFNBQVMsQ0FDN0c7Z0JBQUVWLEtBQUFBO2dCQUFLQyxPQUFBQTtnQkFBT0MsU0FBQUE7WUFBUTtRQUc1QjtRQUVBLElBQUlGLElBQUlXLFVBQVUsQ0FBQyxPQUFPO1lBQ3hCLE1BQU0sSUFBSUosTUFDUiwwQkFBd0JQLE1BQUk7UUFFaEM7UUFFQSxJQUFJLENBQUNBLElBQUlXLFVBQVUsQ0FBQyxRQUFTWixDQUFBQSxPQUFPYSxPQUFPLElBQUliLE9BQU9jLGNBQWMsR0FBRztZQUNyRSxJQUFJQztZQUNKLElBQUk7Z0JBQ0ZBLFlBQVksSUFBSUMsSUFBSWY7WUFDdEIsRUFBRSxPQUFPZ0IsS0FBSztnQkFDWkMsUUFBUUMsS0FBSyxDQUFDRjtnQkFDZCxNQUFNLElBQUlULE1BQ1IsMEJBQXdCUCxNQUFJO1lBRWhDO1lBRUEsSUFDRUcsSUFFNkIsRUFDN0I7Z0JBQ0EsdUVBQXVFO2dCQUN2RSxJQUFNLFdBQWVtQiwrSUFBYkQ7Z0JBQ1IsSUFBSSxDQUFDQSxTQUFTdEIsT0FBT2EsT0FBTyxFQUFFYixPQUFPYyxjQUFjLEVBQUVDLFlBQVk7b0JBQy9ELE1BQU0sSUFBSVAsTUFDUix1QkFBcUJQLE1BQUksa0NBQWlDYyxVQUFVUyxRQUFRLEdBQUMsZ0VBQzFFO2dCQUVQO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsT0FBT3hCLE9BQVV5QixJQUFJLEdBQUMsVUFBT0MsbUJBQW1CekIsT0FBSyxRQUFLQyxRQUFNLFFBQzlEQyxDQUFBQSxXQUFXLE1BRVhDLENBQUFBLE1BQThCLEdBQzFCLENBQXNDLEdBQ3RDO0FBRVI7QUFFQSwrREFBK0Q7QUFDL0QsMkRBQTJEO0FBQzNETixjQUFjOEIsa0JBQWtCLEdBQUc7SUFFbkMvQixXQUFlQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyLnRzP2QyODAiXSwibmFtZXMiOlsiX2RlZmF1bHQiLCJkZWZhdWx0TG9hZGVyIiwicGFyYW0iLCJjb25maWciLCJzcmMiLCJ3aWR0aCIsInF1YWxpdHkiLCJwcm9jZXNzIiwibWlzc2luZ1ZhbHVlcyIsInB1c2giLCJsZW5ndGgiLCJFcnJvciIsImpvaW4iLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhcnRzV2l0aCIsImRvbWFpbnMiLCJyZW1vdGVQYXR0ZXJucyIsInBhcnNlZFNyYyIsIlVSTCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsImVudiIsIk5FWFRfUlVOVElNRSIsImhhc01hdGNoIiwicmVxdWlyZSIsImhvc3RuYW1lIiwicGF0aCIsImVuY29kZVVSSUNvbXBvbmVudCIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsIl9fbmV4dF9pbWdfZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasMatch: function hasMatch1() {\n        return hasMatch;\n    },\n    matchRemotePattern: function matchRemotePattern1() {\n        return matchRemotePattern;\n    }\n});\nvar _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        var actualProto = url.protocol.slice(0, -1);\n        if (pattern.protocol !== actualProto) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern));\n    } else {\n        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : \"**\", {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasMatch(domains, remotePatterns, url) {\n    return domains.some(function(domain) {\n        return url.hostname === domain;\n    }) || remotePatterns.some(function(p) {\n        return matchRemotePattern(p, url);\n    });\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFpQ2dCQSxVQUFRLFNBQVJBO2VBQUFBOztJQTlCQUMsb0JBQWtCLFNBQWxCQTtlQUFBQTs7O3FDQUZPO0FBRWhCLFNBQVNBLG1CQUFtQkMsT0FBc0IsRUFBRUMsR0FBUTtJQUNqRSxJQUFJRCxRQUFRRSxRQUFRLEtBQUtDLFdBQVc7UUFDbEMsSUFBTUMsY0FBY0gsSUFBSUMsUUFBUSxDQUFDRyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQzNDLElBQUlMLFFBQVFFLFFBQVEsS0FBS0UsYUFBYTtZQUNwQyxPQUFPO1FBQ1Q7SUFDRjtJQUNBLElBQUlKLFFBQVFNLElBQUksS0FBS0gsV0FBVztRQUM5QixJQUFJSCxRQUFRTSxJQUFJLEtBQUtMLElBQUlLLElBQUksRUFBRTtZQUM3QixPQUFPO1FBQ1Q7SUFDRjtJQUVBLElBQUlOLFFBQVFPLFFBQVEsS0FBS0osV0FBVztRQUNsQyxNQUFNLElBQUlLLE1BQ1IsK0NBQTZDQyxLQUFLQyxTQUFTLENBQUNWO0lBRWhFLE9BQU87UUFDTCxJQUFJLENBQUNXLENBQUFBLEdBQUFBLFdBQUFBLE1BQU0sRUFBQ1gsUUFBUU8sUUFBUSxFQUFFSyxJQUFJLENBQUNYLElBQUlNLFFBQVEsR0FBRztZQUNoRCxPQUFPO1FBQ1Q7SUFDRjtRQUVZUDtJQUFaLElBQUksQ0FBQ1csQ0FBQUEsR0FBQUEsV0FBQUEsTUFBTSxFQUFDWCxDQUFBQSxvQkFBQUEsUUFBUWEsUUFBUSxZQUFoQmIsb0JBQW9CLE1BQU07UUFBRWMsS0FBSztJQUFLLEdBQUdGLElBQUksQ0FBQ1gsSUFBSVksUUFBUSxHQUFHO1FBQ3ZFLE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVPLFNBQVNmLFNBQ2RpQixPQUFpQixFQUNqQkMsY0FBK0IsRUFDL0JmLEdBQVE7SUFFUixPQUNFYyxRQUFRRSxJQUFJLENBQUMsU0FBQ0M7ZUFBV2pCLElBQUlNLFFBQVEsS0FBS1c7VUFDMUNGLGVBQWVDLElBQUksQ0FBQyxTQUFDRTtlQUFNcEIsbUJBQW1Cb0IsR0FBR2xCOztBQUVyRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvbWF0Y2gtcmVtb3RlLXBhdHRlcm4udHM/ZDYxZCJdLCJuYW1lcyI6WyJoYXNNYXRjaCIsIm1hdGNoUmVtb3RlUGF0dGVybiIsInBhdHRlcm4iLCJ1cmwiLCJwcm90b2NvbCIsInVuZGVmaW5lZCIsImFjdHVhbFByb3RvIiwic2xpY2UiLCJwb3J0IiwiaG9zdG5hbWUiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJtYWtlUmUiLCJ0ZXN0IiwicGF0aG5hbWUiLCJkb3QiLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJzb21lIiwiZG9tYWluIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function get() {\n        return RouterContext;\n    }\n}));\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar RouterContext = _react[\"default\"].createContext(null);\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQUdhQTs7O2VBQUFBOzs7OzBFQUhLO0FBR1gsSUFBTUEsZ0JBQWdCQyxNQUFBQSxDQUFBQSxVQUFLLENBQUNDLGFBQWEsQ0FBb0I7QUFFcEUsSUFBSUMsSUFBeUIsRUFBYztJQUN6Q0gsY0FBY0ksV0FBVyxHQUFHO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS50cz82MzZjIl0sIm5hbWVzIjpbIlJvdXRlckNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/side-effect.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function get() {\n        return SideEffect;\n    }\n}));\nvar _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar isServer = typeof window === \"undefined\";\nvar useClientOnlyLayoutEffect = isServer ? function() {} : _react.useLayoutEffect;\nvar useClientOnlyEffect = isServer ? function() {} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    var headManager = props.headManager, reduceComponentsToState = props.reduceComponentsToState;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            var headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect(function() {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        return function() {\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances[\"delete\"](props.children);\n        };\n    });\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect(function() {\n        if (headManager) {\n            headManager._pendingUpdate = emitChange;\n        }\n        return function() {\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n        };\n    });\n    useClientOnlyEffect(function() {\n        if (headManager && headManager._pendingUpdate) {\n            headManager._pendingUpdate();\n            headManager._pendingUpdate = null;\n        }\n        return function() {\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n        };\n    });\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7MkNBb0JBOzs7ZUFBd0JBOzs7aUNBbkI2QjtBQWVyRCxJQUFNQyxXQUFXLE9BQU9DLFdBQVc7QUFDbkMsSUFBTUMsNEJBQTRCRixXQUFXLFlBQU8sSUFBSUcsT0FBQUEsZUFBZTtBQUN2RSxJQUFNQyxzQkFBc0JKLFdBQVcsWUFBTyxJQUFJSyxPQUFBQSxTQUFTO0FBRTVDLFNBQVNOLFdBQVdPLEtBQXNCOztJQUN2RCxJQUFRQyxjQUF5Q0QsTUFBekNDLGFBQWFDLDBCQUE0QkYsTUFBNUJFO0lBRXJCLFNBQVNDO1FBQ1AsSUFBSUYsZUFBZUEsWUFBWUcsZ0JBQWdCLEVBQUU7WUFDL0MsSUFBTUMsZUFBZUMsT0FBQUEsUUFBUSxDQUFDQyxPQUFPLENBQ25DQyxNQUFNQyxJQUFJLENBQUNSLFlBQVlHLGdCQUFnQixFQUEwQk0sTUFBTSxDQUNyRUM7WUFHSlYsWUFBWVcsVUFBVSxDQUFDVix3QkFBd0JHLGNBQWNMO1FBQy9EO0lBQ0Y7SUFFQSxJQUFJTixVQUFVO1lBQ1pPO1FBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBZ0IscUJBQTdCSCw4QkFBK0JZLEdBQUcsQ0FBQ2IsTUFBTWMsUUFBUTtRQUNqRFg7SUFDRjtJQUVBUCwwQkFBMEI7WUFDeEJLO1FBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBZ0IscUJBQTdCSCw4QkFBK0JZLEdBQUcsQ0FBQ2IsTUFBTWMsUUFBUTtRQUNqRCxPQUFPO2dCQUNMYjtZQUFBQSxlQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSxnQ0FBQUEsWUFBYUcsZ0JBQWdCLHFCQUE3QkgsNkJBQStCYyxDQUFBQSxTQUFNLENBQUNmLE1BQU1jLFFBQVE7UUFDdEQ7SUFDRjtJQUVBLGtGQUFrRjtJQUNsRixvRkFBb0Y7SUFDcEYsZ0VBQWdFO0lBQ2hFLHFGQUFxRjtJQUNyRixtRkFBbUY7SUFDbkZsQiwwQkFBMEI7UUFDeEIsSUFBSUssYUFBYTtZQUNmQSxZQUFZZSxjQUFjLEdBQUdiO1FBQy9CO1FBQ0EsT0FBTztZQUNMLElBQUlGLGFBQWE7Z0JBQ2ZBLFlBQVllLGNBQWMsR0FBR2I7WUFDL0I7UUFDRjtJQUNGO0lBRUFMLG9CQUFvQjtRQUNsQixJQUFJRyxlQUFlQSxZQUFZZSxjQUFjLEVBQUU7WUFDN0NmLFlBQVllLGNBQWM7WUFDMUJmLFlBQVllLGNBQWMsR0FBRztRQUMvQjtRQUNBLE9BQU87WUFDTCxJQUFJZixlQUFlQSxZQUFZZSxjQUFjLEVBQUU7Z0JBQzdDZixZQUFZZSxjQUFjO2dCQUMxQmYsWUFBWWUsY0FBYyxHQUFHO1lBQy9CO1FBQ0Y7SUFDRjtJQUVBLE9BQU87QUFDVDtHQXhEd0J2Qjs7UUFtQnRCRztRQVlBQTtRQVdBRTs7O0tBMUNzQkwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3NpZGUtZWZmZWN0LnRzeD9lOGRkIl0sIm5hbWVzIjpbIlNpZGVFZmZlY3QiLCJpc1NlcnZlciIsIndpbmRvdyIsInVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VDbGllbnRPbmx5RWZmZWN0IiwidXNlRWZmZWN0IiwicHJvcHMiLCJoZWFkTWFuYWdlciIsInJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIiwiZW1pdENoYW5nZSIsIm1vdW50ZWRJbnN0YW5jZXMiLCJoZWFkRWxlbWVudHMiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJBcnJheSIsImZyb20iLCJmaWx0ZXIiLCJCb29sZWFuIiwidXBkYXRlSGVhZCIsImFkZCIsImNoaWxkcmVuIiwiZGVsZXRlIiwiX3BlbmRpbmdVcGRhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0hBQWdIOztBQUVoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QyxnREFBZ0QsTUFBTSxhQUFhOztBQUVqSDtBQUNBLCtDQUErQyxrQ0FBa0MsT0FBTzs7QUFFeEYsdUdBQXVHLGNBQWMsVUFBVSxnR0FBZ0csa0JBQWtCLFVBQVUsVUFBVTs7QUFFclE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiwyREFBMkQsVUFBVTtBQUNyRSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBLGFBQWEsVUFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz9iMGRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/MjI3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz85ZDBhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/process/browser.js\n"));

/***/ })

});